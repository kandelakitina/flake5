'use strict';

var nodeWasm = require('@herb-tools/node-wasm');
var fs = require('fs');
var path = require('path');

const colors = {
    reset: "\x1b[0m",
    bold: "\x1b[1m",
    dim: "\x1b[2m",
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    white: "\x1b[37m",
    gray: "\x1b[90m",
    brightRed: "\x1b[91m",
    brightGreen: "\x1b[92m",
    brightYellow: "\x1b[93m",
    brightBlue: "\x1b[94m",
    brightMagenta: "\x1b[95m",
    brightCyan: "\x1b[96m",
    bgBlack: "\x1b[40m",
    bgRed: "\x1b[41m",
    bgGreen: "\x1b[42m",
    bgYellow: "\x1b[43m",
    bgBlue: "\x1b[44m",
    bgMagenta: "\x1b[45m",
    bgCyan: "\x1b[46m",
    bgWhite: "\x1b[47m",
    bgGray: "\x1b[100m",
};
const hexToAnsi = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `\x1b[38;2;${r};${g};${b}m`;
};
const colorize = (text, color, backgroundColor) => {
    if (process.env.NO_COLOR === undefined) {
        let foreground;
        let background = "";
        if (typeof color === "string" && color.startsWith("#")) {
            foreground = hexToAnsi(color);
        }
        else {
            foreground = colors[color];
        }
        if (backgroundColor) {
            if (typeof backgroundColor === "string" &&
                backgroundColor.startsWith("#")) {
                // Convert hex to background color (48 instead of 38 for background)
                const r = parseInt(backgroundColor.slice(1, 3), 16);
                const g = parseInt(backgroundColor.slice(3, 5), 16);
                const b = parseInt(backgroundColor.slice(5, 7), 16);
                background = `\x1b[48;2;${r};${g};${b}m`;
            }
            else {
                background = colors[backgroundColor];
            }
        }
        return `${background}${foreground}${text}${colors.reset}`;
    }
    return text;
};

function applyDimToStyledText(text) {
    const isColorEnabled = process.env.NO_COLOR === undefined;
    if (!isColorEnabled)
        return text;
    const parts = text.split(/(\x1b\[[0-9;]*m)/g);
    let result = "";
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part.match(/^\x1b\[[0-9;]*m$/)) {
            // This is an ANSI code - modify it to add dimming
            if (part === "\x1b[0m") {
                result += part; // Keep reset codes as-is
            }
            else {
                // Add dim (2;) to existing color codes
                const codes = part.match(/\x1b\[([0-9;]*)m/)?.[1];
                if (codes && codes !== "0" && codes !== "") {
                    result += `\x1b[2;${codes}m`;
                }
                else {
                    result += part;
                }
            }
        }
        else if (part.length > 0) {
            // This is plain text - wrap it with dim formatting
            result += `\x1b[2m${part}\x1b[22m`;
        }
    }
    return result;
}

class LineWrapper {
    static wrapLine(line, maxWidth, indent = "") {
        if (maxWidth <= 0)
            return [line];
        // Strip ANSI codes for width calculation but preserve them in output
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return [line];
        }
        const wrappedLines = [];
        let currentLine = line;
        let currentPlain = plainLine;
        while (currentPlain.length > maxWidth) {
            // Find a good break point (prefer spaces, then other characters)
            let breakPoint = maxWidth;
            // Look for space or other break characters within maxWidth
            // First pass: look for whitespace (ideal breaks)
            for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 40); i--) {
                const char = currentPlain[i];
                if (char === " " || char === "\t") {
                    breakPoint = i + 1; // Break after whitespace
                    break;
                }
            }
            // Second pass: if no whitespace found, look for punctuation but not within quoted strings
            if (breakPoint === maxWidth) {
                for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 30); i--) {
                    const char = currentPlain[i];
                    // Avoid breaking inside quoted strings or immediately after =
                    const prevChar = i > 0 ? currentPlain[i - 1] : "";
                    const nextChar = i < currentPlain.length - 1 ? currentPlain[i + 1] : "";
                    if ((char === ">" || char === "," || char === ";") &&
                        prevChar !== "=" && nextChar !== "\"" && nextChar !== "'") {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            // Third pass: if still no good break point, break at maxWidth but try to avoid =
            if (breakPoint === maxWidth) {
                for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 10); i--) {
                    const char = currentPlain[i];
                    if (char !== "=" && char !== "\"" && char !== "'") {
                        breakPoint = i;
                        break;
                    }
                }
            }
            // Extract the portion to wrap
            const wrapPortion = this.extractPortionWithAnsi(currentLine, breakPoint);
            wrappedLines.push(wrapPortion);
            // Update remaining text
            currentLine = this.extractRemainingWithAnsi(currentLine, currentPlain, breakPoint);
            currentPlain = currentPlain.slice(breakPoint).trimStart();
            // Add indent to continuation lines
            if (currentPlain.length > 0) {
                currentLine = indent + currentLine.trimStart();
            }
        }
        // Add the remaining text
        if (currentPlain.length > 0) {
            wrappedLines.push(currentLine);
        }
        return wrappedLines;
    }
    static extractPortionWithAnsi(styledLine, endIndex) {
        let styledIndex = 0;
        let plainIndex = 0;
        let result = "";
        while (plainIndex < endIndex && styledIndex < styledLine.length) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                // Copy ANSI escape sequence
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    result += ansiMatch[0];
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            result += char;
            styledIndex++;
            plainIndex++;
        }
        return result;
    }
    static extractRemainingWithAnsi(styledLine, plainLine, startIndex) {
        let styledIndex = 0;
        let plainIndex = 0;
        // Find the styled position corresponding to plain position
        while (plainIndex < startIndex && styledIndex < styledLine.length) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                // Skip ANSI escape sequence
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            styledIndex++;
            plainIndex++;
        }
        return styledLine.slice(styledIndex);
    }
    static truncateLine(line, maxWidth) {
        if (maxWidth <= 0)
            return line;
        // Strip ANSI codes for width calculation but preserve them in output
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return line;
        }
        // Reserve space for ellipsis and some padding from the right edge
        const ellipsisChar = "…";
        const ellipsis = colorize(ellipsisChar, "dim");
        const rightPadding = 2; // Leave some breathing room from the right edge
        const availableWidth = maxWidth - ellipsisChar.length - rightPadding;
        if (availableWidth <= 0) {
            return ellipsis;
        }
        // Extract the portion that fits with ANSI codes preserved
        const truncatedPortion = this.extractPortionWithAnsi(line, availableWidth);
        // Add ellipsis (without color codes to avoid issues)
        return truncatedPortion + ellipsis;
    }
    static getTerminalWidth() {
        if (process.stdout.isTTY && process.stdout.columns) {
            return process.stdout.columns;
        }
        return 80; // Default fallback
    }
}

/**
 * Configuration for gutter formatting in the highlighter
 */
// Calculate the gutter width based on the format: "    123 │ "
// - 4 spaces for indentation
// - 3 characters for line number (supports up to 999 lines)
// - 1 space after line number
// - 1 character for separator (│)
// - 1 space after separator
const GUTTER_WIDTH = 4 + 3 + 1 + 1 + 1; // = 10
// Minimum content width to ensure readability
const MIN_CONTENT_WIDTH = 40;

class DiagnosticRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    highlightBackticks(text) {
        if (process.stdout.isTTY && process.env.NO_COLOR === undefined) {
            const boldWhite = "\x1b[1m\x1b[37m";
            const reset = "\x1b[0m";
            return text.replace(/`([^`]+)`/g, `${boldWhite}$1${reset}`);
        }
        return text;
    }
    truncateLineForDiagnostic(line, diagnosticStart, diagnosticEnd, maxWidth) {
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return { line, adjustedStart: diagnosticStart, adjustedEnd: diagnosticEnd };
        }
        const ellipsisChar = "…";
        const ellipsis = colorize(ellipsisChar, "dim");
        const rightPadding = 2; // Leave some breathing room from the right edge
        const ellipsisCharLength = ellipsisChar.length;
        const ellipsisLength = ellipsisCharLength + rightPadding;
        if (diagnosticStart < maxWidth / 3) {
            const availableWidth = maxWidth - ellipsisLength;
            const truncated = LineWrapper.truncateLine(line, availableWidth);
            return {
                line: truncated,
                adjustedStart: diagnosticStart,
                adjustedEnd: Math.min(diagnosticEnd, availableWidth)
            };
        }
        if (diagnosticStart > plainLine.length - maxWidth / 3) {
            const availableWidth = maxWidth - ellipsisLength;
            const startPos = Math.max(0, plainLine.length - availableWidth);
            const visiblePortion = this.extractPortionFromPosition(line, startPos, plainLine.length);
            const truncated = ellipsis + visiblePortion;
            return {
                line: truncated,
                adjustedStart: Math.max(0, diagnosticStart - startPos + ellipsisCharLength),
                adjustedEnd: Math.max(0, diagnosticEnd - startPos + ellipsisCharLength)
            };
        }
        const contextWidth = maxWidth - (ellipsisLength * 2);
        const contextStart = Math.max(0, diagnosticStart - contextWidth / 3);
        const contextEnd = Math.min(plainLine.length, contextStart + contextWidth);
        const visiblePortion = this.extractPortionFromPosition(line, contextStart, contextEnd);
        const truncated = ellipsis + visiblePortion + ellipsis;
        return {
            line: truncated,
            adjustedStart: diagnosticStart - contextStart + ellipsisCharLength,
            adjustedEnd: diagnosticEnd - contextStart + ellipsisCharLength
        };
    }
    extractPortionFromPosition(styledLine, startPos, endPos) {
        let styledIndex = 0;
        let plainIndex = 0;
        let result = "";
        let inRange = false;
        while (styledIndex < styledLine.length && plainIndex <= endPos) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    if (inRange || plainIndex >= startPos) {
                        result += ansiMatch[0];
                    }
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            if (plainIndex >= startPos && !inRange) {
                inRange = true;
            }
            if (inRange) {
                result += char;
            }
            styledIndex++;
            plainIndex++;
        }
        return result;
    }
    renderSingle(path, diagnostic, content, options = {}) {
        const { contextLines = 2, showLineNumbers: _showLineNumbers = true, optimizeHighlighting = true, wrapLines = true, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false, } = options;
        const shouldWrap = wrapLines && !truncateLines;
        const shouldTruncate = truncateLines;
        const isError = diagnostic.severity === "error";
        const fileHeader = `${colorize(path, "cyan")}:${colorize(`${diagnostic.location.start.line}:${diagnostic.location.start.column}`, "cyan")}`;
        const severityText = isError
            ? colorize("error", "brightRed")
            : colorize("warning", "brightYellow");
        const diagnosticId = colorize(diagnostic.code || "-", "gray");
        const originalLines = content.split("\n");
        const targetLineNumber = diagnostic.location.start.line;
        const column = diagnostic.location.start.column - 1;
        const startLine = Math.max(1, targetLineNumber - contextLines);
        const endLine = Math.min(originalLines.length, targetLineNumber + contextLines);
        let lines;
        let lineOffset = 0;
        if (optimizeHighlighting) {
            const relevantLines = [];
            for (let i = startLine; i <= endLine; i++) {
                relevantLines.push(originalLines[i - 1] || "");
            }
            const relevantContent = relevantLines.join("\n");
            const highlightedContent = this.syntaxRenderer.highlight(relevantContent);
            lines = highlightedContent.split("\n");
            lineOffset = startLine - 1;
        }
        else {
            const highlightedContent = this.syntaxRenderer.highlight(content);
            lines = highlightedContent.split("\n");
            lineOffset = 0;
        }
        let contextOutput = "";
        let adjustedColumn = column;
        let adjustedPointerLength = Math.max(1, diagnostic.location.end.column - diagnostic.location.start.column);
        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i - 1 - lineOffset] || "";
            const isTargetLine = i === targetLineNumber;
            const lineNumber = isTargetLine
                ? colorize(i.toString().padStart(3, " "), "bold")
                : colorize(i.toString().padStart(3, " "), "gray");
            const prefix = isTargetLine
                ? colorize("  → ", isError ? "brightRed" : "brightYellow")
                : "    ";
            const separator = colorize("│", "gray");
            let displayLine = line;
            if (isTargetLine) {
                displayLine = line;
            }
            else {
                displayLine = applyDimToStyledText(line);
            }
            if (shouldWrap) {
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        contextOutput += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        contextOutput += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (shouldTruncate) {
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                let truncatedLine;
                if (isTargetLine) {
                    const diagnosticEnd = diagnostic.location.end.column - 1;
                    const result = this.truncateLineForDiagnostic(displayLine, column, diagnosticEnd, availableWidth);
                    truncatedLine = result.line;
                    adjustedColumn = result.adjustedStart;
                    adjustedPointerLength = Math.max(1, result.adjustedEnd - result.adjustedStart);
                }
                else {
                    truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                }
                contextOutput += `${linePrefix}${truncatedLine}\n`;
            }
            else {
                contextOutput += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
            }
            if (isTargetLine) {
                const pointerPrefix = `        ${colorize("│", "gray")}`;
                const pointerSpacing = " ".repeat(adjustedColumn + 2);
                const adjustedPointer = colorize("~".repeat(adjustedPointerLength), isError ? "brightRed" : "brightYellow");
                contextOutput += `${pointerPrefix}${pointerSpacing}${adjustedPointer}\n`;
            }
        }
        const highlightedMessage = this.highlightBackticks(diagnostic.message);
        return `[${severityText}] ${highlightedMessage} (${diagnosticId})

${fileHeader}

${contextOutput.trimEnd()}
`;
    }
}

class FileRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    renderWithLineNumbers(path, content, wrapLines = false, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const lines = highlightedContent.split("\n");
        let output = `${colorize(path, "cyan")}\n\n`;
        for (let i = 1; i <= lines.length; i++) {
            const line = lines[i - 1] || "";
            const lineNumber = colorize(i.toString().padStart(3, " "), "gray");
            const separator = colorize("│", "gray");
            if (wrapLines) {
                const linePrefix = `    ${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(line, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        output += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        output += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (truncateLines) {
                const linePrefix = `    ${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const truncatedLine = LineWrapper.truncateLine(line, availableWidth);
                output += `${linePrefix}${truncatedLine}\n`;
            }
            else {
                output += `    ${lineNumber} ${separator} ${line}\n`;
            }
        }
        return output.trimEnd();
    }
    renderWithFocusLine(path, content, focusLine, contextLines, showLineNumbers = true, maxWidth = LineWrapper.getTerminalWidth(), wrapLines = false, truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const lines = highlightedContent.split("\n");
        const startLine = Math.max(1, focusLine - contextLines);
        const endLine = Math.min(lines.length, focusLine + contextLines);
        let output = showLineNumbers ? `${colorize(path, "cyan")}\n\n` : "";
        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i - 1] || "";
            const isFocusLine = i === focusLine;
            if (showLineNumbers) {
                const lineNumber = isFocusLine
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = isFocusLine ? colorize("  → ", "cyan") : "    ";
                const separator = colorize("│", "gray");
                let displayLine = line;
                if (!isFocusLine) {
                    displayLine = applyDimToStyledText(line);
                }
                if (wrapLines) {
                    const linePrefix = `${prefix}${lineNumber} ${separator} `;
                    const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                    const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                    for (let j = 0; j < wrappedLines.length; j++) {
                        if (j === 0) {
                            output += `${linePrefix}${wrappedLines[j]}\n`;
                        }
                        else {
                            output += `        ${separator} ${wrappedLines[j]}\n`;
                        }
                    }
                }
                else if (truncateLines) {
                    const linePrefix = `${prefix}${lineNumber} ${separator} `;
                    const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                    const truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                    output += `${linePrefix}${truncatedLine}\n`;
                }
                else {
                    output += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
                }
            }
            else {
                let displayLine = line;
                if (!isFocusLine) {
                    displayLine = applyDimToStyledText(line);
                }
                if (wrapLines) {
                    const wrappedLines = LineWrapper.wrapLine(displayLine, maxWidth);
                    for (const wrappedLine of wrappedLines) {
                        output += `${wrappedLine}\n`;
                    }
                }
                else if (truncateLines) {
                    const truncatedLine = LineWrapper.truncateLine(displayLine, maxWidth);
                    output += `${truncatedLine}\n`;
                }
                else {
                    output += `${displayLine}\n`;
                }
            }
        }
        return output.trimEnd();
    }
    renderPlain(content, maxWidth = LineWrapper.getTerminalWidth(), wrapLines = false, truncateLines = false) {
        const highlighted = this.syntaxRenderer.highlight(content);
        if (wrapLines) {
            const lines = highlighted.split("\n");
            const wrappedLines = [];
            for (const line of lines) {
                const wrapped = LineWrapper.wrapLine(line, maxWidth);
                wrappedLines.push(...wrapped);
            }
            return wrappedLines.join("\n");
        }
        else if (truncateLines) {
            const lines = highlighted.split("\n");
            const truncatedLines = [];
            for (const line of lines) {
                const truncated = LineWrapper.truncateLine(line, maxWidth);
                truncatedLines.push(truncated);
            }
            return truncatedLines.join("\n");
        }
        return highlighted;
    }
}

class SyntaxRenderer {
    colors;
    isColorEnabled;
    herb;
    constructor(colors, herb) {
        this.colors = colors;
        this.isColorEnabled = process.env.NO_COLOR === undefined;
        this.herb = herb || nodeWasm.Herb;
    }
    async initialize() {
        if (this.herb.isLoaded) {
            return;
        }
        await this.herb.load();
    }
    get initialized() {
        return this.herb.isLoaded;
    }
    highlight(content) {
        if (!this.initialized || !this.herb) {
            throw new Error("SyntaxRenderer must be initialized before use. Call await initialize() first.");
        }
        const lexResult = this.herb.lex(content);
        if (lexResult.errors.length > 0) {
            return content;
        }
        const tokens = [...lexResult.value];
        return this.highlightTokens(tokens, content);
    }
    applyColor(text, color) {
        if (!this.isColorEnabled || !color)
            return text;
        return colorize(text, color);
    }
    // TODO: in the future we should leverage Prism tokens here
    highlightRubyCode(code) {
        if (!this.isColorEnabled)
            return code;
        const words = code.split(/(\s+|[^\w\s]+)/);
        const keywords = [
            "if",
            "unless",
            "else",
            "elsif",
            "end",
            "def",
            "class",
            "module",
            "return",
            "yield",
            "break",
            "next",
            "case",
            "when",
            "then",
            "while",
            "until",
            "for",
            "in",
            "do",
            "begin",
            "rescue",
            "ensure",
            "retry",
            "raise",
            "super",
            "self",
            "nil",
            "true",
            "false",
            "and",
            "or",
            "not",
        ];
        return words
            .map((word) => {
            if (keywords.includes(word)) {
                return this.applyColor(word, this.colors.RUBY_KEYWORD);
            }
            return word;
        }).join("");
    }
    highlightTokens(tokens, content) {
        if (!tokens || tokens.length === 0) {
            return content;
        }
        let highlighted = "";
        let lastEnd = 0;
        let state = {
            inTag: false,
            inQuotes: false,
            quoteChar: "",
            tagName: "",
            isClosingTag: false,
            expectingAttributeName: false,
            expectingAttributeValue: false,
            inComment: false,
        };
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const nextToken = tokens[i + 1];
            const prevToken = tokens[i - 1];
            if (token.range.start > lastEnd) {
                highlighted += content.slice(lastEnd, token.range.start);
            }
            const tokenText = content.slice(token.range.start, token.range.end);
            this.updateState(state, token, tokenText, nextToken, prevToken);
            const color = this.getContextualColor(state, token, tokenText);
            if (token.type === "TOKEN_ERB_CONTENT") {
                const highlightedRuby = this.highlightRubyCode(tokenText);
                highlighted += highlightedRuby;
            }
            else if (color !== undefined) {
                highlighted += this.applyColor(tokenText, color);
            }
            else {
                highlighted += tokenText;
            }
            lastEnd = token.range.end;
        }
        if (lastEnd < content.length) {
            highlighted += content.slice(lastEnd);
        }
        return highlighted;
    }
    updateState(state, token, tokenText, _nextToken, _prevToken) {
        switch (token.type) {
            case "TOKEN_HTML_TAG_START":
                state.inTag = true;
                state.isClosingTag = false;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_HTML_TAG_START_CLOSE":
                state.inTag = true;
                state.isClosingTag = true;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_HTML_TAG_END":
            case "TOKEN_HTML_TAG_SELF_CLOSE":
                state.inTag = false;
                state.tagName = "";
                state.isClosingTag = false;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_IDENTIFIER":
                if (state.inTag && !state.tagName) {
                    state.tagName = tokenText;
                    state.expectingAttributeName = !state.isClosingTag;
                }
                else if (state.inTag && state.expectingAttributeName) {
                    state.expectingAttributeName = false;
                    state.expectingAttributeValue = true;
                }
                break;
            case "TOKEN_EQUALS":
                if (state.inTag) {
                    state.expectingAttributeValue = true;
                }
                break;
            case "TOKEN_QUOTE":
                if (state.inTag) {
                    if (!state.inQuotes) {
                        state.inQuotes = true;
                        state.quoteChar = tokenText;
                    }
                    else if (tokenText === state.quoteChar) {
                        state.inQuotes = false;
                        state.quoteChar = "";
                        state.expectingAttributeName = true;
                        state.expectingAttributeValue = false;
                    }
                }
                break;
            case "TOKEN_WHITESPACE":
                if (state.inTag && !state.inQuotes && state.tagName) {
                    state.expectingAttributeName = true;
                    state.expectingAttributeValue = false;
                }
                break;
            case "TOKEN_HTML_COMMENT_START":
                state.inComment = true;
                break;
            case "TOKEN_HTML_COMMENT_END":
                state.inComment = false;
                break;
        }
    }
    getContextualColor(state, token, tokenText) {
        if (state.inComment &&
            token.type !== "TOKEN_HTML_COMMENT_START" &&
            token.type !== "TOKEN_HTML_COMMENT_END" &&
            token.type !== "TOKEN_ERB_START" &&
            token.type !== "TOKEN_ERB_CONTENT" &&
            token.type !== "TOKEN_ERB_END") {
            return this.colors.TOKEN_HTML_COMMENT_START;
        }
        switch (token.type) {
            case "TOKEN_IDENTIFIER":
                if (state.inTag && tokenText === state.tagName) {
                    return this.colors.TOKEN_HTML_TAG_START;
                }
                else if (state.inTag &&
                    state.expectingAttributeValue &&
                    !state.inQuotes) {
                    return "#D19A66";
                }
                else if (state.inTag && state.expectingAttributeName) {
                    return "#D19A66";
                }
                else if (state.inTag && state.inQuotes) {
                    return "#98C379";
                }
                break;
            case "TOKEN_QUOTE":
                if (state.inTag) {
                    return "#98C379";
                }
                break;
        }
        if (!this.colors) {
            return null;
        }
        const color = this.colors[token.type];
        return color !== undefined ? color : null;
    }
}

class InitializationManager {
    _initialized = false;
    herb;
    constructor(herb) {
        this.herb = herb;
    }
    async initialize() {
        if (this.herb) {
            await this.herb.load();
        }
        this._initialized = true;
    }
    get initialized() {
        return this._initialized;
    }
    requireInitialized() {
        if (!this._initialized) {
            throw new Error("Highlighter must be initialized before use. Call await highlighter.initialize() first.");
        }
    }
}

class TextFormatter {
    static applyDimToStyledText(text) {
        const isColorEnabled = process.env.NO_COLOR === undefined;
        if (!isColorEnabled)
            return text;
        return text.replace(/\x1b\[([0-9;]*)m/g, (match, codes) => {
            if (codes === "0" || codes === "") {
                return match;
            }
            return `\x1b[2;${codes}m`;
        });
    }
    static highlightBackticks(text) {
        if (process.stdout.isTTY && process.env.NO_COLOR === undefined) {
            const boldWhite = "\x1b[1m\x1b[37m";
            const reset = "\x1b[0m";
            return text.replace(/`([^`]+)`/g, `${boldWhite}$1${reset}`);
        }
        return text;
    }
}

class InlineDiagnosticRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    render(path, content, diagnostics, _contextLines, showLineNumbers = true, wrapLines = false, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const diagnosticsByLine = new Map();
        for (const diagnostic of diagnostics) {
            const lineNumber = diagnostic.location.start.line;
            if (!diagnosticsByLine.has(lineNumber)) {
                diagnosticsByLine.set(lineNumber, []);
            }
            diagnosticsByLine.get(lineNumber).push(diagnostic);
        }
        for (const lineDiagnostics of diagnosticsByLine.values()) {
            lineDiagnostics.sort((a, b) => {
                if (a.severity === "error" && b.severity === "warning")
                    return -1;
                if (a.severity === "warning" && b.severity === "error")
                    return 1;
                return 0;
            });
        }
        const lines = highlightedContent.split("\n");
        let output = showLineNumbers ? `${colorize(path, "cyan")}\n\n` : "";
        let previousLineHadDiagnostics = false;
        for (let i = 1; i <= lines.length; i++) {
            const line = lines[i - 1] || "";
            const lineDiagnostics = diagnosticsByLine.get(i) || [];
            const hasDiagnostics = lineDiagnostics.length > 0;
            if (hasDiagnostics && previousLineHadDiagnostics) {
                output += "\n";
            }
            const hasErrors = lineDiagnostics.some((diagnostic) => diagnostic.severity === "error");
            let displayLine = line;
            let availableWidth = maxWidth;
            if (wrapLines && showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("  → ", hasErrors ? "brightRed" : "brightYellow")
                    : "    ";
                const separator = colorize("│", "gray");
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        output += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        output += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (truncateLines && showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("  → ", hasErrors ? "brightRed" : "brightYellow")
                    : "    ";
                const separator = colorize("│", "gray");
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                output += `${linePrefix}${truncatedLine}\n`;
            }
            else if (showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("  → ", hasErrors ? "brightRed" : "brightYellow")
                    : "    ";
                const separator = colorize("│", "gray");
                output += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
            }
            else if (wrapLines) {
                availableWidth = maxWidth;
                const wrappedLines = LineWrapper.wrapLine(displayLine, maxWidth);
                for (const wrappedLine of wrappedLines) {
                    output += `${wrappedLine}\n`;
                }
            }
            else if (truncateLines) {
                const truncatedLine = LineWrapper.truncateLine(displayLine, maxWidth);
                output += `${truncatedLine}\n`;
            }
            else {
                output += `${displayLine}\n`;
            }
            if (hasDiagnostics) {
                for (const diagnostic of lineDiagnostics) {
                    const column = diagnostic.location.start.column - 1;
                    const pointerLength = Math.max(1, diagnostic.location.end.column - diagnostic.location.start.column);
                    const isError = diagnostic.severity === "error";
                    if (showLineNumbers) {
                        const pointerPrefix = `        ${colorize("│", "gray")}`;
                        const pointerSpacing = " ".repeat(column + 2);
                        const pointer = colorize("~".repeat(pointerLength), isError ? "brightRed" : "brightYellow");
                        output += `${pointerPrefix}${pointerSpacing}${pointer}\n`;
                        const severityText = isError
                            ? colorize("error", "brightRed")
                            : colorize("warning", "brightYellow");
                        const diagnosticId = colorize(diagnostic.code || "-", "gray");
                        const highlightedMessage = TextFormatter.highlightBackticks(diagnostic.message);
                        const diagnosticText = `[${severityText}] ${highlightedMessage} (${diagnosticId})`;
                        const dimmedDiagnosticText = TextFormatter.applyDimToStyledText(diagnosticText);
                        output += `${pointerPrefix}${pointerSpacing}${dimmedDiagnosticText}\n`;
                    }
                    else {
                        const pointerSpacing = " ".repeat(column);
                        const pointer = colorize("~".repeat(pointerLength), isError ? "brightRed" : "brightYellow");
                        output += `${pointerSpacing}${pointer}\n`;
                        const severityText = isError
                            ? colorize("error", "brightRed")
                            : colorize("warning", "brightYellow");
                        const diagnosticId = colorize(diagnostic.code || "-", "gray");
                        const highlightedMessage = TextFormatter.highlightBackticks(diagnostic.message);
                        const diagnosticText = `[${severityText}] ${highlightedMessage} (${diagnosticId})`;
                        const dimmedDiagnosticText = TextFormatter.applyDimToStyledText(diagnosticText);
                        output += `${dimmedDiagnosticText}\n`;
                    }
                }
                output += "\n";
            }
            previousLineHadDiagnostics = hasDiagnostics;
        }
        return output.trimEnd();
    }
}

class FileReader {
    highlighter;
    constructor(highlighter) {
        this.highlighter = highlighter;
    }
    highlightFromPath(filePath, options = {}) {
        this.highlighter.requireInitialized();
        try {
            const content = fs.readFileSync(filePath, "utf8");
            return this.highlighter.highlight(filePath, content, options);
        }
        catch (error) {
            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    highlightDiagnosticFromPath(filePath, diagnostic, options = {}) {
        this.highlighter.requireInitialized();
        try {
            const content = fs.readFileSync(filePath, "utf8");
            return this.highlighter.highlightDiagnostic(filePath, diagnostic, content, options);
        }
        catch (error) {
            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}

var TOKEN_WHITESPACE$4 = null;
var TOKEN_NBSP$4 = "#5C6370";
var TOKEN_NEWLINE$4 = null;
var TOKEN_IDENTIFIER$4 = "#ABB2BF";
var RUBY_KEYWORD$4 = "#C678DD";
var TOKEN_HTML_DOCTYPE$4 = "#61AFEF";
var TOKEN_HTML_TAG_START$4 = "#E06C75";
var TOKEN_HTML_TAG_START_CLOSE$4 = "#E06C75";
var TOKEN_HTML_TAG_END$4 = "#E06C75";
var TOKEN_HTML_TAG_SELF_CLOSE$4 = "#E06C75";
var TOKEN_HTML_COMMENT_START$4 = "#5C6370";
var TOKEN_HTML_COMMENT_END$4 = "#5C6370";
var TOKEN_ERB_START$4 = "#BE5046";
var TOKEN_ERB_CONTENT$4 = "#E5C07B";
var TOKEN_ERB_END$4 = "#BE5046";
var TOKEN_LT$4 = "#E06C75";
var TOKEN_SLASH$4 = "#E06C75";
var TOKEN_EQUALS$4 = "#56B6C2";
var TOKEN_QUOTE$4 = "#98C379";
var TOKEN_DASH$4 = "#ABB2BF";
var TOKEN_UNDERSCORE$4 = "#ABB2BF";
var TOKEN_EXCLAMATION$4 = "#C678DD";
var TOKEN_SEMICOLON$4 = "#ABB2BF";
var TOKEN_COLON$4 = "#ABB2BF";
var TOKEN_PERCENT$4 = "#BE5046";
var TOKEN_AMPERSAND$4 = "#D19A66";
var TOKEN_CHARACTER$4 = "#ABB2BF";
var TOKEN_ERROR$4 = "#E05252";
var TOKEN_EOF$4 = null;
var onedarkTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$4,
	TOKEN_NBSP: TOKEN_NBSP$4,
	TOKEN_NEWLINE: TOKEN_NEWLINE$4,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$4,
	RUBY_KEYWORD: RUBY_KEYWORD$4,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$4,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$4,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$4,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$4,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$4,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$4,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$4,
	TOKEN_ERB_START: TOKEN_ERB_START$4,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$4,
	TOKEN_ERB_END: TOKEN_ERB_END$4,
	TOKEN_LT: TOKEN_LT$4,
	TOKEN_SLASH: TOKEN_SLASH$4,
	TOKEN_EQUALS: TOKEN_EQUALS$4,
	TOKEN_QUOTE: TOKEN_QUOTE$4,
	TOKEN_DASH: TOKEN_DASH$4,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$4,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$4,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$4,
	TOKEN_COLON: TOKEN_COLON$4,
	TOKEN_PERCENT: TOKEN_PERCENT$4,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$4,
	TOKEN_CHARACTER: TOKEN_CHARACTER$4,
	TOKEN_ERROR: TOKEN_ERROR$4,
	TOKEN_EOF: TOKEN_EOF$4
};

var TOKEN_WHITESPACE$3 = null;
var TOKEN_NBSP$3 = "#6a737d";
var TOKEN_NEWLINE$3 = null;
var TOKEN_IDENTIFIER$3 = "#24292e";
var RUBY_KEYWORD$3 = "#d73a49";
var TOKEN_HTML_DOCTYPE$3 = "#005cc5";
var TOKEN_HTML_TAG_START$3 = "#22863a";
var TOKEN_HTML_TAG_START_CLOSE$3 = "#22863a";
var TOKEN_HTML_TAG_END$3 = "#22863a";
var TOKEN_HTML_TAG_SELF_CLOSE$3 = "#22863a";
var TOKEN_HTML_COMMENT_START$3 = "#6a737d";
var TOKEN_HTML_COMMENT_END$3 = "#6a737d";
var TOKEN_ERB_START$3 = "#e36209";
var TOKEN_ERB_CONTENT$3 = "#6f42c1";
var TOKEN_ERB_END$3 = "#e36209";
var TOKEN_LT$3 = "#22863a";
var TOKEN_SLASH$3 = "#22863a";
var TOKEN_EQUALS$3 = "#d73a49";
var TOKEN_QUOTE$3 = "#032f62";
var TOKEN_DASH$3 = "#24292e";
var TOKEN_UNDERSCORE$3 = "#24292e";
var TOKEN_EXCLAMATION$3 = "#d73a49";
var TOKEN_SEMICOLON$3 = "#24292e";
var TOKEN_COLON$3 = "#24292e";
var TOKEN_PERCENT$3 = "#e36209";
var TOKEN_AMPERSAND$3 = "#005cc5";
var TOKEN_CHARACTER$3 = "#24292e";
var TOKEN_ERROR$3 = "#cb2431";
var TOKEN_EOF$3 = null;
var githubLightTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$3,
	TOKEN_NBSP: TOKEN_NBSP$3,
	TOKEN_NEWLINE: TOKEN_NEWLINE$3,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$3,
	RUBY_KEYWORD: RUBY_KEYWORD$3,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$3,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$3,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$3,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$3,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$3,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$3,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$3,
	TOKEN_ERB_START: TOKEN_ERB_START$3,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$3,
	TOKEN_ERB_END: TOKEN_ERB_END$3,
	TOKEN_LT: TOKEN_LT$3,
	TOKEN_SLASH: TOKEN_SLASH$3,
	TOKEN_EQUALS: TOKEN_EQUALS$3,
	TOKEN_QUOTE: TOKEN_QUOTE$3,
	TOKEN_DASH: TOKEN_DASH$3,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$3,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$3,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$3,
	TOKEN_COLON: TOKEN_COLON$3,
	TOKEN_PERCENT: TOKEN_PERCENT$3,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$3,
	TOKEN_CHARACTER: TOKEN_CHARACTER$3,
	TOKEN_ERROR: TOKEN_ERROR$3,
	TOKEN_EOF: TOKEN_EOF$3
};

var TOKEN_WHITESPACE$2 = null;
var TOKEN_NBSP$2 = "#6272a4";
var TOKEN_NEWLINE$2 = null;
var TOKEN_IDENTIFIER$2 = "#f8f8f2";
var RUBY_KEYWORD$2 = "#ff79c6";
var TOKEN_HTML_DOCTYPE$2 = "#8be9fd";
var TOKEN_HTML_TAG_START$2 = "#50fa7b";
var TOKEN_HTML_TAG_START_CLOSE$2 = "#50fa7b";
var TOKEN_HTML_TAG_END$2 = "#50fa7b";
var TOKEN_HTML_TAG_SELF_CLOSE$2 = "#50fa7b";
var TOKEN_HTML_COMMENT_START$2 = "#6272a4";
var TOKEN_HTML_COMMENT_END$2 = "#6272a4";
var TOKEN_ERB_START$2 = "#ffb86c";
var TOKEN_ERB_CONTENT$2 = "#bd93f9";
var TOKEN_ERB_END$2 = "#ffb86c";
var TOKEN_LT$2 = "#50fa7b";
var TOKEN_SLASH$2 = "#50fa7b";
var TOKEN_EQUALS$2 = "#ff79c6";
var TOKEN_QUOTE$2 = "#f1fa8c";
var TOKEN_DASH$2 = "#f8f8f2";
var TOKEN_UNDERSCORE$2 = "#f8f8f2";
var TOKEN_EXCLAMATION$2 = "#ff79c6";
var TOKEN_SEMICOLON$2 = "#f8f8f2";
var TOKEN_COLON$2 = "#f8f8f2";
var TOKEN_PERCENT$2 = "#ffb86c";
var TOKEN_AMPERSAND$2 = "#8be9fd";
var TOKEN_CHARACTER$2 = "#f8f8f2";
var TOKEN_ERROR$2 = "#ff5555";
var TOKEN_EOF$2 = null;
var draculaTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$2,
	TOKEN_NBSP: TOKEN_NBSP$2,
	TOKEN_NEWLINE: TOKEN_NEWLINE$2,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$2,
	RUBY_KEYWORD: RUBY_KEYWORD$2,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$2,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$2,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$2,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$2,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$2,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$2,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$2,
	TOKEN_ERB_START: TOKEN_ERB_START$2,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$2,
	TOKEN_ERB_END: TOKEN_ERB_END$2,
	TOKEN_LT: TOKEN_LT$2,
	TOKEN_SLASH: TOKEN_SLASH$2,
	TOKEN_EQUALS: TOKEN_EQUALS$2,
	TOKEN_QUOTE: TOKEN_QUOTE$2,
	TOKEN_DASH: TOKEN_DASH$2,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$2,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$2,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$2,
	TOKEN_COLON: TOKEN_COLON$2,
	TOKEN_PERCENT: TOKEN_PERCENT$2,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$2,
	TOKEN_CHARACTER: TOKEN_CHARACTER$2,
	TOKEN_ERROR: TOKEN_ERROR$2,
	TOKEN_EOF: TOKEN_EOF$2
};

var TOKEN_WHITESPACE$1 = null;
var TOKEN_NBSP$1 = "#646e9c";
var TOKEN_NEWLINE$1 = null;
var TOKEN_IDENTIFIER$1 = "#c0caf5";
var RUBY_KEYWORD$1 = "#bb9af7";
var TOKEN_HTML_DOCTYPE$1 = "#7aa2f7";
var TOKEN_HTML_TAG_START$1 = "#f7768e";
var TOKEN_HTML_TAG_START_CLOSE$1 = "#f7768e";
var TOKEN_HTML_TAG_END$1 = "#f7768e";
var TOKEN_HTML_TAG_SELF_CLOSE$1 = "#f7768e";
var TOKEN_HTML_COMMENT_START$1 = "#51597d";
var TOKEN_HTML_COMMENT_END$1 = "#51597d";
var TOKEN_ERB_START$1 = "#7dcfff";
var TOKEN_ERB_CONTENT$1 = "#bb9af7";
var TOKEN_ERB_END$1 = "#7dcfff";
var TOKEN_LT$1 = "#f7768e";
var TOKEN_SLASH$1 = "#f7768e";
var TOKEN_EQUALS$1 = "#89ddff";
var TOKEN_QUOTE$1 = "#9ece6a";
var TOKEN_DASH$1 = "#c0caf5";
var TOKEN_UNDERSCORE$1 = "#c0caf5";
var TOKEN_EXCLAMATION$1 = "#bb9af7";
var TOKEN_SEMICOLON$1 = "#c0caf5";
var TOKEN_COLON$1 = "#c0caf5";
var TOKEN_PERCENT$1 = "#7dcfff";
var TOKEN_AMPERSAND$1 = "#e0af68";
var TOKEN_CHARACTER$1 = "#c0caf5";
var TOKEN_ERROR$1 = "#f7768e";
var TOKEN_EOF$1 = null;
var tokyoNightTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$1,
	TOKEN_NBSP: TOKEN_NBSP$1,
	TOKEN_NEWLINE: TOKEN_NEWLINE$1,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$1,
	RUBY_KEYWORD: RUBY_KEYWORD$1,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$1,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$1,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$1,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$1,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$1,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$1,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$1,
	TOKEN_ERB_START: TOKEN_ERB_START$1,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$1,
	TOKEN_ERB_END: TOKEN_ERB_END$1,
	TOKEN_LT: TOKEN_LT$1,
	TOKEN_SLASH: TOKEN_SLASH$1,
	TOKEN_EQUALS: TOKEN_EQUALS$1,
	TOKEN_QUOTE: TOKEN_QUOTE$1,
	TOKEN_DASH: TOKEN_DASH$1,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$1,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$1,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$1,
	TOKEN_COLON: TOKEN_COLON$1,
	TOKEN_PERCENT: TOKEN_PERCENT$1,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$1,
	TOKEN_CHARACTER: TOKEN_CHARACTER$1,
	TOKEN_ERROR: TOKEN_ERROR$1,
	TOKEN_EOF: TOKEN_EOF$1
};

var TOKEN_WHITESPACE = null;
var TOKEN_NBSP = "gray";
var TOKEN_NEWLINE = null;
var TOKEN_IDENTIFIER = "white";
var RUBY_KEYWORD = "magenta";
var TOKEN_HTML_DOCTYPE = "blue";
var TOKEN_HTML_TAG_START = "red";
var TOKEN_HTML_TAG_START_CLOSE = "red";
var TOKEN_HTML_TAG_END = "red";
var TOKEN_HTML_TAG_SELF_CLOSE = "red";
var TOKEN_HTML_COMMENT_START = "gray";
var TOKEN_HTML_COMMENT_END = "gray";
var TOKEN_ERB_START = "yellow";
var TOKEN_ERB_CONTENT = "magenta";
var TOKEN_ERB_END = "yellow";
var TOKEN_LT = "red";
var TOKEN_SLASH = "red";
var TOKEN_EQUALS = "blue";
var TOKEN_QUOTE = "green";
var TOKEN_DASH = "white";
var TOKEN_UNDERSCORE = "white";
var TOKEN_EXCLAMATION = "magenta";
var TOKEN_SEMICOLON = "white";
var TOKEN_COLON = "white";
var TOKEN_PERCENT = "yellow";
var TOKEN_AMPERSAND = "yellow";
var TOKEN_CHARACTER = "white";
var TOKEN_ERROR = "red";
var TOKEN_EOF = null;
var simpleTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE,
	TOKEN_NBSP: TOKEN_NBSP,
	TOKEN_NEWLINE: TOKEN_NEWLINE,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER,
	RUBY_KEYWORD: RUBY_KEYWORD,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END,
	TOKEN_ERB_START: TOKEN_ERB_START,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT,
	TOKEN_ERB_END: TOKEN_ERB_END,
	TOKEN_LT: TOKEN_LT,
	TOKEN_SLASH: TOKEN_SLASH,
	TOKEN_EQUALS: TOKEN_EQUALS,
	TOKEN_QUOTE: TOKEN_QUOTE,
	TOKEN_DASH: TOKEN_DASH,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON,
	TOKEN_COLON: TOKEN_COLON,
	TOKEN_PERCENT: TOKEN_PERCENT,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND,
	TOKEN_CHARACTER: TOKEN_CHARACTER,
	TOKEN_ERROR: TOKEN_ERROR,
	TOKEN_EOF: TOKEN_EOF
};

const THEME_NAMES = ["onedark", "github-light", "dracula", "tokyo-night", "simple"];
const DEFAULT_THEME = "onedark";
// Built-in themes are now bundled directly
const themes = {
    onedark: onedarkTheme,
    "github-light": githubLightTheme,
    dracula: draculaTheme,
    "tokyo-night": tokyoNightTheme,
    simple: simpleTheme
};
function isValidTheme(theme) {
    return THEME_NAMES.includes(theme);
}
function getThemeNames() {
    return THEME_NAMES;
}
function getTheme(theme) {
    return themes[theme];
}
function getDefaultTheme() {
    return DEFAULT_THEME;
}
function loadCustomTheme(themePath) {
    try {
        const absolutePath = path.resolve(themePath);
        const themeContent = fs.readFileSync(absolutePath, 'utf-8');
        const customTheme = JSON.parse(themeContent);
        const requiredKeys = Object.keys(themes.onedark);
        const customKeys = Object.keys(customTheme);
        const missingKeys = requiredKeys.filter(key => !customKeys.includes(key));
        if (missingKeys.length > 0) {
            throw new Error(`Custom theme is missing required properties: ${missingKeys.join(', ')}`);
        }
        return customTheme;
    }
    catch (error) {
        if (error instanceof Error) {
            throw new Error(`Failed to load custom theme from ${themePath}: ${error.message}`);
        }
        throw new Error(`Failed to load custom theme from ${themePath}`);
    }
}
function resolveTheme(themeInput) {
    if (isValidTheme(themeInput)) {
        return getTheme(themeInput);
    }
    return loadCustomTheme(themeInput);
}
function isCustomTheme(themeInput) {
    return !isValidTheme(themeInput);
}

class Highlighter {
    syntaxRenderer;
    diagnosticRenderer;
    fileRenderer;
    initManager;
    inlineDiagnosticRenderer;
    fileReader;
    constructor(theme = "onedark", herb) {
        const colors = resolveTheme(theme);
        this.syntaxRenderer = new SyntaxRenderer(colors, herb);
        this.diagnosticRenderer = new DiagnosticRenderer(this.syntaxRenderer);
        this.fileRenderer = new FileRenderer(this.syntaxRenderer);
        this.initManager = new InitializationManager(herb);
        this.inlineDiagnosticRenderer = new InlineDiagnosticRenderer(this.syntaxRenderer);
        this.fileReader = new FileReader(this);
    }
    /**
     * Initialize the highlighter with the Herb backend
     * This must be called before using highlight() or highlightDiagnostic()
     */
    async initialize() {
        await this.initManager.initialize();
        await this.syntaxRenderer.initialize();
    }
    /**
     * Check if the highlighter has been initialized
     */
    get initialized() {
        return this.initManager.initialized;
    }
    requireInitialized() {
        this.initManager.requireInitialized();
    }
    /**
     * Main highlighting method with flexible rendering options
     * @param path - File path for annotation (display only, not used for reading)
     * @param content - The content to highlight
     * @param options - Configuration options
     *   - diagnostics: Array of diagnostics to display inline or split
     *   - splitDiagnostics: When true with diagnostics, render each diagnostic individually
     *   - contextLines: Number of context lines around focus/diagnostics
     *   - focusLine: Line number to focus on (shows only that line with dimmed context)
     *   - showLineNumbers: Whether to show line numbers (default: true)
     * @returns The highlighted content with optional diagnostics or focused view
     */
    highlight(path, content, options = {}) {
        this.requireInitialized();
        const { diagnostics = [], splitDiagnostics = false, contextLines = 0, focusLine, showLineNumbers = true, wrapLines = true, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false, } = options;
        // Case 1: Split diagnostics - render each diagnostic individually
        if (diagnostics.length > 0 && splitDiagnostics) {
            const results = [];
            for (let i = 0; i < diagnostics.length; i++) {
                const diagnostic = diagnostics[i];
                const result = this.highlightDiagnostic(path, diagnostic, content, {
                    contextLines,
                    showLineNumbers,
                    wrapLines,
                    maxWidth,
                    truncateLines,
                });
                results.push(result);
                // Add separator between diagnostics
                if (i < diagnostics.length - 1) {
                    const width = process.stdout.columns || 80;
                    const progressText = `[${i + 1}/${diagnostics.length}]`;
                    const rightPadding = 16;
                    const separatorLength = Math.max(0, width - progressText.length - 1 - rightPadding);
                    const separator = '⎯';
                    const leftSeparator = separator.repeat(separatorLength);
                    const rightSeparator = separator.repeat(4);
                    const progress = progressText;
                    results.push(`${leftSeparator}  ${progress} ${rightSeparator}`);
                }
            }
            return results.join("\n\n");
        }
        // Case 2: Inline diagnostics - show whole file with diagnostics inline
        if (diagnostics.length > 0) {
            return this.inlineDiagnosticRenderer.render(path, content, diagnostics, contextLines, showLineNumbers, wrapLines, maxWidth, truncateLines);
        }
        // Case 3: Focus line - show only specific line with context
        if (focusLine) {
            return this.fileRenderer.renderWithFocusLine(path, content, focusLine, contextLines, showLineNumbers, maxWidth, wrapLines, truncateLines);
        }
        // Case 4: Default - just highlight the whole file
        if (showLineNumbers) {
            return this.fileRenderer.renderWithLineNumbers(path, content, wrapLines, maxWidth, truncateLines);
        }
        else {
            return this.fileRenderer.renderPlain(content, maxWidth, wrapLines, truncateLines);
        }
    }
    /**
     * Render a single diagnostic with context lines and syntax highlighting
     * @param path - The file path to display in the diagnostic (display only)
     * @param diagnostic - The diagnostic message to render
     * @param content - The content to highlight and render
     * @param options - Optional configuration
     * @returns The rendered diagnostic output with syntax highlighting
     */
    highlightDiagnostic(path, diagnostic, content, options = {}) {
        this.requireInitialized();
        return this.diagnosticRenderer.renderSingle(path, diagnostic, content, options);
    }
    // File reading wrapper functions
    /**
     * Convenience method that reads a file and highlights it
     * @param filePath - Path to the file to read and highlight
     * @param options - Configuration options
     * @returns The highlighted file content with optional diagnostics
     */
    highlightFileFromPath(filePath, options = {}) {
        return this.fileReader.highlightFromPath(filePath, options);
    }
    /**
     * Convenience method that reads a file and renders a diagnostic
     * @param filePath - Path to the file to read
     * @param diagnostic - The diagnostic message to render
     * @param options - Optional configuration
     * @returns The highlighted diagnostic output
     */
    highlightDiagnosticFromPath(filePath, diagnostic, options = {}) {
        return this.fileReader.highlightDiagnosticFromPath(filePath, diagnostic, options);
    }
}
/**
 * Convenience function to highlight content with a specific theme
 * @param content - The content to highlight
 * @param theme - The theme to use (defaults to "onedark")
 * @param options - Additional highlighting options
 * @returns The highlighted content
 */
async function highlightContent(content, theme = "onedark", options = {}) {
    const highlighter = new Highlighter(theme);
    await highlighter.initialize();
    return highlighter.highlight("", content, options);
}
/**
 * Convenience function to highlight a file with a specific theme
 * @param filePath - The path to the file to highlight
 * @param theme - The theme to use (defaults to "onedark")
 * @param options - Additional highlighting options
 * @returns The highlighted file content
 */
async function highlightFile(filePath, theme = "onedark", options = {}) {
    const highlighter = new Highlighter(theme);
    await highlighter.initialize();
    return highlighter.highlightFileFromPath(filePath, options);
}

exports.DEFAULT_THEME = DEFAULT_THEME;
exports.DiagnosticRenderer = DiagnosticRenderer;
exports.FileRenderer = FileRenderer;
exports.Highlighter = Highlighter;
exports.SyntaxRenderer = SyntaxRenderer;
exports.THEME_NAMES = THEME_NAMES;
exports.colorize = colorize;
exports.colors = colors;
exports.getDefaultTheme = getDefaultTheme;
exports.getTheme = getTheme;
exports.getThemeNames = getThemeNames;
exports.highlightContent = highlightContent;
exports.highlightFile = highlightFile;
exports.isCustomTheme = isCustomTheme;
exports.isValidTheme = isValidTheme;
exports.loadCustomTheme = loadCustomTheme;
exports.resolveTheme = resolveTheme;
exports.themes = themes;
//# sourceMappingURL=index.cjs.map
