import { ParserRule } from "../types";
import { ControlFlowTrackingVisitor, ControlFlowType } from "./rule-utils";
import { LiteralNode } from "@herb-tools/core";
import { Printer, IdentityPrinter } from "@herb-tools/printer";
import { hasERBOutput, getValidatableStaticContent, isEffectivelyStatic, isNode, getStaticAttributeName, isERBOutputNode } from "@herb-tools/core";
class OutputPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.write(IdentityPrinter.print(node));
        }
    }
}
class NoDuplicateIdsVisitor extends ControlFlowTrackingVisitor {
    documentIds = new Set();
    currentBranchIds = new Set();
    controlFlowIds = new Set();
    visitHTMLAttributeNode(node) {
        this.checkAttribute(node);
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds,
            previousControlFlowIds: this.controlFlowIds
        };
        this.currentBranchIds = new Set();
        if (!wasAlreadyInControlFlow) {
            this.controlFlowIds = new Set();
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowIds.forEach(id => this.documentIds.add(id));
        }
        this.currentBranchIds = stateToRestore.previousBranchIds;
        this.controlFlowIds = stateToRestore.previousControlFlowIds;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds
        };
        if (this.isInControlFlow) {
            this.currentBranchIds = new Set();
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    checkAttribute(attributeNode) {
        if (!this.isIdAttribute(attributeNode))
            return;
        const idValue = this.extractIdValue(attributeNode);
        if (!idValue)
            return;
        if (this.isWhitespaceOnlyId(idValue.identifier))
            return;
        this.processIdDuplicate(idValue, attributeNode);
    }
    isIdAttribute(attributeNode) {
        if (!attributeNode.name?.children || !attributeNode.value)
            return false;
        return getStaticAttributeName(attributeNode.name) === "id";
    }
    extractIdValue(attributeNode) {
        const valueNodes = attributeNode.value?.children || [];
        if (hasERBOutput(valueNodes) && this.isInControlFlow && this.currentControlFlowType === ControlFlowType.LOOP) {
            return null;
        }
        const identifier = isEffectivelyStatic(valueNodes) ? getValidatableStaticContent(valueNodes) : OutputPrinter.print(valueNodes);
        if (!identifier)
            return null;
        return { identifier, shouldTrackDuplicates: true };
    }
    isWhitespaceOnlyId(identifier) {
        return identifier !== '' && identifier.trim() === '';
    }
    processIdDuplicate(idValue, attributeNode) {
        const { identifier, shouldTrackDuplicates } = idValue;
        if (!shouldTrackDuplicates)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowId(identifier, attributeNode);
        }
        else {
            this.handleGlobalId(identifier, attributeNode);
        }
    }
    handleControlFlowId(identifier, attributeNode) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.handleLoopId(identifier, attributeNode);
        }
        else {
            this.handleConditionalId(identifier, attributeNode);
        }
        this.currentBranchIds.add(identifier);
    }
    handleLoopId(identifier, attributeNode) {
        const isStaticId = this.isStaticId(attributeNode);
        if (isStaticId) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        if (this.currentBranchIds.has(identifier)) {
            this.addSameLoopIterationOffense(identifier, attributeNode.location);
        }
    }
    handleConditionalId(identifier, attributeNode) {
        if (this.currentBranchIds.has(identifier)) {
            this.addSameBranchOffense(identifier, attributeNode.location);
            return;
        }
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.controlFlowIds.add(identifier);
    }
    handleGlobalId(identifier, attributeNode) {
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.documentIds.add(identifier);
    }
    isStaticId(attributeNode) {
        const valueNodes = attributeNode.value.children;
        const isCompletelyStatic = valueNodes.every(child => isNode(child, LiteralNode));
        const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
        return isCompletelyStatic || isEffectivelyStaticValue;
    }
    addDuplicateIdOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found. IDs must be unique within a document.`, location, "error");
    }
    addSameLoopIterationOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same loop iteration. IDs must be unique within the same loop iteration.`, location, "error");
    }
    addSameBranchOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same control flow branch. IDs must be unique within the same control flow branch.`, location, "error");
    }
}
export class HTMLNoDuplicateIdsRule extends ParserRule {
    name = "html-no-duplicate-ids";
    check(result, context) {
        const visitor = new NoDuplicateIdsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-no-duplicate-ids.js.map