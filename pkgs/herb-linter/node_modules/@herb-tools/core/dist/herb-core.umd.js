(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Herb = {}));
})(this, (function (exports) { 'use strict';

    class Position {
        line;
        column;
        static from(position) {
            return new Position(position.line, position.column);
        }
        constructor(line, column) {
            this.line = line;
            this.column = column;
        }
        toHash() {
            return { line: this.line, column: this.column };
        }
        toJSON() {
            return this.toHash();
        }
        treeInspect() {
            return `(${this.line}:${this.column})`;
        }
        inspect() {
            return `#<Herb::Position ${this.treeInspect()}>`;
        }
        toString() {
            return this.inspect();
        }
    }

    class Location {
        start;
        end;
        static from(location) {
            const start = Position.from(location.start);
            const end = Position.from(location.end);
            return new Location(start, end);
        }
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        toHash() {
            return {
                start: this.start.toHash(),
                end: this.end.toHash(),
            };
        }
        toJSON() {
            return this.toHash();
        }
        treeInspect() {
            return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
        }
        treeInspectWithLabel() {
            return `(location: ${this.treeInspect()})`;
        }
        inspect() {
            return `#<Herb::Location ${this.treeInspect()}>`;
        }
        toString() {
            return this.inspect();
        }
    }

    class Range {
        start;
        end;
        static from(range) {
            return new Range(range[0], range[1]);
        }
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        toArray() {
            return [this.start, this.end];
        }
        toJSON() {
            return this.toArray();
        }
        treeInspect() {
            return `[${this.start}, ${this.end}]`;
        }
        inspect() {
            return `#<Herb::Range ${this.toArray()}>`;
        }
        toString() {
            return this.inspect();
        }
    }

    class Token {
        value;
        range;
        location;
        type;
        static from(token) {
            return new Token(token.value, Range.from(token.range), Location.from(token.location), token.type);
        }
        constructor(value, range, location, type) {
            this.value = value;
            this.range = range;
            this.location = location;
            this.type = type;
        }
        toHash() {
            return {
                value: this.value,
                range: this.range?.toArray(),
                location: this.location?.toHash(),
                type: this.type,
            };
        }
        toJSON() {
            return this.toHash();
        }
        treeInspect() {
            return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
        }
        valueInspect() {
            return this.type === "TOKEN_EOF"
                ? JSON.stringify("<EOF>")
                : JSON.stringify(this.value);
        }
        inspect() {
            return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
        }
        toString() {
            return this.inspect();
        }
    }

    // NOTE: This file is generated by the templates/template.rb script and should not
    // be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/errors.ts.erb
    class HerbError {
        type;
        message;
        location;
        severity = "error";
        source = "parser";
        get code() {
            return this.type;
        }
        static from(error) {
            return fromSerializedError(error);
        }
        constructor(type, message, location) {
            this.type = type;
            this.message = message;
            this.location = location;
        }
        toJSON() {
            return {
                type: this.type,
                message: this.message,
                location: this.location.toJSON(),
            };
        }
        inspect() {
            return this.treeInspect(0);
        }
    }
    class UnexpectedError extends HerbError {
        description;
        expected;
        found;
        static from(data) {
            return new UnexpectedError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                description: data.description,
                expected: data.expected,
                found: data.found,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.description = props.description;
            this.expected = props.expected;
            this.found = props.found;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "UNEXPECTED_ERROR",
                description: this.description,
                expected: this.expected,
                found: this.found,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `├── description: ${JSON.stringify(this.description)}\n`;
            output += `├── expected: ${JSON.stringify(this.expected)}\n`;
            output += `└── found: ${JSON.stringify(this.found)}\n`;
            return output;
        }
    }
    class UnexpectedTokenError extends HerbError {
        expected_type;
        found;
        static from(data) {
            return new UnexpectedTokenError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                expected_type: data.expected_type,
                found: data.found ? Token.from(data.found) : null,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.expected_type = props.expected_type;
            this.found = props.found;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "UNEXPECTED_TOKEN_ERROR",
                expected_type: this.expected_type,
                found: this.found ? this.found.toJSON() : null,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
            output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class MissingOpeningTagError extends HerbError {
        closing_tag;
        static from(data) {
            return new MissingOpeningTagError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.closing_tag = props.closing_tag;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "MISSING_OPENING_TAG_ERROR",
                closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class MissingClosingTagError extends HerbError {
        opening_tag;
        static from(data) {
            return new MissingClosingTagError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.opening_tag = props.opening_tag;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "MISSING_CLOSING_TAG_ERROR",
                opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class TagNamesMismatchError extends HerbError {
        opening_tag;
        closing_tag;
        static from(data) {
            return new TagNamesMismatchError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
                closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.opening_tag = props.opening_tag;
            this.closing_tag = props.closing_tag;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "TAG_NAMES_MISMATCH_ERROR",
                opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
                closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
            output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class QuotesMismatchError extends HerbError {
        opening_quote;
        closing_quote;
        static from(data) {
            return new QuotesMismatchError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
                closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.opening_quote = props.opening_quote;
            this.closing_quote = props.closing_quote;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "QUOTES_MISMATCH_ERROR",
                opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
                closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
            output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class VoidElementClosingTagError extends HerbError {
        tag_name;
        expected;
        found;
        static from(data) {
            return new VoidElementClosingTagError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                tag_name: data.tag_name ? Token.from(data.tag_name) : null,
                expected: data.expected,
                found: data.found,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.tag_name = props.tag_name;
            this.expected = props.expected;
            this.found = props.found;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
                tag_name: this.tag_name ? this.tag_name.toJSON() : null,
                expected: this.expected,
                found: this.found,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
            output += `├── expected: ${JSON.stringify(this.expected)}\n`;
            output += `└── found: ${JSON.stringify(this.found)}\n`;
            return output;
        }
    }
    class UnclosedElementError extends HerbError {
        opening_tag;
        static from(data) {
            return new UnclosedElementError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.opening_tag = props.opening_tag;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "UNCLOSED_ELEMENT_ERROR",
                opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class RubyParseError extends HerbError {
        error_message;
        diagnostic_id;
        level;
        static from(data) {
            return new RubyParseError({
                type: data.type,
                message: data.message,
                location: Location.from(data.location),
                error_message: data.error_message,
                diagnostic_id: data.diagnostic_id,
                level: data.level,
            });
        }
        constructor(props) {
            super(props.type, props.message, props.location);
            this.error_message = props.error_message;
            this.diagnostic_id = props.diagnostic_id;
            this.level = props.level;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "RUBY_PARSE_ERROR",
                error_message: this.error_message,
                diagnostic_id: this.diagnostic_id,
                level: this.level,
            };
        }
        toMonacoDiagnostic() {
            return {
                line: this.location.start.line,
                column: this.location.start.column,
                endLine: this.location.end.line,
                endColumn: this.location.end.column,
                message: this.message,
                severity: 'error'
            };
        }
        treeInspect() {
            let output = "";
            output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
            output += `├── message: "${this.message}"\n`;
            output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
            output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
            output += `└── level: ${JSON.stringify(this.level)}\n`;
            return output;
        }
    }
    function fromSerializedError(error) {
        switch (error.type) {
            case "UNEXPECTED_ERROR": return UnexpectedError.from(error);
            case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error);
            case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error);
            case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error);
            case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error);
            case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error);
            case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error);
            case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error);
            case "RUBY_PARSE_ERROR": return RubyParseError.from(error);
            default:
                throw new Error(`Unknown node type: ${error.type}`);
        }
    }

    function ensureString(object) {
        if (typeof object === "string") {
            return object;
        }
        throw new TypeError("Argument must be a string");
    }
    function convertToUTF8(string) {
        const bytes = [];
        for (let i = 0; i < string.length; i++) {
            bytes.push(string.charCodeAt(i));
        }
        const decoder = new TextDecoder("utf-8");
        return decoder.decode(new Uint8Array(bytes));
    }

    // NOTE: This file is generated by the templates/template.rb script and should not
    // be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/nodes.ts.erb
    class Node {
        type;
        location;
        errors;
        static from(node) {
            return fromSerializedNode(node);
        }
        static get type() {
            throw new Error("AST_NODE");
        }
        constructor(type, location, errors) {
            this.type = type;
            this.location = location;
            this.errors = errors;
        }
        toJSON() {
            return {
                type: this.type,
                location: this.location.toJSON(),
                errors: this.errors,
            };
        }
        inspect() {
            return this.treeInspect(0);
        }
        is(nodeClass) {
            return this.type === nodeClass.type;
        }
        isOfType(type) {
            return this.type === type;
        }
        get isSingleLine() {
            return this.location.start.line === this.location.end.line;
        }
        inspectArray(array, prefix) {
            if (!array)
                return "∅\n";
            if (array.length === 0)
                return "[]\n";
            let output = `(${array.length} item${array.length == 1 ? "" : "s"})\n`;
            array.forEach((item, index) => {
                const isLast = index === array.length - 1;
                if (item instanceof Node || item instanceof HerbError) {
                    output += this.inspectNode(item, prefix, isLast ? "    " : "│   ", isLast, false);
                }
                else {
                    const symbol = isLast ? "└── " : "├── ";
                    output += `${prefix}${symbol} ${item}\n`;
                }
            });
            output += `${prefix}\n`;
            return output;
        }
        inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
            if (!node)
                return "∅\n";
            let output = trailingNewline ? "\n" : "";
            output += `${prefix}`;
            output += last ? "└── " : "├── ";
            output += node
                .treeInspect()
                .trimStart()
                .split("\n")
                .map((line, index) => index == 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
                .join("\n")
                .trimStart();
            output += `\n`;
            return output;
        }
    }
    class DocumentNode extends Node {
        children;
        static get type() {
            return "AST_DOCUMENT_NODE";
        }
        static from(data) {
            return new DocumentNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                children: (data.children || []).map(node => fromSerializedNode(node)),
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.children = props.children;
        }
        accept(visitor) {
            visitor.visitDocumentNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_DOCUMENT_NODE",
                children: this.children.map(node => node.toJSON()),
            };
        }
        treeInspect() {
            let output = "";
            output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `└── children: ${this.inspectArray(this.children, "    ")}`;
            return output;
        }
    }
    class LiteralNode extends Node {
        content;
        static get type() {
            return "AST_LITERAL_NODE";
        }
        static from(data) {
            return new LiteralNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                content: data.content,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.content = convertToUTF8(props.content);
        }
        accept(visitor) {
            visitor.visitLiteralNode(this);
        }
        childNodes() {
            return [];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_LITERAL_NODE",
                content: this.content,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
            return output;
        }
    }
    class HTMLOpenTagNode extends Node {
        tag_opening;
        tag_name;
        tag_closing;
        children;
        is_void;
        static get type() {
            return "AST_HTML_OPEN_TAG_NODE";
        }
        static from(data) {
            return new HTMLOpenTagNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                tag_name: data.tag_name ? Token.from(data.tag_name) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                is_void: data.is_void,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.tag_name = props.tag_name;
            this.tag_closing = props.tag_closing;
            this.children = props.children;
            this.is_void = props.is_void;
        }
        accept(visitor) {
            visitor.visitHTMLOpenTagNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_OPEN_TAG_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                tag_name: this.tag_name ? this.tag_name.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                is_void: this.is_void,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
            return output;
        }
    }
    class HTMLCloseTagNode extends Node {
        tag_opening;
        tag_name;
        children;
        tag_closing;
        static get type() {
            return "AST_HTML_CLOSE_TAG_NODE";
        }
        static from(data) {
            return new HTMLCloseTagNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                tag_name: data.tag_name ? Token.from(data.tag_name) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.tag_name = props.tag_name;
            this.children = props.children;
            this.tag_closing = props.tag_closing;
        }
        accept(visitor) {
            visitor.visitHTMLCloseTagNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_CLOSE_TAG_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                tag_name: this.tag_name ? this.tag_name.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class HTMLElementNode extends Node {
        open_tag;
        tag_name;
        body;
        close_tag;
        is_void;
        static get type() {
            return "AST_HTML_ELEMENT_NODE";
        }
        static from(data) {
            return new HTMLElementNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
                tag_name: data.tag_name ? Token.from(data.tag_name) : null,
                body: (data.body || []).map(node => fromSerializedNode(node)),
                close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
                is_void: data.is_void,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.open_tag = props.open_tag;
            this.tag_name = props.tag_name;
            this.body = props.body;
            this.close_tag = props.close_tag;
            this.is_void = props.is_void;
        }
        accept(visitor) {
            visitor.visitHTMLElementNode(this);
        }
        childNodes() {
            return [
                this.open_tag,
                ...this.body,
                this.close_tag,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                this.open_tag ? this.open_tag.recursiveErrors() : [],
                ...this.body.map(node => node.recursiveErrors()),
                this.close_tag ? this.close_tag.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_ELEMENT_NODE",
                open_tag: this.open_tag ? this.open_tag.toJSON() : null,
                tag_name: this.tag_name ? this.tag_name.toJSON() : null,
                body: this.body.map(node => node.toJSON()),
                close_tag: this.close_tag ? this.close_tag.toJSON() : null,
                is_void: this.is_void,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
            output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
            output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
            output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
            output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
            return output;
        }
    }
    class HTMLAttributeValueNode extends Node {
        open_quote;
        children;
        close_quote;
        quoted;
        static get type() {
            return "AST_HTML_ATTRIBUTE_VALUE_NODE";
        }
        static from(data) {
            return new HTMLAttributeValueNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                open_quote: data.open_quote ? Token.from(data.open_quote) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                close_quote: data.close_quote ? Token.from(data.close_quote) : null,
                quoted: data.quoted,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.open_quote = props.open_quote;
            this.children = props.children;
            this.close_quote = props.close_quote;
            this.quoted = props.quoted;
        }
        accept(visitor) {
            visitor.visitHTMLAttributeValueNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
                open_quote: this.open_quote ? this.open_quote.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                close_quote: this.close_quote ? this.close_quote.toJSON() : null,
                quoted: this.quoted,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
            output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;
            return output;
        }
    }
    class HTMLAttributeNameNode extends Node {
        children;
        static get type() {
            return "AST_HTML_ATTRIBUTE_NAME_NODE";
        }
        static from(data) {
            return new HTMLAttributeNameNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                children: (data.children || []).map(node => fromSerializedNode(node)),
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.children = props.children;
        }
        accept(visitor) {
            visitor.visitHTMLAttributeNameNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_ATTRIBUTE_NAME_NODE",
                children: this.children.map(node => node.toJSON()),
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `└── children: ${this.inspectArray(this.children, "    ")}`;
            return output;
        }
    }
    class HTMLAttributeNode extends Node {
        name;
        equals;
        value;
        static get type() {
            return "AST_HTML_ATTRIBUTE_NODE";
        }
        static from(data) {
            return new HTMLAttributeNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                name: data.name ? fromSerializedNode((data.name)) : null,
                equals: data.equals ? Token.from(data.equals) : null,
                value: data.value ? fromSerializedNode((data.value)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.name = props.name;
            this.equals = props.equals;
            this.value = props.value;
        }
        accept(visitor) {
            visitor.visitHTMLAttributeNode(this);
        }
        childNodes() {
            return [
                this.name,
                this.value,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                this.name ? this.name.recursiveErrors() : [],
                this.value ? this.value.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_ATTRIBUTE_NODE",
                name: this.name ? this.name.toJSON() : null,
                equals: this.equals ? this.equals.toJSON() : null,
                value: this.value ? this.value.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
            output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
            output += `└── value: ${this.inspectNode(this.value, "    ")}`;
            return output;
        }
    }
    class HTMLTextNode extends Node {
        content;
        static get type() {
            return "AST_HTML_TEXT_NODE";
        }
        static from(data) {
            return new HTMLTextNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                content: data.content,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.content = convertToUTF8(props.content);
        }
        accept(visitor) {
            visitor.visitHTMLTextNode(this);
        }
        childNodes() {
            return [];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_TEXT_NODE",
                content: this.content,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
            return output;
        }
    }
    class HTMLCommentNode extends Node {
        comment_start;
        children;
        comment_end;
        static get type() {
            return "AST_HTML_COMMENT_NODE";
        }
        static from(data) {
            return new HTMLCommentNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                comment_start: data.comment_start ? Token.from(data.comment_start) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                comment_end: data.comment_end ? Token.from(data.comment_end) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.comment_start = props.comment_start;
            this.children = props.children;
            this.comment_end = props.comment_end;
        }
        accept(visitor) {
            visitor.visitHTMLCommentNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_COMMENT_NODE",
                comment_start: this.comment_start ? this.comment_start.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                comment_end: this.comment_end ? this.comment_end.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class HTMLDoctypeNode extends Node {
        tag_opening;
        children;
        tag_closing;
        static get type() {
            return "AST_HTML_DOCTYPE_NODE";
        }
        static from(data) {
            return new HTMLDoctypeNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.children = props.children;
            this.tag_closing = props.tag_closing;
        }
        accept(visitor) {
            visitor.visitHTMLDoctypeNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_HTML_DOCTYPE_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class XMLDeclarationNode extends Node {
        tag_opening;
        children;
        tag_closing;
        static get type() {
            return "AST_XML_DECLARATION_NODE";
        }
        static from(data) {
            return new XMLDeclarationNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.children = props.children;
            this.tag_closing = props.tag_closing;
        }
        accept(visitor) {
            visitor.visitXMLDeclarationNode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_XML_DECLARATION_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class CDATANode extends Node {
        tag_opening;
        children;
        tag_closing;
        static get type() {
            return "AST_CDATA_NODE";
        }
        static from(data) {
            return new CDATANode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.children = props.children;
            this.tag_closing = props.tag_closing;
        }
        accept(visitor) {
            visitor.visitCDATANode(this);
        }
        childNodes() {
            return [
                ...this.children,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_CDATA_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class WhitespaceNode extends Node {
        value;
        static get type() {
            return "AST_WHITESPACE_NODE";
        }
        static from(data) {
            return new WhitespaceNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                value: data.value ? Token.from(data.value) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.value = props.value;
        }
        accept(visitor) {
            visitor.visitWhitespaceNode(this);
        }
        childNodes() {
            return [];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_WHITESPACE_NODE",
                value: this.value ? this.value.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class ERBContentNode extends Node {
        tag_opening;
        content;
        tag_closing;
        // no-op for analyzed_ruby
        parsed;
        valid;
        static get type() {
            return "AST_ERB_CONTENT_NODE";
        }
        static from(data) {
            return new ERBContentNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                // no-op for analyzed_ruby
                parsed: data.parsed,
                valid: data.valid,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            // no-op for analyzed_ruby
            this.parsed = props.parsed;
            this.valid = props.valid;
        }
        accept(visitor) {
            visitor.visitERBContentNode(this);
        }
        childNodes() {
            return [];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_CONTENT_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                // no-op for analyzed_ruby
                parsed: this.parsed,
                valid: this.valid,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            // no-op for analyzed_ruby
            output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
            output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;
            return output;
        }
    }
    class ERBEndNode extends Node {
        tag_opening;
        content;
        tag_closing;
        static get type() {
            return "AST_ERB_END_NODE";
        }
        static from(data) {
            return new ERBEndNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
        }
        accept(visitor) {
            visitor.visitERBEndNode(this);
        }
        childNodes() {
            return [];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_END_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class ERBElseNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        static get type() {
            return "AST_ERB_ELSE_NODE";
        }
        static from(data) {
            return new ERBElseNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
        }
        accept(visitor) {
            visitor.visitERBElseNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_ELSE_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
            return output;
        }
    }
    class ERBIfNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        subsequent;
        end_node;
        static get type() {
            return "AST_ERB_IF_NODE";
        }
        static from(data) {
            return new ERBIfNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.subsequent = props.subsequent;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBIfNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.subsequent,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.subsequent ? this.subsequent.recursiveErrors() : [],
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_IF_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                subsequent: this.subsequent ? this.subsequent.toJSON() : null,
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBBlockNode extends Node {
        tag_opening;
        content;
        tag_closing;
        body;
        end_node;
        static get type() {
            return "AST_ERB_BLOCK_NODE";
        }
        static from(data) {
            return new ERBBlockNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                body: (data.body || []).map(node => fromSerializedNode(node)),
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.body = props.body;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBBlockNode(this);
        }
        childNodes() {
            return [
                ...this.body,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.body.map(node => node.recursiveErrors()),
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_BLOCK_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                body: this.body.map(node => node.toJSON()),
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBWhenNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        static get type() {
            return "AST_ERB_WHEN_NODE";
        }
        static from(data) {
            return new ERBWhenNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
        }
        accept(visitor) {
            visitor.visitERBWhenNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_WHEN_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
            return output;
        }
    }
    class ERBCaseNode extends Node {
        tag_opening;
        content;
        tag_closing;
        children;
        conditions;
        else_clause;
        end_node;
        static get type() {
            return "AST_ERB_CASE_NODE";
        }
        static from(data) {
            return new ERBCaseNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
                else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.children = props.children;
            this.conditions = props.conditions;
            this.else_clause = props.else_clause;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBCaseNode(this);
        }
        childNodes() {
            return [
                ...this.children,
                ...this.conditions,
                this.else_clause,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
                ...this.conditions.map(node => node.recursiveErrors()),
                this.else_clause ? this.else_clause.recursiveErrors() : [],
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_CASE_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                conditions: this.conditions.map(node => node.toJSON()),
                else_clause: this.else_clause ? this.else_clause.toJSON() : null,
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
            output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBCaseMatchNode extends Node {
        tag_opening;
        content;
        tag_closing;
        children;
        conditions;
        else_clause;
        end_node;
        static get type() {
            return "AST_ERB_CASE_MATCH_NODE";
        }
        static from(data) {
            return new ERBCaseMatchNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                children: (data.children || []).map(node => fromSerializedNode(node)),
                conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
                else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.children = props.children;
            this.conditions = props.conditions;
            this.else_clause = props.else_clause;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBCaseMatchNode(this);
        }
        childNodes() {
            return [
                ...this.children,
                ...this.conditions,
                this.else_clause,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.children.map(node => node.recursiveErrors()),
                ...this.conditions.map(node => node.recursiveErrors()),
                this.else_clause ? this.else_clause.recursiveErrors() : [],
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_CASE_MATCH_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                children: this.children.map(node => node.toJSON()),
                conditions: this.conditions.map(node => node.toJSON()),
                else_clause: this.else_clause ? this.else_clause.toJSON() : null,
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
            output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
            output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBWhileNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        end_node;
        static get type() {
            return "AST_ERB_WHILE_NODE";
        }
        static from(data) {
            return new ERBWhileNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBWhileNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_WHILE_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBUntilNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        end_node;
        static get type() {
            return "AST_ERB_UNTIL_NODE";
        }
        static from(data) {
            return new ERBUntilNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBUntilNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_UNTIL_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBForNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        end_node;
        static get type() {
            return "AST_ERB_FOR_NODE";
        }
        static from(data) {
            return new ERBForNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBForNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_FOR_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBRescueNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        subsequent;
        static get type() {
            return "AST_ERB_RESCUE_NODE";
        }
        static from(data) {
            return new ERBRescueNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.subsequent = props.subsequent;
        }
        accept(visitor) {
            visitor.visitERBRescueNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.subsequent,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.subsequent ? this.subsequent.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_RESCUE_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
            return output;
        }
    }
    class ERBEnsureNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        static get type() {
            return "AST_ERB_ENSURE_NODE";
        }
        static from(data) {
            return new ERBEnsureNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
        }
        accept(visitor) {
            visitor.visitERBEnsureNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_ENSURE_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
            return output;
        }
    }
    class ERBBeginNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        rescue_clause;
        else_clause;
        ensure_clause;
        end_node;
        static get type() {
            return "AST_ERB_BEGIN_NODE";
        }
        static from(data) {
            return new ERBBeginNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
                else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
                ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.rescue_clause = props.rescue_clause;
            this.else_clause = props.else_clause;
            this.ensure_clause = props.ensure_clause;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBBeginNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.rescue_clause,
                this.else_clause,
                this.ensure_clause,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
                this.else_clause ? this.else_clause.recursiveErrors() : [],
                this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_BEGIN_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
                else_clause: this.else_clause ? this.else_clause.toJSON() : null,
                ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
            output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
            output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBUnlessNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        else_clause;
        end_node;
        static get type() {
            return "AST_ERB_UNLESS_NODE";
        }
        static from(data) {
            return new ERBUnlessNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
                else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
                end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
            this.else_clause = props.else_clause;
            this.end_node = props.end_node;
        }
        accept(visitor) {
            visitor.visitERBUnlessNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
                this.else_clause,
                this.end_node,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
                this.else_clause ? this.else_clause.recursiveErrors() : [],
                this.end_node ? this.end_node.recursiveErrors() : [],
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_UNLESS_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
                else_clause: this.else_clause ? this.else_clause.toJSON() : null,
                end_node: this.end_node ? this.end_node.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
            output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
            output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
            return output;
        }
    }
    class ERBYieldNode extends Node {
        tag_opening;
        content;
        tag_closing;
        static get type() {
            return "AST_ERB_YIELD_NODE";
        }
        static from(data) {
            return new ERBYieldNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
        }
        accept(visitor) {
            visitor.visitERBYieldNode(this);
        }
        childNodes() {
            return [];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_YIELD_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            return output;
        }
    }
    class ERBInNode extends Node {
        tag_opening;
        content;
        tag_closing;
        statements;
        static get type() {
            return "AST_ERB_IN_NODE";
        }
        static from(data) {
            return new ERBInNode({
                type: data.type,
                location: Location.from(data.location),
                errors: (data.errors || []).map(error => HerbError.from(error)),
                tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
                content: data.content ? Token.from(data.content) : null,
                tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
                statements: (data.statements || []).map(node => fromSerializedNode(node)),
            });
        }
        constructor(props) {
            super(props.type, props.location, props.errors);
            this.tag_opening = props.tag_opening;
            this.content = props.content;
            this.tag_closing = props.tag_closing;
            this.statements = props.statements;
        }
        accept(visitor) {
            visitor.visitERBInNode(this);
        }
        childNodes() {
            return [
                ...this.statements,
            ];
        }
        compactChildNodes() {
            return this.childNodes().filter(node => node !== null && node !== undefined);
        }
        recursiveErrors() {
            return [
                ...this.errors,
                ...this.statements.map(node => node.recursiveErrors()),
            ].flat();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                type: "AST_ERB_IN_NODE",
                tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
                content: this.content ? this.content.toJSON() : null,
                tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
                statements: this.statements.map(node => node.toJSON()),
            };
        }
        treeInspect() {
            let output = "";
            output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
            output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
            output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
            output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
            output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
            output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
            return output;
        }
    }
    function fromSerializedNode(node) {
        switch (node.type) {
            case "AST_DOCUMENT_NODE": return DocumentNode.from(node);
            case "AST_LITERAL_NODE": return LiteralNode.from(node);
            case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node);
            case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node);
            case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node);
            case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node);
            case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node);
            case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node);
            case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node);
            case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node);
            case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node);
            case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node);
            case "AST_CDATA_NODE": return CDATANode.from(node);
            case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node);
            case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node);
            case "AST_ERB_END_NODE": return ERBEndNode.from(node);
            case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node);
            case "AST_ERB_IF_NODE": return ERBIfNode.from(node);
            case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node);
            case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node);
            case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node);
            case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node);
            case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node);
            case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node);
            case "AST_ERB_FOR_NODE": return ERBForNode.from(node);
            case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node);
            case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node);
            case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node);
            case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node);
            case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node);
            case "AST_ERB_IN_NODE": return ERBInNode.from(node);
            default:
                throw new Error(`Unknown node type: ${node.type}`);
        }
    }
    const ERBNodeClasses = [
        ERBContentNode,
        ERBEndNode,
        ERBElseNode,
        ERBIfNode,
        ERBBlockNode,
        ERBWhenNode,
        ERBCaseNode,
        ERBCaseMatchNode,
        ERBWhileNode,
        ERBUntilNode,
        ERBForNode,
        ERBRescueNode,
        ERBEnsureNode,
        ERBBeginNode,
        ERBUnlessNode,
        ERBYieldNode,
        ERBInNode,
    ];

    class Result {
        source;
        warnings;
        errors;
        constructor(source, warnings = [], errors = []) {
            this.source = source;
            this.warnings = warnings || [];
            this.errors = errors || [];
        }
        /**
         * Determines if the parsing was successful.
         * @returns `true` if there are no errors, otherwise `false`.
         */
        get successful() {
            return this.errors.length === 0;
        }
        /**
         * Determines if the parsing failed.
         * @returns `true` if there are errors, otherwise `false`.
         */
        get failed() {
            return this.errors.length > 0;
        }
    }

    class HerbWarning {
        message;
        location;
        static from(warning) {
            return new HerbWarning(warning.message, Location.from(warning.location));
        }
        constructor(message, location) {
            this.message = message;
            this.location = location;
        }
    }

    /**
     * Represents the result of a parsing operation, extending the base `Result` class.
     * It contains the parsed document node, source code, warnings, and errors.
     */
    class ParseResult extends Result {
        /** The document node generated from the source code. */
        value;
        /**
         * Creates a `ParseResult` instance from a serialized result.
         * @param result - The serialized parse result containing the value and source.
         * @returns A new `ParseResult` instance.
         */
        static from(result) {
            return new ParseResult(DocumentNode.from(result.value), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
        }
        /**
         * Constructs a new `ParseResult`.
         * @param value - The document node.
         * @param source - The source code that was parsed.
         * @param warnings - An array of warnings encountered during parsing.
         * @param errors - An array of errors encountered during parsing.
         */
        constructor(value, source, warnings = [], errors = []) {
            super(source, warnings, errors);
            this.value = value;
        }
        /**
         * Determines if the parsing failed.
         * @returns `true` if there are errors, otherwise `false`.
         */
        get failed() {
            // Consider errors on this result and recursively in the document tree
            return this.recursiveErrors().length > 0;
        }
        /**
         * Determines if the parsing was successful.
         * @returns `true` if there are no errors, otherwise `false`.
         */
        get successful() {
            return !this.failed;
        }
        /**
         * Returns a pretty-printed JSON string of the errors.
         * @returns A string representation of the errors.
         */
        prettyErrors() {
            return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
        }
        recursiveErrors() {
            return [...this.errors, ...this.value.recursiveErrors()];
        }
        /**
         * Returns a pretty-printed string of the parse result.
         * @returns A string representation of the parse result.
         */
        inspect() {
            return this.value.inspect();
        }
        /**
         * Accepts a visitor to traverse the document node.
         * @param visitor - The visitor instance.
         */
        visit(visitor) {
            visitor.visit(this.value);
        }
    }

    // NOTE: This file is generated by the templates/template.rb script and should not
    // be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/node-type-guards.ts.erb
    /**
     * Type guard functions for AST nodes.
     * These functions provide type checking by combining both instanceof
     * checks and type string comparisons for maximum reliability across different
     * runtime scenarios (e.g., serialized/deserialized nodes).
     */
    /**
     * Checks if a node is a DocumentNode
     */
    function isDocumentNode(node) {
        return node instanceof DocumentNode || node.type === "AST_DOCUMENT_NODE" || node.constructor.type === "AST_DOCUMENT_NODE";
    }
    /**
     * Checks if a node is a LiteralNode
     */
    function isLiteralNode(node) {
        return node instanceof LiteralNode || node.type === "AST_LITERAL_NODE" || node.constructor.type === "AST_LITERAL_NODE";
    }
    /**
     * Checks if a node is a HTMLOpenTagNode
     */
    function isHTMLOpenTagNode(node) {
        return node instanceof HTMLOpenTagNode || node.type === "AST_HTML_OPEN_TAG_NODE" || node.constructor.type === "AST_HTML_OPEN_TAG_NODE";
    }
    /**
     * Checks if a node is a HTMLCloseTagNode
     */
    function isHTMLCloseTagNode(node) {
        return node instanceof HTMLCloseTagNode || node.type === "AST_HTML_CLOSE_TAG_NODE" || node.constructor.type === "AST_HTML_CLOSE_TAG_NODE";
    }
    /**
     * Checks if a node is a HTMLElementNode
     */
    function isHTMLElementNode(node) {
        return node instanceof HTMLElementNode || node.type === "AST_HTML_ELEMENT_NODE" || node.constructor.type === "AST_HTML_ELEMENT_NODE";
    }
    /**
     * Checks if a node is a HTMLAttributeValueNode
     */
    function isHTMLAttributeValueNode(node) {
        return node instanceof HTMLAttributeValueNode || node.type === "AST_HTML_ATTRIBUTE_VALUE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    /**
     * Checks if a node is a HTMLAttributeNameNode
     */
    function isHTMLAttributeNameNode(node) {
        return node instanceof HTMLAttributeNameNode || node.type === "AST_HTML_ATTRIBUTE_NAME_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    /**
     * Checks if a node is a HTMLAttributeNode
     */
    function isHTMLAttributeNode(node) {
        return node instanceof HTMLAttributeNode || node.type === "AST_HTML_ATTRIBUTE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NODE";
    }
    /**
     * Checks if a node is a HTMLTextNode
     */
    function isHTMLTextNode(node) {
        return node instanceof HTMLTextNode || node.type === "AST_HTML_TEXT_NODE" || node.constructor.type === "AST_HTML_TEXT_NODE";
    }
    /**
     * Checks if a node is a HTMLCommentNode
     */
    function isHTMLCommentNode(node) {
        return node instanceof HTMLCommentNode || node.type === "AST_HTML_COMMENT_NODE" || node.constructor.type === "AST_HTML_COMMENT_NODE";
    }
    /**
     * Checks if a node is a HTMLDoctypeNode
     */
    function isHTMLDoctypeNode(node) {
        return node instanceof HTMLDoctypeNode || node.type === "AST_HTML_DOCTYPE_NODE" || node.constructor.type === "AST_HTML_DOCTYPE_NODE";
    }
    /**
     * Checks if a node is a XMLDeclarationNode
     */
    function isXMLDeclarationNode(node) {
        return node instanceof XMLDeclarationNode || node.type === "AST_XML_DECLARATION_NODE" || node.constructor.type === "AST_XML_DECLARATION_NODE";
    }
    /**
     * Checks if a node is a CDATANode
     */
    function isCDATANode(node) {
        return node instanceof CDATANode || node.type === "AST_CDATA_NODE" || node.constructor.type === "AST_CDATA_NODE";
    }
    /**
     * Checks if a node is a WhitespaceNode
     */
    function isWhitespaceNode(node) {
        return node instanceof WhitespaceNode || node.type === "AST_WHITESPACE_NODE" || node.constructor.type === "AST_WHITESPACE_NODE";
    }
    /**
     * Checks if a node is a ERBContentNode
     */
    function isERBContentNode(node) {
        return node instanceof ERBContentNode || node.type === "AST_ERB_CONTENT_NODE" || node.constructor.type === "AST_ERB_CONTENT_NODE";
    }
    /**
     * Checks if a node is a ERBEndNode
     */
    function isERBEndNode(node) {
        return node instanceof ERBEndNode || node.type === "AST_ERB_END_NODE" || node.constructor.type === "AST_ERB_END_NODE";
    }
    /**
     * Checks if a node is a ERBElseNode
     */
    function isERBElseNode(node) {
        return node instanceof ERBElseNode || node.type === "AST_ERB_ELSE_NODE" || node.constructor.type === "AST_ERB_ELSE_NODE";
    }
    /**
     * Checks if a node is a ERBIfNode
     */
    function isERBIfNode(node) {
        return node instanceof ERBIfNode || node.type === "AST_ERB_IF_NODE" || node.constructor.type === "AST_ERB_IF_NODE";
    }
    /**
     * Checks if a node is a ERBBlockNode
     */
    function isERBBlockNode(node) {
        return node instanceof ERBBlockNode || node.type === "AST_ERB_BLOCK_NODE" || node.constructor.type === "AST_ERB_BLOCK_NODE";
    }
    /**
     * Checks if a node is a ERBWhenNode
     */
    function isERBWhenNode(node) {
        return node instanceof ERBWhenNode || node.type === "AST_ERB_WHEN_NODE" || node.constructor.type === "AST_ERB_WHEN_NODE";
    }
    /**
     * Checks if a node is a ERBCaseNode
     */
    function isERBCaseNode(node) {
        return node instanceof ERBCaseNode || node.type === "AST_ERB_CASE_NODE" || node.constructor.type === "AST_ERB_CASE_NODE";
    }
    /**
     * Checks if a node is a ERBCaseMatchNode
     */
    function isERBCaseMatchNode(node) {
        return node instanceof ERBCaseMatchNode || node.type === "AST_ERB_CASE_MATCH_NODE" || node.constructor.type === "AST_ERB_CASE_MATCH_NODE";
    }
    /**
     * Checks if a node is a ERBWhileNode
     */
    function isERBWhileNode(node) {
        return node instanceof ERBWhileNode || node.type === "AST_ERB_WHILE_NODE" || node.constructor.type === "AST_ERB_WHILE_NODE";
    }
    /**
     * Checks if a node is a ERBUntilNode
     */
    function isERBUntilNode(node) {
        return node instanceof ERBUntilNode || node.type === "AST_ERB_UNTIL_NODE" || node.constructor.type === "AST_ERB_UNTIL_NODE";
    }
    /**
     * Checks if a node is a ERBForNode
     */
    function isERBForNode(node) {
        return node instanceof ERBForNode || node.type === "AST_ERB_FOR_NODE" || node.constructor.type === "AST_ERB_FOR_NODE";
    }
    /**
     * Checks if a node is a ERBRescueNode
     */
    function isERBRescueNode(node) {
        return node instanceof ERBRescueNode || node.type === "AST_ERB_RESCUE_NODE" || node.constructor.type === "AST_ERB_RESCUE_NODE";
    }
    /**
     * Checks if a node is a ERBEnsureNode
     */
    function isERBEnsureNode(node) {
        return node instanceof ERBEnsureNode || node.type === "AST_ERB_ENSURE_NODE" || node.constructor.type === "AST_ERB_ENSURE_NODE";
    }
    /**
     * Checks if a node is a ERBBeginNode
     */
    function isERBBeginNode(node) {
        return node instanceof ERBBeginNode || node.type === "AST_ERB_BEGIN_NODE" || node.constructor.type === "AST_ERB_BEGIN_NODE";
    }
    /**
     * Checks if a node is a ERBUnlessNode
     */
    function isERBUnlessNode(node) {
        return node instanceof ERBUnlessNode || node.type === "AST_ERB_UNLESS_NODE" || node.constructor.type === "AST_ERB_UNLESS_NODE";
    }
    /**
     * Checks if a node is a ERBYieldNode
     */
    function isERBYieldNode(node) {
        return node instanceof ERBYieldNode || node.type === "AST_ERB_YIELD_NODE" || node.constructor.type === "AST_ERB_YIELD_NODE";
    }
    /**
     * Checks if a node is a ERBInNode
     */
    function isERBInNode(node) {
        return node instanceof ERBInNode || node.type === "AST_ERB_IN_NODE" || node.constructor.type === "AST_ERB_IN_NODE";
    }
    /**
     * Convenience type guards for common node categories
     */
    /**
     * Checks if a node is any HTML node type
     */
    function isHTMLNode(node) {
        return isHTMLOpenTagNode(node) ||
            isHTMLCloseTagNode(node) ||
            isHTMLElementNode(node) ||
            isHTMLAttributeValueNode(node) ||
            isHTMLAttributeNameNode(node) ||
            isHTMLAttributeNode(node) ||
            isHTMLTextNode(node) ||
            isHTMLCommentNode(node) ||
            isHTMLDoctypeNode(node);
    }
    /**
     * Checks if a node is any ERB node type
     */
    function isERBNode(node) {
        return isERBContentNode(node) ||
            isERBEndNode(node) ||
            isERBElseNode(node) ||
            isERBIfNode(node) ||
            isERBBlockNode(node) ||
            isERBWhenNode(node) ||
            isERBCaseNode(node) ||
            isERBCaseMatchNode(node) ||
            isERBWhileNode(node) ||
            isERBUntilNode(node) ||
            isERBForNode(node) ||
            isERBRescueNode(node) ||
            isERBEnsureNode(node) ||
            isERBBeginNode(node) ||
            isERBUnlessNode(node) ||
            isERBYieldNode(node) ||
            isERBInNode(node);
    }
    /**
     * Map of node classes to their corresponding type guard functions
     *
     * @example
     * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
     *
     * if (guard(node)) {
     *   // node is HTMLTextNode
     * }
     */
    const NODE_TYPE_GUARDS = new Map([
        [DocumentNode, isDocumentNode],
        [LiteralNode, isLiteralNode],
        [HTMLOpenTagNode, isHTMLOpenTagNode],
        [HTMLCloseTagNode, isHTMLCloseTagNode],
        [HTMLElementNode, isHTMLElementNode],
        [HTMLAttributeValueNode, isHTMLAttributeValueNode],
        [HTMLAttributeNameNode, isHTMLAttributeNameNode],
        [HTMLAttributeNode, isHTMLAttributeNode],
        [HTMLTextNode, isHTMLTextNode],
        [HTMLCommentNode, isHTMLCommentNode],
        [HTMLDoctypeNode, isHTMLDoctypeNode],
        [XMLDeclarationNode, isXMLDeclarationNode],
        [CDATANode, isCDATANode],
        [WhitespaceNode, isWhitespaceNode],
        [ERBContentNode, isERBContentNode],
        [ERBEndNode, isERBEndNode],
        [ERBElseNode, isERBElseNode],
        [ERBIfNode, isERBIfNode],
        [ERBBlockNode, isERBBlockNode],
        [ERBWhenNode, isERBWhenNode],
        [ERBCaseNode, isERBCaseNode],
        [ERBCaseMatchNode, isERBCaseMatchNode],
        [ERBWhileNode, isERBWhileNode],
        [ERBUntilNode, isERBUntilNode],
        [ERBForNode, isERBForNode],
        [ERBRescueNode, isERBRescueNode],
        [ERBEnsureNode, isERBEnsureNode],
        [ERBBeginNode, isERBBeginNode],
        [ERBUnlessNode, isERBUnlessNode],
        [ERBYieldNode, isERBYieldNode],
        [ERBInNode, isERBInNode],
    ]);
    /**
     * Map of AST node type strings to their corresponding type guard functions
     *
     * @example
     * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
     *
     * if (guard(node)) {
     *   // node is HTMLTextNode
     * }
     */
    const AST_TYPE_GUARDS = new Map([
        ["AST_DOCUMENT_NODE", isDocumentNode],
        ["AST_LITERAL_NODE", isLiteralNode],
        ["AST_HTML_OPEN_TAG_NODE", isHTMLOpenTagNode],
        ["AST_HTML_CLOSE_TAG_NODE", isHTMLCloseTagNode],
        ["AST_HTML_ELEMENT_NODE", isHTMLElementNode],
        ["AST_HTML_ATTRIBUTE_VALUE_NODE", isHTMLAttributeValueNode],
        ["AST_HTML_ATTRIBUTE_NAME_NODE", isHTMLAttributeNameNode],
        ["AST_HTML_ATTRIBUTE_NODE", isHTMLAttributeNode],
        ["AST_HTML_TEXT_NODE", isHTMLTextNode],
        ["AST_HTML_COMMENT_NODE", isHTMLCommentNode],
        ["AST_HTML_DOCTYPE_NODE", isHTMLDoctypeNode],
        ["AST_XML_DECLARATION_NODE", isXMLDeclarationNode],
        ["AST_CDATA_NODE", isCDATANode],
        ["AST_WHITESPACE_NODE", isWhitespaceNode],
        ["AST_ERB_CONTENT_NODE", isERBContentNode],
        ["AST_ERB_END_NODE", isERBEndNode],
        ["AST_ERB_ELSE_NODE", isERBElseNode],
        ["AST_ERB_IF_NODE", isERBIfNode],
        ["AST_ERB_BLOCK_NODE", isERBBlockNode],
        ["AST_ERB_WHEN_NODE", isERBWhenNode],
        ["AST_ERB_CASE_NODE", isERBCaseNode],
        ["AST_ERB_CASE_MATCH_NODE", isERBCaseMatchNode],
        ["AST_ERB_WHILE_NODE", isERBWhileNode],
        ["AST_ERB_UNTIL_NODE", isERBUntilNode],
        ["AST_ERB_FOR_NODE", isERBForNode],
        ["AST_ERB_RESCUE_NODE", isERBRescueNode],
        ["AST_ERB_ENSURE_NODE", isERBEnsureNode],
        ["AST_ERB_BEGIN_NODE", isERBBeginNode],
        ["AST_ERB_UNLESS_NODE", isERBUnlessNode],
        ["AST_ERB_YIELD_NODE", isERBYieldNode],
        ["AST_ERB_IN_NODE", isERBInNode],
    ]);
    /**
     * Checks if a node matches any of the provided type identifiers with proper type narrowing
     * Supports AST type strings, node classes, or type guard functions
     *
     * @example
     * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
     *   // node is narrowed to HTMLTextNode | LiteralNode
     * }
     *
     * @example
     * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
     *   // node is narrowed to HTMLTextNode | LiteralNode
     * }
     */
    function isAnyOf(node, ...types) {
        return types.some(type => {
            if (typeof type === 'string') {
                return isNode(node, type);
            }
            else if (typeof type === 'function' && type.prototype && type.prototype.constructor === type && NODE_TYPE_GUARDS.has(type)) {
                return isNode(node, type);
            }
            else if (typeof type === 'function') {
                return type(node);
            }
            else {
                return false;
            }
        });
    }
    /**
     * Checks if a node does NOT match any of the provided type identifiers
     * Supports AST type strings, node classes, or type guard functions
     * This is the logical inverse of isAnyOf
     *
     * @example
     * if (isNoneOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
     *   // node is neither HTMLTextNode nor LiteralNode
     * }
     *
     * @example
     * if (isNoneOf(node, HTMLTextNode, LiteralNode)) {
     *   // node is neither HTMLTextNode nor LiteralNode
     * }
     *
     * @example
     * if (isNoneOf(node, isHTMLTextNode, isLiteralNode)) {
     *   // node is neither HTMLTextNode nor LiteralNode
     * }
     */
    function isNoneOf(node, ...types) {
        return !isAnyOf(node, ...types);
    }
    function areAllOfType(nodes, ...types) {
        return nodes.every(node => isAnyOf(node, ...types));
    }
    function filterNodes(nodes, ...types) {
        if (!nodes)
            return [];
        return nodes.filter(node => isAnyOf(node, ...types));
    }
    function isNode(node, type) {
        if (!node)
            return false;
        if (typeof type === 'string') {
            const guard = AST_TYPE_GUARDS.get(type);
            return guard ? guard(node) : false;
        }
        else if (typeof type === 'function') {
            const guard = NODE_TYPE_GUARDS.get(type);
            return guard ? guard(node) : false;
        }
        else {
            return false;
        }
    }
    function isToken(object) {
        return (object instanceof Token) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
    }
    function isParseResult(object) {
        return (object instanceof ParseResult) || (object?.constructor?.name === "ParseResult" && "value" in object);
    }
    /**
     * Checks if a node has children (contains other nodes)
     */
    function hasChildren(node) {
        return isDocumentNode(node) ||
            isHTMLOpenTagNode(node) ||
            isHTMLCloseTagNode(node) ||
            isHTMLElementNode(node) ||
            isHTMLAttributeValueNode(node) ||
            isHTMLAttributeNameNode(node) ||
            isHTMLCommentNode(node) ||
            isHTMLDoctypeNode(node) ||
            isERBElseNode(node) ||
            isERBIfNode(node) ||
            isERBBlockNode(node) ||
            isERBWhenNode(node) ||
            isERBCaseNode(node) ||
            isERBCaseMatchNode(node) ||
            isERBWhileNode(node) ||
            isERBUntilNode(node) ||
            isERBForNode(node) ||
            isERBRescueNode(node) ||
            isERBEnsureNode(node) ||
            isERBBeginNode(node) ||
            isERBUnlessNode(node) ||
            isERBInNode(node);
    }
    /**
     * Filter functions for extracting specific node types from arrays
     */
    /**
     * Filters an array of nodes to only include DocumentNode nodes
     */
    function filterDocumentNodes(nodes) {
        return nodes.filter(isDocumentNode);
    }
    /**
     * Filters an array of nodes to only include LiteralNode nodes
     */
    function filterLiteralNodes(nodes) {
        return nodes.filter(isLiteralNode);
    }
    /**
     * Filters an array of nodes to only include HTMLOpenTagNode nodes
     */
    function filterHTMLOpenTagNodes(nodes) {
        return nodes.filter(isHTMLOpenTagNode);
    }
    /**
     * Filters an array of nodes to only include HTMLCloseTagNode nodes
     */
    function filterHTMLCloseTagNodes(nodes) {
        return nodes.filter(isHTMLCloseTagNode);
    }
    /**
     * Filters an array of nodes to only include HTMLElementNode nodes
     */
    function filterHTMLElementNodes(nodes) {
        return nodes.filter(isHTMLElementNode);
    }
    /**
     * Filters an array of nodes to only include HTMLAttributeValueNode nodes
     */
    function filterHTMLAttributeValueNodes(nodes) {
        return nodes.filter(isHTMLAttributeValueNode);
    }
    /**
     * Filters an array of nodes to only include HTMLAttributeNameNode nodes
     */
    function filterHTMLAttributeNameNodes(nodes) {
        return nodes.filter(isHTMLAttributeNameNode);
    }
    /**
     * Filters an array of nodes to only include HTMLAttributeNode nodes
     */
    function filterHTMLAttributeNodes(nodes) {
        return nodes.filter(isHTMLAttributeNode);
    }
    /**
     * Filters an array of nodes to only include HTMLTextNode nodes
     */
    function filterHTMLTextNodes(nodes) {
        return nodes.filter(isHTMLTextNode);
    }
    /**
     * Filters an array of nodes to only include HTMLCommentNode nodes
     */
    function filterHTMLCommentNodes(nodes) {
        return nodes.filter(isHTMLCommentNode);
    }
    /**
     * Filters an array of nodes to only include HTMLDoctypeNode nodes
     */
    function filterHTMLDoctypeNodes(nodes) {
        return nodes.filter(isHTMLDoctypeNode);
    }
    /**
     * Filters an array of nodes to only include XMLDeclarationNode nodes
     */
    function filterXMLDeclarationNodes(nodes) {
        return nodes.filter(isXMLDeclarationNode);
    }
    /**
     * Filters an array of nodes to only include CDATANode nodes
     */
    function filterCDATANodes(nodes) {
        return nodes.filter(isCDATANode);
    }
    /**
     * Filters an array of nodes to only include WhitespaceNode nodes
     */
    function filterWhitespaceNodes(nodes) {
        return nodes.filter(isWhitespaceNode);
    }
    /**
     * Filters an array of nodes to only include ERBContentNode nodes
     */
    function filterERBContentNodes(nodes) {
        return nodes.filter(isERBContentNode);
    }
    /**
     * Filters an array of nodes to only include ERBEndNode nodes
     */
    function filterERBEndNodes(nodes) {
        return nodes.filter(isERBEndNode);
    }
    /**
     * Filters an array of nodes to only include ERBElseNode nodes
     */
    function filterERBElseNodes(nodes) {
        return nodes.filter(isERBElseNode);
    }
    /**
     * Filters an array of nodes to only include ERBIfNode nodes
     */
    function filterERBIfNodes(nodes) {
        return nodes.filter(isERBIfNode);
    }
    /**
     * Filters an array of nodes to only include ERBBlockNode nodes
     */
    function filterERBBlockNodes(nodes) {
        return nodes.filter(isERBBlockNode);
    }
    /**
     * Filters an array of nodes to only include ERBWhenNode nodes
     */
    function filterERBWhenNodes(nodes) {
        return nodes.filter(isERBWhenNode);
    }
    /**
     * Filters an array of nodes to only include ERBCaseNode nodes
     */
    function filterERBCaseNodes(nodes) {
        return nodes.filter(isERBCaseNode);
    }
    /**
     * Filters an array of nodes to only include ERBCaseMatchNode nodes
     */
    function filterERBCaseMatchNodes(nodes) {
        return nodes.filter(isERBCaseMatchNode);
    }
    /**
     * Filters an array of nodes to only include ERBWhileNode nodes
     */
    function filterERBWhileNodes(nodes) {
        return nodes.filter(isERBWhileNode);
    }
    /**
     * Filters an array of nodes to only include ERBUntilNode nodes
     */
    function filterERBUntilNodes(nodes) {
        return nodes.filter(isERBUntilNode);
    }
    /**
     * Filters an array of nodes to only include ERBForNode nodes
     */
    function filterERBForNodes(nodes) {
        return nodes.filter(isERBForNode);
    }
    /**
     * Filters an array of nodes to only include ERBRescueNode nodes
     */
    function filterERBRescueNodes(nodes) {
        return nodes.filter(isERBRescueNode);
    }
    /**
     * Filters an array of nodes to only include ERBEnsureNode nodes
     */
    function filterERBEnsureNodes(nodes) {
        return nodes.filter(isERBEnsureNode);
    }
    /**
     * Filters an array of nodes to only include ERBBeginNode nodes
     */
    function filterERBBeginNodes(nodes) {
        return nodes.filter(isERBBeginNode);
    }
    /**
     * Filters an array of nodes to only include ERBUnlessNode nodes
     */
    function filterERBUnlessNodes(nodes) {
        return nodes.filter(isERBUnlessNode);
    }
    /**
     * Filters an array of nodes to only include ERBYieldNode nodes
     */
    function filterERBYieldNodes(nodes) {
        return nodes.filter(isERBYieldNode);
    }
    /**
     * Filters an array of nodes to only include ERBInNode nodes
     */
    function filterERBInNodes(nodes) {
        return nodes.filter(isERBInNode);
    }

    /**
     * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
     */
    function isERBOutputNode(node) {
        return isNode(node, ERBContentNode) && ["<%=", "<%=="].includes(node.tag_opening?.value);
    }
    /**
     * Checks if a node is a non-output ERB node (control flow: <% %>)
     */
    function isERBControlFlowNode(node) {
        return isAnyOf(node, ERBIfNode, ERBUnlessNode, ERBBlockNode, ERBCaseNode, ERBCaseMatchNode, ERBWhileNode, ERBForNode, ERBBeginNode);
    }
    /**
     * Checks if an array of nodes contains any ERB content nodes
     */
    function hasERBContent(nodes) {
        return nodes.some(isERBContentNode);
    }
    /**
     * Checks if an array of nodes contains any ERB output nodes (dynamic content)
     */
    function hasERBOutput(nodes) {
        return nodes.some(isERBOutputNode);
    }
    /**
     * Extracts a static string from an array of literal nodes
     * Returns null if any node is not a literal node
     */
    function getStaticStringFromNodes(nodes) {
        if (!areAllOfType(nodes, LiteralNode)) {
            return null;
        }
        return nodes.map(node => node.content).join("");
    }
    /**
     * Extracts static content from nodes, including mixed literal/ERB content
     * Returns the concatenated literal content, or null if no literal nodes exist
     */
    function getStaticContentFromNodes(nodes) {
        const literalNodes = filterLiteralNodes(nodes);
        if (literalNodes.length === 0) {
            return null;
        }
        return literalNodes.map(node => node.content).join("");
    }
    /**
     * Checks if nodes contain any literal content (for static validation)
     */
    function hasStaticContent(nodes) {
        return nodes.some(isLiteralNode);
    }
    /**
     * Checks if nodes are effectively static (only literals and non-output ERB)
     * Non-output ERB like <% if %> doesn't affect static validation
     */
    function isEffectivelyStatic(nodes) {
        return !hasERBOutput(nodes);
    }
    /**
     * Gets static-validatable content from nodes (ignores control ERB, includes literals)
     * Returns concatenated literal content for validation, or null if contains output ERB
     */
    function getValidatableStaticContent(nodes) {
        if (hasERBOutput(nodes)) {
            return null;
        }
        return filterLiteralNodes(nodes).map(node => node.content).join("");
    }
    /**
     * Extracts a combined string from nodes, including ERB content
     * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
     * This is useful for debugging or displaying the full attribute name
     */
    function getCombinedStringFromNodes(nodes) {
        return nodes.map(node => {
            if (isLiteralNode(node)) {
                return node.content;
            }
            else if (isERBContentNode(node)) {
                const opening = node.tag_opening?.value || "";
                const content = node.content?.value || "";
                const closing = node.tag_closing?.value || "";
                return `${opening}${content}${closing}`;
            }
            else {
                // For other node types, return a placeholder or empty string
                return `[${node.type}]`;
            }
        }).join("");
    }
    /**
     * Checks if an HTML attribute name node has a static (literal-only) name
     */
    function hasStaticAttributeName(attributeNameNode) {
        if (!attributeNameNode.children) {
            return false;
        }
        return areAllOfType(attributeNameNode.children, LiteralNode);
    }
    /**
     * Checks if an HTML attribute name node has dynamic content (contains ERB)
     */
    function hasDynamicAttributeName(attributeNameNode) {
        if (!attributeNameNode.children) {
            return false;
        }
        return hasERBContent(attributeNameNode.children);
    }
    /**
     * Gets the static string value of an HTML attribute name node
     * Returns null if the attribute name contains dynamic content (ERB)
     */
    function getStaticAttributeName(attributeNameNode) {
        if (!attributeNameNode.children) {
            return null;
        }
        return getStaticStringFromNodes(attributeNameNode.children);
    }
    /**
     * Gets the combined string representation of an HTML attribute name node
     * This includes both static and dynamic content, useful for debugging
     */
    function getCombinedAttributeName(attributeNameNode) {
        if (!attributeNameNode.children) {
            return "";
        }
        return getCombinedStringFromNodes(attributeNameNode.children);
    }
    /**
     * Gets the tag name of an HTML element node
     */
    function getTagName(node) {
        return node.tag_name?.value ?? "";
    }
    /**
     * Check if a node is a comment (HTML comment or ERB comment)
     */
    function isCommentNode(node) {
        return isNode(node, HTMLCommentNode) || (isERBNode(node) && !isERBControlFlowNode(node));
    }
    /**
     * Compares two positions to determine if the first comes before the second
     * Returns true if pos1 comes before pos2 in source order
     * @param inclusive - If true, returns true when positions are equal
     */
    function isPositionBefore(position1, position2, inclusive = false) {
        if (position1.line < position2.line)
            return true;
        if (position1.line > position2.line)
            return false;
        return inclusive ? position1.column <= position2.column : position1.column < position2.column;
    }
    /**
     * Compares two positions to determine if they are equal
     * Returns true if pos1 and pos2 are at the same location
     */
    function isPositionEqual(position1, position2) {
        return position1.line === position2.line && position1.column === position2.column;
    }
    /**
     * Compares two positions to determine if the first comes after the second
     * Returns true if pos1 comes after pos2 in source order
     * @param inclusive - If true, returns true when positions are equal
     */
    function isPositionAfter(position1, position2, inclusive = false) {
        if (position1.line > position2.line)
            return true;
        if (position1.line < position2.line)
            return false;
        return inclusive ? position1.column >= position2.column : position1.column > position2.column;
    }
    /**
     * Gets nodes that appear before the specified location in source order
     * Uses line and column positions to determine ordering
     */
    function getNodesBeforeLocation(nodes, location) {
        return nodes.filter(node => node.location && isPositionBefore(node.location.end, location.start));
    }
    /**
     * Gets nodes that appear after the specified location in source order
     * Uses line and column positions to determine ordering
     */
    function getNodesAfterLocation(nodes, location) {
        return nodes.filter(node => node.location && isPositionAfter(node.location.start, location.end));
    }
    /**
     * Splits nodes into before and after the specified location
     * Returns an object with `before` and `after` arrays
     */
    function splitNodesAroundLocation(nodes, location) {
        return {
            before: getNodesBeforeLocation(nodes, location),
            after: getNodesAfterLocation(nodes, location)
        };
    }
    /**
     * Splits nodes at a specific position
     * Returns nodes that end before the position and nodes that start after the position
     * More precise than splitNodesAroundLocation as it uses a single position point
     * Uses the same defaults as the individual functions: before=exclusive, after=inclusive
     */
    function splitNodesAroundPosition(nodes, position) {
        return {
            before: getNodesBeforePosition(nodes, position), // uses default: inclusive = false
            after: getNodesAfterPosition(nodes, position) // uses default: inclusive = true
        };
    }
    /**
     * Gets nodes that end before the specified position
     * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
     */
    function getNodesBeforePosition(nodes, position, inclusive = false) {
        return nodes.filter(node => node.location && isPositionBefore(node.location.end, position, inclusive));
    }
    /**
     * Gets nodes that start after the specified position
     * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
     */
    function getNodesAfterPosition(nodes, position, inclusive = true) {
        return nodes.filter(node => node.location && isPositionAfter(node.location.start, position, inclusive));
    }

    const expectedFunctions = [
        "parse",
        "lex",
        "parseFile",
        "lexFile",
        "extractRuby",
        "extractHTML",
        "version",
    ];
    // NOTE: This function should never be called and is only for type checking
    // so we can make sure `expectedFunctions` matches the functions defined
    // in `LibHerbBackendFunctions` and the other way around.
    //
    function _TYPECHECK() {
        const checkFunctionsExist = true;
        const checkInterfaceComplete = true;
        return { checkFunctionsExist, checkInterfaceComplete };
    }
    function isLibHerbBackend(object, libherbpath = "unknown") {
        for (const expectedFunction of expectedFunctions) {
            if (object[expectedFunction] === undefined) {
                throw new Error(`Libherb at "${libherbpath}" doesn't expose function "${expectedFunction}".`);
            }
            if (typeof object[expectedFunction] !== "function") {
                throw new Error(`Libherb at "${libherbpath}" has "${expectedFunction}" but it's not a function.`);
            }
        }
        return true;
    }
    function ensureLibHerbBackend(object, libherbpath = "unknown") {
        isLibHerbBackend(object, libherbpath);
        return object;
    }

    /**
     * Converts a Diagnostic to Monaco/VSCode-compatible MonacoDiagnostic format
     */
    function toMonacoDiagnostic(diagnostic) {
        const { message, location } = diagnostic;
        const severity = diagnostic.severity === "hint" ? "info" : diagnostic.severity;
        return {
            line: location.start.line,
            column: location.start.column,
            endLine: location.end.line,
            endColumn: location.end.column,
            message,
            severity
        };
    }

    var name = "@herb-tools/core";
    var version = "0.6.1";
    var packageJSON = {
    	name: name,
    	version: version};

    class TokenList {
        list;
        static from(list) {
            return new TokenList(list.map((token) => Token.from(token)));
        }
        constructor(list) {
            this.list = list;
        }
        get length() {
            return this.list.length;
        }
        get tokens() {
            return this.list;
        }
        [Symbol.iterator]() {
            return this.list[Symbol.iterator]();
        }
        at(index) {
            return this.list.at(index);
        }
        forEach(callback) {
            this.list.forEach(callback);
        }
        map(callback) {
            return this.list.map(callback);
        }
        filter(predicate) {
            return this.list.filter(predicate);
        }
        __getobj__() {
            return this.list;
        }
        inspect() {
            return this.list.map((token) => token.inspect()).join("\n") + "\n";
        }
        toString() {
            return this.inspect();
        }
    }

    /**
     * Represents the result of a lexical analysis, extending the base `Result` class.
     * It contains the token list, source code, warnings, and errors.
     */
    class LexResult extends Result {
        /** The list of tokens generated from the source code. */
        value;
        /**
         * Creates a `LexResult` instance from a serialized result.
         * @param result - The serialized lexical result containing tokens, source, warnings, and errors.
         * @returns A new `LexResult` instance.
         */
        static from(result) {
            return new LexResult(TokenList.from(result.tokens || []), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
        }
        /**
         * Constructs a new `LexResult`.
         * @param value - The list of tokens.
         * @param source - The source code that was lexed.
         * @param warnings - An array of warnings encountered during lexing.
         * @param errors - An array of errors encountered during lexing.
         */
        constructor(value, source, warnings = [], errors = []) {
            super(source, warnings, errors);
            this.value = value;
        }
        /**
         * Determines if the lexing was successful.
         * @returns `true` if there are no errors, otherwise `false`.
         */
        get successful() {
            return this.errors.length === 0;
        }
        /**
         * Determines if the lexing failed.
         * @returns `true` if there are errors, otherwise `false`.
         */
        get failed() {
            return this.errors.length > 0;
        }
        /**
         * Converts the `LexResult` to a JSON representation.
         * @returns An object containing the token list, source, warnings, and errors.
         */
        toJSON() {
            return {
                value: this.value,
                source: this.source,
                warnings: this.warnings,
                errors: this.errors,
            };
        }
    }

    const DEFAULT_PARSER_OPTIONS = {
        track_whitespace: false,
    };

    /**
     * The main Herb parser interface, providing methods to lex and parse input.
     */
    class HerbBackend {
        /** The backend instance handling lexing and parsing. */
        backend = undefined;
        backendPromise;
        /**
         * Creates a new Herb instance.
         * @param backendPromise - A promise resolving to a `LibHerbBackend` implementation for lexing and parsing.
         * @throws Error if no valid backend is provided.
         */
        constructor(backendPromise) {
            if (!backendPromise) {
                throw new Error("No LibHerb backend provided");
            }
            this.backendPromise = backendPromise;
        }
        /**
         * Loads the backend by resolving the backend promise.
         * @returns A promise containing the resolved `HerbBackend` instance after loading it.
         */
        async load() {
            const backend = await this.backendPromise();
            this.backend = backend;
            return this;
        }
        /**
         * Lexes the given source string into a `LexResult`.
         * @param source - The source code to lex.
         * @returns A `LexResult` instance.
         * @throws Error if the backend is not loaded.
         */
        lex(source) {
            this.ensureBackend();
            return LexResult.from(this.backend.lex(ensureString(source)));
        }
        /**
         * Lexes a file.
         * @param path - The file path to lex.
         * @returns A `LexResult` instance.
         * @throws Error if the backend is not loaded.
         */
        lexFile(path) {
            this.ensureBackend();
            return LexResult.from(this.backend.lexFile(ensureString(path)));
        }
        /**
         * Parses the given source string into a `ParseResult`.
         * @param source - The source code to parse.
         * @param options - Optional parsing options.
         * @returns A `ParseResult` instance.
         * @throws Error if the backend is not loaded.
         */
        parse(source, options) {
            this.ensureBackend();
            const mergedOptions = { ...DEFAULT_PARSER_OPTIONS, ...options };
            return ParseResult.from(this.backend.parse(ensureString(source), mergedOptions));
        }
        /**
         * Parses a file.
         * @param path - The file path to parse.
         * @returns A `ParseResult` instance.
         * @throws Error if the backend is not loaded.
         */
        parseFile(path) {
            this.ensureBackend();
            return ParseResult.from(this.backend.parseFile(ensureString(path)));
        }
        /**
         * Extracts embedded Ruby code from the given source.
         * @param source - The source code to extract Ruby from.
         * @returns The extracted Ruby code as a string.
         * @throws Error if the backend is not loaded.
         */
        extractRuby(source) {
            this.ensureBackend();
            return this.backend.extractRuby(ensureString(source));
        }
        /**
         * Extracts HTML from the given source.
         * @param source - The source code to extract HTML from.
         * @returns The extracted HTML as a string.
         * @throws Error if the backend is not loaded.
         */
        extractHTML(source) {
            this.ensureBackend();
            return this.backend.extractHTML(ensureString(source));
        }
        /**
         * Gets the Herb version information, including the core and backend versions.
         * @returns A version string containing backend, core, and libherb versions.
         * @throws Error if the backend is not loaded.
         */
        get version() {
            this.ensureBackend();
            const backend = this.backendVersion();
            const core = `${packageJSON.name}@${packageJSON.version}`;
            const libherb = this.backend.version();
            return `${backend}, ${core}, ${libherb}`;
        }
        /**
         * Ensures that the backend is loaded.
         * @throws Error if the backend is not loaded.
         */
        ensureBackend() {
            if (!this.isLoaded) {
                throw new Error("Herb backend is not loaded. Call `await Herb.load()` first.");
            }
        }
        /**
         * Checks if the backend is loaded.
         * @returns True if the backend is loaded, false otherwise.
         */
        get isLoaded() {
            return this.backend !== undefined;
        }
    }

    // NOTE: This file is generated by the templates/template.rb script and should not
    // be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/visitor.ts.erb
    class Visitor {
        visit(node) {
            if (!node)
                return;
            node.accept(this);
        }
        visitAll(nodes) {
            nodes.forEach(node => node?.accept(this));
        }
        visitChildNodes(node) {
            node.compactChildNodes().forEach(node => node.accept(this));
        }
        visitDocumentNode(node) {
            this.visitChildNodes(node);
        }
        visitLiteralNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLOpenTagNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLCloseTagNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLElementNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLAttributeValueNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLAttributeNameNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLAttributeNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLTextNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLCommentNode(node) {
            this.visitChildNodes(node);
        }
        visitHTMLDoctypeNode(node) {
            this.visitChildNodes(node);
        }
        visitXMLDeclarationNode(node) {
            this.visitChildNodes(node);
        }
        visitCDATANode(node) {
            this.visitChildNodes(node);
        }
        visitWhitespaceNode(node) {
            this.visitChildNodes(node);
        }
        visitERBContentNode(node) {
            this.visitChildNodes(node);
        }
        visitERBEndNode(node) {
            this.visitChildNodes(node);
        }
        visitERBElseNode(node) {
            this.visitChildNodes(node);
        }
        visitERBIfNode(node) {
            this.visitChildNodes(node);
        }
        visitERBBlockNode(node) {
            this.visitChildNodes(node);
        }
        visitERBWhenNode(node) {
            this.visitChildNodes(node);
        }
        visitERBCaseNode(node) {
            this.visitChildNodes(node);
        }
        visitERBCaseMatchNode(node) {
            this.visitChildNodes(node);
        }
        visitERBWhileNode(node) {
            this.visitChildNodes(node);
        }
        visitERBUntilNode(node) {
            this.visitChildNodes(node);
        }
        visitERBForNode(node) {
            this.visitChildNodes(node);
        }
        visitERBRescueNode(node) {
            this.visitChildNodes(node);
        }
        visitERBEnsureNode(node) {
            this.visitChildNodes(node);
        }
        visitERBBeginNode(node) {
            this.visitChildNodes(node);
        }
        visitERBUnlessNode(node) {
            this.visitChildNodes(node);
        }
        visitERBYieldNode(node) {
            this.visitChildNodes(node);
        }
        visitERBInNode(node) {
            this.visitChildNodes(node);
        }
    }

    exports.AST_TYPE_GUARDS = AST_TYPE_GUARDS;
    exports.CDATANode = CDATANode;
    exports.DEFAULT_PARSER_OPTIONS = DEFAULT_PARSER_OPTIONS;
    exports.DocumentNode = DocumentNode;
    exports.ERBBeginNode = ERBBeginNode;
    exports.ERBBlockNode = ERBBlockNode;
    exports.ERBCaseMatchNode = ERBCaseMatchNode;
    exports.ERBCaseNode = ERBCaseNode;
    exports.ERBContentNode = ERBContentNode;
    exports.ERBElseNode = ERBElseNode;
    exports.ERBEndNode = ERBEndNode;
    exports.ERBEnsureNode = ERBEnsureNode;
    exports.ERBForNode = ERBForNode;
    exports.ERBIfNode = ERBIfNode;
    exports.ERBInNode = ERBInNode;
    exports.ERBNodeClasses = ERBNodeClasses;
    exports.ERBRescueNode = ERBRescueNode;
    exports.ERBUnlessNode = ERBUnlessNode;
    exports.ERBUntilNode = ERBUntilNode;
    exports.ERBWhenNode = ERBWhenNode;
    exports.ERBWhileNode = ERBWhileNode;
    exports.ERBYieldNode = ERBYieldNode;
    exports.HTMLAttributeNameNode = HTMLAttributeNameNode;
    exports.HTMLAttributeNode = HTMLAttributeNode;
    exports.HTMLAttributeValueNode = HTMLAttributeValueNode;
    exports.HTMLCloseTagNode = HTMLCloseTagNode;
    exports.HTMLCommentNode = HTMLCommentNode;
    exports.HTMLDoctypeNode = HTMLDoctypeNode;
    exports.HTMLElementNode = HTMLElementNode;
    exports.HTMLOpenTagNode = HTMLOpenTagNode;
    exports.HTMLTextNode = HTMLTextNode;
    exports.HerbBackend = HerbBackend;
    exports.HerbError = HerbError;
    exports.HerbWarning = HerbWarning;
    exports.LexResult = LexResult;
    exports.LiteralNode = LiteralNode;
    exports.Location = Location;
    exports.MissingClosingTagError = MissingClosingTagError;
    exports.MissingOpeningTagError = MissingOpeningTagError;
    exports.NODE_TYPE_GUARDS = NODE_TYPE_GUARDS;
    exports.Node = Node;
    exports.ParseResult = ParseResult;
    exports.Position = Position;
    exports.QuotesMismatchError = QuotesMismatchError;
    exports.Range = Range;
    exports.Result = Result;
    exports.RubyParseError = RubyParseError;
    exports.TagNamesMismatchError = TagNamesMismatchError;
    exports.Token = Token;
    exports.TokenList = TokenList;
    exports.UnclosedElementError = UnclosedElementError;
    exports.UnexpectedError = UnexpectedError;
    exports.UnexpectedTokenError = UnexpectedTokenError;
    exports.Visitor = Visitor;
    exports.VoidElementClosingTagError = VoidElementClosingTagError;
    exports.WhitespaceNode = WhitespaceNode;
    exports.XMLDeclarationNode = XMLDeclarationNode;
    exports._TYPECHECK = _TYPECHECK;
    exports.areAllOfType = areAllOfType;
    exports.convertToUTF8 = convertToUTF8;
    exports.ensureLibHerbBackend = ensureLibHerbBackend;
    exports.ensureString = ensureString;
    exports.filterCDATANodes = filterCDATANodes;
    exports.filterDocumentNodes = filterDocumentNodes;
    exports.filterERBBeginNodes = filterERBBeginNodes;
    exports.filterERBBlockNodes = filterERBBlockNodes;
    exports.filterERBCaseMatchNodes = filterERBCaseMatchNodes;
    exports.filterERBCaseNodes = filterERBCaseNodes;
    exports.filterERBContentNodes = filterERBContentNodes;
    exports.filterERBElseNodes = filterERBElseNodes;
    exports.filterERBEndNodes = filterERBEndNodes;
    exports.filterERBEnsureNodes = filterERBEnsureNodes;
    exports.filterERBForNodes = filterERBForNodes;
    exports.filterERBIfNodes = filterERBIfNodes;
    exports.filterERBInNodes = filterERBInNodes;
    exports.filterERBRescueNodes = filterERBRescueNodes;
    exports.filterERBUnlessNodes = filterERBUnlessNodes;
    exports.filterERBUntilNodes = filterERBUntilNodes;
    exports.filterERBWhenNodes = filterERBWhenNodes;
    exports.filterERBWhileNodes = filterERBWhileNodes;
    exports.filterERBYieldNodes = filterERBYieldNodes;
    exports.filterHTMLAttributeNameNodes = filterHTMLAttributeNameNodes;
    exports.filterHTMLAttributeNodes = filterHTMLAttributeNodes;
    exports.filterHTMLAttributeValueNodes = filterHTMLAttributeValueNodes;
    exports.filterHTMLCloseTagNodes = filterHTMLCloseTagNodes;
    exports.filterHTMLCommentNodes = filterHTMLCommentNodes;
    exports.filterHTMLDoctypeNodes = filterHTMLDoctypeNodes;
    exports.filterHTMLElementNodes = filterHTMLElementNodes;
    exports.filterHTMLOpenTagNodes = filterHTMLOpenTagNodes;
    exports.filterHTMLTextNodes = filterHTMLTextNodes;
    exports.filterLiteralNodes = filterLiteralNodes;
    exports.filterNodes = filterNodes;
    exports.filterWhitespaceNodes = filterWhitespaceNodes;
    exports.filterXMLDeclarationNodes = filterXMLDeclarationNodes;
    exports.fromSerializedError = fromSerializedError;
    exports.fromSerializedNode = fromSerializedNode;
    exports.getCombinedAttributeName = getCombinedAttributeName;
    exports.getCombinedStringFromNodes = getCombinedStringFromNodes;
    exports.getNodesAfterLocation = getNodesAfterLocation;
    exports.getNodesAfterPosition = getNodesAfterPosition;
    exports.getNodesBeforeLocation = getNodesBeforeLocation;
    exports.getNodesBeforePosition = getNodesBeforePosition;
    exports.getStaticAttributeName = getStaticAttributeName;
    exports.getStaticContentFromNodes = getStaticContentFromNodes;
    exports.getStaticStringFromNodes = getStaticStringFromNodes;
    exports.getTagName = getTagName;
    exports.getValidatableStaticContent = getValidatableStaticContent;
    exports.hasChildren = hasChildren;
    exports.hasDynamicAttributeName = hasDynamicAttributeName;
    exports.hasERBContent = hasERBContent;
    exports.hasERBOutput = hasERBOutput;
    exports.hasStaticAttributeName = hasStaticAttributeName;
    exports.hasStaticContent = hasStaticContent;
    exports.isAnyOf = isAnyOf;
    exports.isCDATANode = isCDATANode;
    exports.isCommentNode = isCommentNode;
    exports.isDocumentNode = isDocumentNode;
    exports.isERBBeginNode = isERBBeginNode;
    exports.isERBBlockNode = isERBBlockNode;
    exports.isERBCaseMatchNode = isERBCaseMatchNode;
    exports.isERBCaseNode = isERBCaseNode;
    exports.isERBContentNode = isERBContentNode;
    exports.isERBControlFlowNode = isERBControlFlowNode;
    exports.isERBElseNode = isERBElseNode;
    exports.isERBEndNode = isERBEndNode;
    exports.isERBEnsureNode = isERBEnsureNode;
    exports.isERBForNode = isERBForNode;
    exports.isERBIfNode = isERBIfNode;
    exports.isERBInNode = isERBInNode;
    exports.isERBNode = isERBNode;
    exports.isERBOutputNode = isERBOutputNode;
    exports.isERBRescueNode = isERBRescueNode;
    exports.isERBUnlessNode = isERBUnlessNode;
    exports.isERBUntilNode = isERBUntilNode;
    exports.isERBWhenNode = isERBWhenNode;
    exports.isERBWhileNode = isERBWhileNode;
    exports.isERBYieldNode = isERBYieldNode;
    exports.isEffectivelyStatic = isEffectivelyStatic;
    exports.isHTMLAttributeNameNode = isHTMLAttributeNameNode;
    exports.isHTMLAttributeNode = isHTMLAttributeNode;
    exports.isHTMLAttributeValueNode = isHTMLAttributeValueNode;
    exports.isHTMLCloseTagNode = isHTMLCloseTagNode;
    exports.isHTMLCommentNode = isHTMLCommentNode;
    exports.isHTMLDoctypeNode = isHTMLDoctypeNode;
    exports.isHTMLElementNode = isHTMLElementNode;
    exports.isHTMLNode = isHTMLNode;
    exports.isHTMLOpenTagNode = isHTMLOpenTagNode;
    exports.isHTMLTextNode = isHTMLTextNode;
    exports.isLibHerbBackend = isLibHerbBackend;
    exports.isLiteralNode = isLiteralNode;
    exports.isNode = isNode;
    exports.isNoneOf = isNoneOf;
    exports.isParseResult = isParseResult;
    exports.isPositionAfter = isPositionAfter;
    exports.isPositionEqual = isPositionEqual;
    exports.isToken = isToken;
    exports.isWhitespaceNode = isWhitespaceNode;
    exports.isXMLDeclarationNode = isXMLDeclarationNode;
    exports.splitNodesAroundLocation = splitNodesAroundLocation;
    exports.splitNodesAroundPosition = splitNodesAroundPosition;
    exports.toMonacoDiagnostic = toMonacoDiagnostic;

}));
//# sourceMappingURL=herb-core.umd.js.map
