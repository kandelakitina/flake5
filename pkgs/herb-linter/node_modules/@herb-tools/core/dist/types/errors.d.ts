import { Location, SerializedLocation } from "./location.js";
import { Token, SerializedToken } from "./token.js";
import { Diagnostic, MonacoDiagnostic } from "./diagnostic.js";
export type HerbErrorType = "UNEXPECTED_ERROR" | "UNEXPECTED_TOKEN_ERROR" | "MISSING_OPENING_TAG_ERROR" | "MISSING_CLOSING_TAG_ERROR" | "TAG_NAMES_MISMATCH_ERROR" | "QUOTES_MISMATCH_ERROR" | "VOID_ELEMENT_CLOSING_TAG_ERROR" | "UNCLOSED_ELEMENT_ERROR" | "RUBY_PARSE_ERROR";
export type SerializedErrorType = string;
export interface SerializedHerbError {
    type: string;
    message: string;
    location: SerializedLocation;
}
export declare abstract class HerbError implements Diagnostic {
    readonly type: string;
    readonly message: string;
    readonly location: Location;
    readonly severity: "error" | "warning" | "info" | "hint";
    readonly source: string;
    get code(): string;
    static from(error: SerializedHerbError): HerbError;
    constructor(type: string, message: string, location: Location);
    toJSON(): SerializedHerbError;
    inspect(): string;
    abstract treeInspect(indent?: number): string;
}
export interface SerializedUnexpectedError {
    type: "UNEXPECTED_ERROR";
    message: string;
    location: SerializedLocation;
    description: string;
    expected: string;
    found: string;
}
export interface UnexpectedErrorProps {
    type: string;
    message: string;
    location: Location;
    description: string;
    expected: string;
    found: string;
}
export declare class UnexpectedError extends HerbError {
    readonly description: string;
    readonly expected: string;
    readonly found: string;
    static from(data: SerializedUnexpectedError): UnexpectedError;
    constructor(props: UnexpectedErrorProps);
    toJSON(): SerializedUnexpectedError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedUnexpectedTokenError {
    type: "UNEXPECTED_TOKEN_ERROR";
    message: string;
    location: SerializedLocation;
    expected_type: string | null;
    found: SerializedToken | null;
}
export interface UnexpectedTokenErrorProps {
    type: string;
    message: string;
    location: Location;
    expected_type: string | null;
    found: Token | null;
}
export declare class UnexpectedTokenError extends HerbError {
    readonly expected_type: string | null;
    readonly found: Token | null;
    static from(data: SerializedUnexpectedTokenError): UnexpectedTokenError;
    constructor(props: UnexpectedTokenErrorProps);
    toJSON(): SerializedUnexpectedTokenError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedMissingOpeningTagError {
    type: "MISSING_OPENING_TAG_ERROR";
    message: string;
    location: SerializedLocation;
    closing_tag: SerializedToken | null;
}
export interface MissingOpeningTagErrorProps {
    type: string;
    message: string;
    location: Location;
    closing_tag: Token | null;
}
export declare class MissingOpeningTagError extends HerbError {
    readonly closing_tag: Token | null;
    static from(data: SerializedMissingOpeningTagError): MissingOpeningTagError;
    constructor(props: MissingOpeningTagErrorProps);
    toJSON(): SerializedMissingOpeningTagError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedMissingClosingTagError {
    type: "MISSING_CLOSING_TAG_ERROR";
    message: string;
    location: SerializedLocation;
    opening_tag: SerializedToken | null;
}
export interface MissingClosingTagErrorProps {
    type: string;
    message: string;
    location: Location;
    opening_tag: Token | null;
}
export declare class MissingClosingTagError extends HerbError {
    readonly opening_tag: Token | null;
    static from(data: SerializedMissingClosingTagError): MissingClosingTagError;
    constructor(props: MissingClosingTagErrorProps);
    toJSON(): SerializedMissingClosingTagError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedTagNamesMismatchError {
    type: "TAG_NAMES_MISMATCH_ERROR";
    message: string;
    location: SerializedLocation;
    opening_tag: SerializedToken | null;
    closing_tag: SerializedToken | null;
}
export interface TagNamesMismatchErrorProps {
    type: string;
    message: string;
    location: Location;
    opening_tag: Token | null;
    closing_tag: Token | null;
}
export declare class TagNamesMismatchError extends HerbError {
    readonly opening_tag: Token | null;
    readonly closing_tag: Token | null;
    static from(data: SerializedTagNamesMismatchError): TagNamesMismatchError;
    constructor(props: TagNamesMismatchErrorProps);
    toJSON(): SerializedTagNamesMismatchError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedQuotesMismatchError {
    type: "QUOTES_MISMATCH_ERROR";
    message: string;
    location: SerializedLocation;
    opening_quote: SerializedToken | null;
    closing_quote: SerializedToken | null;
}
export interface QuotesMismatchErrorProps {
    type: string;
    message: string;
    location: Location;
    opening_quote: Token | null;
    closing_quote: Token | null;
}
export declare class QuotesMismatchError extends HerbError {
    readonly opening_quote: Token | null;
    readonly closing_quote: Token | null;
    static from(data: SerializedQuotesMismatchError): QuotesMismatchError;
    constructor(props: QuotesMismatchErrorProps);
    toJSON(): SerializedQuotesMismatchError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedVoidElementClosingTagError {
    type: "VOID_ELEMENT_CLOSING_TAG_ERROR";
    message: string;
    location: SerializedLocation;
    tag_name: SerializedToken | null;
    expected: string;
    found: string;
}
export interface VoidElementClosingTagErrorProps {
    type: string;
    message: string;
    location: Location;
    tag_name: Token | null;
    expected: string;
    found: string;
}
export declare class VoidElementClosingTagError extends HerbError {
    readonly tag_name: Token | null;
    readonly expected: string;
    readonly found: string;
    static from(data: SerializedVoidElementClosingTagError): VoidElementClosingTagError;
    constructor(props: VoidElementClosingTagErrorProps);
    toJSON(): SerializedVoidElementClosingTagError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedUnclosedElementError {
    type: "UNCLOSED_ELEMENT_ERROR";
    message: string;
    location: SerializedLocation;
    opening_tag: SerializedToken | null;
}
export interface UnclosedElementErrorProps {
    type: string;
    message: string;
    location: Location;
    opening_tag: Token | null;
}
export declare class UnclosedElementError extends HerbError {
    readonly opening_tag: Token | null;
    static from(data: SerializedUnclosedElementError): UnclosedElementError;
    constructor(props: UnclosedElementErrorProps);
    toJSON(): SerializedUnclosedElementError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export interface SerializedRubyParseError {
    type: "RUBY_PARSE_ERROR";
    message: string;
    location: SerializedLocation;
    error_message: string;
    diagnostic_id: string;
    level: string;
}
export interface RubyParseErrorProps {
    type: string;
    message: string;
    location: Location;
    error_message: string;
    diagnostic_id: string;
    level: string;
}
export declare class RubyParseError extends HerbError {
    readonly error_message: string;
    readonly diagnostic_id: string;
    readonly level: string;
    static from(data: SerializedRubyParseError): RubyParseError;
    constructor(props: RubyParseErrorProps);
    toJSON(): SerializedRubyParseError;
    toMonacoDiagnostic(): MonacoDiagnostic;
    treeInspect(): string;
}
export declare function fromSerializedError(error: SerializedHerbError): HerbError;
