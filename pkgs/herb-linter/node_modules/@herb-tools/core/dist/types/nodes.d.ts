import { Location } from "./location.js";
import { Token, SerializedToken } from "./token.js";
import { HerbError } from "./errors.js";
import type { SerializedLocation } from "./location.js";
import type { SerializedHerbError } from "./errors.js";
import type { Visitor } from "./visitor.js";
export type SerializedNodeType = string;
export interface SerializedNode {
    type: SerializedNodeType;
    location: SerializedLocation;
    errors: SerializedHerbError[];
}
export interface BaseNodeProps {
    type: NodeType;
    location: Location;
    errors: HerbError[];
}
export declare abstract class Node implements BaseNodeProps {
    readonly type: NodeType;
    readonly location: Location;
    readonly errors: HerbError[];
    static from(node: SerializedNode): Node;
    static get type(): NodeType;
    constructor(type: NodeType, location: Location, errors: HerbError[]);
    toJSON(): SerializedNode;
    inspect(): string;
    is<T extends Node>(nodeClass: {
        new (...args: any[]): T;
        prototype: T;
        type: NodeType;
    }): this is T;
    isOfType<T extends Node>(type: NodeType): this is T;
    get isSingleLine(): boolean;
    abstract treeInspect(indent?: number): string;
    abstract recursiveErrors(): HerbError[];
    abstract accept(visitor: Visitor): void;
    abstract childNodes(): (Node | null | undefined)[];
    abstract compactChildNodes(): Node[];
    protected inspectArray(array: (Node | HerbError)[] | null | undefined, prefix: string): string;
    protected inspectNode(node: Node | HerbError | undefined | null, prefix: string, prefix2?: string, last?: boolean, trailingNewline?: boolean): string;
}
export interface SerializedDocumentNode extends SerializedNode {
    type: "AST_DOCUMENT_NODE";
    children: SerializedNode[];
}
export interface DocumentNodeProps extends BaseNodeProps {
    children: Node[];
}
export declare class DocumentNode extends Node {
    readonly children: Node[];
    static get type(): NodeType;
    static from(data: SerializedDocumentNode): DocumentNode;
    constructor(props: DocumentNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedDocumentNode;
    treeInspect(): string;
}
export interface SerializedLiteralNode extends SerializedNode {
    type: "AST_LITERAL_NODE";
    content: string;
}
export interface LiteralNodeProps extends BaseNodeProps {
    content: string;
}
export declare class LiteralNode extends Node {
    readonly content: string;
    static get type(): NodeType;
    static from(data: SerializedLiteralNode): LiteralNode;
    constructor(props: LiteralNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedLiteralNode;
    treeInspect(): string;
}
export interface SerializedHTMLOpenTagNode extends SerializedNode {
    type: "AST_HTML_OPEN_TAG_NODE";
    tag_opening: SerializedToken | null;
    tag_name: SerializedToken | null;
    tag_closing: SerializedToken | null;
    children: SerializedNode[];
    is_void: boolean;
}
export interface HTMLOpenTagNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    tag_name: Token | null;
    tag_closing: Token | null;
    children: Node[];
    is_void: boolean;
}
export declare class HTMLOpenTagNode extends Node {
    readonly tag_opening: Token | null;
    readonly tag_name: Token | null;
    readonly tag_closing: Token | null;
    readonly children: Node[];
    readonly is_void: boolean;
    static get type(): NodeType;
    static from(data: SerializedHTMLOpenTagNode): HTMLOpenTagNode;
    constructor(props: HTMLOpenTagNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLOpenTagNode;
    treeInspect(): string;
}
export interface SerializedHTMLCloseTagNode extends SerializedNode {
    type: "AST_HTML_CLOSE_TAG_NODE";
    tag_opening: SerializedToken | null;
    tag_name: SerializedToken | null;
    children: SerializedNode[];
    tag_closing: SerializedToken | null;
}
export interface HTMLCloseTagNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    tag_name: Token | null;
    children: Node[];
    tag_closing: Token | null;
}
export declare class HTMLCloseTagNode extends Node {
    readonly tag_opening: Token | null;
    readonly tag_name: Token | null;
    readonly children: Node[];
    readonly tag_closing: Token | null;
    static get type(): NodeType;
    static from(data: SerializedHTMLCloseTagNode): HTMLCloseTagNode;
    constructor(props: HTMLCloseTagNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLCloseTagNode;
    treeInspect(): string;
}
export interface SerializedHTMLElementNode extends SerializedNode {
    type: "AST_HTML_ELEMENT_NODE";
    open_tag: SerializedHTMLOpenTagNode | null;
    tag_name: SerializedToken | null;
    body: SerializedNode[];
    close_tag: SerializedHTMLCloseTagNode | null;
    is_void: boolean;
}
export interface HTMLElementNodeProps extends BaseNodeProps {
    open_tag: HTMLOpenTagNode | null;
    tag_name: Token | null;
    body: Node[];
    close_tag: HTMLCloseTagNode | null;
    is_void: boolean;
}
export declare class HTMLElementNode extends Node {
    readonly open_tag: HTMLOpenTagNode | null;
    readonly tag_name: Token | null;
    readonly body: Node[];
    readonly close_tag: HTMLCloseTagNode | null;
    readonly is_void: boolean;
    static get type(): NodeType;
    static from(data: SerializedHTMLElementNode): HTMLElementNode;
    constructor(props: HTMLElementNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLElementNode;
    treeInspect(): string;
}
export interface SerializedHTMLAttributeValueNode extends SerializedNode {
    type: "AST_HTML_ATTRIBUTE_VALUE_NODE";
    open_quote: SerializedToken | null;
    children: SerializedNode[];
    close_quote: SerializedToken | null;
    quoted: boolean;
}
export interface HTMLAttributeValueNodeProps extends BaseNodeProps {
    open_quote: Token | null;
    children: Node[];
    close_quote: Token | null;
    quoted: boolean;
}
export declare class HTMLAttributeValueNode extends Node {
    readonly open_quote: Token | null;
    readonly children: Node[];
    readonly close_quote: Token | null;
    readonly quoted: boolean;
    static get type(): NodeType;
    static from(data: SerializedHTMLAttributeValueNode): HTMLAttributeValueNode;
    constructor(props: HTMLAttributeValueNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLAttributeValueNode;
    treeInspect(): string;
}
export interface SerializedHTMLAttributeNameNode extends SerializedNode {
    type: "AST_HTML_ATTRIBUTE_NAME_NODE";
    children: SerializedNode[];
}
export interface HTMLAttributeNameNodeProps extends BaseNodeProps {
    children: Node[];
}
export declare class HTMLAttributeNameNode extends Node {
    readonly children: Node[];
    static get type(): NodeType;
    static from(data: SerializedHTMLAttributeNameNode): HTMLAttributeNameNode;
    constructor(props: HTMLAttributeNameNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLAttributeNameNode;
    treeInspect(): string;
}
export interface SerializedHTMLAttributeNode extends SerializedNode {
    type: "AST_HTML_ATTRIBUTE_NODE";
    name: SerializedHTMLAttributeNameNode | null;
    equals: SerializedToken | null;
    value: SerializedHTMLAttributeValueNode | null;
}
export interface HTMLAttributeNodeProps extends BaseNodeProps {
    name: HTMLAttributeNameNode | null;
    equals: Token | null;
    value: HTMLAttributeValueNode | null;
}
export declare class HTMLAttributeNode extends Node {
    readonly name: HTMLAttributeNameNode | null;
    readonly equals: Token | null;
    readonly value: HTMLAttributeValueNode | null;
    static get type(): NodeType;
    static from(data: SerializedHTMLAttributeNode): HTMLAttributeNode;
    constructor(props: HTMLAttributeNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLAttributeNode;
    treeInspect(): string;
}
export interface SerializedHTMLTextNode extends SerializedNode {
    type: "AST_HTML_TEXT_NODE";
    content: string;
}
export interface HTMLTextNodeProps extends BaseNodeProps {
    content: string;
}
export declare class HTMLTextNode extends Node {
    readonly content: string;
    static get type(): NodeType;
    static from(data: SerializedHTMLTextNode): HTMLTextNode;
    constructor(props: HTMLTextNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLTextNode;
    treeInspect(): string;
}
export interface SerializedHTMLCommentNode extends SerializedNode {
    type: "AST_HTML_COMMENT_NODE";
    comment_start: SerializedToken | null;
    children: SerializedNode[];
    comment_end: SerializedToken | null;
}
export interface HTMLCommentNodeProps extends BaseNodeProps {
    comment_start: Token | null;
    children: Node[];
    comment_end: Token | null;
}
export declare class HTMLCommentNode extends Node {
    readonly comment_start: Token | null;
    readonly children: Node[];
    readonly comment_end: Token | null;
    static get type(): NodeType;
    static from(data: SerializedHTMLCommentNode): HTMLCommentNode;
    constructor(props: HTMLCommentNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLCommentNode;
    treeInspect(): string;
}
export interface SerializedHTMLDoctypeNode extends SerializedNode {
    type: "AST_HTML_DOCTYPE_NODE";
    tag_opening: SerializedToken | null;
    children: SerializedNode[];
    tag_closing: SerializedToken | null;
}
export interface HTMLDoctypeNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    children: Node[];
    tag_closing: Token | null;
}
export declare class HTMLDoctypeNode extends Node {
    readonly tag_opening: Token | null;
    readonly children: Node[];
    readonly tag_closing: Token | null;
    static get type(): NodeType;
    static from(data: SerializedHTMLDoctypeNode): HTMLDoctypeNode;
    constructor(props: HTMLDoctypeNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedHTMLDoctypeNode;
    treeInspect(): string;
}
export interface SerializedXMLDeclarationNode extends SerializedNode {
    type: "AST_XML_DECLARATION_NODE";
    tag_opening: SerializedToken | null;
    children: SerializedNode[];
    tag_closing: SerializedToken | null;
}
export interface XMLDeclarationNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    children: Node[];
    tag_closing: Token | null;
}
export declare class XMLDeclarationNode extends Node {
    readonly tag_opening: Token | null;
    readonly children: Node[];
    readonly tag_closing: Token | null;
    static get type(): NodeType;
    static from(data: SerializedXMLDeclarationNode): XMLDeclarationNode;
    constructor(props: XMLDeclarationNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedXMLDeclarationNode;
    treeInspect(): string;
}
export interface SerializedCDATANode extends SerializedNode {
    type: "AST_CDATA_NODE";
    tag_opening: SerializedToken | null;
    children: SerializedNode[];
    tag_closing: SerializedToken | null;
}
export interface CDATANodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    children: Node[];
    tag_closing: Token | null;
}
export declare class CDATANode extends Node {
    readonly tag_opening: Token | null;
    readonly children: Node[];
    readonly tag_closing: Token | null;
    static get type(): NodeType;
    static from(data: SerializedCDATANode): CDATANode;
    constructor(props: CDATANodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedCDATANode;
    treeInspect(): string;
}
export interface SerializedWhitespaceNode extends SerializedNode {
    type: "AST_WHITESPACE_NODE";
    value: SerializedToken | null;
}
export interface WhitespaceNodeProps extends BaseNodeProps {
    value: Token | null;
}
export declare class WhitespaceNode extends Node {
    readonly value: Token | null;
    static get type(): NodeType;
    static from(data: SerializedWhitespaceNode): WhitespaceNode;
    constructor(props: WhitespaceNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedWhitespaceNode;
    treeInspect(): string;
}
export interface SerializedERBContentNode extends SerializedNode {
    type: "AST_ERB_CONTENT_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    parsed: boolean;
    valid: boolean;
}
export interface ERBContentNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    parsed: boolean;
    valid: boolean;
}
export declare class ERBContentNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly parsed: boolean;
    readonly valid: boolean;
    static get type(): NodeType;
    static from(data: SerializedERBContentNode): ERBContentNode;
    constructor(props: ERBContentNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBContentNode;
    treeInspect(): string;
}
export interface SerializedERBEndNode extends SerializedNode {
    type: "AST_ERB_END_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
}
export interface ERBEndNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
}
export declare class ERBEndNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    static get type(): NodeType;
    static from(data: SerializedERBEndNode): ERBEndNode;
    constructor(props: ERBEndNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBEndNode;
    treeInspect(): string;
}
export interface SerializedERBElseNode extends SerializedNode {
    type: "AST_ERB_ELSE_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
}
export interface ERBElseNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
}
export declare class ERBElseNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    static get type(): NodeType;
    static from(data: SerializedERBElseNode): ERBElseNode;
    constructor(props: ERBElseNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBElseNode;
    treeInspect(): string;
}
export interface SerializedERBIfNode extends SerializedNode {
    type: "AST_ERB_IF_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    subsequent: SerializedNode | null;
    end_node: SerializedERBEndNode | null;
}
export interface ERBIfNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    subsequent: Node | null;
    end_node: ERBEndNode | null;
}
export declare class ERBIfNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly subsequent: Node | null;
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBIfNode): ERBIfNode;
    constructor(props: ERBIfNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBIfNode;
    treeInspect(): string;
}
export interface SerializedERBBlockNode extends SerializedNode {
    type: "AST_ERB_BLOCK_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    body: SerializedNode[];
    end_node: SerializedERBEndNode | null;
}
export interface ERBBlockNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    body: Node[];
    end_node: ERBEndNode | null;
}
export declare class ERBBlockNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly body: Node[];
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBBlockNode): ERBBlockNode;
    constructor(props: ERBBlockNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBBlockNode;
    treeInspect(): string;
}
export interface SerializedERBWhenNode extends SerializedNode {
    type: "AST_ERB_WHEN_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
}
export interface ERBWhenNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
}
export declare class ERBWhenNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    static get type(): NodeType;
    static from(data: SerializedERBWhenNode): ERBWhenNode;
    constructor(props: ERBWhenNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBWhenNode;
    treeInspect(): string;
}
export interface SerializedERBCaseNode extends SerializedNode {
    type: "AST_ERB_CASE_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    children: SerializedNode[];
    conditions: SerializedNode[];
    else_clause: SerializedERBElseNode | null;
    end_node: SerializedERBEndNode | null;
}
export interface ERBCaseNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    children: Node[];
    conditions: any[];
    else_clause: ERBElseNode | null;
    end_node: ERBEndNode | null;
}
export declare class ERBCaseNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly children: Node[];
    readonly conditions: Node[];
    readonly else_clause: ERBElseNode | null;
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBCaseNode): ERBCaseNode;
    constructor(props: ERBCaseNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBCaseNode;
    treeInspect(): string;
}
export interface SerializedERBCaseMatchNode extends SerializedNode {
    type: "AST_ERB_CASE_MATCH_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    children: SerializedNode[];
    conditions: SerializedNode[];
    else_clause: SerializedERBElseNode | null;
    end_node: SerializedERBEndNode | null;
}
export interface ERBCaseMatchNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    children: Node[];
    conditions: any[];
    else_clause: ERBElseNode | null;
    end_node: ERBEndNode | null;
}
export declare class ERBCaseMatchNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly children: Node[];
    readonly conditions: Node[];
    readonly else_clause: ERBElseNode | null;
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBCaseMatchNode): ERBCaseMatchNode;
    constructor(props: ERBCaseMatchNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBCaseMatchNode;
    treeInspect(): string;
}
export interface SerializedERBWhileNode extends SerializedNode {
    type: "AST_ERB_WHILE_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    end_node: SerializedERBEndNode | null;
}
export interface ERBWhileNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    end_node: ERBEndNode | null;
}
export declare class ERBWhileNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBWhileNode): ERBWhileNode;
    constructor(props: ERBWhileNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBWhileNode;
    treeInspect(): string;
}
export interface SerializedERBUntilNode extends SerializedNode {
    type: "AST_ERB_UNTIL_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    end_node: SerializedERBEndNode | null;
}
export interface ERBUntilNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    end_node: ERBEndNode | null;
}
export declare class ERBUntilNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBUntilNode): ERBUntilNode;
    constructor(props: ERBUntilNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBUntilNode;
    treeInspect(): string;
}
export interface SerializedERBForNode extends SerializedNode {
    type: "AST_ERB_FOR_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    end_node: SerializedERBEndNode | null;
}
export interface ERBForNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    end_node: ERBEndNode | null;
}
export declare class ERBForNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBForNode): ERBForNode;
    constructor(props: ERBForNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBForNode;
    treeInspect(): string;
}
export interface SerializedERBRescueNode extends SerializedNode {
    type: "AST_ERB_RESCUE_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    subsequent: SerializedERBRescueNode | null;
}
export interface ERBRescueNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    subsequent: ERBRescueNode | null;
}
export declare class ERBRescueNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly subsequent: ERBRescueNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBRescueNode): ERBRescueNode;
    constructor(props: ERBRescueNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBRescueNode;
    treeInspect(): string;
}
export interface SerializedERBEnsureNode extends SerializedNode {
    type: "AST_ERB_ENSURE_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
}
export interface ERBEnsureNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
}
export declare class ERBEnsureNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    static get type(): NodeType;
    static from(data: SerializedERBEnsureNode): ERBEnsureNode;
    constructor(props: ERBEnsureNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBEnsureNode;
    treeInspect(): string;
}
export interface SerializedERBBeginNode extends SerializedNode {
    type: "AST_ERB_BEGIN_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    rescue_clause: SerializedERBRescueNode | null;
    else_clause: SerializedERBElseNode | null;
    ensure_clause: SerializedERBEnsureNode | null;
    end_node: SerializedERBEndNode | null;
}
export interface ERBBeginNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    rescue_clause: ERBRescueNode | null;
    else_clause: ERBElseNode | null;
    ensure_clause: ERBEnsureNode | null;
    end_node: ERBEndNode | null;
}
export declare class ERBBeginNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly rescue_clause: ERBRescueNode | null;
    readonly else_clause: ERBElseNode | null;
    readonly ensure_clause: ERBEnsureNode | null;
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBBeginNode): ERBBeginNode;
    constructor(props: ERBBeginNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBBeginNode;
    treeInspect(): string;
}
export interface SerializedERBUnlessNode extends SerializedNode {
    type: "AST_ERB_UNLESS_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
    else_clause: SerializedERBElseNode | null;
    end_node: SerializedERBEndNode | null;
}
export interface ERBUnlessNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
    else_clause: ERBElseNode | null;
    end_node: ERBEndNode | null;
}
export declare class ERBUnlessNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    readonly else_clause: ERBElseNode | null;
    readonly end_node: ERBEndNode | null;
    static get type(): NodeType;
    static from(data: SerializedERBUnlessNode): ERBUnlessNode;
    constructor(props: ERBUnlessNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBUnlessNode;
    treeInspect(): string;
}
export interface SerializedERBYieldNode extends SerializedNode {
    type: "AST_ERB_YIELD_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
}
export interface ERBYieldNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
}
export declare class ERBYieldNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    static get type(): NodeType;
    static from(data: SerializedERBYieldNode): ERBYieldNode;
    constructor(props: ERBYieldNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBYieldNode;
    treeInspect(): string;
}
export interface SerializedERBInNode extends SerializedNode {
    type: "AST_ERB_IN_NODE";
    tag_opening: SerializedToken | null;
    content: SerializedToken | null;
    tag_closing: SerializedToken | null;
    statements: SerializedNode[];
}
export interface ERBInNodeProps extends BaseNodeProps {
    tag_opening: Token | null;
    content: Token | null;
    tag_closing: Token | null;
    statements: Node[];
}
export declare class ERBInNode extends Node {
    readonly tag_opening: Token | null;
    readonly content: Token | null;
    readonly tag_closing: Token | null;
    readonly statements: Node[];
    static get type(): NodeType;
    static from(data: SerializedERBInNode): ERBInNode;
    constructor(props: ERBInNodeProps);
    accept(visitor: Visitor): void;
    childNodes(): (Node | null | undefined)[];
    compactChildNodes(): Node[];
    recursiveErrors(): HerbError[];
    toJSON(): SerializedERBInNode;
    treeInspect(): string;
}
export type ConcreteNode = DocumentNode | LiteralNode | HTMLOpenTagNode | HTMLCloseTagNode | HTMLElementNode | HTMLAttributeValueNode | HTMLAttributeNameNode | HTMLAttributeNode | HTMLTextNode | HTMLCommentNode | HTMLDoctypeNode | XMLDeclarationNode | CDATANode | WhitespaceNode | ERBContentNode | ERBEndNode | ERBElseNode | ERBIfNode | ERBBlockNode | ERBWhenNode | ERBCaseNode | ERBCaseMatchNode | ERBWhileNode | ERBUntilNode | ERBForNode | ERBRescueNode | ERBEnsureNode | ERBBeginNode | ERBUnlessNode | ERBYieldNode | ERBInNode;
export declare function fromSerializedNode(node: SerializedDocumentNode): DocumentNode;
export declare function fromSerializedNode(node: SerializedLiteralNode): LiteralNode;
export declare function fromSerializedNode(node: SerializedHTMLOpenTagNode): HTMLOpenTagNode;
export declare function fromSerializedNode(node: SerializedHTMLCloseTagNode): HTMLCloseTagNode;
export declare function fromSerializedNode(node: SerializedHTMLElementNode): HTMLElementNode;
export declare function fromSerializedNode(node: SerializedHTMLAttributeValueNode): HTMLAttributeValueNode;
export declare function fromSerializedNode(node: SerializedHTMLAttributeNameNode): HTMLAttributeNameNode;
export declare function fromSerializedNode(node: SerializedHTMLAttributeNode): HTMLAttributeNode;
export declare function fromSerializedNode(node: SerializedHTMLTextNode): HTMLTextNode;
export declare function fromSerializedNode(node: SerializedHTMLCommentNode): HTMLCommentNode;
export declare function fromSerializedNode(node: SerializedHTMLDoctypeNode): HTMLDoctypeNode;
export declare function fromSerializedNode(node: SerializedXMLDeclarationNode): XMLDeclarationNode;
export declare function fromSerializedNode(node: SerializedCDATANode): CDATANode;
export declare function fromSerializedNode(node: SerializedWhitespaceNode): WhitespaceNode;
export declare function fromSerializedNode(node: SerializedERBContentNode): ERBContentNode;
export declare function fromSerializedNode(node: SerializedERBEndNode): ERBEndNode;
export declare function fromSerializedNode(node: SerializedERBElseNode): ERBElseNode;
export declare function fromSerializedNode(node: SerializedERBIfNode): ERBIfNode;
export declare function fromSerializedNode(node: SerializedERBBlockNode): ERBBlockNode;
export declare function fromSerializedNode(node: SerializedERBWhenNode): ERBWhenNode;
export declare function fromSerializedNode(node: SerializedERBCaseNode): ERBCaseNode;
export declare function fromSerializedNode(node: SerializedERBCaseMatchNode): ERBCaseMatchNode;
export declare function fromSerializedNode(node: SerializedERBWhileNode): ERBWhileNode;
export declare function fromSerializedNode(node: SerializedERBUntilNode): ERBUntilNode;
export declare function fromSerializedNode(node: SerializedERBForNode): ERBForNode;
export declare function fromSerializedNode(node: SerializedERBRescueNode): ERBRescueNode;
export declare function fromSerializedNode(node: SerializedERBEnsureNode): ERBEnsureNode;
export declare function fromSerializedNode(node: SerializedERBBeginNode): ERBBeginNode;
export declare function fromSerializedNode(node: SerializedERBUnlessNode): ERBUnlessNode;
export declare function fromSerializedNode(node: SerializedERBYieldNode): ERBYieldNode;
export declare function fromSerializedNode(node: SerializedERBInNode): ERBInNode;
export declare function fromSerializedNode(node: SerializedNode): Node;
export type NodeType = "AST_DOCUMENT_NODE" | "AST_LITERAL_NODE" | "AST_HTML_OPEN_TAG_NODE" | "AST_HTML_CLOSE_TAG_NODE" | "AST_HTML_ELEMENT_NODE" | "AST_HTML_ATTRIBUTE_VALUE_NODE" | "AST_HTML_ATTRIBUTE_NAME_NODE" | "AST_HTML_ATTRIBUTE_NODE" | "AST_HTML_TEXT_NODE" | "AST_HTML_COMMENT_NODE" | "AST_HTML_DOCTYPE_NODE" | "AST_XML_DECLARATION_NODE" | "AST_CDATA_NODE" | "AST_WHITESPACE_NODE" | "AST_ERB_CONTENT_NODE" | "AST_ERB_END_NODE" | "AST_ERB_ELSE_NODE" | "AST_ERB_IF_NODE" | "AST_ERB_BLOCK_NODE" | "AST_ERB_WHEN_NODE" | "AST_ERB_CASE_NODE" | "AST_ERB_CASE_MATCH_NODE" | "AST_ERB_WHILE_NODE" | "AST_ERB_UNTIL_NODE" | "AST_ERB_FOR_NODE" | "AST_ERB_RESCUE_NODE" | "AST_ERB_ENSURE_NODE" | "AST_ERB_BEGIN_NODE" | "AST_ERB_UNLESS_NODE" | "AST_ERB_YIELD_NODE" | "AST_ERB_IN_NODE";
export type ERBNodeType = Extract<NodeType, `AST_ERB_${string}`>;
export type ERBNode = ERBContentNode | ERBEndNode | ERBElseNode | ERBIfNode | ERBBlockNode | ERBWhenNode | ERBCaseNode | ERBCaseMatchNode | ERBWhileNode | ERBUntilNode | ERBForNode | ERBRescueNode | ERBEnsureNode | ERBBeginNode | ERBUnlessNode | ERBYieldNode | ERBInNode;
export declare const ERBNodeClasses: (typeof ERBContentNode | typeof ERBEndNode | typeof ERBElseNode | typeof ERBIfNode | typeof ERBBlockNode | typeof ERBWhenNode | typeof ERBCaseNode | typeof ERBCaseMatchNode | typeof ERBWhileNode | typeof ERBUntilNode | typeof ERBForNode | typeof ERBRescueNode | typeof ERBEnsureNode | typeof ERBBeginNode | typeof ERBUnlessNode | typeof ERBYieldNode | typeof ERBInNode)[];
