#!/usr/bin/env node
'use strict';

var require$$0$2 = require('node:util');
var require$$0 = require('util');
var require$$1 = require('path');
var require$$2 = require('os');
var require$$3 = require('crypto');
var require$$4 = require('net');
var require$$0$1 = require('url');
var require$$2$1 = require('fs');
var require$$3$1 = require('child_process');
var node_url = require('node:url');
var node_path = require('node:path');
var actualFS = require('node:fs');
var promises = require('node:fs/promises');
var node_events = require('node:events');
var Stream = require('node:stream');
var node_string_decoder = require('node:string_decoder');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n.default = e;
	return Object.freeze(n);
}

var actualFS__namespace = /*#__PURE__*/_interopNamespaceDefault(actualFS);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var main$3 = {};

var is$2 = {};

var hasRequiredIs$2;

function requireIs$2 () {
	if (hasRequiredIs$2) return is$2;
	hasRequiredIs$2 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(is$2, "__esModule", { value: true });
	is$2.thenable = is$2.typedArray = is$2.stringArray = is$2.array = is$2.func = is$2.error = is$2.number = is$2.string = is$2.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$2.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$2.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$2.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$2.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$2.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$2.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$2.stringArray = stringArray;
	function typedArray(value, check) {
	    return Array.isArray(value) && value.every(check);
	}
	is$2.typedArray = typedArray;
	function thenable(value) {
	    return value && func(value.then);
	}
	is$2.thenable = thenable;
	return is$2;
}

var server = {};

var main$2 = {};

var main$1 = {};

var ril = {};

var api$2 = {};

var messages$1 = {};

var is$1 = {};

var hasRequiredIs$1;

function requireIs$1 () {
	if (hasRequiredIs$1) return is$1;
	hasRequiredIs$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(is$1, "__esModule", { value: true });
	is$1.stringArray = is$1.array = is$1.func = is$1.error = is$1.number = is$1.string = is$1.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$1.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$1.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$1.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$1.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$1.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$1.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$1.stringArray = stringArray;
	return is$1;
}

var hasRequiredMessages$1;

function requireMessages$1 () {
	if (hasRequiredMessages$1) return messages$1;
	hasRequiredMessages$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messages$1, "__esModule", { value: true });
	messages$1.Message = messages$1.NotificationType9 = messages$1.NotificationType8 = messages$1.NotificationType7 = messages$1.NotificationType6 = messages$1.NotificationType5 = messages$1.NotificationType4 = messages$1.NotificationType3 = messages$1.NotificationType2 = messages$1.NotificationType1 = messages$1.NotificationType0 = messages$1.NotificationType = messages$1.RequestType9 = messages$1.RequestType8 = messages$1.RequestType7 = messages$1.RequestType6 = messages$1.RequestType5 = messages$1.RequestType4 = messages$1.RequestType3 = messages$1.RequestType2 = messages$1.RequestType1 = messages$1.RequestType = messages$1.RequestType0 = messages$1.AbstractMessageSignature = messages$1.ParameterStructures = messages$1.ResponseError = messages$1.ErrorCodes = void 0;
	const is = requireIs$1();
	/**
	 * Predefined error codes.
	 */
	var ErrorCodes;
	(function (ErrorCodes) {
	    // Defined by JSON RPC
	    ErrorCodes.ParseError = -32700;
	    ErrorCodes.InvalidRequest = -32600;
	    ErrorCodes.MethodNotFound = -32601;
	    ErrorCodes.InvalidParams = -32602;
	    ErrorCodes.InternalError = -32603;
	    /**
	     * This is the start range of JSON RPC reserved error codes.
	     * It doesn't denote a real error code. No application error codes should
	     * be defined between the start and end range. For backwards
	     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
	     * are left in the range.
	     *
	     * @since 3.16.0
	    */
	    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
	    /** @deprecated use  jsonrpcReservedErrorRangeStart */
	    ErrorCodes.serverErrorStart = -32099;
	    /**
	     * An error occurred when write a message to the transport layer.
	     */
	    ErrorCodes.MessageWriteError = -32099;
	    /**
	     * An error occurred when reading a message from the transport layer.
	     */
	    ErrorCodes.MessageReadError = -32098;
	    /**
	     * The connection got disposed or lost and all pending responses got
	     * rejected.
	     */
	    ErrorCodes.PendingResponseRejected = -32097;
	    /**
	     * The connection is inactive and a use of it failed.
	     */
	    ErrorCodes.ConnectionInactive = -32096;
	    /**
	     * Error code indicating that a server received a notification or
	     * request before the server has received the `initialize` request.
	     */
	    ErrorCodes.ServerNotInitialized = -32002;
	    ErrorCodes.UnknownErrorCode = -32001;
	    /**
	     * This is the end range of JSON RPC reserved error codes.
	     * It doesn't denote a real error code.
	     *
	     * @since 3.16.0
	    */
	    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32e3;
	    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
	    ErrorCodes.serverErrorEnd = -32e3;
	})(ErrorCodes || (messages$1.ErrorCodes = ErrorCodes = {}));
	/**
	 * An error object return in a response in case a request
	 * has failed.
	 */
	class ResponseError extends Error {
	    constructor(code, message, data) {
	        super(message);
	        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
	        this.data = data;
	        Object.setPrototypeOf(this, ResponseError.prototype);
	    }
	    toJson() {
	        const result = {
	            code: this.code,
	            message: this.message
	        };
	        if (this.data !== undefined) {
	            result.data = this.data;
	        }
	        return result;
	    }
	}
	messages$1.ResponseError = ResponseError;
	class ParameterStructures {
	    constructor(kind) {
	        this.kind = kind;
	    }
	    static is(value) {
	        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
	    }
	    toString() {
	        return this.kind;
	    }
	}
	messages$1.ParameterStructures = ParameterStructures;
	/**
	 * The parameter structure is automatically inferred on the number of parameters
	 * and the parameter type in case of a single param.
	 */
	ParameterStructures.auto = new ParameterStructures('auto');
	/**
	 * Forces `byPosition` parameter structure. This is useful if you have a single
	 * parameter which has a literal type.
	 */
	ParameterStructures.byPosition = new ParameterStructures('byPosition');
	/**
	 * Forces `byName` parameter structure. This is only useful when having a single
	 * parameter. The library will report errors if used with a different number of
	 * parameters.
	 */
	ParameterStructures.byName = new ParameterStructures('byName');
	/**
	 * An abstract implementation of a MessageType.
	 */
	class AbstractMessageSignature {
	    constructor(method, numberOfParams) {
	        this.method = method;
	        this.numberOfParams = numberOfParams;
	    }
	    get parameterStructures() {
	        return ParameterStructures.auto;
	    }
	}
	messages$1.AbstractMessageSignature = AbstractMessageSignature;
	/**
	 * Classes to type request response pairs
	 */
	class RequestType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$1.RequestType0 = RequestType0;
	class RequestType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.RequestType = RequestType;
	class RequestType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.RequestType1 = RequestType1;
	class RequestType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$1.RequestType2 = RequestType2;
	class RequestType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$1.RequestType3 = RequestType3;
	class RequestType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$1.RequestType4 = RequestType4;
	class RequestType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$1.RequestType5 = RequestType5;
	class RequestType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$1.RequestType6 = RequestType6;
	class RequestType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$1.RequestType7 = RequestType7;
	class RequestType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$1.RequestType8 = RequestType8;
	class RequestType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$1.RequestType9 = RequestType9;
	class NotificationType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.NotificationType = NotificationType;
	class NotificationType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$1.NotificationType0 = NotificationType0;
	class NotificationType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.NotificationType1 = NotificationType1;
	class NotificationType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$1.NotificationType2 = NotificationType2;
	class NotificationType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$1.NotificationType3 = NotificationType3;
	class NotificationType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$1.NotificationType4 = NotificationType4;
	class NotificationType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$1.NotificationType5 = NotificationType5;
	class NotificationType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$1.NotificationType6 = NotificationType6;
	class NotificationType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$1.NotificationType7 = NotificationType7;
	class NotificationType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$1.NotificationType8 = NotificationType8;
	class NotificationType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$1.NotificationType9 = NotificationType9;
	var Message;
	(function (Message) {
	    /**
	     * Tests if the given message is a request message
	     */
	    function isRequest(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
	    }
	    Message.isRequest = isRequest;
	    /**
	     * Tests if the given message is a notification message
	     */
	    function isNotification(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && message.id === void 0;
	    }
	    Message.isNotification = isNotification;
	    /**
	     * Tests if the given message is a response message
	     */
	    function isResponse(message) {
	        const candidate = message;
	        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
	    }
	    Message.isResponse = isResponse;
	})(Message || (messages$1.Message = Message = {}));
	return messages$1;
}

var linkedMap = {};

var hasRequiredLinkedMap;

function requireLinkedMap () {
	if (hasRequiredLinkedMap) return linkedMap;
	hasRequiredLinkedMap = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	var _a;
	Object.defineProperty(linkedMap, "__esModule", { value: true });
	linkedMap.LRUCache = linkedMap.LinkedMap = linkedMap.Touch = void 0;
	var Touch;
	(function (Touch) {
	    Touch.None = 0;
	    Touch.First = 1;
	    Touch.AsOld = Touch.First;
	    Touch.Last = 2;
	    Touch.AsNew = Touch.Last;
	})(Touch || (linkedMap.Touch = Touch = {}));
	class LinkedMap {
	    constructor() {
	        this[_a] = 'LinkedMap';
	        this._map = new Map();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state = 0;
	    }
	    clear() {
	        this._map.clear();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state++;
	    }
	    isEmpty() {
	        return !this._head && !this._tail;
	    }
	    get size() {
	        return this._size;
	    }
	    get first() {
	        return this._head?.value;
	    }
	    get last() {
	        return this._tail?.value;
	    }
	    has(key) {
	        return this._map.has(key);
	    }
	    get(key, touch = Touch.None) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        if (touch !== Touch.None) {
	            this.touch(item, touch);
	        }
	        return item.value;
	    }
	    set(key, value, touch = Touch.None) {
	        let item = this._map.get(key);
	        if (item) {
	            item.value = value;
	            if (touch !== Touch.None) {
	                this.touch(item, touch);
	            }
	        }
	        else {
	            item = { key, value, next: undefined, previous: undefined };
	            switch (touch) {
	                case Touch.None:
	                    this.addItemLast(item);
	                    break;
	                case Touch.First:
	                    this.addItemFirst(item);
	                    break;
	                case Touch.Last:
	                    this.addItemLast(item);
	                    break;
	                default:
	                    this.addItemLast(item);
	                    break;
	            }
	            this._map.set(key, item);
	            this._size++;
	        }
	        return this;
	    }
	    delete(key) {
	        return !!this.remove(key);
	    }
	    remove(key) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        this._map.delete(key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    shift() {
	        if (!this._head && !this._tail) {
	            return undefined;
	        }
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        const item = this._head;
	        this._map.delete(item.key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    forEach(callbackfn, thisArg) {
	        const state = this._state;
	        let current = this._head;
	        while (current) {
	            if (thisArg) {
	                callbackfn.bind(thisArg)(current.value, current.key, this);
	            }
	            else {
	                callbackfn(current.value, current.key, this);
	            }
	            if (this._state !== state) {
	                throw new Error(`LinkedMap got modified during iteration.`);
	            }
	            current = current.next;
	        }
	    }
	    keys() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.key, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    values() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.value, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    entries() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: [current.key, current.value], done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
	        return this.entries();
	    }
	    trimOld(newSize) {
	        if (newSize >= this.size) {
	            return;
	        }
	        if (newSize === 0) {
	            this.clear();
	            return;
	        }
	        let current = this._head;
	        let currentSize = this.size;
	        while (current && currentSize > newSize) {
	            this._map.delete(current.key);
	            current = current.next;
	            currentSize--;
	        }
	        this._head = current;
	        this._size = currentSize;
	        if (current) {
	            current.previous = undefined;
	        }
	        this._state++;
	    }
	    addItemFirst(item) {
	        // First time Insert
	        if (!this._head && !this._tail) {
	            this._tail = item;
	        }
	        else if (!this._head) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.next = this._head;
	            this._head.previous = item;
	        }
	        this._head = item;
	        this._state++;
	    }
	    addItemLast(item) {
	        // First time Insert
	        if (!this._head && !this._tail) {
	            this._head = item;
	        }
	        else if (!this._tail) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.previous = this._tail;
	            this._tail.next = item;
	        }
	        this._tail = item;
	        this._state++;
	    }
	    removeItem(item) {
	        if (item === this._head && item === this._tail) {
	            this._head = undefined;
	            this._tail = undefined;
	        }
	        else if (item === this._head) {
	            // This can only happened if size === 1 which is handle
	            // by the case above.
	            if (!item.next) {
	                throw new Error('Invalid list');
	            }
	            item.next.previous = undefined;
	            this._head = item.next;
	        }
	        else if (item === this._tail) {
	            // This can only happened if size === 1 which is handle
	            // by the case above.
	            if (!item.previous) {
	                throw new Error('Invalid list');
	            }
	            item.previous.next = undefined;
	            this._tail = item.previous;
	        }
	        else {
	            const next = item.next;
	            const previous = item.previous;
	            if (!next || !previous) {
	                throw new Error('Invalid list');
	            }
	            next.previous = previous;
	            previous.next = next;
	        }
	        item.next = undefined;
	        item.previous = undefined;
	        this._state++;
	    }
	    touch(item, touch) {
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        if ((touch !== Touch.First && touch !== Touch.Last)) {
	            return;
	        }
	        if (touch === Touch.First) {
	            if (item === this._head) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            // Unlink the item
	            if (item === this._tail) {
	                // previous must be defined since item was not head but is tail
	                // So there are more than on item in the map
	                previous.next = undefined;
	                this._tail = previous;
	            }
	            else {
	                // Both next and previous are not undefined since item was neither head nor tail.
	                next.previous = previous;
	                previous.next = next;
	            }
	            // Insert the node at head
	            item.previous = undefined;
	            item.next = this._head;
	            this._head.previous = item;
	            this._head = item;
	            this._state++;
	        }
	        else if (touch === Touch.Last) {
	            if (item === this._tail) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            // Unlink the item.
	            if (item === this._head) {
	                // next must be defined since item was not tail but is head
	                // So there are more than on item in the map
	                next.previous = undefined;
	                this._head = next;
	            }
	            else {
	                // Both next and previous are not undefined since item was neither head nor tail.
	                next.previous = previous;
	                previous.next = next;
	            }
	            item.next = undefined;
	            item.previous = this._tail;
	            this._tail.next = item;
	            this._tail = item;
	            this._state++;
	        }
	    }
	    toJSON() {
	        const data = [];
	        this.forEach((value, key) => {
	            data.push([key, value]);
	        });
	        return data;
	    }
	    fromJSON(data) {
	        this.clear();
	        for (const [key, value] of data) {
	            this.set(key, value);
	        }
	    }
	}
	linkedMap.LinkedMap = LinkedMap;
	class LRUCache extends LinkedMap {
	    constructor(limit, ratio = 1) {
	        super();
	        this._limit = limit;
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	    }
	    get limit() {
	        return this._limit;
	    }
	    set limit(limit) {
	        this._limit = limit;
	        this.checkTrim();
	    }
	    get ratio() {
	        return this._ratio;
	    }
	    set ratio(ratio) {
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	        this.checkTrim();
	    }
	    get(key, touch = Touch.AsNew) {
	        return super.get(key, touch);
	    }
	    peek(key) {
	        return super.get(key, Touch.None);
	    }
	    set(key, value) {
	        super.set(key, value, Touch.Last);
	        this.checkTrim();
	        return this;
	    }
	    checkTrim() {
	        if (this.size > this._limit) {
	            this.trimOld(Math.round(this._limit * this._ratio));
	        }
	    }
	}
	linkedMap.LRUCache = LRUCache;
	return linkedMap;
}

var disposable = {};

var hasRequiredDisposable;

function requireDisposable () {
	if (hasRequiredDisposable) return disposable;
	hasRequiredDisposable = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(disposable, "__esModule", { value: true });
	disposable.Disposable = void 0;
	var Disposable;
	(function (Disposable) {
	    function create(func) {
	        return {
	            dispose: func
	        };
	    }
	    Disposable.create = create;
	})(Disposable || (disposable.Disposable = Disposable = {}));
	return disposable;
}

var events = {};

var ral = {};

var hasRequiredRal;

function requireRal () {
	if (hasRequiredRal) return ral;
	hasRequiredRal = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(ral, "__esModule", { value: true });
	let _ral;
	function RAL() {
	    if (_ral === undefined) {
	        throw new Error(`No runtime abstraction layer installed`);
	    }
	    return _ral;
	}
	(function (RAL) {
	    function install(ral) {
	        if (ral === undefined) {
	            throw new Error(`No runtime abstraction layer provided`);
	        }
	        _ral = ral;
	    }
	    RAL.install = install;
	})(RAL || (RAL = {}));
	ral.default = RAL;
	return ral;
}

var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(events, "__esModule", { value: true });
	events.Emitter = events.Event = void 0;
	const ral_1 = requireRal();
	var Event;
	(function (Event) {
	    const _disposable = { dispose() { } };
	    Event.None = function () { return _disposable; };
	})(Event || (events.Event = Event = {}));
	class CallbackList {
	    add(callback, context = null, bucket) {
	        if (!this._callbacks) {
	            this._callbacks = [];
	            this._contexts = [];
	        }
	        this._callbacks.push(callback);
	        this._contexts.push(context);
	        if (Array.isArray(bucket)) {
	            bucket.push({ dispose: () => this.remove(callback, context) });
	        }
	    }
	    remove(callback, context = null) {
	        if (!this._callbacks) {
	            return;
	        }
	        let foundCallbackWithDifferentContext = false;
	        for (let i = 0, len = this._callbacks.length; i < len; i++) {
	            if (this._callbacks[i] === callback) {
	                if (this._contexts[i] === context) {
	                    // callback & context match => remove it
	                    this._callbacks.splice(i, 1);
	                    this._contexts.splice(i, 1);
	                    return;
	                }
	                else {
	                    foundCallbackWithDifferentContext = true;
	                }
	            }
	        }
	        if (foundCallbackWithDifferentContext) {
	            throw new Error('When adding a listener with a context, you should remove it with the same context');
	        }
	    }
	    invoke(...args) {
	        if (!this._callbacks) {
	            return [];
	        }
	        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
	        for (let i = 0, len = callbacks.length; i < len; i++) {
	            try {
	                ret.push(callbacks[i].apply(contexts[i], args));
	            }
	            catch (e) {
	                // eslint-disable-next-line no-console
	                (0, ral_1.default)().console.error(e);
	            }
	        }
	        return ret;
	    }
	    isEmpty() {
	        return !this._callbacks || this._callbacks.length === 0;
	    }
	    dispose() {
	        this._callbacks = undefined;
	        this._contexts = undefined;
	    }
	}
	class Emitter {
	    constructor(_options) {
	        this._options = _options;
	    }
	    /**
	     * For the public to allow to subscribe
	     * to events from this Emitter
	     */
	    get event() {
	        if (!this._event) {
	            this._event = (listener, thisArgs, disposables) => {
	                if (!this._callbacks) {
	                    this._callbacks = new CallbackList();
	                }
	                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
	                    this._options.onFirstListenerAdd(this);
	                }
	                this._callbacks.add(listener, thisArgs);
	                const result = {
	                    dispose: () => {
	                        if (!this._callbacks) {
	                            // disposable is disposed after emitter is disposed.
	                            return;
	                        }
	                        this._callbacks.remove(listener, thisArgs);
	                        result.dispose = Emitter._noop;
	                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
	                            this._options.onLastListenerRemove(this);
	                        }
	                    }
	                };
	                if (Array.isArray(disposables)) {
	                    disposables.push(result);
	                }
	                return result;
	            };
	        }
	        return this._event;
	    }
	    /**
	     * To be kept private to fire an event to
	     * subscribers
	     */
	    fire(event) {
	        if (this._callbacks) {
	            this._callbacks.invoke.call(this._callbacks, event);
	        }
	    }
	    dispose() {
	        if (this._callbacks) {
	            this._callbacks.dispose();
	            this._callbacks = undefined;
	        }
	    }
	}
	events.Emitter = Emitter;
	Emitter._noop = function () { };
	return events;
}

var cancellation = {};

var hasRequiredCancellation;

function requireCancellation () {
	if (hasRequiredCancellation) return cancellation;
	hasRequiredCancellation = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(cancellation, "__esModule", { value: true });
	cancellation.CancellationTokenSource = cancellation.CancellationToken = void 0;
	const ral_1 = requireRal();
	const Is = requireIs$1();
	const events_1 = requireEvents();
	var CancellationToken;
	(function (CancellationToken) {
	    CancellationToken.None = Object.freeze({
	        isCancellationRequested: false,
	        onCancellationRequested: events_1.Event.None
	    });
	    CancellationToken.Cancelled = Object.freeze({
	        isCancellationRequested: true,
	        onCancellationRequested: events_1.Event.None
	    });
	    function is(value) {
	        const candidate = value;
	        return candidate && (candidate === CancellationToken.None
	            || candidate === CancellationToken.Cancelled
	            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
	    }
	    CancellationToken.is = is;
	})(CancellationToken || (cancellation.CancellationToken = CancellationToken = {}));
	const shortcutEvent = Object.freeze(function (callback, context) {
	    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
	    return { dispose() { handle.dispose(); } };
	});
	class MutableToken {
	    constructor() {
	        this._isCancelled = false;
	    }
	    cancel() {
	        if (!this._isCancelled) {
	            this._isCancelled = true;
	            if (this._emitter) {
	                this._emitter.fire(undefined);
	                this.dispose();
	            }
	        }
	    }
	    get isCancellationRequested() {
	        return this._isCancelled;
	    }
	    get onCancellationRequested() {
	        if (this._isCancelled) {
	            return shortcutEvent;
	        }
	        if (!this._emitter) {
	            this._emitter = new events_1.Emitter();
	        }
	        return this._emitter.event;
	    }
	    dispose() {
	        if (this._emitter) {
	            this._emitter.dispose();
	            this._emitter = undefined;
	        }
	    }
	}
	class CancellationTokenSource {
	    get token() {
	        if (!this._token) {
	            // be lazy and create the token only when
	            // actually needed
	            this._token = new MutableToken();
	        }
	        return this._token;
	    }
	    cancel() {
	        if (!this._token) {
	            // save an object by returning the default
	            // cancelled token when cancellation happens
	            // before someone asks for the token
	            this._token = CancellationToken.Cancelled;
	        }
	        else {
	            this._token.cancel();
	        }
	    }
	    dispose() {
	        if (!this._token) {
	            // ensure to initialize with an empty token if we had none
	            this._token = CancellationToken.None;
	        }
	        else if (this._token instanceof MutableToken) {
	            // actually dispose
	            this._token.dispose();
	        }
	    }
	}
	cancellation.CancellationTokenSource = CancellationTokenSource;
	return cancellation;
}

var sharedArrayCancellation = {};

var hasRequiredSharedArrayCancellation;

function requireSharedArrayCancellation () {
	if (hasRequiredSharedArrayCancellation) return sharedArrayCancellation;
	hasRequiredSharedArrayCancellation = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(sharedArrayCancellation, "__esModule", { value: true });
	sharedArrayCancellation.SharedArrayReceiverStrategy = sharedArrayCancellation.SharedArraySenderStrategy = void 0;
	const cancellation_1 = requireCancellation();
	var CancellationState;
	(function (CancellationState) {
	    CancellationState.Continue = 0;
	    CancellationState.Cancelled = 1;
	})(CancellationState || (CancellationState = {}));
	class SharedArraySenderStrategy {
	    constructor() {
	        this.buffers = new Map();
	    }
	    enableCancellation(request) {
	        if (request.id === null) {
	            return;
	        }
	        const buffer = new SharedArrayBuffer(4);
	        const data = new Int32Array(buffer, 0, 1);
	        data[0] = CancellationState.Continue;
	        this.buffers.set(request.id, buffer);
	        request.$cancellationData = buffer;
	    }
	    async sendCancellation(_conn, id) {
	        const buffer = this.buffers.get(id);
	        if (buffer === undefined) {
	            return;
	        }
	        const data = new Int32Array(buffer, 0, 1);
	        Atomics.store(data, 0, CancellationState.Cancelled);
	    }
	    cleanup(id) {
	        this.buffers.delete(id);
	    }
	    dispose() {
	        this.buffers.clear();
	    }
	}
	sharedArrayCancellation.SharedArraySenderStrategy = SharedArraySenderStrategy;
	class SharedArrayBufferCancellationToken {
	    constructor(buffer) {
	        this.data = new Int32Array(buffer, 0, 1);
	    }
	    get isCancellationRequested() {
	        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
	    }
	    get onCancellationRequested() {
	        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
	    }
	}
	class SharedArrayBufferCancellationTokenSource {
	    constructor(buffer) {
	        this.token = new SharedArrayBufferCancellationToken(buffer);
	    }
	    cancel() {
	    }
	    dispose() {
	    }
	}
	class SharedArrayReceiverStrategy {
	    constructor() {
	        this.kind = 'request';
	    }
	    createCancellationTokenSource(request) {
	        const buffer = request.$cancellationData;
	        if (buffer === undefined) {
	            return new cancellation_1.CancellationTokenSource();
	        }
	        return new SharedArrayBufferCancellationTokenSource(buffer);
	    }
	}
	sharedArrayCancellation.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
	return sharedArrayCancellation;
}

var messageReader = {};

var semaphore = {};

var hasRequiredSemaphore;

function requireSemaphore () {
	if (hasRequiredSemaphore) return semaphore;
	hasRequiredSemaphore = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(semaphore, "__esModule", { value: true });
	semaphore.Semaphore = void 0;
	const ral_1 = requireRal();
	class Semaphore {
	    constructor(capacity = 1) {
	        if (capacity <= 0) {
	            throw new Error('Capacity must be greater than 0');
	        }
	        this._capacity = capacity;
	        this._active = 0;
	        this._waiting = [];
	    }
	    lock(thunk) {
	        return new Promise((resolve, reject) => {
	            this._waiting.push({ thunk, resolve, reject });
	            this.runNext();
	        });
	    }
	    get active() {
	        return this._active;
	    }
	    runNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
	    }
	    doRunNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        const next = this._waiting.shift();
	        this._active++;
	        if (this._active > this._capacity) {
	            throw new Error(`To many thunks active`);
	        }
	        try {
	            const result = next.thunk();
	            if (result instanceof Promise) {
	                result.then((value) => {
	                    this._active--;
	                    next.resolve(value);
	                    this.runNext();
	                }, (err) => {
	                    this._active--;
	                    next.reject(err);
	                    this.runNext();
	                });
	            }
	            else {
	                this._active--;
	                next.resolve(result);
	                this.runNext();
	            }
	        }
	        catch (err) {
	            this._active--;
	            next.reject(err);
	            this.runNext();
	        }
	    }
	}
	semaphore.Semaphore = Semaphore;
	return semaphore;
}

var hasRequiredMessageReader;

function requireMessageReader () {
	if (hasRequiredMessageReader) return messageReader;
	hasRequiredMessageReader = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messageReader, "__esModule", { value: true });
	messageReader.ReadableStreamMessageReader = messageReader.AbstractMessageReader = messageReader.MessageReader = void 0;
	const ral_1 = requireRal();
	const Is = requireIs$1();
	const events_1 = requireEvents();
	const semaphore_1 = requireSemaphore();
	var MessageReader;
	(function (MessageReader) {
	    function is(value) {
	        let candidate = value;
	        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
	            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
	    }
	    MessageReader.is = is;
	})(MessageReader || (messageReader.MessageReader = MessageReader = {}));
	class AbstractMessageReader {
	    constructor() {
	        this.errorEmitter = new events_1.Emitter();
	        this.closeEmitter = new events_1.Emitter();
	        this.partialMessageEmitter = new events_1.Emitter();
	    }
	    dispose() {
	        this.errorEmitter.dispose();
	        this.closeEmitter.dispose();
	    }
	    get onError() {
	        return this.errorEmitter.event;
	    }
	    fireError(error) {
	        this.errorEmitter.fire(this.asError(error));
	    }
	    get onClose() {
	        return this.closeEmitter.event;
	    }
	    fireClose() {
	        this.closeEmitter.fire(undefined);
	    }
	    get onPartialMessage() {
	        return this.partialMessageEmitter.event;
	    }
	    firePartialMessage(info) {
	        this.partialMessageEmitter.fire(info);
	    }
	    asError(error) {
	        if (error instanceof Error) {
	            return error;
	        }
	        else {
	            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
	        }
	    }
	}
	messageReader.AbstractMessageReader = AbstractMessageReader;
	var ResolvedMessageReaderOptions;
	(function (ResolvedMessageReaderOptions) {
	    function fromOptions(options) {
	        let charset;
	        let contentDecoder;
	        const contentDecoders = new Map();
	        let contentTypeDecoder;
	        const contentTypeDecoders = new Map();
	        if (options === undefined || typeof options === 'string') {
	            charset = options ?? 'utf-8';
	        }
	        else {
	            charset = options.charset ?? 'utf-8';
	            if (options.contentDecoder !== undefined) {
	                contentDecoder = options.contentDecoder;
	                contentDecoders.set(contentDecoder.name, contentDecoder);
	            }
	            if (options.contentDecoders !== undefined) {
	                for (const decoder of options.contentDecoders) {
	                    contentDecoders.set(decoder.name, decoder);
	                }
	            }
	            if (options.contentTypeDecoder !== undefined) {
	                contentTypeDecoder = options.contentTypeDecoder;
	                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
	            }
	            if (options.contentTypeDecoders !== undefined) {
	                for (const decoder of options.contentTypeDecoders) {
	                    contentTypeDecoders.set(decoder.name, decoder);
	                }
	            }
	        }
	        if (contentTypeDecoder === undefined) {
	            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
	            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
	        }
	        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
	    }
	    ResolvedMessageReaderOptions.fromOptions = fromOptions;
	})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
	class ReadableStreamMessageReader extends AbstractMessageReader {
	    constructor(readable, options) {
	        super();
	        this.readable = readable;
	        this.options = ResolvedMessageReaderOptions.fromOptions(options);
	        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
	        this._partialMessageTimeout = 10000;
	        this.nextMessageLength = -1;
	        this.messageToken = 0;
	        this.readSemaphore = new semaphore_1.Semaphore(1);
	    }
	    set partialMessageTimeout(timeout) {
	        this._partialMessageTimeout = timeout;
	    }
	    get partialMessageTimeout() {
	        return this._partialMessageTimeout;
	    }
	    listen(callback) {
	        this.nextMessageLength = -1;
	        this.messageToken = 0;
	        this.partialMessageTimer = undefined;
	        this.callback = callback;
	        const result = this.readable.onData((data) => {
	            this.onData(data);
	        });
	        this.readable.onError((error) => this.fireError(error));
	        this.readable.onClose(() => this.fireClose());
	        return result;
	    }
	    onData(data) {
	        try {
	            this.buffer.append(data);
	            while (true) {
	                if (this.nextMessageLength === -1) {
	                    const headers = this.buffer.tryReadHeaders(true);
	                    if (!headers) {
	                        return;
	                    }
	                    const contentLength = headers.get('content-length');
	                    if (!contentLength) {
	                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
	                        return;
	                    }
	                    const length = parseInt(contentLength);
	                    if (isNaN(length)) {
	                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
	                        return;
	                    }
	                    this.nextMessageLength = length;
	                }
	                const body = this.buffer.tryReadBody(this.nextMessageLength);
	                if (body === undefined) {
	                    /** We haven't received the full message yet. */
	                    this.setPartialMessageTimer();
	                    return;
	                }
	                this.clearPartialMessageTimer();
	                this.nextMessageLength = -1;
	                // Make sure that we convert one received message after the
	                // other. Otherwise it could happen that a decoding of a second
	                // smaller message finished before the decoding of a first larger
	                // message and then we would deliver the second message first.
	                this.readSemaphore.lock(async () => {
	                    const bytes = this.options.contentDecoder !== undefined
	                        ? await this.options.contentDecoder.decode(body)
	                        : body;
	                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
	                    this.callback(message);
	                }).catch((error) => {
	                    this.fireError(error);
	                });
	            }
	        }
	        catch (error) {
	            this.fireError(error);
	        }
	    }
	    clearPartialMessageTimer() {
	        if (this.partialMessageTimer) {
	            this.partialMessageTimer.dispose();
	            this.partialMessageTimer = undefined;
	        }
	    }
	    setPartialMessageTimer() {
	        this.clearPartialMessageTimer();
	        if (this._partialMessageTimeout <= 0) {
	            return;
	        }
	        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
	            this.partialMessageTimer = undefined;
	            if (token === this.messageToken) {
	                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
	                this.setPartialMessageTimer();
	            }
	        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
	    }
	}
	messageReader.ReadableStreamMessageReader = ReadableStreamMessageReader;
	return messageReader;
}

var messageWriter = {};

var hasRequiredMessageWriter;

function requireMessageWriter () {
	if (hasRequiredMessageWriter) return messageWriter;
	hasRequiredMessageWriter = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messageWriter, "__esModule", { value: true });
	messageWriter.WriteableStreamMessageWriter = messageWriter.AbstractMessageWriter = messageWriter.MessageWriter = void 0;
	const ral_1 = requireRal();
	const Is = requireIs$1();
	const semaphore_1 = requireSemaphore();
	const events_1 = requireEvents();
	const ContentLength = 'Content-Length: ';
	const CRLF = '\r\n';
	var MessageWriter;
	(function (MessageWriter) {
	    function is(value) {
	        let candidate = value;
	        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
	            Is.func(candidate.onError) && Is.func(candidate.write);
	    }
	    MessageWriter.is = is;
	})(MessageWriter || (messageWriter.MessageWriter = MessageWriter = {}));
	class AbstractMessageWriter {
	    constructor() {
	        this.errorEmitter = new events_1.Emitter();
	        this.closeEmitter = new events_1.Emitter();
	    }
	    dispose() {
	        this.errorEmitter.dispose();
	        this.closeEmitter.dispose();
	    }
	    get onError() {
	        return this.errorEmitter.event;
	    }
	    fireError(error, message, count) {
	        this.errorEmitter.fire([this.asError(error), message, count]);
	    }
	    get onClose() {
	        return this.closeEmitter.event;
	    }
	    fireClose() {
	        this.closeEmitter.fire(undefined);
	    }
	    asError(error) {
	        if (error instanceof Error) {
	            return error;
	        }
	        else {
	            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
	        }
	    }
	}
	messageWriter.AbstractMessageWriter = AbstractMessageWriter;
	var ResolvedMessageWriterOptions;
	(function (ResolvedMessageWriterOptions) {
	    function fromOptions(options) {
	        if (options === undefined || typeof options === 'string') {
	            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
	        }
	        else {
	            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
	        }
	    }
	    ResolvedMessageWriterOptions.fromOptions = fromOptions;
	})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
	class WriteableStreamMessageWriter extends AbstractMessageWriter {
	    constructor(writable, options) {
	        super();
	        this.writable = writable;
	        this.options = ResolvedMessageWriterOptions.fromOptions(options);
	        this.errorCount = 0;
	        this.writeSemaphore = new semaphore_1.Semaphore(1);
	        this.writable.onError((error) => this.fireError(error));
	        this.writable.onClose(() => this.fireClose());
	    }
	    async write(msg) {
	        return this.writeSemaphore.lock(async () => {
	            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
	                if (this.options.contentEncoder !== undefined) {
	                    return this.options.contentEncoder.encode(buffer);
	                }
	                else {
	                    return buffer;
	                }
	            });
	            return payload.then((buffer) => {
	                const headers = [];
	                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
	                headers.push(CRLF);
	                return this.doWrite(msg, headers, buffer);
	            }, (error) => {
	                this.fireError(error);
	                throw error;
	            });
	        });
	    }
	    async doWrite(msg, headers, data) {
	        try {
	            await this.writable.write(headers.join(''), 'ascii');
	            return this.writable.write(data);
	        }
	        catch (error) {
	            this.handleError(error, msg);
	            return Promise.reject(error);
	        }
	    }
	    handleError(error, msg) {
	        this.errorCount++;
	        this.fireError(error, msg, this.errorCount);
	    }
	    end() {
	        this.writable.end();
	    }
	}
	messageWriter.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
	return messageWriter;
}

var messageBuffer = {};

var hasRequiredMessageBuffer;

function requireMessageBuffer () {
	if (hasRequiredMessageBuffer) return messageBuffer;
	hasRequiredMessageBuffer = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(messageBuffer, "__esModule", { value: true });
	messageBuffer.AbstractMessageBuffer = void 0;
	const CR = 13;
	const LF = 10;
	const CRLF = '\r\n';
	class AbstractMessageBuffer {
	    constructor(encoding = 'utf-8') {
	        this._encoding = encoding;
	        this._chunks = [];
	        this._totalLength = 0;
	    }
	    get encoding() {
	        return this._encoding;
	    }
	    append(chunk) {
	        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
	        this._chunks.push(toAppend);
	        this._totalLength += toAppend.byteLength;
	    }
	    tryReadHeaders(lowerCaseKeys = false) {
	        if (this._chunks.length === 0) {
	            return undefined;
	        }
	        let state = 0;
	        let chunkIndex = 0;
	        let offset = 0;
	        let chunkBytesRead = 0;
	        row: while (chunkIndex < this._chunks.length) {
	            const chunk = this._chunks[chunkIndex];
	            offset = 0;
	            while (offset < chunk.length) {
	                const value = chunk[offset];
	                switch (value) {
	                    case CR:
	                        switch (state) {
	                            case 0:
	                                state = 1;
	                                break;
	                            case 2:
	                                state = 3;
	                                break;
	                            default:
	                                state = 0;
	                        }
	                        break;
	                    case LF:
	                        switch (state) {
	                            case 1:
	                                state = 2;
	                                break;
	                            case 3:
	                                state = 4;
	                                offset++;
	                                break row;
	                            default:
	                                state = 0;
	                        }
	                        break;
	                    default:
	                        state = 0;
	                }
	                offset++;
	            }
	            chunkBytesRead += chunk.byteLength;
	            chunkIndex++;
	        }
	        if (state !== 4) {
	            return undefined;
	        }
	        // The buffer contains the two CRLF at the end. So we will
	        // have two empty lines after the split at the end as well.
	        const buffer = this._read(chunkBytesRead + offset);
	        const result = new Map();
	        const headers = this.toString(buffer, 'ascii').split(CRLF);
	        if (headers.length < 2) {
	            return result;
	        }
	        for (let i = 0; i < headers.length - 2; i++) {
	            const header = headers[i];
	            const index = header.indexOf(':');
	            if (index === -1) {
	                throw new Error(`Message header must separate key and value using ':'\n${header}`);
	            }
	            const key = header.substr(0, index);
	            const value = header.substr(index + 1).trim();
	            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
	        }
	        return result;
	    }
	    tryReadBody(length) {
	        if (this._totalLength < length) {
	            return undefined;
	        }
	        return this._read(length);
	    }
	    get numberOfBytes() {
	        return this._totalLength;
	    }
	    _read(byteCount) {
	        if (byteCount === 0) {
	            return this.emptyBuffer();
	        }
	        if (byteCount > this._totalLength) {
	            throw new Error(`Cannot read so many bytes!`);
	        }
	        if (this._chunks[0].byteLength === byteCount) {
	            // super fast path, precisely first chunk must be returned
	            const chunk = this._chunks[0];
	            this._chunks.shift();
	            this._totalLength -= byteCount;
	            return this.asNative(chunk);
	        }
	        if (this._chunks[0].byteLength > byteCount) {
	            // fast path, the reading is entirely within the first chunk
	            const chunk = this._chunks[0];
	            const result = this.asNative(chunk, byteCount);
	            this._chunks[0] = chunk.slice(byteCount);
	            this._totalLength -= byteCount;
	            return result;
	        }
	        const result = this.allocNative(byteCount);
	        let resultOffset = 0;
	        let chunkIndex = 0;
	        while (byteCount > 0) {
	            const chunk = this._chunks[chunkIndex];
	            if (chunk.byteLength > byteCount) {
	                // this chunk will survive
	                const chunkPart = chunk.slice(0, byteCount);
	                result.set(chunkPart, resultOffset);
	                resultOffset += byteCount;
	                this._chunks[chunkIndex] = chunk.slice(byteCount);
	                this._totalLength -= byteCount;
	                byteCount -= byteCount;
	            }
	            else {
	                // this chunk will be entirely read
	                result.set(chunk, resultOffset);
	                resultOffset += chunk.byteLength;
	                this._chunks.shift();
	                this._totalLength -= chunk.byteLength;
	                byteCount -= chunk.byteLength;
	            }
	        }
	        return result;
	    }
	}
	messageBuffer.AbstractMessageBuffer = AbstractMessageBuffer;
	return messageBuffer;
}

var connection$1 = {};

var hasRequiredConnection$1;

function requireConnection$1 () {
	if (hasRequiredConnection$1) return connection$1;
	hasRequiredConnection$1 = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
		const ral_1 = requireRal();
		const Is = requireIs$1();
		const messages_1 = requireMessages$1();
		const linkedMap_1 = requireLinkedMap();
		const events_1 = requireEvents();
		const cancellation_1 = requireCancellation();
		var CancelNotification;
		(function (CancelNotification) {
		    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
		})(CancelNotification || (CancelNotification = {}));
		var ProgressToken;
		(function (ProgressToken) {
		    function is(value) {
		        return typeof value === 'string' || typeof value === 'number';
		    }
		    ProgressToken.is = is;
		})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
		var ProgressNotification;
		(function (ProgressNotification) {
		    ProgressNotification.type = new messages_1.NotificationType('$/progress');
		})(ProgressNotification || (ProgressNotification = {}));
		class ProgressType {
		    constructor() {
		    }
		}
		exports.ProgressType = ProgressType;
		var StarRequestHandler;
		(function (StarRequestHandler) {
		    function is(value) {
		        return Is.func(value);
		    }
		    StarRequestHandler.is = is;
		})(StarRequestHandler || (StarRequestHandler = {}));
		exports.NullLogger = Object.freeze({
		    error: () => { },
		    warn: () => { },
		    info: () => { },
		    log: () => { }
		});
		var Trace;
		(function (Trace) {
		    Trace[Trace["Off"] = 0] = "Off";
		    Trace[Trace["Messages"] = 1] = "Messages";
		    Trace[Trace["Compact"] = 2] = "Compact";
		    Trace[Trace["Verbose"] = 3] = "Verbose";
		})(Trace || (exports.Trace = Trace = {}));
		var TraceValues;
		(function (TraceValues) {
		    /**
		     * Turn tracing off.
		     */
		    TraceValues.Off = 'off';
		    /**
		     * Trace messages only.
		     */
		    TraceValues.Messages = 'messages';
		    /**
		     * Compact message tracing.
		     */
		    TraceValues.Compact = 'compact';
		    /**
		     * Verbose message tracing.
		     */
		    TraceValues.Verbose = 'verbose';
		})(TraceValues || (exports.TraceValues = TraceValues = {}));
		(function (Trace) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return Trace.Off;
		        }
		        value = value.toLowerCase();
		        switch (value) {
		            case 'off':
		                return Trace.Off;
		            case 'messages':
		                return Trace.Messages;
		            case 'compact':
		                return Trace.Compact;
		            case 'verbose':
		                return Trace.Verbose;
		            default:
		                return Trace.Off;
		        }
		    }
		    Trace.fromString = fromString;
		    function toString(value) {
		        switch (value) {
		            case Trace.Off:
		                return 'off';
		            case Trace.Messages:
		                return 'messages';
		            case Trace.Compact:
		                return 'compact';
		            case Trace.Verbose:
		                return 'verbose';
		            default:
		                return 'off';
		        }
		    }
		    Trace.toString = toString;
		})(Trace || (exports.Trace = Trace = {}));
		var TraceFormat;
		(function (TraceFormat) {
		    TraceFormat["Text"] = "text";
		    TraceFormat["JSON"] = "json";
		})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
		(function (TraceFormat) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return TraceFormat.Text;
		        }
		        value = value.toLowerCase();
		        if (value === 'json') {
		            return TraceFormat.JSON;
		        }
		        else {
		            return TraceFormat.Text;
		        }
		    }
		    TraceFormat.fromString = fromString;
		})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
		var SetTraceNotification;
		(function (SetTraceNotification) {
		    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
		})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
		var LogTraceNotification;
		(function (LogTraceNotification) {
		    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
		})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
		var ConnectionErrors;
		(function (ConnectionErrors) {
		    /**
		     * The connection is closed.
		     */
		    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
		    /**
		     * The connection got disposed.
		     */
		    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
		    /**
		     * The connection is already in listening mode.
		     */
		    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
		})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
		class ConnectionError extends Error {
		    constructor(code, message) {
		        super(message);
		        this.code = code;
		        Object.setPrototypeOf(this, ConnectionError.prototype);
		    }
		}
		exports.ConnectionError = ConnectionError;
		var ConnectionStrategy;
		(function (ConnectionStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.cancelUndispatched);
		    }
		    ConnectionStrategy.is = is;
		})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
		var IdCancellationReceiverStrategy;
		(function (IdCancellationReceiverStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
		    }
		    IdCancellationReceiverStrategy.is = is;
		})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
		var RequestCancellationReceiverStrategy;
		(function (RequestCancellationReceiverStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
		    }
		    RequestCancellationReceiverStrategy.is = is;
		})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
		var CancellationReceiverStrategy;
		(function (CancellationReceiverStrategy) {
		    CancellationReceiverStrategy.Message = Object.freeze({
		        createCancellationTokenSource(_) {
		            return new cancellation_1.CancellationTokenSource();
		        }
		    });
		    function is(value) {
		        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
		    }
		    CancellationReceiverStrategy.is = is;
		})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
		var CancellationSenderStrategy;
		(function (CancellationSenderStrategy) {
		    CancellationSenderStrategy.Message = Object.freeze({
		        sendCancellation(conn, id) {
		            return conn.sendNotification(CancelNotification.type, { id });
		        },
		        cleanup(_) { }
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
		    }
		    CancellationSenderStrategy.is = is;
		})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
		var CancellationStrategy;
		(function (CancellationStrategy) {
		    CancellationStrategy.Message = Object.freeze({
		        receiver: CancellationReceiverStrategy.Message,
		        sender: CancellationSenderStrategy.Message
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
		    }
		    CancellationStrategy.is = is;
		})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
		var MessageStrategy;
		(function (MessageStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.handleMessage);
		    }
		    MessageStrategy.is = is;
		})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
		var ConnectionOptions;
		(function (ConnectionOptions) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
		    }
		    ConnectionOptions.is = is;
		})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
		var ConnectionState;
		(function (ConnectionState) {
		    ConnectionState[ConnectionState["New"] = 1] = "New";
		    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
		    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
		    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
		})(ConnectionState || (ConnectionState = {}));
		function createMessageConnection(messageReader, messageWriter, _logger, options) {
		    const logger = _logger !== undefined ? _logger : exports.NullLogger;
		    let sequenceNumber = 0;
		    let notificationSequenceNumber = 0;
		    let unknownResponseSequenceNumber = 0;
		    const version = '2.0';
		    let starRequestHandler = undefined;
		    const requestHandlers = new Map();
		    let starNotificationHandler = undefined;
		    const notificationHandlers = new Map();
		    const progressHandlers = new Map();
		    let timer;
		    let messageQueue = new linkedMap_1.LinkedMap();
		    let responsePromises = new Map();
		    let knownCanceledRequests = new Set();
		    let requestTokens = new Map();
		    let trace = Trace.Off;
		    let traceFormat = TraceFormat.Text;
		    let tracer;
		    let state = ConnectionState.New;
		    const errorEmitter = new events_1.Emitter();
		    const closeEmitter = new events_1.Emitter();
		    const unhandledNotificationEmitter = new events_1.Emitter();
		    const unhandledProgressEmitter = new events_1.Emitter();
		    const disposeEmitter = new events_1.Emitter();
		    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
		    function createRequestQueueKey(id) {
		        if (id === null) {
		            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
		        }
		        return 'req-' + id.toString();
		    }
		    function createResponseQueueKey(id) {
		        if (id === null) {
		            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
		        }
		        else {
		            return 'res-' + id.toString();
		        }
		    }
		    function createNotificationQueueKey() {
		        return 'not-' + (++notificationSequenceNumber).toString();
		    }
		    function addMessageToQueue(queue, message) {
		        if (messages_1.Message.isRequest(message)) {
		            queue.set(createRequestQueueKey(message.id), message);
		        }
		        else if (messages_1.Message.isResponse(message)) {
		            queue.set(createResponseQueueKey(message.id), message);
		        }
		        else {
		            queue.set(createNotificationQueueKey(), message);
		        }
		    }
		    function cancelUndispatched(_message) {
		        return undefined;
		    }
		    function isListening() {
		        return state === ConnectionState.Listening;
		    }
		    function isClosed() {
		        return state === ConnectionState.Closed;
		    }
		    function isDisposed() {
		        return state === ConnectionState.Disposed;
		    }
		    function closeHandler() {
		        if (state === ConnectionState.New || state === ConnectionState.Listening) {
		            state = ConnectionState.Closed;
		            closeEmitter.fire(undefined);
		        }
		        // If the connection is disposed don't sent close events.
		    }
		    function readErrorHandler(error) {
		        errorEmitter.fire([error, undefined, undefined]);
		    }
		    function writeErrorHandler(data) {
		        errorEmitter.fire(data);
		    }
		    messageReader.onClose(closeHandler);
		    messageReader.onError(readErrorHandler);
		    messageWriter.onClose(closeHandler);
		    messageWriter.onError(writeErrorHandler);
		    function triggerMessageQueue() {
		        if (timer || messageQueue.size === 0) {
		            return;
		        }
		        timer = (0, ral_1.default)().timer.setImmediate(() => {
		            timer = undefined;
		            processMessageQueue();
		        });
		    }
		    function handleMessage(message) {
		        if (messages_1.Message.isRequest(message)) {
		            handleRequest(message);
		        }
		        else if (messages_1.Message.isNotification(message)) {
		            handleNotification(message);
		        }
		        else if (messages_1.Message.isResponse(message)) {
		            handleResponse(message);
		        }
		        else {
		            handleInvalidMessage(message);
		        }
		    }
		    function processMessageQueue() {
		        if (messageQueue.size === 0) {
		            return;
		        }
		        const message = messageQueue.shift();
		        try {
		            const messageStrategy = options?.messageStrategy;
		            if (MessageStrategy.is(messageStrategy)) {
		                messageStrategy.handleMessage(message, handleMessage);
		            }
		            else {
		                handleMessage(message);
		            }
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    }
		    const callback = (message) => {
		        try {
		            // We have received a cancellation message. Check if the message is still in the queue
		            // and cancel it if allowed to do so.
		            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
		                const cancelId = message.params.id;
		                const key = createRequestQueueKey(cancelId);
		                const toCancel = messageQueue.get(key);
		                if (messages_1.Message.isRequest(toCancel)) {
		                    const strategy = options?.connectionStrategy;
		                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
		                    if (response && (response.error !== undefined || response.result !== undefined)) {
		                        messageQueue.delete(key);
		                        requestTokens.delete(cancelId);
		                        response.id = toCancel.id;
		                        traceSendingResponse(response, message.method, Date.now());
		                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
		                        return;
		                    }
		                }
		                const cancellationToken = requestTokens.get(cancelId);
		                // The request is already running. Cancel the token
		                if (cancellationToken !== undefined) {
		                    cancellationToken.cancel();
		                    traceReceivedNotification(message);
		                    return;
		                }
		                else {
		                    // Remember the cancel but still queue the message to
		                    // clean up state in process message.
		                    knownCanceledRequests.add(cancelId);
		                }
		            }
		            addMessageToQueue(messageQueue, message);
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    };
		    function handleRequest(requestMessage) {
		        if (isDisposed()) {
		            // we return here silently since we fired an event when the
		            // connection got disposed.
		            return;
		        }
		        function reply(resultOrError, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id
		            };
		            if (resultOrError instanceof messages_1.ResponseError) {
		                message.error = resultOrError.toJson();
		            }
		            else {
		                message.result = resultOrError === undefined ? null : resultOrError;
		            }
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        function replyError(error, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                error: error.toJson()
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        function replySuccess(result, method, startTime) {
		            // The JSON RPC defines that a response must either have a result or an error
		            // So we can't treat undefined as a valid response result.
		            if (result === undefined) {
		                result = null;
		            }
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                result: result
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        traceReceivedRequest(requestMessage);
		        const element = requestHandlers.get(requestMessage.method);
		        let type;
		        let requestHandler;
		        if (element) {
		            type = element.type;
		            requestHandler = element.handler;
		        }
		        const startTime = Date.now();
		        if (requestHandler || starRequestHandler) {
		            const tokenKey = requestMessage.id ?? String(Date.now()); //
		            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
		                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
		                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
		            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
		                cancellationSource.cancel();
		            }
		            if (requestMessage.id !== null) {
		                requestTokens.set(tokenKey, cancellationSource);
		            }
		            try {
		                let handlerResult;
		                if (requestHandler) {
		                    if (requestMessage.params === undefined) {
		                        if (type !== undefined && type.numberOfParams !== 0) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(cancellationSource.token);
		                    }
		                    else if (Array.isArray(requestMessage.params)) {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
		                    }
		                }
		                else if (starRequestHandler) {
		                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
		                }
		                const promise = handlerResult;
		                if (!handlerResult) {
		                    requestTokens.delete(tokenKey);
		                    replySuccess(handlerResult, requestMessage.method, startTime);
		                }
		                else if (promise.then) {
		                    promise.then((resultOrError) => {
		                        requestTokens.delete(tokenKey);
		                        reply(resultOrError, requestMessage.method, startTime);
		                    }, error => {
		                        requestTokens.delete(tokenKey);
		                        if (error instanceof messages_1.ResponseError) {
		                            replyError(error, requestMessage.method, startTime);
		                        }
		                        else if (error && Is.string(error.message)) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                        }
		                        else {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                        }
		                    });
		                }
		                else {
		                    requestTokens.delete(tokenKey);
		                    reply(handlerResult, requestMessage.method, startTime);
		                }
		            }
		            catch (error) {
		                requestTokens.delete(tokenKey);
		                if (error instanceof messages_1.ResponseError) {
		                    reply(error, requestMessage.method, startTime);
		                }
		                else if (error && Is.string(error.message)) {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                }
		                else {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                }
		            }
		        }
		        else {
		            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
		        }
		    }
		    function handleResponse(responseMessage) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        if (responseMessage.id === null) {
		            if (responseMessage.error) {
		                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
		            }
		            else {
		                logger.error(`Received response message without id. No further error information provided.`);
		            }
		        }
		        else {
		            const key = responseMessage.id;
		            const responsePromise = responsePromises.get(key);
		            traceReceivedResponse(responseMessage, responsePromise);
		            if (responsePromise !== undefined) {
		                responsePromises.delete(key);
		                try {
		                    if (responseMessage.error) {
		                        const error = responseMessage.error;
		                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
		                    }
		                    else if (responseMessage.result !== undefined) {
		                        responsePromise.resolve(responseMessage.result);
		                    }
		                    else {
		                        throw new Error('Should never happen.');
		                    }
		                }
		                catch (error) {
		                    if (error.message) {
		                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
		                    }
		                    else {
		                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
		                    }
		                }
		            }
		        }
		    }
		    function handleNotification(message) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        let type = undefined;
		        let notificationHandler;
		        if (message.method === CancelNotification.type.method) {
		            const cancelId = message.params.id;
		            knownCanceledRequests.delete(cancelId);
		            traceReceivedNotification(message);
		            return;
		        }
		        else {
		            const element = notificationHandlers.get(message.method);
		            if (element) {
		                notificationHandler = element.handler;
		                type = element.type;
		            }
		        }
		        if (notificationHandler || starNotificationHandler) {
		            try {
		                traceReceivedNotification(message);
		                if (notificationHandler) {
		                    if (message.params === undefined) {
		                        if (type !== undefined) {
		                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
		                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
		                            }
		                        }
		                        notificationHandler();
		                    }
		                    else if (Array.isArray(message.params)) {
		                        // There are JSON-RPC libraries that send progress message as positional params although
		                        // specified as named. So convert them if this is the case.
		                        const params = message.params;
		                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
		                            notificationHandler({ token: params[0], value: params[1] });
		                        }
		                        else {
		                            if (type !== undefined) {
		                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
		                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
		                                }
		                                if (type.numberOfParams !== message.params.length) {
		                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
		                                }
		                            }
		                            notificationHandler(...params);
		                        }
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
		                        }
		                        notificationHandler(message.params);
		                    }
		                }
		                else if (starNotificationHandler) {
		                    starNotificationHandler(message.method, message.params);
		                }
		            }
		            catch (error) {
		                if (error.message) {
		                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
		                }
		                else {
		                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
		                }
		            }
		        }
		        else {
		            unhandledNotificationEmitter.fire(message);
		        }
		    }
		    function handleInvalidMessage(message) {
		        if (!message) {
		            logger.error('Received empty message.');
		            return;
		        }
		        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
		        // Test whether we find an id to reject the promise
		        const responseMessage = message;
		        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
		            const key = responseMessage.id;
		            const responseHandler = responsePromises.get(key);
		            if (responseHandler) {
		                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
		            }
		        }
		    }
		    function stringifyTrace(params) {
		        if (params === undefined || params === null) {
		            return undefined;
		        }
		        switch (trace) {
		            case Trace.Verbose:
		                return JSON.stringify(params, null, 4);
		            case Trace.Compact:
		                return JSON.stringify(params);
		            default:
		                return undefined;
		        }
		    }
		    function traceSendingRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
		                data = `Params: ${stringifyTrace(message.params)}\n\n`;
		            }
		            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('send-request', message);
		        }
		    }
		    function traceSendingNotification(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.params) {
		                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Sending notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('send-notification', message);
		        }
		    }
		    function traceSendingResponse(message, method, startTime) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
		        }
		        else {
		            logLSPMessage('send-response', message);
		        }
		    }
		    function traceReceivedRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
		                data = `Params: ${stringifyTrace(message.params)}\n\n`;
		            }
		            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('receive-request', message);
		        }
		    }
		    function traceReceivedNotification(message) {
		        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.params) {
		                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Received notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('receive-notification', message);
		        }
		    }
		    function traceReceivedResponse(message, responsePromise) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            if (responsePromise) {
		                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
		                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
		            }
		            else {
		                tracer.log(`Received response ${message.id} without active response promise.`, data);
		            }
		        }
		        else {
		            logLSPMessage('receive-response', message);
		        }
		    }
		    function logLSPMessage(type, message) {
		        if (!tracer || trace === Trace.Off) {
		            return;
		        }
		        const lspMessage = {
		            isLSPMessage: true,
		            type,
		            message,
		            timestamp: Date.now()
		        };
		        tracer.log(lspMessage);
		    }
		    function throwIfClosedOrDisposed() {
		        if (isClosed()) {
		            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
		        }
		        if (isDisposed()) {
		            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
		        }
		    }
		    function throwIfListening() {
		        if (isListening()) {
		            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
		        }
		    }
		    function throwIfNotListening() {
		        if (!isListening()) {
		            throw new Error('Call listen() first.');
		        }
		    }
		    function undefinedToNull(param) {
		        if (param === undefined) {
		            return null;
		        }
		        else {
		            return param;
		        }
		    }
		    function nullToUndefined(param) {
		        if (param === null) {
		            return undefined;
		        }
		        else {
		            return param;
		        }
		    }
		    function isNamedParam(param) {
		        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
		    }
		    function computeSingleParam(parameterStructures, param) {
		        switch (parameterStructures) {
		            case messages_1.ParameterStructures.auto:
		                if (isNamedParam(param)) {
		                    return nullToUndefined(param);
		                }
		                else {
		                    return [undefinedToNull(param)];
		                }
		            case messages_1.ParameterStructures.byName:
		                if (!isNamedParam(param)) {
		                    throw new Error(`Received parameters by name but param is not an object literal.`);
		                }
		                return nullToUndefined(param);
		            case messages_1.ParameterStructures.byPosition:
		                return [undefinedToNull(param)];
		            default:
		                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
		        }
		    }
		    function computeMessageParams(type, params) {
		        let result;
		        const numberOfParams = type.numberOfParams;
		        switch (numberOfParams) {
		            case 0:
		                result = undefined;
		                break;
		            case 1:
		                result = computeSingleParam(type.parameterStructures, params[0]);
		                break;
		            default:
		                result = [];
		                for (let i = 0; i < params.length && i < numberOfParams; i++) {
		                    result.push(undefinedToNull(params[i]));
		                }
		                if (params.length < numberOfParams) {
		                    for (let i = params.length; i < numberOfParams; i++) {
		                        result.push(null);
		                    }
		                }
		                break;
		        }
		        return result;
		    }
		    const connection = {
		        sendNotification: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            let method;
		            let messageParams;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		            }
		            const notificationMessage = {
		                jsonrpc: version,
		                method: method,
		                params: messageParams
		            };
		            traceSendingNotification(notificationMessage);
		            return messageWriter.write(notificationMessage).catch((error) => {
		                logger.error(`Sending notification failed.`);
		                throw error;
		            });
		        },
		        onNotification: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method;
		            if (Is.func(type)) {
		                starNotificationHandler = type;
		            }
		            else if (handler) {
		                if (Is.string(type)) {
		                    method = type;
		                    notificationHandlers.set(type, { type: undefined, handler });
		                }
		                else {
		                    method = type.method;
		                    notificationHandlers.set(type.method, { type, handler });
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method !== undefined) {
		                        notificationHandlers.delete(method);
		                    }
		                    else {
		                        starNotificationHandler = undefined;
		                    }
		                }
		            };
		        },
		        onProgress: (_type, token, handler) => {
		            if (progressHandlers.has(token)) {
		                throw new Error(`Progress handler for token ${token} already registered`);
		            }
		            progressHandlers.set(token, handler);
		            return {
		                dispose: () => {
		                    progressHandlers.delete(token);
		                }
		            };
		        },
		        sendProgress: (_type, token, value) => {
		            // This should not await but simple return to ensure that we don't have another
		            // async scheduling. Otherwise one send could overtake another send.
		            return connection.sendNotification(ProgressNotification.type, { token, value });
		        },
		        onUnhandledProgress: unhandledProgressEmitter.event,
		        sendRequest: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            throwIfNotListening();
		            let method;
		            let messageParams;
		            let token = undefined;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                const last = args[args.length - 1];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                if (cancellation_1.CancellationToken.is(last)) {
		                    paramEnd = paramEnd - 1;
		                    token = last;
		                }
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		                const numberOfParams = type.numberOfParams;
		                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
		            }
		            const id = sequenceNumber++;
		            let disposable;
		            if (token) {
		                disposable = token.onCancellationRequested(() => {
		                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
		                    if (p === undefined) {
		                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
		                        return Promise.resolve();
		                    }
		                    else {
		                        return p.catch(() => {
		                            logger.log(`Sending cancellation messages for id ${id} failed`);
		                        });
		                    }
		                });
		            }
		            const requestMessage = {
		                jsonrpc: version,
		                id: id,
		                method: method,
		                params: messageParams
		            };
		            traceSendingRequest(requestMessage);
		            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
		                cancellationStrategy.sender.enableCancellation(requestMessage);
		            }
		            return new Promise(async (resolve, reject) => {
		                const resolveWithCleanup = (r) => {
		                    resolve(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable?.dispose();
		                };
		                const rejectWithCleanup = (r) => {
		                    reject(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable?.dispose();
		                };
		                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
		                try {
		                    await messageWriter.write(requestMessage);
		                    responsePromises.set(id, responsePromise);
		                }
		                catch (error) {
		                    logger.error(`Sending request failed.`);
		                    // Writing the message failed. So we need to reject the promise.
		                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
		                    throw error;
		                }
		            });
		        },
		        onRequest: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method = null;
		            if (StarRequestHandler.is(type)) {
		                method = undefined;
		                starRequestHandler = type;
		            }
		            else if (Is.string(type)) {
		                method = null;
		                if (handler !== undefined) {
		                    method = type;
		                    requestHandlers.set(type, { handler: handler, type: undefined });
		                }
		            }
		            else {
		                if (handler !== undefined) {
		                    method = type.method;
		                    requestHandlers.set(type.method, { type, handler });
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method === null) {
		                        return;
		                    }
		                    if (method !== undefined) {
		                        requestHandlers.delete(method);
		                    }
		                    else {
		                        starRequestHandler = undefined;
		                    }
		                }
		            };
		        },
		        hasPendingResponse: () => {
		            return responsePromises.size > 0;
		        },
		        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
		            let _sendNotification = false;
		            let _traceFormat = TraceFormat.Text;
		            if (sendNotificationOrTraceOptions !== undefined) {
		                if (Is.boolean(sendNotificationOrTraceOptions)) {
		                    _sendNotification = sendNotificationOrTraceOptions;
		                }
		                else {
		                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
		                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
		                }
		            }
		            trace = _value;
		            traceFormat = _traceFormat;
		            if (trace === Trace.Off) {
		                tracer = undefined;
		            }
		            else {
		                tracer = _tracer;
		            }
		            if (_sendNotification && !isClosed() && !isDisposed()) {
		                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
		            }
		        },
		        onError: errorEmitter.event,
		        onClose: closeEmitter.event,
		        onUnhandledNotification: unhandledNotificationEmitter.event,
		        onDispose: disposeEmitter.event,
		        end: () => {
		            messageWriter.end();
		        },
		        dispose: () => {
		            if (isDisposed()) {
		                return;
		            }
		            state = ConnectionState.Disposed;
		            disposeEmitter.fire(undefined);
		            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
		            for (const promise of responsePromises.values()) {
		                promise.reject(error);
		            }
		            responsePromises = new Map();
		            requestTokens = new Map();
		            knownCanceledRequests = new Set();
		            messageQueue = new linkedMap_1.LinkedMap();
		            // Test for backwards compatibility
		            if (Is.func(messageWriter.dispose)) {
		                messageWriter.dispose();
		            }
		            if (Is.func(messageReader.dispose)) {
		                messageReader.dispose();
		            }
		        },
		        listen: () => {
		            throwIfClosedOrDisposed();
		            throwIfListening();
		            state = ConnectionState.Listening;
		            messageReader.listen(callback);
		        },
		        inspect: () => {
		            // eslint-disable-next-line no-console
		            (0, ral_1.default)().console.log('inspect');
		        }
		    };
		    connection.onNotification(LogTraceNotification.type, (params) => {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
		        tracer.log(params.message, verbose ? params.verbose : undefined);
		    });
		    connection.onNotification(ProgressNotification.type, (params) => {
		        const handler = progressHandlers.get(params.token);
		        if (handler) {
		            handler(params.value);
		        }
		        else {
		            unhandledProgressEmitter.fire(params);
		        }
		    });
		    return connection;
		}
		exports.createMessageConnection = createMessageConnection; 
	} (connection$1));
	return connection$1;
}

var hasRequiredApi$2;

function requireApi$2 () {
	if (hasRequiredApi$2) return api$2;
	hasRequiredApi$2 = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		/// <reference path="../../typings/thenable.d.ts" />
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
		exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
		const messages_1 = requireMessages$1();
		Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return messages_1.Message; } });
		Object.defineProperty(exports, "RequestType", { enumerable: true, get: function () { return messages_1.RequestType; } });
		Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function () { return messages_1.RequestType0; } });
		Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function () { return messages_1.RequestType1; } });
		Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function () { return messages_1.RequestType2; } });
		Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function () { return messages_1.RequestType3; } });
		Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function () { return messages_1.RequestType4; } });
		Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function () { return messages_1.RequestType5; } });
		Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function () { return messages_1.RequestType6; } });
		Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function () { return messages_1.RequestType7; } });
		Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function () { return messages_1.RequestType8; } });
		Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function () { return messages_1.RequestType9; } });
		Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function () { return messages_1.ResponseError; } });
		Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });
		Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function () { return messages_1.NotificationType; } });
		Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function () { return messages_1.NotificationType0; } });
		Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function () { return messages_1.NotificationType1; } });
		Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function () { return messages_1.NotificationType2; } });
		Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function () { return messages_1.NotificationType3; } });
		Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function () { return messages_1.NotificationType4; } });
		Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function () { return messages_1.NotificationType5; } });
		Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function () { return messages_1.NotificationType6; } });
		Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function () { return messages_1.NotificationType7; } });
		Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function () { return messages_1.NotificationType8; } });
		Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function () { return messages_1.NotificationType9; } });
		Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });
		const linkedMap_1 = requireLinkedMap();
		Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });
		Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });
		Object.defineProperty(exports, "Touch", { enumerable: true, get: function () { return linkedMap_1.Touch; } });
		const disposable_1 = requireDisposable();
		Object.defineProperty(exports, "Disposable", { enumerable: true, get: function () { return disposable_1.Disposable; } });
		const events_1 = requireEvents();
		Object.defineProperty(exports, "Event", { enumerable: true, get: function () { return events_1.Event; } });
		Object.defineProperty(exports, "Emitter", { enumerable: true, get: function () { return events_1.Emitter; } });
		const cancellation_1 = requireCancellation();
		Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });
		Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });
		const sharedArrayCancellation_1 = requireSharedArrayCancellation();
		Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });
		Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });
		const messageReader_1 = requireMessageReader();
		Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });
		Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });
		Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });
		const messageWriter_1 = requireMessageWriter();
		Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });
		Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });
		Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });
		const messageBuffer_1 = requireMessageBuffer();
		Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });
		const connection_1 = requireConnection$1();
		Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });
		Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });
		Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function () { return connection_1.NullLogger; } });
		Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });
		Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function () { return connection_1.ProgressToken; } });
		Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function () { return connection_1.ProgressType; } });
		Object.defineProperty(exports, "Trace", { enumerable: true, get: function () { return connection_1.Trace; } });
		Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function () { return connection_1.TraceValues; } });
		Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function () { return connection_1.TraceFormat; } });
		Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });
		Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });
		Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });
		Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function () { return connection_1.ConnectionError; } });
		Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });
		Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });
		Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });
		Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function () { return connection_1.MessageStrategy; } });
		const ral_1 = requireRal();
		exports.RAL = ral_1.default; 
	} (api$2));
	return api$2;
}

var hasRequiredRil;

function requireRil () {
	if (hasRequiredRil) return ril;
	hasRequiredRil = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(ril, "__esModule", { value: true });
	const util_1 = require$$0;
	const api_1 = requireApi$2();
	class MessageBuffer extends api_1.AbstractMessageBuffer {
	    constructor(encoding = 'utf-8') {
	        super(encoding);
	    }
	    emptyBuffer() {
	        return MessageBuffer.emptyBuffer;
	    }
	    fromString(value, encoding) {
	        return Buffer.from(value, encoding);
	    }
	    toString(value, encoding) {
	        if (value instanceof Buffer) {
	            return value.toString(encoding);
	        }
	        else {
	            return new util_1.TextDecoder(encoding).decode(value);
	        }
	    }
	    asNative(buffer, length) {
	        if (length === undefined) {
	            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
	        }
	        else {
	            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
	        }
	    }
	    allocNative(length) {
	        return Buffer.allocUnsafe(length);
	    }
	}
	MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
	class ReadableStreamWrapper {
	    constructor(stream) {
	        this.stream = stream;
	    }
	    onClose(listener) {
	        this.stream.on('close', listener);
	        return api_1.Disposable.create(() => this.stream.off('close', listener));
	    }
	    onError(listener) {
	        this.stream.on('error', listener);
	        return api_1.Disposable.create(() => this.stream.off('error', listener));
	    }
	    onEnd(listener) {
	        this.stream.on('end', listener);
	        return api_1.Disposable.create(() => this.stream.off('end', listener));
	    }
	    onData(listener) {
	        this.stream.on('data', listener);
	        return api_1.Disposable.create(() => this.stream.off('data', listener));
	    }
	}
	class WritableStreamWrapper {
	    constructor(stream) {
	        this.stream = stream;
	    }
	    onClose(listener) {
	        this.stream.on('close', listener);
	        return api_1.Disposable.create(() => this.stream.off('close', listener));
	    }
	    onError(listener) {
	        this.stream.on('error', listener);
	        return api_1.Disposable.create(() => this.stream.off('error', listener));
	    }
	    onEnd(listener) {
	        this.stream.on('end', listener);
	        return api_1.Disposable.create(() => this.stream.off('end', listener));
	    }
	    write(data, encoding) {
	        return new Promise((resolve, reject) => {
	            const callback = (error) => {
	                if (error === undefined || error === null) {
	                    resolve();
	                }
	                else {
	                    reject(error);
	                }
	            };
	            if (typeof data === 'string') {
	                this.stream.write(data, encoding, callback);
	            }
	            else {
	                this.stream.write(data, callback);
	            }
	        });
	    }
	    end() {
	        this.stream.end();
	    }
	}
	const _ril = Object.freeze({
	    messageBuffer: Object.freeze({
	        create: (encoding) => new MessageBuffer(encoding)
	    }),
	    applicationJson: Object.freeze({
	        encoder: Object.freeze({
	            name: 'application/json',
	            encode: (msg, options) => {
	                try {
	                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
	                }
	                catch (err) {
	                    return Promise.reject(err);
	                }
	            }
	        }),
	        decoder: Object.freeze({
	            name: 'application/json',
	            decode: (buffer, options) => {
	                try {
	                    if (buffer instanceof Buffer) {
	                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
	                    }
	                    else {
	                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
	                    }
	                }
	                catch (err) {
	                    return Promise.reject(err);
	                }
	            }
	        })
	    }),
	    stream: Object.freeze({
	        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
	        asWritableStream: (stream) => new WritableStreamWrapper(stream)
	    }),
	    console: console,
	    timer: Object.freeze({
	        setTimeout(callback, ms, ...args) {
	            const handle = setTimeout(callback, ms, ...args);
	            return { dispose: () => clearTimeout(handle) };
	        },
	        setImmediate(callback, ...args) {
	            const handle = setImmediate(callback, ...args);
	            return { dispose: () => clearImmediate(handle) };
	        },
	        setInterval(callback, ms, ...args) {
	            const handle = setInterval(callback, ms, ...args);
	            return { dispose: () => clearInterval(handle) };
	        }
	    })
	});
	function RIL() {
	    return _ril;
	}
	(function (RIL) {
	    function install() {
	        api_1.RAL.install(_ril);
	    }
	    RIL.install = install;
	})(RIL || (RIL = {}));
	ril.default = RIL;
	return ril;
}

var hasRequiredMain$3;

function requireMain$3 () {
	if (hasRequiredMain$3) return main$1;
	hasRequiredMain$3 = 1;
	(function (exports) {
		var __createBinding = (main$1 && main$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$1 && main$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ----------------------------------------------------------------------------------------- */
		const ril_1 = requireRil();
		// Install the node runtime abstract.
		ril_1.default.install();
		const path = require$$1;
		const os = require$$2;
		const crypto_1 = require$$3;
		const net_1 = require$$4;
		const api_1 = requireApi$2();
		__exportStar(requireApi$2(), exports);
		class IPCMessageReader extends api_1.AbstractMessageReader {
		    constructor(process) {
		        super();
		        this.process = process;
		        let eventEmitter = this.process;
		        eventEmitter.on('error', (error) => this.fireError(error));
		        eventEmitter.on('close', () => this.fireClose());
		    }
		    listen(callback) {
		        this.process.on('message', callback);
		        return api_1.Disposable.create(() => this.process.off('message', callback));
		    }
		}
		exports.IPCMessageReader = IPCMessageReader;
		class IPCMessageWriter extends api_1.AbstractMessageWriter {
		    constructor(process) {
		        super();
		        this.process = process;
		        this.errorCount = 0;
		        const eventEmitter = this.process;
		        eventEmitter.on('error', (error) => this.fireError(error));
		        eventEmitter.on('close', () => this.fireClose);
		    }
		    write(msg) {
		        try {
		            if (typeof this.process.send === 'function') {
		                this.process.send(msg, undefined, undefined, (error) => {
		                    if (error) {
		                        this.errorCount++;
		                        this.handleError(error, msg);
		                    }
		                    else {
		                        this.errorCount = 0;
		                    }
		                });
		            }
		            return Promise.resolve();
		        }
		        catch (error) {
		            this.handleError(error, msg);
		            return Promise.reject(error);
		        }
		    }
		    handleError(error, msg) {
		        this.errorCount++;
		        this.fireError(error, msg, this.errorCount);
		    }
		    end() {
		    }
		}
		exports.IPCMessageWriter = IPCMessageWriter;
		class PortMessageReader extends api_1.AbstractMessageReader {
		    constructor(port) {
		        super();
		        this.onData = new api_1.Emitter;
		        port.on('close', () => this.fireClose);
		        port.on('error', (error) => this.fireError(error));
		        port.on('message', (message) => {
		            this.onData.fire(message);
		        });
		    }
		    listen(callback) {
		        return this.onData.event(callback);
		    }
		}
		exports.PortMessageReader = PortMessageReader;
		class PortMessageWriter extends api_1.AbstractMessageWriter {
		    constructor(port) {
		        super();
		        this.port = port;
		        this.errorCount = 0;
		        port.on('close', () => this.fireClose());
		        port.on('error', (error) => this.fireError(error));
		    }
		    write(msg) {
		        try {
		            this.port.postMessage(msg);
		            return Promise.resolve();
		        }
		        catch (error) {
		            this.handleError(error, msg);
		            return Promise.reject(error);
		        }
		    }
		    handleError(error, msg) {
		        this.errorCount++;
		        this.fireError(error, msg, this.errorCount);
		    }
		    end() {
		    }
		}
		exports.PortMessageWriter = PortMessageWriter;
		class SocketMessageReader extends api_1.ReadableStreamMessageReader {
		    constructor(socket, encoding = 'utf-8') {
		        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
		    }
		}
		exports.SocketMessageReader = SocketMessageReader;
		class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
		    constructor(socket, options) {
		        super((0, ril_1.default)().stream.asWritableStream(socket), options);
		        this.socket = socket;
		    }
		    dispose() {
		        super.dispose();
		        this.socket.destroy();
		    }
		}
		exports.SocketMessageWriter = SocketMessageWriter;
		class StreamMessageReader extends api_1.ReadableStreamMessageReader {
		    constructor(readable, encoding) {
		        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
		    }
		}
		exports.StreamMessageReader = StreamMessageReader;
		class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
		    constructor(writable, options) {
		        super((0, ril_1.default)().stream.asWritableStream(writable), options);
		    }
		}
		exports.StreamMessageWriter = StreamMessageWriter;
		const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
		const safeIpcPathLengths = new Map([
		    ['linux', 107],
		    ['darwin', 103]
		]);
		function generateRandomPipeName() {
		    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
		    if (process.platform === 'win32') {
		        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
		    }
		    let result;
		    if (XDG_RUNTIME_DIR) {
		        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
		    }
		    else {
		        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
		    }
		    const limit = safeIpcPathLengths.get(process.platform);
		    if (limit !== undefined && result.length > limit) {
		        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
		    }
		    return result;
		}
		exports.generateRandomPipeName = generateRandomPipeName;
		function createClientPipeTransport(pipeName, encoding = 'utf-8') {
		    let connectResolve;
		    const connected = new Promise((resolve, _reject) => {
		        connectResolve = resolve;
		    });
		    return new Promise((resolve, reject) => {
		        let server = (0, net_1.createServer)((socket) => {
		            server.close();
		            connectResolve([
		                new SocketMessageReader(socket, encoding),
		                new SocketMessageWriter(socket, encoding)
		            ]);
		        });
		        server.on('error', reject);
		        server.listen(pipeName, () => {
		            server.removeListener('error', reject);
		            resolve({
		                onConnected: () => { return connected; }
		            });
		        });
		    });
		}
		exports.createClientPipeTransport = createClientPipeTransport;
		function createServerPipeTransport(pipeName, encoding = 'utf-8') {
		    const socket = (0, net_1.createConnection)(pipeName);
		    return [
		        new SocketMessageReader(socket, encoding),
		        new SocketMessageWriter(socket, encoding)
		    ];
		}
		exports.createServerPipeTransport = createServerPipeTransport;
		function createClientSocketTransport(port, encoding = 'utf-8') {
		    let connectResolve;
		    const connected = new Promise((resolve, _reject) => {
		        connectResolve = resolve;
		    });
		    return new Promise((resolve, reject) => {
		        const server = (0, net_1.createServer)((socket) => {
		            server.close();
		            connectResolve([
		                new SocketMessageReader(socket, encoding),
		                new SocketMessageWriter(socket, encoding)
		            ]);
		        });
		        server.on('error', reject);
		        server.listen(port, '127.0.0.1', () => {
		            server.removeListener('error', reject);
		            resolve({
		                onConnected: () => { return connected; }
		            });
		        });
		    });
		}
		exports.createClientSocketTransport = createClientSocketTransport;
		function createServerSocketTransport(port, encoding = 'utf-8') {
		    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
		    return [
		        new SocketMessageReader(socket, encoding),
		        new SocketMessageWriter(socket, encoding)
		    ];
		}
		exports.createServerSocketTransport = createServerSocketTransport;
		function isReadableStream(value) {
		    const candidate = value;
		    return candidate.read !== undefined && candidate.addListener !== undefined;
		}
		function isWritableStream(value) {
		    const candidate = value;
		    return candidate.write !== undefined && candidate.addListener !== undefined;
		}
		function createMessageConnection(input, output, logger, options) {
		    if (!logger) {
		        logger = api_1.NullLogger;
		    }
		    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
		    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
		    if (api_1.ConnectionStrategy.is(options)) {
		        options = { connectionStrategy: options };
		    }
		    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
		}
		exports.createMessageConnection = createMessageConnection; 
	} (main$1));
	return main$1;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node$2;
var hasRequiredNode$2;

function requireNode$2 () {
	if (hasRequiredNode$2) return node$2;
	hasRequiredNode$2 = 1;

	node$2 = requireMain$3();
	return node$2;
}

var api$1 = {};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var main = {exports: {}};

var hasRequiredMain$2;

function requireMain$2 () {
	if (hasRequiredMain$2) return main.exports;
	hasRequiredMain$2 = 1;
	(function (module, exports) {
		(function (factory) {
		    {
		        var v = factory(commonjsRequire, exports);
		        if (v !== undefined) module.exports = v;
		    }
		})(function (require, exports) {
		    Object.defineProperty(exports, "__esModule", { value: true });
		    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;
		    var DocumentUri;
		    (function (DocumentUri) {
		        function is(value) {
		            return typeof value === 'string';
		        }
		        DocumentUri.is = is;
		    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));
		    var URI;
		    (function (URI) {
		        function is(value) {
		            return typeof value === 'string';
		        }
		        URI.is = is;
		    })(URI || (exports.URI = URI = {}));
		    var integer;
		    (function (integer) {
		        integer.MIN_VALUE = -2147483648;
		        integer.MAX_VALUE = 2147483647;
		        function is(value) {
		            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
		        }
		        integer.is = is;
		    })(integer || (exports.integer = integer = {}));
		    var uinteger;
		    (function (uinteger) {
		        uinteger.MIN_VALUE = 0;
		        uinteger.MAX_VALUE = 2147483647;
		        function is(value) {
		            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
		        }
		        uinteger.is = is;
		    })(uinteger || (exports.uinteger = uinteger = {}));
		    /**
		     * The Position namespace provides helper functions to work with
		     * {@link Position} literals.
		     */
		    var Position;
		    (function (Position) {
		        /**
		         * Creates a new Position literal from the given line and character.
		         * @param line The position's line.
		         * @param character The position's character.
		         */
		        function create(line, character) {
		            if (line === Number.MAX_VALUE) {
		                line = uinteger.MAX_VALUE;
		            }
		            if (character === Number.MAX_VALUE) {
		                character = uinteger.MAX_VALUE;
		            }
		            return { line: line, character: character };
		        }
		        Position.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Position} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
		        }
		        Position.is = is;
		    })(Position || (exports.Position = Position = {}));
		    /**
		     * The Range namespace provides helper functions to work with
		     * {@link Range} literals.
		     */
		    var Range;
		    (function (Range) {
		        function create(one, two, three, four) {
		            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
		                return { start: Position.create(one, two), end: Position.create(three, four) };
		            }
		            else if (Position.is(one) && Position.is(two)) {
		                return { start: one, end: two };
		            }
		            else {
		                throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
		            }
		        }
		        Range.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Range} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
		        }
		        Range.is = is;
		    })(Range || (exports.Range = Range = {}));
		    /**
		     * The Location namespace provides helper functions to work with
		     * {@link Location} literals.
		     */
		    var Location;
		    (function (Location) {
		        /**
		         * Creates a Location literal.
		         * @param uri The location's uri.
		         * @param range The location's range.
		         */
		        function create(uri, range) {
		            return { uri: uri, range: range };
		        }
		        Location.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Location} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
		        }
		        Location.is = is;
		    })(Location || (exports.Location = Location = {}));
		    /**
		     * The LocationLink namespace provides helper functions to work with
		     * {@link LocationLink} literals.
		     */
		    var LocationLink;
		    (function (LocationLink) {
		        /**
		         * Creates a LocationLink literal.
		         * @param targetUri The definition's uri.
		         * @param targetRange The full range of the definition.
		         * @param targetSelectionRange The span of the symbol definition at the target.
		         * @param originSelectionRange The span of the symbol being defined in the originating source file.
		         */
		        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
		            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
		        }
		        LocationLink.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link LocationLink} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
		                && Range.is(candidate.targetSelectionRange)
		                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
		        }
		        LocationLink.is = is;
		    })(LocationLink || (exports.LocationLink = LocationLink = {}));
		    /**
		     * The Color namespace provides helper functions to work with
		     * {@link Color} literals.
		     */
		    var Color;
		    (function (Color) {
		        /**
		         * Creates a new Color literal.
		         */
		        function create(red, green, blue, alpha) {
		            return {
		                red: red,
		                green: green,
		                blue: blue,
		                alpha: alpha,
		            };
		        }
		        Color.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Color} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
		                && Is.numberRange(candidate.green, 0, 1)
		                && Is.numberRange(candidate.blue, 0, 1)
		                && Is.numberRange(candidate.alpha, 0, 1);
		        }
		        Color.is = is;
		    })(Color || (exports.Color = Color = {}));
		    /**
		     * The ColorInformation namespace provides helper functions to work with
		     * {@link ColorInformation} literals.
		     */
		    var ColorInformation;
		    (function (ColorInformation) {
		        /**
		         * Creates a new ColorInformation literal.
		         */
		        function create(range, color) {
		            return {
		                range: range,
		                color: color,
		            };
		        }
		        ColorInformation.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
		        }
		        ColorInformation.is = is;
		    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));
		    /**
		     * The Color namespace provides helper functions to work with
		     * {@link ColorPresentation} literals.
		     */
		    var ColorPresentation;
		    (function (ColorPresentation) {
		        /**
		         * Creates a new ColorInformation literal.
		         */
		        function create(label, textEdit, additionalTextEdits) {
		            return {
		                label: label,
		                textEdit: textEdit,
		                additionalTextEdits: additionalTextEdits,
		            };
		        }
		        ColorPresentation.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.string(candidate.label)
		                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
		                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
		        }
		        ColorPresentation.is = is;
		    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));
		    /**
		     * A set of predefined range kinds.
		     */
		    var FoldingRangeKind;
		    (function (FoldingRangeKind) {
		        /**
		         * Folding range for a comment
		         */
		        FoldingRangeKind.Comment = 'comment';
		        /**
		         * Folding range for an import or include
		         */
		        FoldingRangeKind.Imports = 'imports';
		        /**
		         * Folding range for a region (e.g. `#region`)
		         */
		        FoldingRangeKind.Region = 'region';
		    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));
		    /**
		     * The folding range namespace provides helper functions to work with
		     * {@link FoldingRange} literals.
		     */
		    var FoldingRange;
		    (function (FoldingRange) {
		        /**
		         * Creates a new FoldingRange literal.
		         */
		        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
		            var result = {
		                startLine: startLine,
		                endLine: endLine
		            };
		            if (Is.defined(startCharacter)) {
		                result.startCharacter = startCharacter;
		            }
		            if (Is.defined(endCharacter)) {
		                result.endCharacter = endCharacter;
		            }
		            if (Is.defined(kind)) {
		                result.kind = kind;
		            }
		            if (Is.defined(collapsedText)) {
		                result.collapsedText = collapsedText;
		            }
		            return result;
		        }
		        FoldingRange.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link FoldingRange} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
		                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
		                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
		                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
		        }
		        FoldingRange.is = is;
		    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));
		    /**
		     * The DiagnosticRelatedInformation namespace provides helper functions to work with
		     * {@link DiagnosticRelatedInformation} literals.
		     */
		    var DiagnosticRelatedInformation;
		    (function (DiagnosticRelatedInformation) {
		        /**
		         * Creates a new DiagnosticRelatedInformation literal.
		         */
		        function create(location, message) {
		            return {
		                location: location,
		                message: message
		            };
		        }
		        DiagnosticRelatedInformation.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
		        }
		        DiagnosticRelatedInformation.is = is;
		    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
		    /**
		     * The diagnostic's severity.
		     */
		    var DiagnosticSeverity;
		    (function (DiagnosticSeverity) {
		        /**
		         * Reports an error.
		         */
		        DiagnosticSeverity.Error = 1;
		        /**
		         * Reports a warning.
		         */
		        DiagnosticSeverity.Warning = 2;
		        /**
		         * Reports an information.
		         */
		        DiagnosticSeverity.Information = 3;
		        /**
		         * Reports a hint.
		         */
		        DiagnosticSeverity.Hint = 4;
		    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
		    /**
		     * The diagnostic tags.
		     *
		     * @since 3.15.0
		     */
		    var DiagnosticTag;
		    (function (DiagnosticTag) {
		        /**
		         * Unused or unnecessary code.
		         *
		         * Clients are allowed to render diagnostics with this tag faded out instead of having
		         * an error squiggle.
		         */
		        DiagnosticTag.Unnecessary = 1;
		        /**
		         * Deprecated or obsolete code.
		         *
		         * Clients are allowed to rendered diagnostics with this tag strike through.
		         */
		        DiagnosticTag.Deprecated = 2;
		    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
		    /**
		     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
		     *
		     * @since 3.16.0
		     */
		    var CodeDescription;
		    (function (CodeDescription) {
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.string(candidate.href);
		        }
		        CodeDescription.is = is;
		    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));
		    /**
		     * The Diagnostic namespace provides helper functions to work with
		     * {@link Diagnostic} literals.
		     */
		    var Diagnostic;
		    (function (Diagnostic) {
		        /**
		         * Creates a new Diagnostic literal.
		         */
		        function create(range, message, severity, code, source, relatedInformation) {
		            var result = { range: range, message: message };
		            if (Is.defined(severity)) {
		                result.severity = severity;
		            }
		            if (Is.defined(code)) {
		                result.code = code;
		            }
		            if (Is.defined(source)) {
		                result.source = source;
		            }
		            if (Is.defined(relatedInformation)) {
		                result.relatedInformation = relatedInformation;
		            }
		            return result;
		        }
		        Diagnostic.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Diagnostic} interface.
		         */
		        function is(value) {
		            var _a;
		            var candidate = value;
		            return Is.defined(candidate)
		                && Range.is(candidate.range)
		                && Is.string(candidate.message)
		                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
		                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
		                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
		                && (Is.string(candidate.source) || Is.undefined(candidate.source))
		                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
		        }
		        Diagnostic.is = is;
		    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));
		    /**
		     * The Command namespace provides helper functions to work with
		     * {@link Command} literals.
		     */
		    var Command;
		    (function (Command) {
		        /**
		         * Creates a new Command literal.
		         */
		        function create(title, command) {
		            var args = [];
		            for (var _i = 2; _i < arguments.length; _i++) {
		                args[_i - 2] = arguments[_i];
		            }
		            var result = { title: title, command: command };
		            if (Is.defined(args) && args.length > 0) {
		                result.arguments = args;
		            }
		            return result;
		        }
		        Command.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Command} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
		        }
		        Command.is = is;
		    })(Command || (exports.Command = Command = {}));
		    /**
		     * The TextEdit namespace provides helper function to create replace,
		     * insert and delete edits more easily.
		     */
		    var TextEdit;
		    (function (TextEdit) {
		        /**
		         * Creates a replace text edit.
		         * @param range The range of text to be replaced.
		         * @param newText The new text.
		         */
		        function replace(range, newText) {
		            return { range: range, newText: newText };
		        }
		        TextEdit.replace = replace;
		        /**
		         * Creates an insert text edit.
		         * @param position The position to insert the text at.
		         * @param newText The text to be inserted.
		         */
		        function insert(position, newText) {
		            return { range: { start: position, end: position }, newText: newText };
		        }
		        TextEdit.insert = insert;
		        /**
		         * Creates a delete text edit.
		         * @param range The range of text to be deleted.
		         */
		        function del(range) {
		            return { range: range, newText: '' };
		        }
		        TextEdit.del = del;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate)
		                && Is.string(candidate.newText)
		                && Range.is(candidate.range);
		        }
		        TextEdit.is = is;
		    })(TextEdit || (exports.TextEdit = TextEdit = {}));
		    var ChangeAnnotation;
		    (function (ChangeAnnotation) {
		        function create(label, needsConfirmation, description) {
		            var result = { label: label };
		            if (needsConfirmation !== undefined) {
		                result.needsConfirmation = needsConfirmation;
		            }
		            if (description !== undefined) {
		                result.description = description;
		            }
		            return result;
		        }
		        ChangeAnnotation.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
		                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
		                (Is.string(candidate.description) || candidate.description === undefined);
		        }
		        ChangeAnnotation.is = is;
		    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));
		    var ChangeAnnotationIdentifier;
		    (function (ChangeAnnotationIdentifier) {
		        function is(value) {
		            var candidate = value;
		            return Is.string(candidate);
		        }
		        ChangeAnnotationIdentifier.is = is;
		    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
		    var AnnotatedTextEdit;
		    (function (AnnotatedTextEdit) {
		        /**
		         * Creates an annotated replace text edit.
		         *
		         * @param range The range of text to be replaced.
		         * @param newText The new text.
		         * @param annotation The annotation.
		         */
		        function replace(range, newText, annotation) {
		            return { range: range, newText: newText, annotationId: annotation };
		        }
		        AnnotatedTextEdit.replace = replace;
		        /**
		         * Creates an annotated insert text edit.
		         *
		         * @param position The position to insert the text at.
		         * @param newText The text to be inserted.
		         * @param annotation The annotation.
		         */
		        function insert(position, newText, annotation) {
		            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
		        }
		        AnnotatedTextEdit.insert = insert;
		        /**
		         * Creates an annotated delete text edit.
		         *
		         * @param range The range of text to be deleted.
		         * @param annotation The annotation.
		         */
		        function del(range, annotation) {
		            return { range: range, newText: '', annotationId: annotation };
		        }
		        AnnotatedTextEdit.del = del;
		        function is(value) {
		            var candidate = value;
		            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        AnnotatedTextEdit.is = is;
		    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));
		    /**
		     * The TextDocumentEdit namespace provides helper function to create
		     * an edit that manipulates a text document.
		     */
		    var TextDocumentEdit;
		    (function (TextDocumentEdit) {
		        /**
		         * Creates a new `TextDocumentEdit`
		         */
		        function create(textDocument, edits) {
		            return { textDocument: textDocument, edits: edits };
		        }
		        TextDocumentEdit.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate)
		                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
		                && Array.isArray(candidate.edits);
		        }
		        TextDocumentEdit.is = is;
		    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));
		    var CreateFile;
		    (function (CreateFile) {
		        function create(uri, options, annotation) {
		            var result = {
		                kind: 'create',
		                uri: uri
		            };
		            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
		                result.options = options;
		            }
		            if (annotation !== undefined) {
		                result.annotationId = annotation;
		            }
		            return result;
		        }
		        CreateFile.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
		                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        CreateFile.is = is;
		    })(CreateFile || (exports.CreateFile = CreateFile = {}));
		    var RenameFile;
		    (function (RenameFile) {
		        function create(oldUri, newUri, options, annotation) {
		            var result = {
		                kind: 'rename',
		                oldUri: oldUri,
		                newUri: newUri
		            };
		            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
		                result.options = options;
		            }
		            if (annotation !== undefined) {
		                result.annotationId = annotation;
		            }
		            return result;
		        }
		        RenameFile.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
		                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        RenameFile.is = is;
		    })(RenameFile || (exports.RenameFile = RenameFile = {}));
		    var DeleteFile;
		    (function (DeleteFile) {
		        function create(uri, options, annotation) {
		            var result = {
		                kind: 'delete',
		                uri: uri
		            };
		            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
		                result.options = options;
		            }
		            if (annotation !== undefined) {
		                result.annotationId = annotation;
		            }
		            return result;
		        }
		        DeleteFile.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
		                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        DeleteFile.is = is;
		    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));
		    var WorkspaceEdit;
		    (function (WorkspaceEdit) {
		        function is(value) {
		            var candidate = value;
		            return candidate &&
		                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
		                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
		                    if (Is.string(change.kind)) {
		                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
		                    }
		                    else {
		                        return TextDocumentEdit.is(change);
		                    }
		                }));
		        }
		        WorkspaceEdit.is = is;
		    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));
		    var TextEditChangeImpl = /** @class */ (function () {
		        function TextEditChangeImpl(edits, changeAnnotations) {
		            this.edits = edits;
		            this.changeAnnotations = changeAnnotations;
		        }
		        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
		            var edit;
		            var id;
		            if (annotation === undefined) {
		                edit = TextEdit.insert(position, newText);
		            }
		            else if (ChangeAnnotationIdentifier.is(annotation)) {
		                id = annotation;
		                edit = AnnotatedTextEdit.insert(position, newText, annotation);
		            }
		            else {
		                this.assertChangeAnnotations(this.changeAnnotations);
		                id = this.changeAnnotations.manage(annotation);
		                edit = AnnotatedTextEdit.insert(position, newText, id);
		            }
		            this.edits.push(edit);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
		            var edit;
		            var id;
		            if (annotation === undefined) {
		                edit = TextEdit.replace(range, newText);
		            }
		            else if (ChangeAnnotationIdentifier.is(annotation)) {
		                id = annotation;
		                edit = AnnotatedTextEdit.replace(range, newText, annotation);
		            }
		            else {
		                this.assertChangeAnnotations(this.changeAnnotations);
		                id = this.changeAnnotations.manage(annotation);
		                edit = AnnotatedTextEdit.replace(range, newText, id);
		            }
		            this.edits.push(edit);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        TextEditChangeImpl.prototype.delete = function (range, annotation) {
		            var edit;
		            var id;
		            if (annotation === undefined) {
		                edit = TextEdit.del(range);
		            }
		            else if (ChangeAnnotationIdentifier.is(annotation)) {
		                id = annotation;
		                edit = AnnotatedTextEdit.del(range, annotation);
		            }
		            else {
		                this.assertChangeAnnotations(this.changeAnnotations);
		                id = this.changeAnnotations.manage(annotation);
		                edit = AnnotatedTextEdit.del(range, id);
		            }
		            this.edits.push(edit);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        TextEditChangeImpl.prototype.add = function (edit) {
		            this.edits.push(edit);
		        };
		        TextEditChangeImpl.prototype.all = function () {
		            return this.edits;
		        };
		        TextEditChangeImpl.prototype.clear = function () {
		            this.edits.splice(0, this.edits.length);
		        };
		        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
		            if (value === undefined) {
		                throw new Error("Text edit change is not configured to manage change annotations.");
		            }
		        };
		        return TextEditChangeImpl;
		    }());
		    /**
		     * A helper class
		     */
		    var ChangeAnnotations = /** @class */ (function () {
		        function ChangeAnnotations(annotations) {
		            this._annotations = annotations === undefined ? Object.create(null) : annotations;
		            this._counter = 0;
		            this._size = 0;
		        }
		        ChangeAnnotations.prototype.all = function () {
		            return this._annotations;
		        };
		        Object.defineProperty(ChangeAnnotations.prototype, "size", {
		            get: function () {
		                return this._size;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
		            var id;
		            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
		                id = idOrAnnotation;
		            }
		            else {
		                id = this.nextId();
		                annotation = idOrAnnotation;
		            }
		            if (this._annotations[id] !== undefined) {
		                throw new Error("Id ".concat(id, " is already in use."));
		            }
		            if (annotation === undefined) {
		                throw new Error("No annotation provided for id ".concat(id));
		            }
		            this._annotations[id] = annotation;
		            this._size++;
		            return id;
		        };
		        ChangeAnnotations.prototype.nextId = function () {
		            this._counter++;
		            return this._counter.toString();
		        };
		        return ChangeAnnotations;
		    }());
		    /**
		     * A workspace change helps constructing changes to a workspace.
		     */
		    var WorkspaceChange = /** @class */ (function () {
		        function WorkspaceChange(workspaceEdit) {
		            var _this = this;
		            this._textEditChanges = Object.create(null);
		            if (workspaceEdit !== undefined) {
		                this._workspaceEdit = workspaceEdit;
		                if (workspaceEdit.documentChanges) {
		                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
		                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();
		                    workspaceEdit.documentChanges.forEach(function (change) {
		                        if (TextDocumentEdit.is(change)) {
		                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
		                            _this._textEditChanges[change.textDocument.uri] = textEditChange;
		                        }
		                    });
		                }
		                else if (workspaceEdit.changes) {
		                    Object.keys(workspaceEdit.changes).forEach(function (key) {
		                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
		                        _this._textEditChanges[key] = textEditChange;
		                    });
		                }
		            }
		            else {
		                this._workspaceEdit = {};
		            }
		        }
		        Object.defineProperty(WorkspaceChange.prototype, "edit", {
		            /**
		             * Returns the underlying {@link WorkspaceEdit} literal
		             * use to be returned from a workspace edit operation like rename.
		             */
		            get: function () {
		                this.initDocumentChanges();
		                if (this._changeAnnotations !== undefined) {
		                    if (this._changeAnnotations.size === 0) {
		                        this._workspaceEdit.changeAnnotations = undefined;
		                    }
		                    else {
		                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
		                    }
		                }
		                return this._workspaceEdit;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        WorkspaceChange.prototype.getTextEditChange = function (key) {
		            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
		                this.initDocumentChanges();
		                if (this._workspaceEdit.documentChanges === undefined) {
		                    throw new Error('Workspace edit is not configured for document changes.');
		                }
		                var textDocument = { uri: key.uri, version: key.version };
		                var result = this._textEditChanges[textDocument.uri];
		                if (!result) {
		                    var edits = [];
		                    var textDocumentEdit = {
		                        textDocument: textDocument,
		                        edits: edits
		                    };
		                    this._workspaceEdit.documentChanges.push(textDocumentEdit);
		                    result = new TextEditChangeImpl(edits, this._changeAnnotations);
		                    this._textEditChanges[textDocument.uri] = result;
		                }
		                return result;
		            }
		            else {
		                this.initChanges();
		                if (this._workspaceEdit.changes === undefined) {
		                    throw new Error('Workspace edit is not configured for normal text edit changes.');
		                }
		                var result = this._textEditChanges[key];
		                if (!result) {
		                    var edits = [];
		                    this._workspaceEdit.changes[key] = edits;
		                    result = new TextEditChangeImpl(edits);
		                    this._textEditChanges[key] = result;
		                }
		                return result;
		            }
		        };
		        WorkspaceChange.prototype.initDocumentChanges = function () {
		            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
		                this._changeAnnotations = new ChangeAnnotations();
		                this._workspaceEdit.documentChanges = [];
		                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
		            }
		        };
		        WorkspaceChange.prototype.initChanges = function () {
		            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
		                this._workspaceEdit.changes = Object.create(null);
		            }
		        };
		        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
		            this.initDocumentChanges();
		            if (this._workspaceEdit.documentChanges === undefined) {
		                throw new Error('Workspace edit is not configured for document changes.');
		            }
		            var annotation;
		            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
		                annotation = optionsOrAnnotation;
		            }
		            else {
		                options = optionsOrAnnotation;
		            }
		            var operation;
		            var id;
		            if (annotation === undefined) {
		                operation = CreateFile.create(uri, options);
		            }
		            else {
		                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
		                operation = CreateFile.create(uri, options, id);
		            }
		            this._workspaceEdit.documentChanges.push(operation);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
		            this.initDocumentChanges();
		            if (this._workspaceEdit.documentChanges === undefined) {
		                throw new Error('Workspace edit is not configured for document changes.');
		            }
		            var annotation;
		            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
		                annotation = optionsOrAnnotation;
		            }
		            else {
		                options = optionsOrAnnotation;
		            }
		            var operation;
		            var id;
		            if (annotation === undefined) {
		                operation = RenameFile.create(oldUri, newUri, options);
		            }
		            else {
		                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
		                operation = RenameFile.create(oldUri, newUri, options, id);
		            }
		            this._workspaceEdit.documentChanges.push(operation);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
		            this.initDocumentChanges();
		            if (this._workspaceEdit.documentChanges === undefined) {
		                throw new Error('Workspace edit is not configured for document changes.');
		            }
		            var annotation;
		            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
		                annotation = optionsOrAnnotation;
		            }
		            else {
		                options = optionsOrAnnotation;
		            }
		            var operation;
		            var id;
		            if (annotation === undefined) {
		                operation = DeleteFile.create(uri, options);
		            }
		            else {
		                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
		                operation = DeleteFile.create(uri, options, id);
		            }
		            this._workspaceEdit.documentChanges.push(operation);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        return WorkspaceChange;
		    }());
		    exports.WorkspaceChange = WorkspaceChange;
		    /**
		     * The TextDocumentIdentifier namespace provides helper functions to work with
		     * {@link TextDocumentIdentifier} literals.
		     */
		    var TextDocumentIdentifier;
		    (function (TextDocumentIdentifier) {
		        /**
		         * Creates a new TextDocumentIdentifier literal.
		         * @param uri The document's uri.
		         */
		        function create(uri) {
		            return { uri: uri };
		        }
		        TextDocumentIdentifier.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri);
		        }
		        TextDocumentIdentifier.is = is;
		    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));
		    /**
		     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
		     * {@link VersionedTextDocumentIdentifier} literals.
		     */
		    var VersionedTextDocumentIdentifier;
		    (function (VersionedTextDocumentIdentifier) {
		        /**
		         * Creates a new VersionedTextDocumentIdentifier literal.
		         * @param uri The document's uri.
		         * @param version The document's version.
		         */
		        function create(uri, version) {
		            return { uri: uri, version: version };
		        }
		        VersionedTextDocumentIdentifier.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
		        }
		        VersionedTextDocumentIdentifier.is = is;
		    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
		    /**
		     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
		     * {@link OptionalVersionedTextDocumentIdentifier} literals.
		     */
		    var OptionalVersionedTextDocumentIdentifier;
		    (function (OptionalVersionedTextDocumentIdentifier) {
		        /**
		         * Creates a new OptionalVersionedTextDocumentIdentifier literal.
		         * @param uri The document's uri.
		         * @param version The document's version.
		         */
		        function create(uri, version) {
		            return { uri: uri, version: version };
		        }
		        OptionalVersionedTextDocumentIdentifier.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
		        }
		        OptionalVersionedTextDocumentIdentifier.is = is;
		    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
		    /**
		     * The TextDocumentItem namespace provides helper functions to work with
		     * {@link TextDocumentItem} literals.
		     */
		    var TextDocumentItem;
		    (function (TextDocumentItem) {
		        /**
		         * Creates a new TextDocumentItem literal.
		         * @param uri The document's uri.
		         * @param languageId The document's language identifier.
		         * @param version The document's version number.
		         * @param text The document's text.
		         */
		        function create(uri, languageId, version, text) {
		            return { uri: uri, languageId: languageId, version: version, text: text };
		        }
		        TextDocumentItem.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
		        }
		        TextDocumentItem.is = is;
		    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));
		    /**
		     * Describes the content type that a client supports in various
		     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
		     *
		     * Please note that `MarkupKinds` must not start with a `$`. This kinds
		     * are reserved for internal usage.
		     */
		    var MarkupKind;
		    (function (MarkupKind) {
		        /**
		         * Plain text is supported as a content format
		         */
		        MarkupKind.PlainText = 'plaintext';
		        /**
		         * Markdown is supported as a content format
		         */
		        MarkupKind.Markdown = 'markdown';
		        /**
		         * Checks whether the given value is a value of the {@link MarkupKind} type.
		         */
		        function is(value) {
		            var candidate = value;
		            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
		        }
		        MarkupKind.is = is;
		    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));
		    var MarkupContent;
		    (function (MarkupContent) {
		        /**
		         * Checks whether the given value conforms to the {@link MarkupContent} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
		        }
		        MarkupContent.is = is;
		    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));
		    /**
		     * The kind of a completion entry.
		     */
		    var CompletionItemKind;
		    (function (CompletionItemKind) {
		        CompletionItemKind.Text = 1;
		        CompletionItemKind.Method = 2;
		        CompletionItemKind.Function = 3;
		        CompletionItemKind.Constructor = 4;
		        CompletionItemKind.Field = 5;
		        CompletionItemKind.Variable = 6;
		        CompletionItemKind.Class = 7;
		        CompletionItemKind.Interface = 8;
		        CompletionItemKind.Module = 9;
		        CompletionItemKind.Property = 10;
		        CompletionItemKind.Unit = 11;
		        CompletionItemKind.Value = 12;
		        CompletionItemKind.Enum = 13;
		        CompletionItemKind.Keyword = 14;
		        CompletionItemKind.Snippet = 15;
		        CompletionItemKind.Color = 16;
		        CompletionItemKind.File = 17;
		        CompletionItemKind.Reference = 18;
		        CompletionItemKind.Folder = 19;
		        CompletionItemKind.EnumMember = 20;
		        CompletionItemKind.Constant = 21;
		        CompletionItemKind.Struct = 22;
		        CompletionItemKind.Event = 23;
		        CompletionItemKind.Operator = 24;
		        CompletionItemKind.TypeParameter = 25;
		    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
		    /**
		     * Defines whether the insert text in a completion item should be interpreted as
		     * plain text or a snippet.
		     */
		    var InsertTextFormat;
		    (function (InsertTextFormat) {
		        /**
		         * The primary text to be inserted is treated as a plain string.
		         */
		        InsertTextFormat.PlainText = 1;
		        /**
		         * The primary text to be inserted is treated as a snippet.
		         *
		         * A snippet can define tab stops and placeholders with `$1`, `$2`
		         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
		         * the end of the snippet. Placeholders with equal identifiers are linked,
		         * that is typing in one will update others too.
		         *
		         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
		         */
		        InsertTextFormat.Snippet = 2;
		    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));
		    /**
		     * Completion item tags are extra annotations that tweak the rendering of a completion
		     * item.
		     *
		     * @since 3.15.0
		     */
		    var CompletionItemTag;
		    (function (CompletionItemTag) {
		        /**
		         * Render a completion as obsolete, usually using a strike-out.
		         */
		        CompletionItemTag.Deprecated = 1;
		    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));
		    /**
		     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
		     *
		     * @since 3.16.0
		     */
		    var InsertReplaceEdit;
		    (function (InsertReplaceEdit) {
		        /**
		         * Creates a new insert / replace edit
		         */
		        function create(newText, insert, replace) {
		            return { newText: newText, insert: insert, replace: replace };
		        }
		        InsertReplaceEdit.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
		        }
		        InsertReplaceEdit.is = is;
		    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));
		    /**
		     * How whitespace and indentation is handled during completion
		     * item insertion.
		     *
		     * @since 3.16.0
		     */
		    var InsertTextMode;
		    (function (InsertTextMode) {
		        /**
		         * The insertion or replace strings is taken as it is. If the
		         * value is multi line the lines below the cursor will be
		         * inserted using the indentation defined in the string value.
		         * The client will not apply any kind of adjustments to the
		         * string.
		         */
		        InsertTextMode.asIs = 1;
		        /**
		         * The editor adjusts leading whitespace of new lines so that
		         * they match the indentation up to the cursor of the line for
		         * which the item is accepted.
		         *
		         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
		         * multi line completion item is indented using 2 tabs and all
		         * following lines inserted will be indented using 2 tabs as well.
		         */
		        InsertTextMode.adjustIndentation = 2;
		    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));
		    var CompletionItemLabelDetails;
		    (function (CompletionItemLabelDetails) {
		        function is(value) {
		            var candidate = value;
		            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
		                (Is.string(candidate.description) || candidate.description === undefined);
		        }
		        CompletionItemLabelDetails.is = is;
		    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
		    /**
		     * The CompletionItem namespace provides functions to deal with
		     * completion items.
		     */
		    var CompletionItem;
		    (function (CompletionItem) {
		        /**
		         * Create a completion item and seed it with a label.
		         * @param label The completion item's label
		         */
		        function create(label) {
		            return { label: label };
		        }
		        CompletionItem.create = create;
		    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));
		    /**
		     * The CompletionList namespace provides functions to deal with
		     * completion lists.
		     */
		    var CompletionList;
		    (function (CompletionList) {
		        /**
		         * Creates a new completion list.
		         *
		         * @param items The completion items.
		         * @param isIncomplete The list is not complete.
		         */
		        function create(items, isIncomplete) {
		            return { items: items ? items : [], isIncomplete: !!isIncomplete };
		        }
		        CompletionList.create = create;
		    })(CompletionList || (exports.CompletionList = CompletionList = {}));
		    var MarkedString;
		    (function (MarkedString) {
		        /**
		         * Creates a marked string from plain text.
		         *
		         * @param plainText The plain text.
		         */
		        function fromPlainText(plainText) {
		            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
		        }
		        MarkedString.fromPlainText = fromPlainText;
		        /**
		         * Checks whether the given value conforms to the {@link MarkedString} type.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
		        }
		        MarkedString.is = is;
		    })(MarkedString || (exports.MarkedString = MarkedString = {}));
		    var Hover;
		    (function (Hover) {
		        /**
		         * Checks whether the given value conforms to the {@link Hover} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
		                MarkedString.is(candidate.contents) ||
		                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
		        }
		        Hover.is = is;
		    })(Hover || (exports.Hover = Hover = {}));
		    /**
		     * The ParameterInformation namespace provides helper functions to work with
		     * {@link ParameterInformation} literals.
		     */
		    var ParameterInformation;
		    (function (ParameterInformation) {
		        /**
		         * Creates a new parameter information literal.
		         *
		         * @param label A label string.
		         * @param documentation A doc string.
		         */
		        function create(label, documentation) {
		            return documentation ? { label: label, documentation: documentation } : { label: label };
		        }
		        ParameterInformation.create = create;
		    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));
		    /**
		     * The SignatureInformation namespace provides helper functions to work with
		     * {@link SignatureInformation} literals.
		     */
		    var SignatureInformation;
		    (function (SignatureInformation) {
		        function create(label, documentation) {
		            var parameters = [];
		            for (var _i = 2; _i < arguments.length; _i++) {
		                parameters[_i - 2] = arguments[_i];
		            }
		            var result = { label: label };
		            if (Is.defined(documentation)) {
		                result.documentation = documentation;
		            }
		            if (Is.defined(parameters)) {
		                result.parameters = parameters;
		            }
		            else {
		                result.parameters = [];
		            }
		            return result;
		        }
		        SignatureInformation.create = create;
		    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));
		    /**
		     * A document highlight kind.
		     */
		    var DocumentHighlightKind;
		    (function (DocumentHighlightKind) {
		        /**
		         * A textual occurrence.
		         */
		        DocumentHighlightKind.Text = 1;
		        /**
		         * Read-access of a symbol, like reading a variable.
		         */
		        DocumentHighlightKind.Read = 2;
		        /**
		         * Write-access of a symbol, like writing to a variable.
		         */
		        DocumentHighlightKind.Write = 3;
		    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));
		    /**
		     * DocumentHighlight namespace to provide helper functions to work with
		     * {@link DocumentHighlight} literals.
		     */
		    var DocumentHighlight;
		    (function (DocumentHighlight) {
		        /**
		         * Create a DocumentHighlight object.
		         * @param range The range the highlight applies to.
		         * @param kind The highlight kind
		         */
		        function create(range, kind) {
		            var result = { range: range };
		            if (Is.number(kind)) {
		                result.kind = kind;
		            }
		            return result;
		        }
		        DocumentHighlight.create = create;
		    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));
		    /**
		     * A symbol kind.
		     */
		    var SymbolKind;
		    (function (SymbolKind) {
		        SymbolKind.File = 1;
		        SymbolKind.Module = 2;
		        SymbolKind.Namespace = 3;
		        SymbolKind.Package = 4;
		        SymbolKind.Class = 5;
		        SymbolKind.Method = 6;
		        SymbolKind.Property = 7;
		        SymbolKind.Field = 8;
		        SymbolKind.Constructor = 9;
		        SymbolKind.Enum = 10;
		        SymbolKind.Interface = 11;
		        SymbolKind.Function = 12;
		        SymbolKind.Variable = 13;
		        SymbolKind.Constant = 14;
		        SymbolKind.String = 15;
		        SymbolKind.Number = 16;
		        SymbolKind.Boolean = 17;
		        SymbolKind.Array = 18;
		        SymbolKind.Object = 19;
		        SymbolKind.Key = 20;
		        SymbolKind.Null = 21;
		        SymbolKind.EnumMember = 22;
		        SymbolKind.Struct = 23;
		        SymbolKind.Event = 24;
		        SymbolKind.Operator = 25;
		        SymbolKind.TypeParameter = 26;
		    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
		    /**
		     * Symbol tags are extra annotations that tweak the rendering of a symbol.
		     *
		     * @since 3.16
		     */
		    var SymbolTag;
		    (function (SymbolTag) {
		        /**
		         * Render a symbol as obsolete, usually using a strike-out.
		         */
		        SymbolTag.Deprecated = 1;
		    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
		    var SymbolInformation;
		    (function (SymbolInformation) {
		        /**
		         * Creates a new symbol information literal.
		         *
		         * @param name The name of the symbol.
		         * @param kind The kind of the symbol.
		         * @param range The range of the location of the symbol.
		         * @param uri The resource of the location of symbol.
		         * @param containerName The name of the symbol containing the symbol.
		         */
		        function create(name, kind, range, uri, containerName) {
		            var result = {
		                name: name,
		                kind: kind,
		                location: { uri: uri, range: range }
		            };
		            if (containerName) {
		                result.containerName = containerName;
		            }
		            return result;
		        }
		        SymbolInformation.create = create;
		    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));
		    var WorkspaceSymbol;
		    (function (WorkspaceSymbol) {
		        /**
		         * Create a new workspace symbol.
		         *
		         * @param name The name of the symbol.
		         * @param kind The kind of the symbol.
		         * @param uri The resource of the location of the symbol.
		         * @param range An options range of the location.
		         * @returns A WorkspaceSymbol.
		         */
		        function create(name, kind, uri, range) {
		            return range !== undefined
		                ? { name: name, kind: kind, location: { uri: uri, range: range } }
		                : { name: name, kind: kind, location: { uri: uri } };
		        }
		        WorkspaceSymbol.create = create;
		    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));
		    var DocumentSymbol;
		    (function (DocumentSymbol) {
		        /**
		         * Creates a new symbol information literal.
		         *
		         * @param name The name of the symbol.
		         * @param detail The detail of the symbol.
		         * @param kind The kind of the symbol.
		         * @param range The range of the symbol.
		         * @param selectionRange The selectionRange of the symbol.
		         * @param children Children of the symbol.
		         */
		        function create(name, detail, kind, range, selectionRange, children) {
		            var result = {
		                name: name,
		                detail: detail,
		                kind: kind,
		                range: range,
		                selectionRange: selectionRange
		            };
		            if (children !== undefined) {
		                result.children = children;
		            }
		            return result;
		        }
		        DocumentSymbol.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return candidate &&
		                Is.string(candidate.name) && Is.number(candidate.kind) &&
		                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
		                (candidate.detail === undefined || Is.string(candidate.detail)) &&
		                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
		                (candidate.children === undefined || Array.isArray(candidate.children)) &&
		                (candidate.tags === undefined || Array.isArray(candidate.tags));
		        }
		        DocumentSymbol.is = is;
		    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));
		    /**
		     * A set of predefined code action kinds
		     */
		    var CodeActionKind;
		    (function (CodeActionKind) {
		        /**
		         * Empty kind.
		         */
		        CodeActionKind.Empty = '';
		        /**
		         * Base kind for quickfix actions: 'quickfix'
		         */
		        CodeActionKind.QuickFix = 'quickfix';
		        /**
		         * Base kind for refactoring actions: 'refactor'
		         */
		        CodeActionKind.Refactor = 'refactor';
		        /**
		         * Base kind for refactoring extraction actions: 'refactor.extract'
		         *
		         * Example extract actions:
		         *
		         * - Extract method
		         * - Extract function
		         * - Extract variable
		         * - Extract interface from class
		         * - ...
		         */
		        CodeActionKind.RefactorExtract = 'refactor.extract';
		        /**
		         * Base kind for refactoring inline actions: 'refactor.inline'
		         *
		         * Example inline actions:
		         *
		         * - Inline function
		         * - Inline variable
		         * - Inline constant
		         * - ...
		         */
		        CodeActionKind.RefactorInline = 'refactor.inline';
		        /**
		         * Base kind for refactoring rewrite actions: 'refactor.rewrite'
		         *
		         * Example rewrite actions:
		         *
		         * - Convert JavaScript function to class
		         * - Add or remove parameter
		         * - Encapsulate field
		         * - Make method static
		         * - Move method to base class
		         * - ...
		         */
		        CodeActionKind.RefactorRewrite = 'refactor.rewrite';
		        /**
		         * Base kind for source actions: `source`
		         *
		         * Source code actions apply to the entire file.
		         */
		        CodeActionKind.Source = 'source';
		        /**
		         * Base kind for an organize imports source action: `source.organizeImports`
		         */
		        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
		        /**
		         * Base kind for auto-fix source actions: `source.fixAll`.
		         *
		         * Fix all actions automatically fix errors that have a clear fix that do not require user input.
		         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
		         *
		         * @since 3.15.0
		         */
		        CodeActionKind.SourceFixAll = 'source.fixAll';
		    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));
		    /**
		     * The reason why code actions were requested.
		     *
		     * @since 3.17.0
		     */
		    var CodeActionTriggerKind;
		    (function (CodeActionTriggerKind) {
		        /**
		         * Code actions were explicitly requested by the user or by an extension.
		         */
		        CodeActionTriggerKind.Invoked = 1;
		        /**
		         * Code actions were requested automatically.
		         *
		         * This typically happens when current selection in a file changes, but can
		         * also be triggered when file content changes.
		         */
		        CodeActionTriggerKind.Automatic = 2;
		    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
		    /**
		     * The CodeActionContext namespace provides helper functions to work with
		     * {@link CodeActionContext} literals.
		     */
		    var CodeActionContext;
		    (function (CodeActionContext) {
		        /**
		         * Creates a new CodeActionContext literal.
		         */
		        function create(diagnostics, only, triggerKind) {
		            var result = { diagnostics: diagnostics };
		            if (only !== undefined && only !== null) {
		                result.only = only;
		            }
		            if (triggerKind !== undefined && triggerKind !== null) {
		                result.triggerKind = triggerKind;
		            }
		            return result;
		        }
		        CodeActionContext.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
		                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
		                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
		        }
		        CodeActionContext.is = is;
		    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));
		    var CodeAction;
		    (function (CodeAction) {
		        function create(title, kindOrCommandOrEdit, kind) {
		            var result = { title: title };
		            var checkKind = true;
		            if (typeof kindOrCommandOrEdit === 'string') {
		                checkKind = false;
		                result.kind = kindOrCommandOrEdit;
		            }
		            else if (Command.is(kindOrCommandOrEdit)) {
		                result.command = kindOrCommandOrEdit;
		            }
		            else {
		                result.edit = kindOrCommandOrEdit;
		            }
		            if (checkKind && kind !== undefined) {
		                result.kind = kind;
		            }
		            return result;
		        }
		        CodeAction.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && Is.string(candidate.title) &&
		                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
		                (candidate.kind === undefined || Is.string(candidate.kind)) &&
		                (candidate.edit !== undefined || candidate.command !== undefined) &&
		                (candidate.command === undefined || Command.is(candidate.command)) &&
		                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
		                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
		        }
		        CodeAction.is = is;
		    })(CodeAction || (exports.CodeAction = CodeAction = {}));
		    /**
		     * The CodeLens namespace provides helper functions to work with
		     * {@link CodeLens} literals.
		     */
		    var CodeLens;
		    (function (CodeLens) {
		        /**
		         * Creates a new CodeLens literal.
		         */
		        function create(range, data) {
		            var result = { range: range };
		            if (Is.defined(data)) {
		                result.data = data;
		            }
		            return result;
		        }
		        CodeLens.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link CodeLens} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
		        }
		        CodeLens.is = is;
		    })(CodeLens || (exports.CodeLens = CodeLens = {}));
		    /**
		     * The FormattingOptions namespace provides helper functions to work with
		     * {@link FormattingOptions} literals.
		     */
		    var FormattingOptions;
		    (function (FormattingOptions) {
		        /**
		         * Creates a new FormattingOptions literal.
		         */
		        function create(tabSize, insertSpaces) {
		            return { tabSize: tabSize, insertSpaces: insertSpaces };
		        }
		        FormattingOptions.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
		        }
		        FormattingOptions.is = is;
		    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));
		    /**
		     * The DocumentLink namespace provides helper functions to work with
		     * {@link DocumentLink} literals.
		     */
		    var DocumentLink;
		    (function (DocumentLink) {
		        /**
		         * Creates a new DocumentLink literal.
		         */
		        function create(range, target, data) {
		            return { range: range, target: target, data: data };
		        }
		        DocumentLink.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link DocumentLink} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
		        }
		        DocumentLink.is = is;
		    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));
		    /**
		     * The SelectionRange namespace provides helper function to work with
		     * SelectionRange literals.
		     */
		    var SelectionRange;
		    (function (SelectionRange) {
		        /**
		         * Creates a new SelectionRange
		         * @param range the range.
		         * @param parent an optional parent.
		         */
		        function create(range, parent) {
		            return { range: range, parent: parent };
		        }
		        SelectionRange.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
		        }
		        SelectionRange.is = is;
		    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));
		    /**
		     * A set of predefined token types. This set is not fixed
		     * an clients can specify additional token types via the
		     * corresponding client capabilities.
		     *
		     * @since 3.16.0
		     */
		    var SemanticTokenTypes;
		    (function (SemanticTokenTypes) {
		        SemanticTokenTypes["namespace"] = "namespace";
		        /**
		         * Represents a generic type. Acts as a fallback for types which can't be mapped to
		         * a specific type like class or enum.
		         */
		        SemanticTokenTypes["type"] = "type";
		        SemanticTokenTypes["class"] = "class";
		        SemanticTokenTypes["enum"] = "enum";
		        SemanticTokenTypes["interface"] = "interface";
		        SemanticTokenTypes["struct"] = "struct";
		        SemanticTokenTypes["typeParameter"] = "typeParameter";
		        SemanticTokenTypes["parameter"] = "parameter";
		        SemanticTokenTypes["variable"] = "variable";
		        SemanticTokenTypes["property"] = "property";
		        SemanticTokenTypes["enumMember"] = "enumMember";
		        SemanticTokenTypes["event"] = "event";
		        SemanticTokenTypes["function"] = "function";
		        SemanticTokenTypes["method"] = "method";
		        SemanticTokenTypes["macro"] = "macro";
		        SemanticTokenTypes["keyword"] = "keyword";
		        SemanticTokenTypes["modifier"] = "modifier";
		        SemanticTokenTypes["comment"] = "comment";
		        SemanticTokenTypes["string"] = "string";
		        SemanticTokenTypes["number"] = "number";
		        SemanticTokenTypes["regexp"] = "regexp";
		        SemanticTokenTypes["operator"] = "operator";
		        /**
		         * @since 3.17.0
		         */
		        SemanticTokenTypes["decorator"] = "decorator";
		    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));
		    /**
		     * A set of predefined token modifiers. This set is not fixed
		     * an clients can specify additional token types via the
		     * corresponding client capabilities.
		     *
		     * @since 3.16.0
		     */
		    var SemanticTokenModifiers;
		    (function (SemanticTokenModifiers) {
		        SemanticTokenModifiers["declaration"] = "declaration";
		        SemanticTokenModifiers["definition"] = "definition";
		        SemanticTokenModifiers["readonly"] = "readonly";
		        SemanticTokenModifiers["static"] = "static";
		        SemanticTokenModifiers["deprecated"] = "deprecated";
		        SemanticTokenModifiers["abstract"] = "abstract";
		        SemanticTokenModifiers["async"] = "async";
		        SemanticTokenModifiers["modification"] = "modification";
		        SemanticTokenModifiers["documentation"] = "documentation";
		        SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
		    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));
		    /**
		     * @since 3.16.0
		     */
		    var SemanticTokens;
		    (function (SemanticTokens) {
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
		                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
		        }
		        SemanticTokens.is = is;
		    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));
		    /**
		     * The InlineValueText namespace provides functions to deal with InlineValueTexts.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueText;
		    (function (InlineValueText) {
		        /**
		         * Creates a new InlineValueText literal.
		         */
		        function create(range, text) {
		            return { range: range, text: text };
		        }
		        InlineValueText.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
		        }
		        InlineValueText.is = is;
		    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));
		    /**
		     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueVariableLookup;
		    (function (InlineValueVariableLookup) {
		        /**
		         * Creates a new InlineValueText literal.
		         */
		        function create(range, variableName, caseSensitiveLookup) {
		            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
		        }
		        InlineValueVariableLookup.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
		                && (Is.string(candidate.variableName) || candidate.variableName === undefined);
		        }
		        InlineValueVariableLookup.is = is;
		    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));
		    /**
		     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueEvaluatableExpression;
		    (function (InlineValueEvaluatableExpression) {
		        /**
		         * Creates a new InlineValueEvaluatableExpression literal.
		         */
		        function create(range, expression) {
		            return { range: range, expression: expression };
		        }
		        InlineValueEvaluatableExpression.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate !== undefined && candidate !== null && Range.is(candidate.range)
		                && (Is.string(candidate.expression) || candidate.expression === undefined);
		        }
		        InlineValueEvaluatableExpression.is = is;
		    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
		    /**
		     * The InlineValueContext namespace provides helper functions to work with
		     * {@link InlineValueContext} literals.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueContext;
		    (function (InlineValueContext) {
		        /**
		         * Creates a new InlineValueContext literal.
		         */
		        function create(frameId, stoppedLocation) {
		            return { frameId: frameId, stoppedLocation: stoppedLocation };
		        }
		        InlineValueContext.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Range.is(value.stoppedLocation);
		        }
		        InlineValueContext.is = is;
		    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));
		    /**
		     * Inlay hint kinds.
		     *
		     * @since 3.17.0
		     */
		    var InlayHintKind;
		    (function (InlayHintKind) {
		        /**
		         * An inlay hint that for a type annotation.
		         */
		        InlayHintKind.Type = 1;
		        /**
		         * An inlay hint that is for a parameter.
		         */
		        InlayHintKind.Parameter = 2;
		        function is(value) {
		            return value === 1 || value === 2;
		        }
		        InlayHintKind.is = is;
		    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
		    var InlayHintLabelPart;
		    (function (InlayHintLabelPart) {
		        function create(value) {
		            return { value: value };
		        }
		        InlayHintLabelPart.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate)
		                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
		                && (candidate.location === undefined || Location.is(candidate.location))
		                && (candidate.command === undefined || Command.is(candidate.command));
		        }
		        InlayHintLabelPart.is = is;
		    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));
		    var InlayHint;
		    (function (InlayHint) {
		        function create(position, label, kind) {
		            var result = { position: position, label: label };
		            if (kind !== undefined) {
		                result.kind = kind;
		            }
		            return result;
		        }
		        InlayHint.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Position.is(candidate.position)
		                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
		                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
		                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
		                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
		                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
		                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
		        }
		        InlayHint.is = is;
		    })(InlayHint || (exports.InlayHint = InlayHint = {}));
		    var StringValue;
		    (function (StringValue) {
		        function createSnippet(value) {
		            return { kind: 'snippet', value: value };
		        }
		        StringValue.createSnippet = createSnippet;
		    })(StringValue || (exports.StringValue = StringValue = {}));
		    var InlineCompletionItem;
		    (function (InlineCompletionItem) {
		        function create(insertText, filterText, range, command) {
		            return { insertText: insertText, filterText: filterText, range: range, command: command };
		        }
		        InlineCompletionItem.create = create;
		    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));
		    var InlineCompletionList;
		    (function (InlineCompletionList) {
		        function create(items) {
		            return { items: items };
		        }
		        InlineCompletionList.create = create;
		    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));
		    /**
		     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
		     *
		     * @since 3.18.0
		     * @proposed
		     */
		    var InlineCompletionTriggerKind;
		    (function (InlineCompletionTriggerKind) {
		        /**
		         * Completion was triggered explicitly by a user gesture.
		         */
		        InlineCompletionTriggerKind.Invoked = 0;
		        /**
		         * Completion was triggered automatically while editing.
		         */
		        InlineCompletionTriggerKind.Automatic = 1;
		    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
		    var SelectedCompletionInfo;
		    (function (SelectedCompletionInfo) {
		        function create(range, text) {
		            return { range: range, text: text };
		        }
		        SelectedCompletionInfo.create = create;
		    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));
		    var InlineCompletionContext;
		    (function (InlineCompletionContext) {
		        function create(triggerKind, selectedCompletionInfo) {
		            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };
		        }
		        InlineCompletionContext.create = create;
		    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));
		    var WorkspaceFolder;
		    (function (WorkspaceFolder) {
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
		        }
		        WorkspaceFolder.is = is;
		    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));
		    exports.EOL = ['\n', '\r\n', '\r'];
		    /**
		     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
		     */
		    var TextDocument;
		    (function (TextDocument) {
		        /**
		         * Creates a new ITextDocument literal from the given uri and content.
		         * @param uri The document's uri.
		         * @param languageId The document's language Id.
		         * @param version The document's version.
		         * @param content The document's content.
		         */
		        function create(uri, languageId, version, content) {
		            return new FullTextDocument(uri, languageId, version, content);
		        }
		        TextDocument.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link ITextDocument} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
		                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
		        }
		        TextDocument.is = is;
		        function applyEdits(document, edits) {
		            var text = document.getText();
		            var sortedEdits = mergeSort(edits, function (a, b) {
		                var diff = a.range.start.line - b.range.start.line;
		                if (diff === 0) {
		                    return a.range.start.character - b.range.start.character;
		                }
		                return diff;
		            });
		            var lastModifiedOffset = text.length;
		            for (var i = sortedEdits.length - 1; i >= 0; i--) {
		                var e = sortedEdits[i];
		                var startOffset = document.offsetAt(e.range.start);
		                var endOffset = document.offsetAt(e.range.end);
		                if (endOffset <= lastModifiedOffset) {
		                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
		                }
		                else {
		                    throw new Error('Overlapping edit');
		                }
		                lastModifiedOffset = startOffset;
		            }
		            return text;
		        }
		        TextDocument.applyEdits = applyEdits;
		        function mergeSort(data, compare) {
		            if (data.length <= 1) {
		                // sorted
		                return data;
		            }
		            var p = (data.length / 2) | 0;
		            var left = data.slice(0, p);
		            var right = data.slice(p);
		            mergeSort(left, compare);
		            mergeSort(right, compare);
		            var leftIdx = 0;
		            var rightIdx = 0;
		            var i = 0;
		            while (leftIdx < left.length && rightIdx < right.length) {
		                var ret = compare(left[leftIdx], right[rightIdx]);
		                if (ret <= 0) {
		                    // smaller_equal -> take left to preserve order
		                    data[i++] = left[leftIdx++];
		                }
		                else {
		                    // greater -> take right
		                    data[i++] = right[rightIdx++];
		                }
		            }
		            while (leftIdx < left.length) {
		                data[i++] = left[leftIdx++];
		            }
		            while (rightIdx < right.length) {
		                data[i++] = right[rightIdx++];
		            }
		            return data;
		        }
		    })(TextDocument || (exports.TextDocument = TextDocument = {}));
		    /**
		     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
		     */
		    var FullTextDocument = /** @class */ (function () {
		        function FullTextDocument(uri, languageId, version, content) {
		            this._uri = uri;
		            this._languageId = languageId;
		            this._version = version;
		            this._content = content;
		            this._lineOffsets = undefined;
		        }
		        Object.defineProperty(FullTextDocument.prototype, "uri", {
		            get: function () {
		                return this._uri;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        Object.defineProperty(FullTextDocument.prototype, "languageId", {
		            get: function () {
		                return this._languageId;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        Object.defineProperty(FullTextDocument.prototype, "version", {
		            get: function () {
		                return this._version;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        FullTextDocument.prototype.getText = function (range) {
		            if (range) {
		                var start = this.offsetAt(range.start);
		                var end = this.offsetAt(range.end);
		                return this._content.substring(start, end);
		            }
		            return this._content;
		        };
		        FullTextDocument.prototype.update = function (event, version) {
		            this._content = event.text;
		            this._version = version;
		            this._lineOffsets = undefined;
		        };
		        FullTextDocument.prototype.getLineOffsets = function () {
		            if (this._lineOffsets === undefined) {
		                var lineOffsets = [];
		                var text = this._content;
		                var isLineStart = true;
		                for (var i = 0; i < text.length; i++) {
		                    if (isLineStart) {
		                        lineOffsets.push(i);
		                        isLineStart = false;
		                    }
		                    var ch = text.charAt(i);
		                    isLineStart = (ch === '\r' || ch === '\n');
		                    if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
		                        i++;
		                    }
		                }
		                if (isLineStart && text.length > 0) {
		                    lineOffsets.push(text.length);
		                }
		                this._lineOffsets = lineOffsets;
		            }
		            return this._lineOffsets;
		        };
		        FullTextDocument.prototype.positionAt = function (offset) {
		            offset = Math.max(Math.min(offset, this._content.length), 0);
		            var lineOffsets = this.getLineOffsets();
		            var low = 0, high = lineOffsets.length;
		            if (high === 0) {
		                return Position.create(0, offset);
		            }
		            while (low < high) {
		                var mid = Math.floor((low + high) / 2);
		                if (lineOffsets[mid] > offset) {
		                    high = mid;
		                }
		                else {
		                    low = mid + 1;
		                }
		            }
		            // low is the least x for which the line offset is larger than the current offset
		            // or array.length if no line offset is larger than the current offset
		            var line = low - 1;
		            return Position.create(line, offset - lineOffsets[line]);
		        };
		        FullTextDocument.prototype.offsetAt = function (position) {
		            var lineOffsets = this.getLineOffsets();
		            if (position.line >= lineOffsets.length) {
		                return this._content.length;
		            }
		            else if (position.line < 0) {
		                return 0;
		            }
		            var lineOffset = lineOffsets[position.line];
		            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
		            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
		        };
		        Object.defineProperty(FullTextDocument.prototype, "lineCount", {
		            get: function () {
		                return this.getLineOffsets().length;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        return FullTextDocument;
		    }());
		    var Is;
		    (function (Is) {
		        var toString = Object.prototype.toString;
		        function defined(value) {
		            return typeof value !== 'undefined';
		        }
		        Is.defined = defined;
		        function undefined$1(value) {
		            return typeof value === 'undefined';
		        }
		        Is.undefined = undefined$1;
		        function boolean(value) {
		            return value === true || value === false;
		        }
		        Is.boolean = boolean;
		        function string(value) {
		            return toString.call(value) === '[object String]';
		        }
		        Is.string = string;
		        function number(value) {
		            return toString.call(value) === '[object Number]';
		        }
		        Is.number = number;
		        function numberRange(value, min, max) {
		            return toString.call(value) === '[object Number]' && min <= value && value <= max;
		        }
		        Is.numberRange = numberRange;
		        function integer(value) {
		            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
		        }
		        Is.integer = integer;
		        function uinteger(value) {
		            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
		        }
		        Is.uinteger = uinteger;
		        function func(value) {
		            return toString.call(value) === '[object Function]';
		        }
		        Is.func = func;
		        function objectLiteral(value) {
		            // Strictly speaking class instances pass this check as well. Since the LSP
		            // doesn't use classes we ignore this for now. If we do we need to add something
		            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
		            return value !== null && typeof value === 'object';
		        }
		        Is.objectLiteral = objectLiteral;
		        function typedArray(value, check) {
		            return Array.isArray(value) && value.every(check);
		        }
		        Is.typedArray = typedArray;
		    })(Is || (Is = {}));
		}); 
	} (main, main.exports));
	return main.exports;
}

var messages = {};

var hasRequiredMessages;

function requireMessages () {
	if (hasRequiredMessages) return messages;
	hasRequiredMessages = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messages, "__esModule", { value: true });
	messages.ProtocolNotificationType = messages.ProtocolNotificationType0 = messages.ProtocolRequestType = messages.ProtocolRequestType0 = messages.RegistrationType = messages.MessageDirection = void 0;
	const vscode_jsonrpc_1 = requireMain$3();
	var MessageDirection;
	(function (MessageDirection) {
	    MessageDirection["clientToServer"] = "clientToServer";
	    MessageDirection["serverToClient"] = "serverToClient";
	    MessageDirection["both"] = "both";
	})(MessageDirection || (messages.MessageDirection = MessageDirection = {}));
	class RegistrationType {
	    constructor(method) {
	        this.method = method;
	    }
	}
	messages.RegistrationType = RegistrationType;
	class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
	    constructor(method) {
	        super(method);
	    }
	}
	messages.ProtocolRequestType0 = ProtocolRequestType0;
	class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
	    constructor(method) {
	        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
	    }
	}
	messages.ProtocolRequestType = ProtocolRequestType;
	class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
	    constructor(method) {
	        super(method);
	    }
	}
	messages.ProtocolNotificationType0 = ProtocolNotificationType0;
	class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
	    constructor(method) {
	        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
	    }
	}
	messages.ProtocolNotificationType = ProtocolNotificationType;
	return messages;
}

var protocol = {};

var is = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredIs;

function requireIs () {
	if (hasRequiredIs) return is;
	hasRequiredIs = 1;
	Object.defineProperty(is, "__esModule", { value: true });
	is.objectLiteral = is.typedArray = is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is.stringArray = stringArray;
	function typedArray(value, check) {
	    return Array.isArray(value) && value.every(check);
	}
	is.typedArray = typedArray;
	function objectLiteral(value) {
	    // Strictly speaking class instances pass this check as well. Since the LSP
	    // doesn't use classes we ignore this for now. If we do we need to add something
	    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
	    return value !== null && typeof value === 'object';
	}
	is.objectLiteral = objectLiteral;
	return is;
}

var protocol_implementation = {};

var hasRequiredProtocol_implementation;

function requireProtocol_implementation () {
	if (hasRequiredProtocol_implementation) return protocol_implementation;
	hasRequiredProtocol_implementation = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_implementation, "__esModule", { value: true });
	protocol_implementation.ImplementationRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to resolve the implementation locations of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
	 * the response is of type {@link Definition} or a Thenable that resolves to such.
	 */
	var ImplementationRequest;
	(function (ImplementationRequest) {
	    ImplementationRequest.method = 'textDocument/implementation';
	    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
	})(ImplementationRequest || (protocol_implementation.ImplementationRequest = ImplementationRequest = {}));
	return protocol_implementation;
}

var protocol_typeDefinition = {};

var hasRequiredProtocol_typeDefinition;

function requireProtocol_typeDefinition () {
	if (hasRequiredProtocol_typeDefinition) return protocol_typeDefinition;
	hasRequiredProtocol_typeDefinition = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_typeDefinition, "__esModule", { value: true });
	protocol_typeDefinition.TypeDefinitionRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to resolve the type definition locations of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
	 * the response is of type {@link Definition} or a Thenable that resolves to such.
	 */
	var TypeDefinitionRequest;
	(function (TypeDefinitionRequest) {
	    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
	    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
	})(TypeDefinitionRequest || (protocol_typeDefinition.TypeDefinitionRequest = TypeDefinitionRequest = {}));
	return protocol_typeDefinition;
}

var protocol_workspaceFolder = {};

var hasRequiredProtocol_workspaceFolder;

function requireProtocol_workspaceFolder () {
	if (hasRequiredProtocol_workspaceFolder) return protocol_workspaceFolder;
	hasRequiredProtocol_workspaceFolder = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_workspaceFolder, "__esModule", { value: true });
	protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolder.WorkspaceFoldersRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
	 */
	var WorkspaceFoldersRequest;
	(function (WorkspaceFoldersRequest) {
	    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
	    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
	})(WorkspaceFoldersRequest || (protocol_workspaceFolder.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
	/**
	 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
	 * folder configuration changes.
	 */
	var DidChangeWorkspaceFoldersNotification;
	(function (DidChangeWorkspaceFoldersNotification) {
	    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
	    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
	})(DidChangeWorkspaceFoldersNotification || (protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
	return protocol_workspaceFolder;
}

var protocol_configuration = {};

var hasRequiredProtocol_configuration;

function requireProtocol_configuration () {
	if (hasRequiredProtocol_configuration) return protocol_configuration;
	hasRequiredProtocol_configuration = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_configuration, "__esModule", { value: true });
	protocol_configuration.ConfigurationRequest = void 0;
	const messages_1 = requireMessages();
	//---- Get Configuration request ----
	/**
	 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
	 * configuration setting.
	 *
	 * This pull model replaces the old push model were the client signaled configuration change via an
	 * event. If the server still needs to react to configuration changes (since the server caches the
	 * result of `workspace/configuration` requests) the server should register for an empty configuration
	 * change event and empty the cache if such an event is received.
	 */
	var ConfigurationRequest;
	(function (ConfigurationRequest) {
	    ConfigurationRequest.method = 'workspace/configuration';
	    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
	})(ConfigurationRequest || (protocol_configuration.ConfigurationRequest = ConfigurationRequest = {}));
	return protocol_configuration;
}

var protocol_colorProvider = {};

var hasRequiredProtocol_colorProvider;

function requireProtocol_colorProvider () {
	if (hasRequiredProtocol_colorProvider) return protocol_colorProvider;
	hasRequiredProtocol_colorProvider = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_colorProvider, "__esModule", { value: true });
	protocol_colorProvider.ColorPresentationRequest = protocol_colorProvider.DocumentColorRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to list all color symbols found in a given text document. The request's
	 * parameter is of type {@link DocumentColorParams} the
	 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	 * that resolves to such.
	 */
	var DocumentColorRequest;
	(function (DocumentColorRequest) {
	    DocumentColorRequest.method = 'textDocument/documentColor';
	    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
	})(DocumentColorRequest || (protocol_colorProvider.DocumentColorRequest = DocumentColorRequest = {}));
	/**
	 * A request to list all presentation for a color. The request's
	 * parameter is of type {@link ColorPresentationParams} the
	 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	 * that resolves to such.
	 */
	var ColorPresentationRequest;
	(function (ColorPresentationRequest) {
	    ColorPresentationRequest.method = 'textDocument/colorPresentation';
	    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
	})(ColorPresentationRequest || (protocol_colorProvider.ColorPresentationRequest = ColorPresentationRequest = {}));
	return protocol_colorProvider;
}

var protocol_foldingRange = {};

var hasRequiredProtocol_foldingRange;

function requireProtocol_foldingRange () {
	if (hasRequiredProtocol_foldingRange) return protocol_foldingRange;
	hasRequiredProtocol_foldingRange = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_foldingRange, "__esModule", { value: true });
	protocol_foldingRange.FoldingRangeRefreshRequest = protocol_foldingRange.FoldingRangeRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide folding ranges in a document. The request's
	 * parameter is of type {@link FoldingRangeParams}, the
	 * response is of type {@link FoldingRangeList} or a Thenable
	 * that resolves to such.
	 */
	var FoldingRangeRequest;
	(function (FoldingRangeRequest) {
	    FoldingRangeRequest.method = 'textDocument/foldingRange';
	    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
	})(FoldingRangeRequest || (protocol_foldingRange.FoldingRangeRequest = FoldingRangeRequest = {}));
	/**
	 * @since 3.18.0
	 * @proposed
	 */
	var FoldingRangeRefreshRequest;
	(function (FoldingRangeRefreshRequest) {
	    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
	    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
	})(FoldingRangeRefreshRequest || (protocol_foldingRange.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
	return protocol_foldingRange;
}

var protocol_declaration = {};

var hasRequiredProtocol_declaration;

function requireProtocol_declaration () {
	if (hasRequiredProtocol_declaration) return protocol_declaration;
	hasRequiredProtocol_declaration = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_declaration, "__esModule", { value: true });
	protocol_declaration.DeclarationRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to resolve the type definition locations of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
	 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
	 * or a Thenable that resolves to such.
	 */
	var DeclarationRequest;
	(function (DeclarationRequest) {
	    DeclarationRequest.method = 'textDocument/declaration';
	    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
	})(DeclarationRequest || (protocol_declaration.DeclarationRequest = DeclarationRequest = {}));
	return protocol_declaration;
}

var protocol_selectionRange = {};

var hasRequiredProtocol_selectionRange;

function requireProtocol_selectionRange () {
	if (hasRequiredProtocol_selectionRange) return protocol_selectionRange;
	hasRequiredProtocol_selectionRange = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_selectionRange, "__esModule", { value: true });
	protocol_selectionRange.SelectionRangeRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide selection ranges in a document. The request's
	 * parameter is of type {@link SelectionRangeParams}, the
	 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
	 * that resolves to such.
	 */
	var SelectionRangeRequest;
	(function (SelectionRangeRequest) {
	    SelectionRangeRequest.method = 'textDocument/selectionRange';
	    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
	})(SelectionRangeRequest || (protocol_selectionRange.SelectionRangeRequest = SelectionRangeRequest = {}));
	return protocol_selectionRange;
}

var protocol_progress = {};

var hasRequiredProtocol_progress;

function requireProtocol_progress () {
	if (hasRequiredProtocol_progress) return protocol_progress;
	hasRequiredProtocol_progress = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_progress, "__esModule", { value: true });
	protocol_progress.WorkDoneProgressCancelNotification = protocol_progress.WorkDoneProgressCreateRequest = protocol_progress.WorkDoneProgress = void 0;
	const vscode_jsonrpc_1 = requireMain$3();
	const messages_1 = requireMessages();
	var WorkDoneProgress;
	(function (WorkDoneProgress) {
	    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
	    function is(value) {
	        return value === WorkDoneProgress.type;
	    }
	    WorkDoneProgress.is = is;
	})(WorkDoneProgress || (protocol_progress.WorkDoneProgress = WorkDoneProgress = {}));
	/**
	 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
	 * reporting from the server.
	 */
	var WorkDoneProgressCreateRequest;
	(function (WorkDoneProgressCreateRequest) {
	    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
	    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
	})(WorkDoneProgressCreateRequest || (protocol_progress.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
	/**
	 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
	 * initiated on the server side.
	 */
	var WorkDoneProgressCancelNotification;
	(function (WorkDoneProgressCancelNotification) {
	    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
	    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
	})(WorkDoneProgressCancelNotification || (protocol_progress.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
	return protocol_progress;
}

var protocol_callHierarchy = {};

var hasRequiredProtocol_callHierarchy;

function requireProtocol_callHierarchy () {
	if (hasRequiredProtocol_callHierarchy) return protocol_callHierarchy;
	hasRequiredProtocol_callHierarchy = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_callHierarchy, "__esModule", { value: true });
	protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = protocol_callHierarchy.CallHierarchyIncomingCallsRequest = protocol_callHierarchy.CallHierarchyPrepareRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to result a `CallHierarchyItem` in a document at a given position.
	 * Can be used as an input to an incoming or outgoing call hierarchy.
	 *
	 * @since 3.16.0
	 */
	var CallHierarchyPrepareRequest;
	(function (CallHierarchyPrepareRequest) {
	    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
	    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
	})(CallHierarchyPrepareRequest || (protocol_callHierarchy.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
	/**
	 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
	 *
	 * @since 3.16.0
	 */
	var CallHierarchyIncomingCallsRequest;
	(function (CallHierarchyIncomingCallsRequest) {
	    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
	    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
	})(CallHierarchyIncomingCallsRequest || (protocol_callHierarchy.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
	/**
	 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
	 *
	 * @since 3.16.0
	 */
	var CallHierarchyOutgoingCallsRequest;
	(function (CallHierarchyOutgoingCallsRequest) {
	    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
	    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
	})(CallHierarchyOutgoingCallsRequest || (protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
	return protocol_callHierarchy;
}

var protocol_semanticTokens = {};

var hasRequiredProtocol_semanticTokens;

function requireProtocol_semanticTokens () {
	if (hasRequiredProtocol_semanticTokens) return protocol_semanticTokens;
	hasRequiredProtocol_semanticTokens = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_semanticTokens, "__esModule", { value: true });
	protocol_semanticTokens.SemanticTokensRefreshRequest = protocol_semanticTokens.SemanticTokensRangeRequest = protocol_semanticTokens.SemanticTokensDeltaRequest = protocol_semanticTokens.SemanticTokensRequest = protocol_semanticTokens.SemanticTokensRegistrationType = protocol_semanticTokens.TokenFormat = void 0;
	const messages_1 = requireMessages();
	//------- 'textDocument/semanticTokens' -----
	var TokenFormat;
	(function (TokenFormat) {
	    TokenFormat.Relative = 'relative';
	})(TokenFormat || (protocol_semanticTokens.TokenFormat = TokenFormat = {}));
	var SemanticTokensRegistrationType;
	(function (SemanticTokensRegistrationType) {
	    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
	    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
	})(SemanticTokensRegistrationType || (protocol_semanticTokens.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensRequest;
	(function (SemanticTokensRequest) {
	    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
	    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
	    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
	})(SemanticTokensRequest || (protocol_semanticTokens.SemanticTokensRequest = SemanticTokensRequest = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensDeltaRequest;
	(function (SemanticTokensDeltaRequest) {
	    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
	    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
	    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
	})(SemanticTokensDeltaRequest || (protocol_semanticTokens.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensRangeRequest;
	(function (SemanticTokensRangeRequest) {
	    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
	    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
	    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
	})(SemanticTokensRangeRequest || (protocol_semanticTokens.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensRefreshRequest;
	(function (SemanticTokensRefreshRequest) {
	    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
	    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
	})(SemanticTokensRefreshRequest || (protocol_semanticTokens.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
	return protocol_semanticTokens;
}

var protocol_showDocument = {};

var hasRequiredProtocol_showDocument;

function requireProtocol_showDocument () {
	if (hasRequiredProtocol_showDocument) return protocol_showDocument;
	hasRequiredProtocol_showDocument = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_showDocument, "__esModule", { value: true });
	protocol_showDocument.ShowDocumentRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to show a document. This request might open an
	 * external program depending on the value of the URI to open.
	 * For example a request to open `https://code.visualstudio.com/`
	 * will very likely open the URI in a WEB browser.
	 *
	 * @since 3.16.0
	*/
	var ShowDocumentRequest;
	(function (ShowDocumentRequest) {
	    ShowDocumentRequest.method = 'window/showDocument';
	    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
	})(ShowDocumentRequest || (protocol_showDocument.ShowDocumentRequest = ShowDocumentRequest = {}));
	return protocol_showDocument;
}

var protocol_linkedEditingRange = {};

var hasRequiredProtocol_linkedEditingRange;

function requireProtocol_linkedEditingRange () {
	if (hasRequiredProtocol_linkedEditingRange) return protocol_linkedEditingRange;
	hasRequiredProtocol_linkedEditingRange = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_linkedEditingRange, "__esModule", { value: true });
	protocol_linkedEditingRange.LinkedEditingRangeRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide ranges that can be edited together.
	 *
	 * @since 3.16.0
	 */
	var LinkedEditingRangeRequest;
	(function (LinkedEditingRangeRequest) {
	    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
	    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
	})(LinkedEditingRangeRequest || (protocol_linkedEditingRange.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
	return protocol_linkedEditingRange;
}

var protocol_fileOperations = {};

var hasRequiredProtocol_fileOperations;

function requireProtocol_fileOperations () {
	if (hasRequiredProtocol_fileOperations) return protocol_fileOperations;
	hasRequiredProtocol_fileOperations = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_fileOperations, "__esModule", { value: true });
	protocol_fileOperations.WillDeleteFilesRequest = protocol_fileOperations.DidDeleteFilesNotification = protocol_fileOperations.DidRenameFilesNotification = protocol_fileOperations.WillRenameFilesRequest = protocol_fileOperations.DidCreateFilesNotification = protocol_fileOperations.WillCreateFilesRequest = protocol_fileOperations.FileOperationPatternKind = void 0;
	const messages_1 = requireMessages();
	/**
	 * A pattern kind describing if a glob pattern matches a file a folder or
	 * both.
	 *
	 * @since 3.16.0
	 */
	var FileOperationPatternKind;
	(function (FileOperationPatternKind) {
	    /**
	     * The pattern matches a file only.
	     */
	    FileOperationPatternKind.file = 'file';
	    /**
	     * The pattern matches a folder only.
	     */
	    FileOperationPatternKind.folder = 'folder';
	})(FileOperationPatternKind || (protocol_fileOperations.FileOperationPatternKind = FileOperationPatternKind = {}));
	/**
	 * The will create files request is sent from the client to the server before files are actually
	 * created as long as the creation is triggered from within the client.
	 *
	 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
	 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
	 * to be created.
	 *
	 * @since 3.16.0
	 */
	var WillCreateFilesRequest;
	(function (WillCreateFilesRequest) {
	    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
	    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
	})(WillCreateFilesRequest || (protocol_fileOperations.WillCreateFilesRequest = WillCreateFilesRequest = {}));
	/**
	 * The did create files notification is sent from the client to the server when
	 * files were created from within the client.
	 *
	 * @since 3.16.0
	 */
	var DidCreateFilesNotification;
	(function (DidCreateFilesNotification) {
	    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
	    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
	})(DidCreateFilesNotification || (protocol_fileOperations.DidCreateFilesNotification = DidCreateFilesNotification = {}));
	/**
	 * The will rename files request is sent from the client to the server before files are actually
	 * renamed as long as the rename is triggered from within the client.
	 *
	 * @since 3.16.0
	 */
	var WillRenameFilesRequest;
	(function (WillRenameFilesRequest) {
	    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
	    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
	})(WillRenameFilesRequest || (protocol_fileOperations.WillRenameFilesRequest = WillRenameFilesRequest = {}));
	/**
	 * The did rename files notification is sent from the client to the server when
	 * files were renamed from within the client.
	 *
	 * @since 3.16.0
	 */
	var DidRenameFilesNotification;
	(function (DidRenameFilesNotification) {
	    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
	    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
	})(DidRenameFilesNotification || (protocol_fileOperations.DidRenameFilesNotification = DidRenameFilesNotification = {}));
	/**
	 * The will delete files request is sent from the client to the server before files are actually
	 * deleted as long as the deletion is triggered from within the client.
	 *
	 * @since 3.16.0
	 */
	var DidDeleteFilesNotification;
	(function (DidDeleteFilesNotification) {
	    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
	    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
	})(DidDeleteFilesNotification || (protocol_fileOperations.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
	/**
	 * The did delete files notification is sent from the client to the server when
	 * files were deleted from within the client.
	 *
	 * @since 3.16.0
	 */
	var WillDeleteFilesRequest;
	(function (WillDeleteFilesRequest) {
	    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
	    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
	})(WillDeleteFilesRequest || (protocol_fileOperations.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
	return protocol_fileOperations;
}

var protocol_moniker = {};

var hasRequiredProtocol_moniker;

function requireProtocol_moniker () {
	if (hasRequiredProtocol_moniker) return protocol_moniker;
	hasRequiredProtocol_moniker = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_moniker, "__esModule", { value: true });
	protocol_moniker.MonikerRequest = protocol_moniker.MonikerKind = protocol_moniker.UniquenessLevel = void 0;
	const messages_1 = requireMessages();
	/**
	 * Moniker uniqueness level to define scope of the moniker.
	 *
	 * @since 3.16.0
	 */
	var UniquenessLevel;
	(function (UniquenessLevel) {
	    /**
	     * The moniker is only unique inside a document
	     */
	    UniquenessLevel.document = 'document';
	    /**
	     * The moniker is unique inside a project for which a dump got created
	     */
	    UniquenessLevel.project = 'project';
	    /**
	     * The moniker is unique inside the group to which a project belongs
	     */
	    UniquenessLevel.group = 'group';
	    /**
	     * The moniker is unique inside the moniker scheme.
	     */
	    UniquenessLevel.scheme = 'scheme';
	    /**
	     * The moniker is globally unique
	     */
	    UniquenessLevel.global = 'global';
	})(UniquenessLevel || (protocol_moniker.UniquenessLevel = UniquenessLevel = {}));
	/**
	 * The moniker kind.
	 *
	 * @since 3.16.0
	 */
	var MonikerKind;
	(function (MonikerKind) {
	    /**
	     * The moniker represent a symbol that is imported into a project
	     */
	    MonikerKind.$import = 'import';
	    /**
	     * The moniker represents a symbol that is exported from a project
	     */
	    MonikerKind.$export = 'export';
	    /**
	     * The moniker represents a symbol that is local to a project (e.g. a local
	     * variable of a function, a class not visible outside the project, ...)
	     */
	    MonikerKind.local = 'local';
	})(MonikerKind || (protocol_moniker.MonikerKind = MonikerKind = {}));
	/**
	 * A request to get the moniker of a symbol at a given text document position.
	 * The request parameter is of type {@link TextDocumentPositionParams}.
	 * The response is of type {@link Moniker Moniker[]} or `null`.
	 */
	var MonikerRequest;
	(function (MonikerRequest) {
	    MonikerRequest.method = 'textDocument/moniker';
	    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
	})(MonikerRequest || (protocol_moniker.MonikerRequest = MonikerRequest = {}));
	return protocol_moniker;
}

var protocol_typeHierarchy = {};

var hasRequiredProtocol_typeHierarchy;

function requireProtocol_typeHierarchy () {
	if (hasRequiredProtocol_typeHierarchy) return protocol_typeHierarchy;
	hasRequiredProtocol_typeHierarchy = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_typeHierarchy, "__esModule", { value: true });
	protocol_typeHierarchy.TypeHierarchySubtypesRequest = protocol_typeHierarchy.TypeHierarchySupertypesRequest = protocol_typeHierarchy.TypeHierarchyPrepareRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to result a `TypeHierarchyItem` in a document at a given position.
	 * Can be used as an input to a subtypes or supertypes type hierarchy.
	 *
	 * @since 3.17.0
	 */
	var TypeHierarchyPrepareRequest;
	(function (TypeHierarchyPrepareRequest) {
	    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
	    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
	})(TypeHierarchyPrepareRequest || (protocol_typeHierarchy.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
	/**
	 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
	 *
	 * @since 3.17.0
	 */
	var TypeHierarchySupertypesRequest;
	(function (TypeHierarchySupertypesRequest) {
	    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
	    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
	})(TypeHierarchySupertypesRequest || (protocol_typeHierarchy.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
	/**
	 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
	 *
	 * @since 3.17.0
	 */
	var TypeHierarchySubtypesRequest;
	(function (TypeHierarchySubtypesRequest) {
	    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
	    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
	})(TypeHierarchySubtypesRequest || (protocol_typeHierarchy.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
	return protocol_typeHierarchy;
}

var protocol_inlineValue = {};

var hasRequiredProtocol_inlineValue;

function requireProtocol_inlineValue () {
	if (hasRequiredProtocol_inlineValue) return protocol_inlineValue;
	hasRequiredProtocol_inlineValue = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_inlineValue, "__esModule", { value: true });
	protocol_inlineValue.InlineValueRefreshRequest = protocol_inlineValue.InlineValueRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide inline values in a document. The request's parameter is of
	 * type {@link InlineValueParams}, the response is of type
	 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
	 *
	 * @since 3.17.0
	 */
	var InlineValueRequest;
	(function (InlineValueRequest) {
	    InlineValueRequest.method = 'textDocument/inlineValue';
	    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
	})(InlineValueRequest || (protocol_inlineValue.InlineValueRequest = InlineValueRequest = {}));
	/**
	 * @since 3.17.0
	 */
	var InlineValueRefreshRequest;
	(function (InlineValueRefreshRequest) {
	    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
	    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
	})(InlineValueRefreshRequest || (protocol_inlineValue.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
	return protocol_inlineValue;
}

var protocol_inlayHint = {};

var hasRequiredProtocol_inlayHint;

function requireProtocol_inlayHint () {
	if (hasRequiredProtocol_inlayHint) return protocol_inlayHint;
	hasRequiredProtocol_inlayHint = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_inlayHint, "__esModule", { value: true });
	protocol_inlayHint.InlayHintRefreshRequest = protocol_inlayHint.InlayHintResolveRequest = protocol_inlayHint.InlayHintRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide inlay hints in a document. The request's parameter is of
	 * type {@link InlayHintsParams}, the response is of type
	 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
	 *
	 * @since 3.17.0
	 */
	var InlayHintRequest;
	(function (InlayHintRequest) {
	    InlayHintRequest.method = 'textDocument/inlayHint';
	    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
	})(InlayHintRequest || (protocol_inlayHint.InlayHintRequest = InlayHintRequest = {}));
	/**
	 * A request to resolve additional properties for an inlay hint.
	 * The request's parameter is of type {@link InlayHint}, the response is
	 * of type {@link InlayHint} or a Thenable that resolves to such.
	 *
	 * @since 3.17.0
	 */
	var InlayHintResolveRequest;
	(function (InlayHintResolveRequest) {
	    InlayHintResolveRequest.method = 'inlayHint/resolve';
	    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
	})(InlayHintResolveRequest || (protocol_inlayHint.InlayHintResolveRequest = InlayHintResolveRequest = {}));
	/**
	 * @since 3.17.0
	 */
	var InlayHintRefreshRequest;
	(function (InlayHintRefreshRequest) {
	    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
	    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
	})(InlayHintRefreshRequest || (protocol_inlayHint.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
	return protocol_inlayHint;
}

var protocol_diagnostic = {};

var hasRequiredProtocol_diagnostic;

function requireProtocol_diagnostic () {
	if (hasRequiredProtocol_diagnostic) return protocol_diagnostic;
	hasRequiredProtocol_diagnostic = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_diagnostic, "__esModule", { value: true });
	protocol_diagnostic.DiagnosticRefreshRequest = protocol_diagnostic.WorkspaceDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticReportKind = protocol_diagnostic.DiagnosticServerCancellationData = void 0;
	const vscode_jsonrpc_1 = requireMain$3();
	const Is = requireIs();
	const messages_1 = requireMessages();
	/**
	 * @since 3.17.0
	 */
	var DiagnosticServerCancellationData;
	(function (DiagnosticServerCancellationData) {
	    function is(value) {
	        const candidate = value;
	        return candidate && Is.boolean(candidate.retriggerRequest);
	    }
	    DiagnosticServerCancellationData.is = is;
	})(DiagnosticServerCancellationData || (protocol_diagnostic.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
	/**
	 * The document diagnostic report kinds.
	 *
	 * @since 3.17.0
	 */
	var DocumentDiagnosticReportKind;
	(function (DocumentDiagnosticReportKind) {
	    /**
	     * A diagnostic report with a full
	     * set of problems.
	     */
	    DocumentDiagnosticReportKind.Full = 'full';
	    /**
	     * A report indicating that the last
	     * returned report is still accurate.
	     */
	    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
	})(DocumentDiagnosticReportKind || (protocol_diagnostic.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
	/**
	 * The document diagnostic request definition.
	 *
	 * @since 3.17.0
	 */
	var DocumentDiagnosticRequest;
	(function (DocumentDiagnosticRequest) {
	    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
	    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
	    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
	})(DocumentDiagnosticRequest || (protocol_diagnostic.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
	/**
	 * The workspace diagnostic request definition.
	 *
	 * @since 3.17.0
	 */
	var WorkspaceDiagnosticRequest;
	(function (WorkspaceDiagnosticRequest) {
	    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
	    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
	    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
	})(WorkspaceDiagnosticRequest || (protocol_diagnostic.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
	/**
	 * The diagnostic refresh request definition.
	 *
	 * @since 3.17.0
	 */
	var DiagnosticRefreshRequest;
	(function (DiagnosticRefreshRequest) {
	    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
	    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
	})(DiagnosticRefreshRequest || (protocol_diagnostic.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
	return protocol_diagnostic;
}

var protocol_notebook = {};

var hasRequiredProtocol_notebook;

function requireProtocol_notebook () {
	if (hasRequiredProtocol_notebook) return protocol_notebook;
	hasRequiredProtocol_notebook = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_notebook, "__esModule", { value: true });
	protocol_notebook.DidCloseNotebookDocumentNotification = protocol_notebook.DidSaveNotebookDocumentNotification = protocol_notebook.DidChangeNotebookDocumentNotification = protocol_notebook.NotebookCellArrayChange = protocol_notebook.DidOpenNotebookDocumentNotification = protocol_notebook.NotebookDocumentSyncRegistrationType = protocol_notebook.NotebookDocument = protocol_notebook.NotebookCell = protocol_notebook.ExecutionSummary = protocol_notebook.NotebookCellKind = void 0;
	const vscode_languageserver_types_1 = requireMain$2();
	const Is = requireIs();
	const messages_1 = requireMessages();
	/**
	 * A notebook cell kind.
	 *
	 * @since 3.17.0
	 */
	var NotebookCellKind;
	(function (NotebookCellKind) {
	    /**
	     * A markup-cell is formatted source that is used for display.
	     */
	    NotebookCellKind.Markup = 1;
	    /**
	     * A code-cell is source code.
	     */
	    NotebookCellKind.Code = 2;
	    function is(value) {
	        return value === 1 || value === 2;
	    }
	    NotebookCellKind.is = is;
	})(NotebookCellKind || (protocol_notebook.NotebookCellKind = NotebookCellKind = {}));
	var ExecutionSummary;
	(function (ExecutionSummary) {
	    function create(executionOrder, success) {
	        const result = { executionOrder };
	        if (success === true || success === false) {
	            result.success = success;
	        }
	        return result;
	    }
	    ExecutionSummary.create = create;
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
	    }
	    ExecutionSummary.is = is;
	    function equals(one, other) {
	        if (one === other) {
	            return true;
	        }
	        if (one === null || one === undefined || other === null || other === undefined) {
	            return false;
	        }
	        return one.executionOrder === other.executionOrder && one.success === other.success;
	    }
	    ExecutionSummary.equals = equals;
	})(ExecutionSummary || (protocol_notebook.ExecutionSummary = ExecutionSummary = {}));
	var NotebookCell;
	(function (NotebookCell) {
	    function create(kind, document) {
	        return { kind, document };
	    }
	    NotebookCell.create = create;
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
	            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
	    }
	    NotebookCell.is = is;
	    function diff(one, two) {
	        const result = new Set();
	        if (one.document !== two.document) {
	            result.add('document');
	        }
	        if (one.kind !== two.kind) {
	            result.add('kind');
	        }
	        if (one.executionSummary !== two.executionSummary) {
	            result.add('executionSummary');
	        }
	        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
	            result.add('metadata');
	        }
	        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
	            result.add('executionSummary');
	        }
	        return result;
	    }
	    NotebookCell.diff = diff;
	    function equalsMetadata(one, other) {
	        if (one === other) {
	            return true;
	        }
	        if (one === null || one === undefined || other === null || other === undefined) {
	            return false;
	        }
	        if (typeof one !== typeof other) {
	            return false;
	        }
	        if (typeof one !== 'object') {
	            return false;
	        }
	        const oneArray = Array.isArray(one);
	        const otherArray = Array.isArray(other);
	        if (oneArray !== otherArray) {
	            return false;
	        }
	        if (oneArray && otherArray) {
	            if (one.length !== other.length) {
	                return false;
	            }
	            for (let i = 0; i < one.length; i++) {
	                if (!equalsMetadata(one[i], other[i])) {
	                    return false;
	                }
	            }
	        }
	        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
	            const oneKeys = Object.keys(one);
	            const otherKeys = Object.keys(other);
	            if (oneKeys.length !== otherKeys.length) {
	                return false;
	            }
	            oneKeys.sort();
	            otherKeys.sort();
	            if (!equalsMetadata(oneKeys, otherKeys)) {
	                return false;
	            }
	            for (let i = 0; i < oneKeys.length; i++) {
	                const prop = oneKeys[i];
	                if (!equalsMetadata(one[prop], other[prop])) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }
	})(NotebookCell || (protocol_notebook.NotebookCell = NotebookCell = {}));
	var NotebookDocument;
	(function (NotebookDocument) {
	    function create(uri, notebookType, version, cells) {
	        return { uri, notebookType, version, cells };
	    }
	    NotebookDocument.create = create;
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
	    }
	    NotebookDocument.is = is;
	})(NotebookDocument || (protocol_notebook.NotebookDocument = NotebookDocument = {}));
	var NotebookDocumentSyncRegistrationType;
	(function (NotebookDocumentSyncRegistrationType) {
	    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
	    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
	    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
	})(NotebookDocumentSyncRegistrationType || (protocol_notebook.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
	/**
	 * A notification sent when a notebook opens.
	 *
	 * @since 3.17.0
	 */
	var DidOpenNotebookDocumentNotification;
	(function (DidOpenNotebookDocumentNotification) {
	    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
	    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
	    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidOpenNotebookDocumentNotification || (protocol_notebook.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
	var NotebookCellArrayChange;
	(function (NotebookCellArrayChange) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
	    }
	    NotebookCellArrayChange.is = is;
	    function create(start, deleteCount, cells) {
	        const result = { start, deleteCount };
	        if (cells !== undefined) {
	            result.cells = cells;
	        }
	        return result;
	    }
	    NotebookCellArrayChange.create = create;
	})(NotebookCellArrayChange || (protocol_notebook.NotebookCellArrayChange = NotebookCellArrayChange = {}));
	var DidChangeNotebookDocumentNotification;
	(function (DidChangeNotebookDocumentNotification) {
	    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
	    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
	    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidChangeNotebookDocumentNotification || (protocol_notebook.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
	/**
	 * A notification sent when a notebook document is saved.
	 *
	 * @since 3.17.0
	 */
	var DidSaveNotebookDocumentNotification;
	(function (DidSaveNotebookDocumentNotification) {
	    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
	    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
	    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidSaveNotebookDocumentNotification || (protocol_notebook.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
	/**
	 * A notification sent when a notebook closes.
	 *
	 * @since 3.17.0
	 */
	var DidCloseNotebookDocumentNotification;
	(function (DidCloseNotebookDocumentNotification) {
	    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
	    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
	    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidCloseNotebookDocumentNotification || (protocol_notebook.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
	return protocol_notebook;
}

var protocol_inlineCompletion = {};

var hasRequiredProtocol_inlineCompletion;

function requireProtocol_inlineCompletion () {
	if (hasRequiredProtocol_inlineCompletion) return protocol_inlineCompletion;
	hasRequiredProtocol_inlineCompletion = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_inlineCompletion, "__esModule", { value: true });
	protocol_inlineCompletion.InlineCompletionRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide inline completions in a document. The request's parameter is of
	 * type {@link InlineCompletionParams}, the response is of type
	 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
	 *
	 * @since 3.18.0
	 * @proposed
	 */
	var InlineCompletionRequest;
	(function (InlineCompletionRequest) {
	    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
	    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
	})(InlineCompletionRequest || (protocol_inlineCompletion.InlineCompletionRequest = InlineCompletionRequest = {}));
	return protocol_inlineCompletion;
}

var hasRequiredProtocol;

function requireProtocol () {
	if (hasRequiredProtocol) return protocol;
	hasRequiredProtocol = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
		exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
		exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
		const messages_1 = requireMessages();
		const vscode_languageserver_types_1 = requireMain$2();
		const Is = requireIs();
		const protocol_implementation_1 = requireProtocol_implementation();
		Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });
		const protocol_typeDefinition_1 = requireProtocol_typeDefinition();
		Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });
		const protocol_workspaceFolder_1 = requireProtocol_workspaceFolder();
		Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } });
		Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } });
		const protocol_configuration_1 = requireProtocol_configuration();
		Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });
		const protocol_colorProvider_1 = requireProtocol_colorProvider();
		Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });
		Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });
		const protocol_foldingRange_1 = requireProtocol_foldingRange();
		Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });
		Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRefreshRequest; } });
		const protocol_declaration_1 = requireProtocol_declaration();
		Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });
		const protocol_selectionRange_1 = requireProtocol_selectionRange();
		Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });
		const protocol_progress_1 = requireProtocol_progress();
		Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });
		Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });
		Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });
		const protocol_callHierarchy_1 = requireProtocol_callHierarchy();
		Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });
		Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });
		Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });
		const protocol_semanticTokens_1 = requireProtocol_semanticTokens();
		Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });
		Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });
		Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });
		Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });
		Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });
		Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });
		const protocol_showDocument_1 = requireProtocol_showDocument();
		Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });
		const protocol_linkedEditingRange_1 = requireProtocol_linkedEditingRange();
		Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });
		const protocol_fileOperations_1 = requireProtocol_fileOperations();
		Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });
		Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });
		Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });
		Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });
		Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });
		Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });
		Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });
		const protocol_moniker_1 = requireProtocol_moniker();
		Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });
		Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });
		Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });
		const protocol_typeHierarchy_1 = requireProtocol_typeHierarchy();
		Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } });
		Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } });
		Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } });
		const protocol_inlineValue_1 = requireProtocol_inlineValue();
		Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } });
		Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } });
		const protocol_inlayHint_1 = requireProtocol_inlayHint();
		Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } });
		Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } });
		Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } });
		const protocol_diagnostic_1 = requireProtocol_diagnostic();
		Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } });
		Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } });
		Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } });
		Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } });
		Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } });
		const protocol_notebook_1 = requireProtocol_notebook();
		Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } });
		Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } });
		Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } });
		Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } });
		Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } });
		Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } });
		Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } });
		Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } });
		Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } });
		Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } });
		const protocol_inlineCompletion_1 = requireProtocol_inlineCompletion();
		Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function () { return protocol_inlineCompletion_1.InlineCompletionRequest; } });
		/**
		 * The TextDocumentFilter namespace provides helper functions to work with
		 * {@link TextDocumentFilter} literals.
		 *
		 * @since 3.17.0
		 */
		var TextDocumentFilter;
		(function (TextDocumentFilter) {
		    function is(value) {
		        const candidate = value;
		        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
		    }
		    TextDocumentFilter.is = is;
		})(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
		/**
		 * The NotebookDocumentFilter namespace provides helper functions to work with
		 * {@link NotebookDocumentFilter} literals.
		 *
		 * @since 3.17.0
		 */
		var NotebookDocumentFilter;
		(function (NotebookDocumentFilter) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
		    }
		    NotebookDocumentFilter.is = is;
		})(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
		/**
		 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
		 * {@link NotebookCellTextDocumentFilter} literals.
		 *
		 * @since 3.17.0
		 */
		var NotebookCellTextDocumentFilter;
		(function (NotebookCellTextDocumentFilter) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate)
		            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
		            && (candidate.language === undefined || Is.string(candidate.language));
		    }
		    NotebookCellTextDocumentFilter.is = is;
		})(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
		/**
		 * The DocumentSelector namespace provides helper functions to work with
		 * {@link DocumentSelector}s.
		 */
		var DocumentSelector;
		(function (DocumentSelector) {
		    function is(value) {
		        if (!Array.isArray(value)) {
		            return false;
		        }
		        for (let elem of value) {
		            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
		                return false;
		            }
		        }
		        return true;
		    }
		    DocumentSelector.is = is;
		})(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
		/**
		 * The `client/registerCapability` request is sent from the server to the client to register a new capability
		 * handler on the client side.
		 */
		var RegistrationRequest;
		(function (RegistrationRequest) {
		    RegistrationRequest.method = 'client/registerCapability';
		    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
		})(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
		/**
		 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
		 * handler on the client side.
		 */
		var UnregistrationRequest;
		(function (UnregistrationRequest) {
		    UnregistrationRequest.method = 'client/unregisterCapability';
		    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
		})(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
		var ResourceOperationKind;
		(function (ResourceOperationKind) {
		    /**
		     * Supports creating new files and folders.
		     */
		    ResourceOperationKind.Create = 'create';
		    /**
		     * Supports renaming existing files and folders.
		     */
		    ResourceOperationKind.Rename = 'rename';
		    /**
		     * Supports deleting existing files and folders.
		     */
		    ResourceOperationKind.Delete = 'delete';
		})(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
		var FailureHandlingKind;
		(function (FailureHandlingKind) {
		    /**
		     * Applying the workspace change is simply aborted if one of the changes provided
		     * fails. All operations executed before the failing operation stay executed.
		     */
		    FailureHandlingKind.Abort = 'abort';
		    /**
		     * All operations are executed transactional. That means they either all
		     * succeed or no changes at all are applied to the workspace.
		     */
		    FailureHandlingKind.Transactional = 'transactional';
		    /**
		     * If the workspace edit contains only textual file changes they are executed transactional.
		     * If resource changes (create, rename or delete file) are part of the change the failure
		     * handling strategy is abort.
		     */
		    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
		    /**
		     * The client tries to undo the operations already executed. But there is no
		     * guarantee that this is succeeding.
		     */
		    FailureHandlingKind.Undo = 'undo';
		})(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
		/**
		 * A set of predefined position encoding kinds.
		 *
		 * @since 3.17.0
		 */
		var PositionEncodingKind;
		(function (PositionEncodingKind) {
		    /**
		     * Character offsets count UTF-8 code units (e.g. bytes).
		     */
		    PositionEncodingKind.UTF8 = 'utf-8';
		    /**
		     * Character offsets count UTF-16 code units.
		     *
		     * This is the default and must always be supported
		     * by servers
		     */
		    PositionEncodingKind.UTF16 = 'utf-16';
		    /**
		     * Character offsets count UTF-32 code units.
		     *
		     * Implementation note: these are the same as Unicode codepoints,
		     * so this `PositionEncodingKind` may also be used for an
		     * encoding-agnostic representation of character offsets.
		     */
		    PositionEncodingKind.UTF32 = 'utf-32';
		})(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
		/**
		 * The StaticRegistrationOptions namespace provides helper functions to work with
		 * {@link StaticRegistrationOptions} literals.
		 */
		var StaticRegistrationOptions;
		(function (StaticRegistrationOptions) {
		    function hasId(value) {
		        const candidate = value;
		        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
		    }
		    StaticRegistrationOptions.hasId = hasId;
		})(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
		/**
		 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
		 * {@link TextDocumentRegistrationOptions} literals.
		 */
		var TextDocumentRegistrationOptions;
		(function (TextDocumentRegistrationOptions) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
		    }
		    TextDocumentRegistrationOptions.is = is;
		})(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
		/**
		 * The WorkDoneProgressOptions namespace provides helper functions to work with
		 * {@link WorkDoneProgressOptions} literals.
		 */
		var WorkDoneProgressOptions;
		(function (WorkDoneProgressOptions) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
		    }
		    WorkDoneProgressOptions.is = is;
		    function hasWorkDoneProgress(value) {
		        const candidate = value;
		        return candidate && Is.boolean(candidate.workDoneProgress);
		    }
		    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
		})(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
		/**
		 * The initialize request is sent from the client to the server.
		 * It is sent once as the request after starting up the server.
		 * The requests parameter is of type {@link InitializeParams}
		 * the response if of type {@link InitializeResult} of a Thenable that
		 * resolves to such.
		 */
		var InitializeRequest;
		(function (InitializeRequest) {
		    InitializeRequest.method = 'initialize';
		    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
		})(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
		/**
		 * Known error codes for an `InitializeErrorCodes`;
		 */
		var InitializeErrorCodes;
		(function (InitializeErrorCodes) {
		    /**
		     * If the protocol version provided by the client can't be handled by the server.
		     *
		     * @deprecated This initialize error got replaced by client capabilities. There is
		     * no version handshake in version 3.0x
		     */
		    InitializeErrorCodes.unknownProtocolVersion = 1;
		})(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
		/**
		 * The initialized notification is sent from the client to the
		 * server after the client is fully initialized and the server
		 * is allowed to send requests from the server to the client.
		 */
		var InitializedNotification;
		(function (InitializedNotification) {
		    InitializedNotification.method = 'initialized';
		    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
		})(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
		//---- Shutdown Method ----
		/**
		 * A shutdown request is sent from the client to the server.
		 * It is sent once when the client decides to shutdown the
		 * server. The only notification that is sent after a shutdown request
		 * is the exit event.
		 */
		var ShutdownRequest;
		(function (ShutdownRequest) {
		    ShutdownRequest.method = 'shutdown';
		    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
		})(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
		//---- Exit Notification ----
		/**
		 * The exit event is sent from the client to the server to
		 * ask the server to exit its process.
		 */
		var ExitNotification;
		(function (ExitNotification) {
		    ExitNotification.method = 'exit';
		    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
		})(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
		/**
		 * The configuration change notification is sent from the client to the server
		 * when the client's configuration has changed. The notification contains
		 * the changed configuration as defined by the language client.
		 */
		var DidChangeConfigurationNotification;
		(function (DidChangeConfigurationNotification) {
		    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
		    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
		})(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
		//---- Message show and log notifications ----
		/**
		 * The message type
		 */
		var MessageType;
		(function (MessageType) {
		    /**
		     * An error message.
		     */
		    MessageType.Error = 1;
		    /**
		     * A warning message.
		     */
		    MessageType.Warning = 2;
		    /**
		     * An information message.
		     */
		    MessageType.Info = 3;
		    /**
		     * A log message.
		     */
		    MessageType.Log = 4;
		    /**
		     * A debug message.
		     *
		     * @since 3.18.0
		     */
		    MessageType.Debug = 5;
		})(MessageType || (exports.MessageType = MessageType = {}));
		/**
		 * The show message notification is sent from a server to a client to ask
		 * the client to display a particular message in the user interface.
		 */
		var ShowMessageNotification;
		(function (ShowMessageNotification) {
		    ShowMessageNotification.method = 'window/showMessage';
		    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
		})(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
		/**
		 * The show message request is sent from the server to the client to show a message
		 * and a set of options actions to the user.
		 */
		var ShowMessageRequest;
		(function (ShowMessageRequest) {
		    ShowMessageRequest.method = 'window/showMessageRequest';
		    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
		})(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
		/**
		 * The log message notification is sent from the server to the client to ask
		 * the client to log a particular message.
		 */
		var LogMessageNotification;
		(function (LogMessageNotification) {
		    LogMessageNotification.method = 'window/logMessage';
		    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
		})(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
		//---- Telemetry notification
		/**
		 * The telemetry event notification is sent from the server to the client to ask
		 * the client to log telemetry data.
		 */
		var TelemetryEventNotification;
		(function (TelemetryEventNotification) {
		    TelemetryEventNotification.method = 'telemetry/event';
		    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
		})(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
		/**
		 * Defines how the host (editor) should sync
		 * document changes to the language server.
		 */
		var TextDocumentSyncKind;
		(function (TextDocumentSyncKind) {
		    /**
		     * Documents should not be synced at all.
		     */
		    TextDocumentSyncKind.None = 0;
		    /**
		     * Documents are synced by always sending the full content
		     * of the document.
		     */
		    TextDocumentSyncKind.Full = 1;
		    /**
		     * Documents are synced by sending the full content on open.
		     * After that only incremental updates to the document are
		     * send.
		     */
		    TextDocumentSyncKind.Incremental = 2;
		})(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
		/**
		 * The document open notification is sent from the client to the server to signal
		 * newly opened text documents. The document's truth is now managed by the client
		 * and the server must not try to read the document's truth using the document's
		 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
		 * mean that its content is presented in an editor. An open notification must not
		 * be sent more than once without a corresponding close notification send before.
		 * This means open and close notification must be balanced and the max open count
		 * is one.
		 */
		var DidOpenTextDocumentNotification;
		(function (DidOpenTextDocumentNotification) {
		    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
		    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
		})(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
		var TextDocumentContentChangeEvent;
		(function (TextDocumentContentChangeEvent) {
		    /**
		     * Checks whether the information describes a delta event.
		     */
		    function isIncremental(event) {
		        let candidate = event;
		        return candidate !== undefined && candidate !== null &&
		            typeof candidate.text === 'string' && candidate.range !== undefined &&
		            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
		    }
		    TextDocumentContentChangeEvent.isIncremental = isIncremental;
		    /**
		     * Checks whether the information describes a full replacement event.
		     */
		    function isFull(event) {
		        let candidate = event;
		        return candidate !== undefined && candidate !== null &&
		            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
		    }
		    TextDocumentContentChangeEvent.isFull = isFull;
		})(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
		/**
		 * The document change notification is sent from the client to the server to signal
		 * changes to a text document.
		 */
		var DidChangeTextDocumentNotification;
		(function (DidChangeTextDocumentNotification) {
		    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
		    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
		})(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
		/**
		 * The document close notification is sent from the client to the server when
		 * the document got closed in the client. The document's truth now exists where
		 * the document's uri points to (e.g. if the document's uri is a file uri the
		 * truth now exists on disk). As with the open notification the close notification
		 * is about managing the document's content. Receiving a close notification
		 * doesn't mean that the document was open in an editor before. A close
		 * notification requires a previous open notification to be sent.
		 */
		var DidCloseTextDocumentNotification;
		(function (DidCloseTextDocumentNotification) {
		    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
		    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
		})(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
		/**
		 * The document save notification is sent from the client to the server when
		 * the document got saved in the client.
		 */
		var DidSaveTextDocumentNotification;
		(function (DidSaveTextDocumentNotification) {
		    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
		    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
		})(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
		/**
		 * Represents reasons why a text document is saved.
		 */
		var TextDocumentSaveReason;
		(function (TextDocumentSaveReason) {
		    /**
		     * Manually triggered, e.g. by the user pressing save, by starting debugging,
		     * or by an API call.
		     */
		    TextDocumentSaveReason.Manual = 1;
		    /**
		     * Automatic after a delay.
		     */
		    TextDocumentSaveReason.AfterDelay = 2;
		    /**
		     * When the editor lost focus.
		     */
		    TextDocumentSaveReason.FocusOut = 3;
		})(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
		/**
		 * A document will save notification is sent from the client to the server before
		 * the document is actually saved.
		 */
		var WillSaveTextDocumentNotification;
		(function (WillSaveTextDocumentNotification) {
		    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
		    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
		})(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
		/**
		 * A document will save request is sent from the client to the server before
		 * the document is actually saved. The request can return an array of TextEdits
		 * which will be applied to the text document before it is saved. Please note that
		 * clients might drop results if computing the text edits took too long or if a
		 * server constantly fails on this request. This is done to keep the save fast and
		 * reliable.
		 */
		var WillSaveTextDocumentWaitUntilRequest;
		(function (WillSaveTextDocumentWaitUntilRequest) {
		    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
		    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
		})(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
		/**
		 * The watched files notification is sent from the client to the server when
		 * the client detects changes to file watched by the language client.
		 */
		var DidChangeWatchedFilesNotification;
		(function (DidChangeWatchedFilesNotification) {
		    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
		    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
		})(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
		/**
		 * The file event type
		 */
		var FileChangeType;
		(function (FileChangeType) {
		    /**
		     * The file got created.
		     */
		    FileChangeType.Created = 1;
		    /**
		     * The file got changed.
		     */
		    FileChangeType.Changed = 2;
		    /**
		     * The file got deleted.
		     */
		    FileChangeType.Deleted = 3;
		})(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
		var RelativePattern;
		(function (RelativePattern) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
		    }
		    RelativePattern.is = is;
		})(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
		var WatchKind;
		(function (WatchKind) {
		    /**
		     * Interested in create events.
		     */
		    WatchKind.Create = 1;
		    /**
		     * Interested in change events
		     */
		    WatchKind.Change = 2;
		    /**
		     * Interested in delete events
		     */
		    WatchKind.Delete = 4;
		})(WatchKind || (exports.WatchKind = WatchKind = {}));
		/**
		 * Diagnostics notification are sent from the server to the client to signal
		 * results of validation runs.
		 */
		var PublishDiagnosticsNotification;
		(function (PublishDiagnosticsNotification) {
		    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
		    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
		})(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
		/**
		 * How a completion was triggered
		 */
		var CompletionTriggerKind;
		(function (CompletionTriggerKind) {
		    /**
		     * Completion was triggered by typing an identifier (24x7 code
		     * complete), manual invocation (e.g Ctrl+Space) or via API.
		     */
		    CompletionTriggerKind.Invoked = 1;
		    /**
		     * Completion was triggered by a trigger character specified by
		     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
		     */
		    CompletionTriggerKind.TriggerCharacter = 2;
		    /**
		     * Completion was re-triggered as current completion list is incomplete
		     */
		    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
		})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
		/**
		 * Request to request completion at a given text document position. The request's
		 * parameter is of type {@link TextDocumentPosition} the response
		 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
		 * or a Thenable that resolves to such.
		 *
		 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
		 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
		 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
		 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
		 */
		var CompletionRequest;
		(function (CompletionRequest) {
		    CompletionRequest.method = 'textDocument/completion';
		    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
		})(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
		/**
		 * Request to resolve additional information for a given completion item.The request's
		 * parameter is of type {@link CompletionItem} the response
		 * is of type {@link CompletionItem} or a Thenable that resolves to such.
		 */
		var CompletionResolveRequest;
		(function (CompletionResolveRequest) {
		    CompletionResolveRequest.method = 'completionItem/resolve';
		    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
		})(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
		/**
		 * Request to request hover information at a given text document position. The request's
		 * parameter is of type {@link TextDocumentPosition} the response is of
		 * type {@link Hover} or a Thenable that resolves to such.
		 */
		var HoverRequest;
		(function (HoverRequest) {
		    HoverRequest.method = 'textDocument/hover';
		    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
		})(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
		/**
		 * How a signature help was triggered.
		 *
		 * @since 3.15.0
		 */
		var SignatureHelpTriggerKind;
		(function (SignatureHelpTriggerKind) {
		    /**
		     * Signature help was invoked manually by the user or by a command.
		     */
		    SignatureHelpTriggerKind.Invoked = 1;
		    /**
		     * Signature help was triggered by a trigger character.
		     */
		    SignatureHelpTriggerKind.TriggerCharacter = 2;
		    /**
		     * Signature help was triggered by the cursor moving or by the document content changing.
		     */
		    SignatureHelpTriggerKind.ContentChange = 3;
		})(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
		var SignatureHelpRequest;
		(function (SignatureHelpRequest) {
		    SignatureHelpRequest.method = 'textDocument/signatureHelp';
		    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
		})(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
		/**
		 * A request to resolve the definition location of a symbol at a given text
		 * document position. The request's parameter is of type {@link TextDocumentPosition}
		 * the response is of either type {@link Definition} or a typed array of
		 * {@link DefinitionLink} or a Thenable that resolves to such.
		 */
		var DefinitionRequest;
		(function (DefinitionRequest) {
		    DefinitionRequest.method = 'textDocument/definition';
		    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
		})(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
		/**
		 * A request to resolve project-wide references for the symbol denoted
		 * by the given text document position. The request's parameter is of
		 * type {@link ReferenceParams} the response is of type
		 * {@link Location Location[]} or a Thenable that resolves to such.
		 */
		var ReferencesRequest;
		(function (ReferencesRequest) {
		    ReferencesRequest.method = 'textDocument/references';
		    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
		})(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
		/**
		 * Request to resolve a {@link DocumentHighlight} for a given
		 * text document position. The request's parameter is of type {@link TextDocumentPosition}
		 * the request response is an array of type {@link DocumentHighlight}
		 * or a Thenable that resolves to such.
		 */
		var DocumentHighlightRequest;
		(function (DocumentHighlightRequest) {
		    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
		    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
		})(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
		/**
		 * A request to list all symbols found in a given text document. The request's
		 * parameter is of type {@link TextDocumentIdentifier} the
		 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
		 * that resolves to such.
		 */
		var DocumentSymbolRequest;
		(function (DocumentSymbolRequest) {
		    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
		    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
		})(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
		/**
		 * A request to provide commands for the given text document and range.
		 */
		var CodeActionRequest;
		(function (CodeActionRequest) {
		    CodeActionRequest.method = 'textDocument/codeAction';
		    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
		})(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
		/**
		 * Request to resolve additional information for a given code action.The request's
		 * parameter is of type {@link CodeAction} the response
		 * is of type {@link CodeAction} or a Thenable that resolves to such.
		 */
		var CodeActionResolveRequest;
		(function (CodeActionResolveRequest) {
		    CodeActionResolveRequest.method = 'codeAction/resolve';
		    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
		})(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
		/**
		 * A request to list project-wide symbols matching the query string given
		 * by the {@link WorkspaceSymbolParams}. The response is
		 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
		 * resolves to such.
		 *
		 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
		 *  need to advertise support for WorkspaceSymbols via the client capability
		 *  `workspace.symbol.resolveSupport`.
		 *
		 */
		var WorkspaceSymbolRequest;
		(function (WorkspaceSymbolRequest) {
		    WorkspaceSymbolRequest.method = 'workspace/symbol';
		    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
		})(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
		/**
		 * A request to resolve the range inside the workspace
		 * symbol's location.
		 *
		 * @since 3.17.0
		 */
		var WorkspaceSymbolResolveRequest;
		(function (WorkspaceSymbolResolveRequest) {
		    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
		    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
		})(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
		/**
		 * A request to provide code lens for the given text document.
		 */
		var CodeLensRequest;
		(function (CodeLensRequest) {
		    CodeLensRequest.method = 'textDocument/codeLens';
		    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
		})(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
		/**
		 * A request to resolve a command for a given code lens.
		 */
		var CodeLensResolveRequest;
		(function (CodeLensResolveRequest) {
		    CodeLensResolveRequest.method = 'codeLens/resolve';
		    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
		})(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
		/**
		 * A request to refresh all code actions
		 *
		 * @since 3.16.0
		 */
		var CodeLensRefreshRequest;
		(function (CodeLensRefreshRequest) {
		    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
		    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
		})(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
		/**
		 * A request to provide document links
		 */
		var DocumentLinkRequest;
		(function (DocumentLinkRequest) {
		    DocumentLinkRequest.method = 'textDocument/documentLink';
		    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
		})(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
		/**
		 * Request to resolve additional information for a given document link. The request's
		 * parameter is of type {@link DocumentLink} the response
		 * is of type {@link DocumentLink} or a Thenable that resolves to such.
		 */
		var DocumentLinkResolveRequest;
		(function (DocumentLinkResolveRequest) {
		    DocumentLinkResolveRequest.method = 'documentLink/resolve';
		    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
		})(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
		/**
		 * A request to format a whole document.
		 */
		var DocumentFormattingRequest;
		(function (DocumentFormattingRequest) {
		    DocumentFormattingRequest.method = 'textDocument/formatting';
		    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
		})(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
		/**
		 * A request to format a range in a document.
		 */
		var DocumentRangeFormattingRequest;
		(function (DocumentRangeFormattingRequest) {
		    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
		    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
		})(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
		/**
		 * A request to format ranges in a document.
		 *
		 * @since 3.18.0
		 * @proposed
		 */
		var DocumentRangesFormattingRequest;
		(function (DocumentRangesFormattingRequest) {
		    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
		    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
		})(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
		/**
		 * A request to format a document on type.
		 */
		var DocumentOnTypeFormattingRequest;
		(function (DocumentOnTypeFormattingRequest) {
		    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
		    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
		})(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
		//---- Rename ----------------------------------------------
		var PrepareSupportDefaultBehavior;
		(function (PrepareSupportDefaultBehavior) {
		    /**
		     * The client's default behavior is to select the identifier
		     * according the to language's syntax rule.
		     */
		    PrepareSupportDefaultBehavior.Identifier = 1;
		})(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
		/**
		 * A request to rename a symbol.
		 */
		var RenameRequest;
		(function (RenameRequest) {
		    RenameRequest.method = 'textDocument/rename';
		    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
		})(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
		/**
		 * A request to test and perform the setup necessary for a rename.
		 *
		 * @since 3.16 - support for default behavior
		 */
		var PrepareRenameRequest;
		(function (PrepareRenameRequest) {
		    PrepareRenameRequest.method = 'textDocument/prepareRename';
		    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
		})(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
		/**
		 * A request send from the client to the server to execute a command. The request might return
		 * a workspace edit which the client will apply to the workspace.
		 */
		var ExecuteCommandRequest;
		(function (ExecuteCommandRequest) {
		    ExecuteCommandRequest.method = 'workspace/executeCommand';
		    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
		})(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
		/**
		 * A request sent from the server to the client to modified certain resources.
		 */
		var ApplyWorkspaceEditRequest;
		(function (ApplyWorkspaceEditRequest) {
		    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
		    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
		})(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {})); 
	} (protocol));
	return protocol;
}

var connection = {};

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection;
	hasRequiredConnection = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(connection, "__esModule", { value: true });
	connection.createProtocolConnection = void 0;
	const vscode_jsonrpc_1 = requireMain$3();
	function createProtocolConnection(input, output, logger, options) {
	    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
	        options = { connectionStrategy: options };
	    }
	    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
	}
	connection.createProtocolConnection = createProtocolConnection;
	return connection;
}

var hasRequiredApi$1;

function requireApi$1 () {
	if (hasRequiredApi$1) return api$1;
	hasRequiredApi$1 = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		var __createBinding = (api$1 && api$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (api$1 && api$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
		__exportStar(requireMain$3(), exports);
		__exportStar(requireMain$2(), exports);
		__exportStar(requireMessages(), exports);
		__exportStar(requireProtocol(), exports);
		var connection_1 = requireConnection();
		Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });
		var LSPErrorCodes;
		(function (LSPErrorCodes) {
		    /**
		    * This is the start range of LSP reserved error codes.
		    * It doesn't denote a real error code.
		    *
		    * @since 3.16.0
		    */
		    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
		    /**
		     * A request failed but it was syntactically correct, e.g the
		     * method name was known and the parameters were valid. The error
		     * message should contain human readable information about why
		     * the request failed.
		     *
		     * @since 3.17.0
		     */
		    LSPErrorCodes.RequestFailed = -32803;
		    /**
		     * The server cancelled the request. This error code should
		     * only be used for requests that explicitly support being
		     * server cancellable.
		     *
		     * @since 3.17.0
		     */
		    LSPErrorCodes.ServerCancelled = -32802;
		    /**
		     * The server detected that the content of a document got
		     * modified outside normal conditions. A server should
		     * NOT send this error code if it detects a content change
		     * in it unprocessed messages. The result even computed
		     * on an older state might still be useful for the client.
		     *
		     * If a client decides that a result is not of any use anymore
		     * the client should cancel the request.
		     */
		    LSPErrorCodes.ContentModified = -32801;
		    /**
		     * The client has canceled a request and a server as detected
		     * the cancel.
		     */
		    LSPErrorCodes.RequestCancelled = -32800;
		    /**
		    * This is the end range of LSP reserved error codes.
		    * It doesn't denote a real error code.
		    *
		    * @since 3.16.0
		    */
		    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
		})(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {})); 
	} (api$1));
	return api$1;
}

var hasRequiredMain$1;

function requireMain$1 () {
	if (hasRequiredMain$1) return main$2;
	hasRequiredMain$1 = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		var __createBinding = (main$2 && main$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$2 && main$2.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createProtocolConnection = void 0;
		const node_1 = requireNode$2();
		__exportStar(requireNode$2(), exports);
		__exportStar(requireApi$1(), exports);
		function createProtocolConnection(input, output, logger, options) {
		    return (0, node_1.createMessageConnection)(input, output, logger, options);
		}
		exports.createProtocolConnection = createProtocolConnection; 
	} (main$2));
	return main$2;
}

var uuid = {};

var hasRequiredUuid;

function requireUuid () {
	if (hasRequiredUuid) return uuid;
	hasRequiredUuid = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(uuid, "__esModule", { value: true });
	uuid.generateUuid = uuid.parse = uuid.isUUID = uuid.v4 = uuid.empty = void 0;
	class ValueUUID {
	    constructor(_value) {
	        this._value = _value;
	        // empty
	    }
	    asHex() {
	        return this._value;
	    }
	    equals(other) {
	        return this.asHex() === other.asHex();
	    }
	}
	class V4UUID extends ValueUUID {
	    static _oneOf(array) {
	        return array[Math.floor(array.length * Math.random())];
	    }
	    static _randomHex() {
	        return V4UUID._oneOf(V4UUID._chars);
	    }
	    constructor() {
	        super([
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            '4',
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            V4UUID._oneOf(V4UUID._timeHighBits),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	        ].join(''));
	    }
	}
	V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
	V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
	/**
	 * An empty UUID that contains only zeros.
	 */
	uuid.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
	function v4() {
	    return new V4UUID();
	}
	uuid.v4 = v4;
	const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
	function isUUID(value) {
	    return _UUIDPattern.test(value);
	}
	uuid.isUUID = isUUID;
	/**
	 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
	 * @param value A uuid string.
	 */
	function parse(value) {
	    if (!isUUID(value)) {
	        throw new Error('invalid uuid');
	    }
	    return new ValueUUID(value);
	}
	uuid.parse = parse;
	function generateUuid() {
	    return v4().asHex();
	}
	uuid.generateUuid = generateUuid;
	return uuid;
}

var progress = {};

var hasRequiredProgress;

function requireProgress () {
	if (hasRequiredProgress) return progress;
	hasRequiredProgress = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(progress, "__esModule", { value: true });
	progress.attachPartialResult = progress.ProgressFeature = progress.attachWorkDone = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const uuid_1 = requireUuid();
	class WorkDoneProgressReporterImpl {
	    constructor(_connection, _token) {
	        this._connection = _connection;
	        this._token = _token;
	        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
	    }
	    begin(title, percentage, message, cancellable) {
	        let param = {
	            kind: 'begin',
	            title,
	            percentage,
	            message,
	            cancellable
	        };
	        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
	    }
	    report(arg0, arg1) {
	        let param = {
	            kind: 'report'
	        };
	        if (typeof arg0 === 'number') {
	            param.percentage = arg0;
	            if (arg1 !== undefined) {
	                param.message = arg1;
	            }
	        }
	        else {
	            param.message = arg0;
	        }
	        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
	    }
	    done() {
	        WorkDoneProgressReporterImpl.Instances.delete(this._token);
	        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
	    }
	}
	WorkDoneProgressReporterImpl.Instances = new Map();
	class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
	    constructor(connection, token) {
	        super(connection, token);
	        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
	    }
	    get token() {
	        return this._source.token;
	    }
	    done() {
	        this._source.dispose();
	        super.done();
	    }
	    cancel() {
	        this._source.cancel();
	    }
	}
	class NullProgressReporter {
	    constructor() {
	    }
	    begin() {
	    }
	    report() {
	    }
	    done() {
	    }
	}
	class NullProgressServerReporter extends NullProgressReporter {
	    constructor() {
	        super();
	        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
	    }
	    get token() {
	        return this._source.token;
	    }
	    done() {
	        this._source.dispose();
	    }
	    cancel() {
	        this._source.cancel();
	    }
	}
	function attachWorkDone(connection, params) {
	    if (params === undefined || params.workDoneToken === undefined) {
	        return new NullProgressReporter();
	    }
	    const token = params.workDoneToken;
	    delete params.workDoneToken;
	    return new WorkDoneProgressReporterImpl(connection, token);
	}
	progress.attachWorkDone = attachWorkDone;
	const ProgressFeature = (Base) => {
	    return class extends Base {
	        constructor() {
	            super();
	            this._progressSupported = false;
	        }
	        initialize(capabilities) {
	            super.initialize(capabilities);
	            if (capabilities?.window?.workDoneProgress === true) {
	                this._progressSupported = true;
	                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
	                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
	                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
	                        progress.cancel();
	                    }
	                });
	            }
	        }
	        attachWorkDoneProgress(token) {
	            if (token === undefined) {
	                return new NullProgressReporter();
	            }
	            else {
	                return new WorkDoneProgressReporterImpl(this.connection, token);
	            }
	        }
	        createWorkDoneProgress() {
	            if (this._progressSupported) {
	                const token = (0, uuid_1.generateUuid)();
	                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
	                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
	                    return result;
	                });
	            }
	            else {
	                return Promise.resolve(new NullProgressServerReporter());
	            }
	        }
	    };
	};
	progress.ProgressFeature = ProgressFeature;
	var ResultProgress;
	(function (ResultProgress) {
	    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
	})(ResultProgress || (ResultProgress = {}));
	class ResultProgressReporterImpl {
	    constructor(_connection, _token) {
	        this._connection = _connection;
	        this._token = _token;
	    }
	    report(data) {
	        this._connection.sendProgress(ResultProgress.type, this._token, data);
	    }
	}
	function attachPartialResult(connection, params) {
	    if (params === undefined || params.partialResultToken === undefined) {
	        return undefined;
	    }
	    const token = params.partialResultToken;
	    delete params.partialResultToken;
	    return new ResultProgressReporterImpl(connection, token);
	}
	progress.attachPartialResult = attachPartialResult;
	return progress;
}

var configuration = {};

var hasRequiredConfiguration;

function requireConfiguration () {
	if (hasRequiredConfiguration) return configuration;
	hasRequiredConfiguration = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(configuration, "__esModule", { value: true });
	configuration.ConfigurationFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const Is = requireIs$2();
	const ConfigurationFeature = (Base) => {
	    return class extends Base {
	        getConfiguration(arg) {
	            if (!arg) {
	                return this._getConfiguration({});
	            }
	            else if (Is.string(arg)) {
	                return this._getConfiguration({ section: arg });
	            }
	            else {
	                return this._getConfiguration(arg);
	            }
	        }
	        _getConfiguration(arg) {
	            let params = {
	                items: Array.isArray(arg) ? arg : [arg]
	            };
	            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
	                if (Array.isArray(result)) {
	                    return Array.isArray(arg) ? result : result[0];
	                }
	                else {
	                    return Array.isArray(arg) ? [] : null;
	                }
	            });
	        }
	    };
	};
	configuration.ConfigurationFeature = ConfigurationFeature;
	return configuration;
}

var workspaceFolder = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredWorkspaceFolder;

function requireWorkspaceFolder () {
	if (hasRequiredWorkspaceFolder) return workspaceFolder;
	hasRequiredWorkspaceFolder = 1;
	Object.defineProperty(workspaceFolder, "__esModule", { value: true });
	workspaceFolder.WorkspaceFoldersFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const WorkspaceFoldersFeature = (Base) => {
	    return class extends Base {
	        constructor() {
	            super();
	            this._notificationIsAutoRegistered = false;
	        }
	        initialize(capabilities) {
	            super.initialize(capabilities);
	            let workspaceCapabilities = capabilities.workspace;
	            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
	                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
	                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
	                    this._onDidChangeWorkspaceFolders.fire(params.event);
	                });
	            }
	        }
	        fillServerCapabilities(capabilities) {
	            super.fillServerCapabilities(capabilities);
	            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
	            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';
	        }
	        getWorkspaceFolders() {
	            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
	        }
	        get onDidChangeWorkspaceFolders() {
	            if (!this._onDidChangeWorkspaceFolders) {
	                throw new Error('Client doesn\'t support sending workspace folder change events.');
	            }
	            if (!this._notificationIsAutoRegistered && !this._unregistration) {
	                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
	            }
	            return this._onDidChangeWorkspaceFolders.event;
	        }
	    };
	};
	workspaceFolder.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
	return workspaceFolder;
}

var callHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredCallHierarchy;

function requireCallHierarchy () {
	if (hasRequiredCallHierarchy) return callHierarchy;
	hasRequiredCallHierarchy = 1;
	Object.defineProperty(callHierarchy, "__esModule", { value: true });
	callHierarchy.CallHierarchyFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const CallHierarchyFeature = (Base) => {
	    return class extends Base {
	        get callHierarchy() {
	            return {
	                onPrepare: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
	                    });
	                },
	                onIncomingCalls: (handler) => {
	                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onOutgoingCalls: (handler) => {
	                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	callHierarchy.CallHierarchyFeature = CallHierarchyFeature;
	return callHierarchy;
}

var semanticTokens = {};

var hasRequiredSemanticTokens;

function requireSemanticTokens () {
	if (hasRequiredSemanticTokens) return semanticTokens;
	hasRequiredSemanticTokens = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(semanticTokens, "__esModule", { value: true });
	semanticTokens.SemanticTokensBuilder = semanticTokens.SemanticTokensDiff = semanticTokens.SemanticTokensFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const SemanticTokensFeature = (Base) => {
	    return class extends Base {
	        get semanticTokens() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
	                },
	                on: (handler) => {
	                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onDelta: (handler) => {
	                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onRange: (handler) => {
	                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	semanticTokens.SemanticTokensFeature = SemanticTokensFeature;
	class SemanticTokensDiff {
	    constructor(originalSequence, modifiedSequence) {
	        this.originalSequence = originalSequence;
	        this.modifiedSequence = modifiedSequence;
	    }
	    computeDiff() {
	        const originalLength = this.originalSequence.length;
	        const modifiedLength = this.modifiedSequence.length;
	        let startIndex = 0;
	        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
	            startIndex++;
	        }
	        if (startIndex < modifiedLength && startIndex < originalLength) {
	            let originalEndIndex = originalLength - 1;
	            let modifiedEndIndex = modifiedLength - 1;
	            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
	                originalEndIndex--;
	                modifiedEndIndex--;
	            }
	            // if one moved behind the start index move them forward again
	            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
	                originalEndIndex++;
	                modifiedEndIndex++;
	            }
	            const deleteCount = originalEndIndex - startIndex + 1;
	            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
	            // If we moved behind the start index we could have missed a simple delete.
	            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
	                return [
	                    { start: startIndex, deleteCount: deleteCount - 1 }
	                ];
	            }
	            else {
	                return [
	                    { start: startIndex, deleteCount, data: newData }
	                ];
	            }
	        }
	        else if (startIndex < modifiedLength) {
	            return [
	                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
	            ];
	        }
	        else if (startIndex < originalLength) {
	            return [
	                { start: startIndex, deleteCount: originalLength - startIndex }
	            ];
	        }
	        else {
	            // The two arrays are the same.
	            return [];
	        }
	    }
	}
	semanticTokens.SemanticTokensDiff = SemanticTokensDiff;
	class SemanticTokensBuilder {
	    constructor() {
	        this._prevData = undefined;
	        this.initialize();
	    }
	    initialize() {
	        this._id = Date.now();
	        this._prevLine = 0;
	        this._prevChar = 0;
	        this._data = [];
	        this._dataLen = 0;
	    }
	    push(line, char, length, tokenType, tokenModifiers) {
	        let pushLine = line;
	        let pushChar = char;
	        if (this._dataLen > 0) {
	            pushLine -= this._prevLine;
	            if (pushLine === 0) {
	                pushChar -= this._prevChar;
	            }
	        }
	        this._data[this._dataLen++] = pushLine;
	        this._data[this._dataLen++] = pushChar;
	        this._data[this._dataLen++] = length;
	        this._data[this._dataLen++] = tokenType;
	        this._data[this._dataLen++] = tokenModifiers;
	        this._prevLine = line;
	        this._prevChar = char;
	    }
	    get id() {
	        return this._id.toString();
	    }
	    previousResult(id) {
	        if (this.id === id) {
	            this._prevData = this._data;
	        }
	        this.initialize();
	    }
	    build() {
	        this._prevData = undefined;
	        return {
	            resultId: this.id,
	            data: this._data
	        };
	    }
	    canBuildEdits() {
	        return this._prevData !== undefined;
	    }
	    buildEdits() {
	        if (this._prevData !== undefined) {
	            return {
	                resultId: this.id,
	                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()
	            };
	        }
	        else {
	            return this.build();
	        }
	    }
	}
	semanticTokens.SemanticTokensBuilder = SemanticTokensBuilder;
	return semanticTokens;
}

var showDocument = {};

var hasRequiredShowDocument;

function requireShowDocument () {
	if (hasRequiredShowDocument) return showDocument;
	hasRequiredShowDocument = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(showDocument, "__esModule", { value: true });
	showDocument.ShowDocumentFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const ShowDocumentFeature = (Base) => {
	    return class extends Base {
	        showDocument(params) {
	            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
	        }
	    };
	};
	showDocument.ShowDocumentFeature = ShowDocumentFeature;
	return showDocument;
}

var fileOperations = {};

var hasRequiredFileOperations;

function requireFileOperations () {
	if (hasRequiredFileOperations) return fileOperations;
	hasRequiredFileOperations = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(fileOperations, "__esModule", { value: true });
	fileOperations.FileOperationsFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const FileOperationsFeature = (Base) => {
	    return class extends Base {
	        onDidCreateFiles(handler) {
	            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
	                handler(params);
	            });
	        }
	        onDidRenameFiles(handler) {
	            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
	                handler(params);
	            });
	        }
	        onDidDeleteFiles(handler) {
	            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
	                handler(params);
	            });
	        }
	        onWillCreateFiles(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
	                return handler(params, cancel);
	            });
	        }
	        onWillRenameFiles(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
	                return handler(params, cancel);
	            });
	        }
	        onWillDeleteFiles(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
	                return handler(params, cancel);
	            });
	        }
	    };
	};
	fileOperations.FileOperationsFeature = FileOperationsFeature;
	return fileOperations;
}

var linkedEditingRange = {};

var hasRequiredLinkedEditingRange;

function requireLinkedEditingRange () {
	if (hasRequiredLinkedEditingRange) return linkedEditingRange;
	hasRequiredLinkedEditingRange = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(linkedEditingRange, "__esModule", { value: true });
	linkedEditingRange.LinkedEditingRangeFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const LinkedEditingRangeFeature = (Base) => {
	    return class extends Base {
	        onLinkedEditingRange(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
	                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
	            });
	        }
	    };
	};
	linkedEditingRange.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
	return linkedEditingRange;
}

var typeHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredTypeHierarchy;

function requireTypeHierarchy () {
	if (hasRequiredTypeHierarchy) return typeHierarchy;
	hasRequiredTypeHierarchy = 1;
	Object.defineProperty(typeHierarchy, "__esModule", { value: true });
	typeHierarchy.TypeHierarchyFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const TypeHierarchyFeature = (Base) => {
	    return class extends Base {
	        get typeHierarchy() {
	            return {
	                onPrepare: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
	                    });
	                },
	                onSupertypes: (handler) => {
	                    const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onSubtypes: (handler) => {
	                    const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	typeHierarchy.TypeHierarchyFeature = TypeHierarchyFeature;
	return typeHierarchy;
}

var inlineValue = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredInlineValue;

function requireInlineValue () {
	if (hasRequiredInlineValue) return inlineValue;
	hasRequiredInlineValue = 1;
	Object.defineProperty(inlineValue, "__esModule", { value: true });
	inlineValue.InlineValueFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const InlineValueFeature = (Base) => {
	    return class extends Base {
	        get inlineValue() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
	                },
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params));
	                    });
	                }
	            };
	        }
	    };
	};
	inlineValue.InlineValueFeature = InlineValueFeature;
	return inlineValue;
}

var foldingRange = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredFoldingRange;

function requireFoldingRange () {
	if (hasRequiredFoldingRange) return foldingRange;
	hasRequiredFoldingRange = 1;
	Object.defineProperty(foldingRange, "__esModule", { value: true });
	foldingRange.FoldingRangeFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const FoldingRangeFeature = (Base) => {
	    return class extends Base {
	        get foldingRange() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
	                },
	                on: (handler) => {
	                    const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	foldingRange.FoldingRangeFeature = FoldingRangeFeature;
	return foldingRange;
}

var inlayHint = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredInlayHint;

function requireInlayHint () {
	if (hasRequiredInlayHint) return inlayHint;
	hasRequiredInlayHint = 1;
	Object.defineProperty(inlayHint, "__esModule", { value: true });
	inlayHint.InlayHintFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const InlayHintFeature = (Base) => {
	    return class extends Base {
	        get inlayHint() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
	                },
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params));
	                    });
	                },
	                resolve: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
	                        return handler(params, cancel);
	                    });
	                }
	            };
	        }
	    };
	};
	inlayHint.InlayHintFeature = InlayHintFeature;
	return inlayHint;
}

var diagnostic = {};

var hasRequiredDiagnostic;

function requireDiagnostic () {
	if (hasRequiredDiagnostic) return diagnostic;
	hasRequiredDiagnostic = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(diagnostic, "__esModule", { value: true });
	diagnostic.DiagnosticFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const DiagnosticFeature = (Base) => {
	    return class extends Base {
	        get diagnostics() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
	                },
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
	                    });
	                },
	                onWorkspace: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
	                    });
	                }
	            };
	        }
	    };
	};
	diagnostic.DiagnosticFeature = DiagnosticFeature;
	return diagnostic;
}

var notebook = {};

var textDocuments = {};

var hasRequiredTextDocuments;

function requireTextDocuments () {
	if (hasRequiredTextDocuments) return textDocuments;
	hasRequiredTextDocuments = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(textDocuments, "__esModule", { value: true });
	textDocuments.TextDocuments = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	/**
	 * A manager for simple text documents. The manager requires at a minimum that
	 * the server registered for the following text document sync events in the
	 * initialize handler or via dynamic registration:
	 *
	 * - open and close events.
	 * - change events.
	 *
	 * Registering for save and will save events is optional.
	 */
	class TextDocuments {
	    /**
	     * Create a new text document manager.
	     */
	    constructor(configuration) {
	        this._configuration = configuration;
	        this._syncedDocuments = new Map();
	        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
	        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been opened.
	     */
	    get onDidOpen() {
	        return this._onDidOpen.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been opened or the content changes.
	     */
	    get onDidChangeContent() {
	        return this._onDidChangeContent.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * will be saved.
	     */
	    get onWillSave() {
	        return this._onWillSave.event;
	    }
	    /**
	     * Sets a handler that will be called if a participant wants to provide
	     * edits during a text document save.
	     */
	    onWillSaveWaitUntil(handler) {
	        this._willSaveWaitUntil = handler;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been saved.
	     */
	    get onDidSave() {
	        return this._onDidSave.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been closed.
	     */
	    get onDidClose() {
	        return this._onDidClose.event;
	    }
	    /**
	     * Returns the document for the given URI. Returns undefined if
	     * the document is not managed by this instance.
	     *
	     * @param uri The text document's URI to retrieve.
	     * @return the text document or `undefined`.
	     */
	    get(uri) {
	        return this._syncedDocuments.get(uri);
	    }
	    /**
	     * Returns all text documents managed by this instance.
	     *
	     * @return all text documents.
	     */
	    all() {
	        return Array.from(this._syncedDocuments.values());
	    }
	    /**
	     * Returns the URIs of all text documents managed by this instance.
	     *
	     * @return the URI's of all text documents.
	     */
	    keys() {
	        return Array.from(this._syncedDocuments.keys());
	    }
	    /**
	     * Listens for `low level` notification on the given connection to
	     * update the text documents managed by this instance.
	     *
	     * Please note that the connection only provides handlers not an event model. Therefore
	     * listening on a connection will overwrite the following handlers on a connection:
	     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
	     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
	     *
	     * Use the corresponding events on the TextDocuments instance instead.
	     *
	     * @param connection The connection to listen on.
	     */
	    listen(connection) {
	        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
	        const disposables = [];
	        disposables.push(connection.onDidOpenTextDocument((event) => {
	            const td = event.textDocument;
	            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
	            this._syncedDocuments.set(td.uri, document);
	            const toFire = Object.freeze({ document });
	            this._onDidOpen.fire(toFire);
	            this._onDidChangeContent.fire(toFire);
	        }));
	        disposables.push(connection.onDidChangeTextDocument((event) => {
	            const td = event.textDocument;
	            const changes = event.contentChanges;
	            if (changes.length === 0) {
	                return;
	            }
	            const { version } = td;
	            if (version === null || version === undefined) {
	                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
	            }
	            let syncedDocument = this._syncedDocuments.get(td.uri);
	            if (syncedDocument !== undefined) {
	                syncedDocument = this._configuration.update(syncedDocument, changes, version);
	                this._syncedDocuments.set(td.uri, syncedDocument);
	                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
	            }
	        }));
	        disposables.push(connection.onDidCloseTextDocument((event) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined) {
	                this._syncedDocuments.delete(event.textDocument.uri);
	                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
	            }
	        }));
	        disposables.push(connection.onWillSaveTextDocument((event) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined) {
	                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
	            }
	        }));
	        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined && this._willSaveWaitUntil) {
	                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
	            }
	            else {
	                return [];
	            }
	        }));
	        disposables.push(connection.onDidSaveTextDocument((event) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined) {
	                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
	            }
	        }));
	        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
	    }
	}
	textDocuments.TextDocuments = TextDocuments;
	return textDocuments;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredNotebook;

function requireNotebook () {
	if (hasRequiredNotebook) return notebook;
	hasRequiredNotebook = 1;
	Object.defineProperty(notebook, "__esModule", { value: true });
	notebook.NotebookDocuments = notebook.NotebookSyncFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const textDocuments_1 = requireTextDocuments();
	const NotebookSyncFeature = (Base) => {
	    return class extends Base {
	        get synchronization() {
	            return {
	                onDidOpenNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                },
	                onDidChangeNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                },
	                onDidSaveNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                },
	                onDidCloseNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                }
	            };
	        }
	    };
	};
	notebook.NotebookSyncFeature = NotebookSyncFeature;
	class CellTextDocumentConnection {
	    onDidOpenTextDocument(handler) {
	        this.openHandler = handler;
	        return vscode_languageserver_protocol_1.Disposable.create(() => { this.openHandler = undefined; });
	    }
	    openTextDocument(params) {
	        this.openHandler && this.openHandler(params);
	    }
	    onDidChangeTextDocument(handler) {
	        this.changeHandler = handler;
	        return vscode_languageserver_protocol_1.Disposable.create(() => { this.changeHandler = handler; });
	    }
	    changeTextDocument(params) {
	        this.changeHandler && this.changeHandler(params);
	    }
	    onDidCloseTextDocument(handler) {
	        this.closeHandler = handler;
	        return vscode_languageserver_protocol_1.Disposable.create(() => { this.closeHandler = undefined; });
	    }
	    closeTextDocument(params) {
	        this.closeHandler && this.closeHandler(params);
	    }
	    onWillSaveTextDocument() {
	        return CellTextDocumentConnection.NULL_DISPOSE;
	    }
	    onWillSaveTextDocumentWaitUntil() {
	        return CellTextDocumentConnection.NULL_DISPOSE;
	    }
	    onDidSaveTextDocument() {
	        return CellTextDocumentConnection.NULL_DISPOSE;
	    }
	}
	CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });
	class NotebookDocuments {
	    constructor(configurationOrTextDocuments) {
	        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
	            this._cellTextDocuments = configurationOrTextDocuments;
	        }
	        else {
	            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
	        }
	        this.notebookDocuments = new Map();
	        this.notebookCellMap = new Map();
	        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
	    }
	    get cellTextDocuments() {
	        return this._cellTextDocuments;
	    }
	    getCellTextDocument(cell) {
	        return this._cellTextDocuments.get(cell.document);
	    }
	    getNotebookDocument(uri) {
	        return this.notebookDocuments.get(uri);
	    }
	    getNotebookCell(uri) {
	        const value = this.notebookCellMap.get(uri);
	        return value && value[0];
	    }
	    findNotebookDocumentForCell(cell) {
	        const key = typeof cell === 'string' ? cell : cell.document;
	        const value = this.notebookCellMap.get(key);
	        return value && value[1];
	    }
	    get onDidOpen() {
	        return this._onDidOpen.event;
	    }
	    get onDidSave() {
	        return this._onDidSave.event;
	    }
	    get onDidChange() {
	        return this._onDidChange.event;
	    }
	    get onDidClose() {
	        return this._onDidClose.event;
	    }
	    /**
	     * Listens for `low level` notification on the given connection to
	     * update the notebook documents managed by this instance.
	     *
	     * Please note that the connection only provides handlers not an event model. Therefore
	     * listening on a connection will overwrite the following handlers on a connection:
	     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
	     *  and `onDidCloseNotebookDocument`.
	     *
	     * @param connection The connection to listen on.
	     */
	    listen(connection) {
	        const cellTextDocumentConnection = new CellTextDocumentConnection();
	        const disposables = [];
	        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
	        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
	            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
	            for (const cellTextDocument of params.cellTextDocuments) {
	                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
	            }
	            this.updateCellMap(params.notebookDocument);
	            this._onDidOpen.fire(params.notebookDocument);
	        }));
	        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
	            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
	            if (notebookDocument === undefined) {
	                return;
	            }
	            notebookDocument.version = params.notebookDocument.version;
	            const oldMetadata = notebookDocument.metadata;
	            let metadataChanged = false;
	            const change = params.change;
	            if (change.metadata !== undefined) {
	                metadataChanged = true;
	                notebookDocument.metadata = change.metadata;
	            }
	            const opened = [];
	            const closed = [];
	            const data = [];
	            const text = [];
	            if (change.cells !== undefined) {
	                const changedCells = change.cells;
	                if (changedCells.structure !== undefined) {
	                    const array = changedCells.structure.array;
	                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));
	                    // Additional open cell text documents.
	                    if (changedCells.structure.didOpen !== undefined) {
	                        for (const open of changedCells.structure.didOpen) {
	                            cellTextDocumentConnection.openTextDocument({ textDocument: open });
	                            opened.push(open.uri);
	                        }
	                    }
	                    // Additional closed cell test documents.
	                    if (changedCells.structure.didClose) {
	                        for (const close of changedCells.structure.didClose) {
	                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });
	                            closed.push(close.uri);
	                        }
	                    }
	                }
	                if (changedCells.data !== undefined) {
	                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));
	                    for (let i = 0; i <= notebookDocument.cells.length; i++) {
	                        const change = cellUpdates.get(notebookDocument.cells[i].document);
	                        if (change !== undefined) {
	                            const old = notebookDocument.cells.splice(i, 1, change);
	                            data.push({ old: old[0], new: change });
	                            cellUpdates.delete(change.document);
	                            if (cellUpdates.size === 0) {
	                                break;
	                            }
	                        }
	                    }
	                }
	                if (changedCells.textContent !== undefined) {
	                    for (const cellTextDocument of changedCells.textContent) {
	                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
	                        text.push(cellTextDocument.document.uri);
	                    }
	                }
	            }
	            // Update internal data structure.
	            this.updateCellMap(notebookDocument);
	            const changeEvent = { notebookDocument };
	            if (metadataChanged) {
	                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
	            }
	            const added = [];
	            for (const open of opened) {
	                added.push(this.getNotebookCell(open));
	            }
	            const removed = [];
	            for (const close of closed) {
	                removed.push(this.getNotebookCell(close));
	            }
	            const textContent = [];
	            for (const change of text) {
	                textContent.push(this.getNotebookCell(change));
	            }
	            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
	                changeEvent.cells = { added, removed, changed: { data, textContent } };
	            }
	            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {
	                this._onDidChange.fire(changeEvent);
	            }
	        }));
	        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
	            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
	            if (notebookDocument === undefined) {
	                return;
	            }
	            this._onDidSave.fire(notebookDocument);
	        }));
	        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
	            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
	            if (notebookDocument === undefined) {
	                return;
	            }
	            this._onDidClose.fire(notebookDocument);
	            for (const cellTextDocument of params.cellTextDocuments) {
	                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
	            }
	            this.notebookDocuments.delete(params.notebookDocument.uri);
	            for (const cell of notebookDocument.cells) {
	                this.notebookCellMap.delete(cell.document);
	            }
	        }));
	        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
	    }
	    updateCellMap(notebookDocument) {
	        for (const cell of notebookDocument.cells) {
	            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
	        }
	    }
	}
	notebook.NotebookDocuments = NotebookDocuments;
	return notebook;
}

var moniker = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredMoniker;

function requireMoniker () {
	if (hasRequiredMoniker) return moniker;
	hasRequiredMoniker = 1;
	Object.defineProperty(moniker, "__esModule", { value: true });
	moniker.MonikerFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const MonikerFeature = (Base) => {
	    return class extends Base {
	        get moniker() {
	            return {
	                on: (handler) => {
	                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	            };
	        }
	    };
	};
	moniker.MonikerFeature = MonikerFeature;
	return moniker;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server;
	hasRequiredServer = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(server, "__esModule", { value: true });
	server.createConnection = server.combineFeatures = server.combineNotebooksFeatures = server.combineLanguagesFeatures = server.combineWorkspaceFeatures = server.combineWindowFeatures = server.combineClientFeatures = server.combineTracerFeatures = server.combineTelemetryFeatures = server.combineConsoleFeatures = server._NotebooksImpl = server._LanguagesImpl = server.BulkUnregistration = server.BulkRegistration = server.ErrorMessageTracker = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const Is = requireIs$2();
	const UUID = requireUuid();
	const progress_1 = requireProgress();
	const configuration_1 = requireConfiguration();
	const workspaceFolder_1 = requireWorkspaceFolder();
	const callHierarchy_1 = requireCallHierarchy();
	const semanticTokens_1 = requireSemanticTokens();
	const showDocument_1 = requireShowDocument();
	const fileOperations_1 = requireFileOperations();
	const linkedEditingRange_1 = requireLinkedEditingRange();
	const typeHierarchy_1 = requireTypeHierarchy();
	const inlineValue_1 = requireInlineValue();
	const foldingRange_1 = requireFoldingRange();
	// import { InlineCompletionFeatureShape, InlineCompletionFeature } from './inlineCompletion.proposed';
	const inlayHint_1 = requireInlayHint();
	const diagnostic_1 = requireDiagnostic();
	const notebook_1 = requireNotebook();
	const moniker_1 = requireMoniker();
	function null2Undefined(value) {
	    if (value === null) {
	        return undefined;
	    }
	    return value;
	}
	/**
	 * Helps tracking error message. Equal occurrences of the same
	 * message are only stored once. This class is for example
	 * useful if text documents are validated in a loop and equal
	 * error message should be folded into one.
	 */
	class ErrorMessageTracker {
	    constructor() {
	        this._messages = Object.create(null);
	    }
	    /**
	     * Add a message to the tracker.
	     *
	     * @param message The message to add.
	     */
	    add(message) {
	        let count = this._messages[message];
	        if (!count) {
	            count = 0;
	        }
	        count++;
	        this._messages[message] = count;
	    }
	    /**
	     * Send all tracked messages to the connection's window.
	     *
	     * @param connection The connection established between client and server.
	     */
	    sendErrors(connection) {
	        Object.keys(this._messages).forEach(message => {
	            connection.window.showErrorMessage(message);
	        });
	    }
	}
	server.ErrorMessageTracker = ErrorMessageTracker;
	class RemoteConsoleImpl {
	    constructor() {
	    }
	    rawAttach(connection) {
	        this._rawConnection = connection;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    initialize(_capabilities) {
	    }
	    error(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
	    }
	    warn(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
	    }
	    info(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
	    }
	    log(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
	    }
	    debug(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
	    }
	    send(type, message) {
	        if (this._rawConnection) {
	            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
	                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
	            });
	        }
	    }
	}
	class _RemoteWindowImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    showErrorMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	    showWarningMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	    showInformationMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	}
	const RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
	var BulkRegistration;
	(function (BulkRegistration) {
	    /**
	     * Creates a new bulk registration.
	     * @return an empty bulk registration.
	     */
	    function create() {
	        return new BulkRegistrationImpl();
	    }
	    BulkRegistration.create = create;
	})(BulkRegistration || (server.BulkRegistration = BulkRegistration = {}));
	class BulkRegistrationImpl {
	    constructor() {
	        this._registrations = [];
	        this._registered = new Set();
	    }
	    add(type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        if (this._registered.has(method)) {
	            throw new Error(`${method} is already added to this registration`);
	        }
	        const id = UUID.generateUuid();
	        this._registrations.push({
	            id: id,
	            method: method,
	            registerOptions: registerOptions || {}
	        });
	        this._registered.add(method);
	    }
	    asRegistrationParams() {
	        return {
	            registrations: this._registrations
	        };
	    }
	}
	var BulkUnregistration;
	(function (BulkUnregistration) {
	    function create() {
	        return new BulkUnregistrationImpl(undefined, []);
	    }
	    BulkUnregistration.create = create;
	})(BulkUnregistration || (server.BulkUnregistration = BulkUnregistration = {}));
	class BulkUnregistrationImpl {
	    constructor(_connection, unregistrations) {
	        this._connection = _connection;
	        this._unregistrations = new Map();
	        unregistrations.forEach(unregistration => {
	            this._unregistrations.set(unregistration.method, unregistration);
	        });
	    }
	    get isAttached() {
	        return !!this._connection;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    add(unregistration) {
	        this._unregistrations.set(unregistration.method, unregistration);
	    }
	    dispose() {
	        let unregistrations = [];
	        for (let unregistration of this._unregistrations.values()) {
	            unregistrations.push(unregistration);
	        }
	        let params = {
	            unregisterations: unregistrations
	        };
	        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
	            this._connection.console.info(`Bulk unregistration failed.`);
	        });
	    }
	    disposeSingle(arg) {
	        const method = Is.string(arg) ? arg : arg.method;
	        const unregistration = this._unregistrations.get(method);
	        if (!unregistration) {
	            return false;
	        }
	        let params = {
	            unregisterations: [unregistration]
	        };
	        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
	            this._unregistrations.delete(method);
	        }, (_error) => {
	            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
	        });
	        return true;
	    }
	}
	class RemoteClientImpl {
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
	        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
	            return this.registerMany(typeOrRegistrations);
	        }
	        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
	            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
	        }
	        else {
	            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
	        }
	    }
	    registerSingle1(unregistration, type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        const id = UUID.generateUuid();
	        let params = {
	            registrations: [{ id, method, registerOptions: registerOptions || {} }]
	        };
	        if (!unregistration.isAttached) {
	            unregistration.attach(this.connection);
	        }
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
	            unregistration.add({ id: id, method: method });
	            return unregistration;
	        }, (_error) => {
	            this.connection.console.info(`Registering request handler for ${method} failed.`);
	            return Promise.reject(_error);
	        });
	    }
	    registerSingle2(type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        const id = UUID.generateUuid();
	        let params = {
	            registrations: [{ id, method, registerOptions: registerOptions || {} }]
	        };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
	            return vscode_languageserver_protocol_1.Disposable.create(() => {
	                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });
	            });
	        }, (_error) => {
	            this.connection.console.info(`Registering request handler for ${method} failed.`);
	            return Promise.reject(_error);
	        });
	    }
	    unregisterSingle(id, method) {
	        let params = {
	            unregisterations: [{ id, method }]
	        };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
	            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
	        });
	    }
	    registerMany(registrations) {
	        let params = registrations.asRegistrationParams();
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
	            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
	        }, (_error) => {
	            this.connection.console.info(`Bulk registration failed.`);
	            return Promise.reject(_error);
	        });
	    }
	}
	class _RemoteWorkspaceImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    applyEdit(paramOrEdit) {
	        function isApplyWorkspaceEditParams(value) {
	            return value && !!value.edit;
	        }
	        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
	    }
	}
	const RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
	class TracerImpl {
	    constructor() {
	        this._trace = vscode_languageserver_protocol_1.Trace.Off;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    set trace(value) {
	        this._trace = value;
	    }
	    log(message, verbose) {
	        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
	            return;
	        }
	        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
	            message: message,
	            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
	        }).catch(() => {
	            // Very hard to decide what to do. We tried to send a log
	            // message which failed so we can't simply send another :-(.
	        });
	    }
	}
	class TelemetryImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    logEvent(data) {
	        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
	            this.connection.console.log(`Sending TelemetryEventNotification failed`);
	        });
	    }
	}
	class _LanguagesImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    attachWorkDoneProgress(params) {
	        return (0, progress_1.attachWorkDone)(this.connection, params);
	    }
	    attachPartialResultProgress(_type, params) {
	        return (0, progress_1.attachPartialResult)(this.connection, params);
	    }
	}
	server._LanguagesImpl = _LanguagesImpl;
	const LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
	class _NotebooksImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    attachWorkDoneProgress(params) {
	        return (0, progress_1.attachWorkDone)(this.connection, params);
	    }
	    attachPartialResultProgress(_type, params) {
	        return (0, progress_1.attachPartialResult)(this.connection, params);
	    }
	}
	server._NotebooksImpl = _NotebooksImpl;
	const NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
	function combineConsoleFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineConsoleFeatures = combineConsoleFeatures;
	function combineTelemetryFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineTelemetryFeatures = combineTelemetryFeatures;
	function combineTracerFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineTracerFeatures = combineTracerFeatures;
	function combineClientFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineClientFeatures = combineClientFeatures;
	function combineWindowFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineWindowFeatures = combineWindowFeatures;
	function combineWorkspaceFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineWorkspaceFeatures = combineWorkspaceFeatures;
	function combineLanguagesFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineLanguagesFeatures = combineLanguagesFeatures;
	function combineNotebooksFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server.combineNotebooksFeatures = combineNotebooksFeatures;
	function combineFeatures(one, two) {
	    function combine(one, two, func) {
	        if (one && two) {
	            return func(one, two);
	        }
	        else if (one) {
	            return one;
	        }
	        else {
	            return two;
	        }
	    }
	    let result = {
	        __brand: 'features',
	        console: combine(one.console, two.console, combineConsoleFeatures),
	        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
	        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
	        client: combine(one.client, two.client, combineClientFeatures),
	        window: combine(one.window, two.window, combineWindowFeatures),
	        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
	        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
	        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
	    };
	    return result;
	}
	server.combineFeatures = combineFeatures;
	function createConnection(connectionFactory, watchDog, factories) {
	    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
	    const connection = connectionFactory(logger);
	    logger.rawAttach(connection);
	    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
	    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
	    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
	    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
	    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
	    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
	    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());
	    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
	    function asPromise(value) {
	        if (value instanceof Promise) {
	            return value;
	        }
	        else if (Is.thenable(value)) {
	            return new Promise((resolve, reject) => {
	                value.then((resolved) => resolve(resolved), (error) => reject(error));
	            });
	        }
	        else {
	            return Promise.resolve(value);
	        }
	    }
	    let shutdownHandler = undefined;
	    let initializeHandler = undefined;
	    let exitHandler = undefined;
	    let protocolConnection = {
	        listen: () => connection.listen(),
	        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
	        onRequest: (type, handler) => connection.onRequest(type, handler),
	        sendNotification: (type, param) => {
	            const method = Is.string(type) ? type : type.method;
	            return connection.sendNotification(method, param);
	        },
	        onNotification: (type, handler) => connection.onNotification(type, handler),
	        onProgress: connection.onProgress,
	        sendProgress: connection.sendProgress,
	        onInitialize: (handler) => {
	            initializeHandler = handler;
	            return {
	                dispose: () => {
	                    initializeHandler = undefined;
	                }
	            };
	        },
	        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
	        onShutdown: (handler) => {
	            shutdownHandler = handler;
	            return {
	                dispose: () => {
	                    shutdownHandler = undefined;
	                }
	            };
	        },
	        onExit: (handler) => {
	            exitHandler = handler;
	            return {
	                dispose: () => {
	                    exitHandler = undefined;
	                }
	            };
	        },
	        get console() { return logger; },
	        get telemetry() { return telemetry; },
	        get tracer() { return tracer; },
	        get client() { return client; },
	        get window() { return remoteWindow; },
	        get workspace() { return workspace; },
	        get languages() { return languages; },
	        get notebooks() { return notebooks; },
	        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
	        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
	        __textDocumentSync: undefined,
	        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
	        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
	        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
	        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
	        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
	        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
	        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
	        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
	        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
	        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        dispose: () => connection.dispose()
	    };
	    for (let remote of allRemotes) {
	        remote.attach(protocolConnection);
	    }
	    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
	        watchDog.initialize(params);
	        if (Is.string(params.trace)) {
	            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
	        }
	        for (let remote of allRemotes) {
	            remote.initialize(params.capabilities);
	        }
	        if (initializeHandler) {
	            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);
	            return asPromise(result).then((value) => {
	                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
	                    return value;
	                }
	                let result = value;
	                if (!result) {
	                    result = { capabilities: {} };
	                }
	                let capabilities = result.capabilities;
	                if (!capabilities) {
	                    capabilities = {};
	                    result.capabilities = capabilities;
	                }
	                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
	                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
	                }
	                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
	                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
	                }
	                for (let remote of allRemotes) {
	                    remote.fillServerCapabilities(capabilities);
	                }
	                return result;
	            });
	        }
	        else {
	            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
	            for (let remote of allRemotes) {
	                remote.fillServerCapabilities(result.capabilities);
	            }
	            return result;
	        }
	    });
	    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
	        watchDog.shutdownReceived = true;
	        if (shutdownHandler) {
	            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
	        }
	        else {
	            return undefined;
	        }
	    });
	    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
	        try {
	            if (exitHandler) {
	                exitHandler();
	            }
	        }
	        finally {
	            if (watchDog.shutdownReceived) {
	                watchDog.exit(0);
	            }
	            else {
	                watchDog.exit(1);
	            }
	        }
	    });
	    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
	        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
	    });
	    return protocolConnection;
	}
	server.createConnection = createConnection;
	return server;
}

var files = {};

var hasRequiredFiles;

function requireFiles () {
	if (hasRequiredFiles) return files;
	hasRequiredFiles = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(files, "__esModule", { value: true });
	files.resolveModulePath = files.FileSystem = files.resolveGlobalYarnPath = files.resolveGlobalNodePath = files.resolve = files.uriToFilePath = void 0;
	const url = require$$0$1;
	const path = require$$1;
	const fs = require$$2$1;
	const child_process_1 = require$$3$1;
	/**
	 * @deprecated Use the `vscode-uri` npm module which provides a more
	 * complete implementation of handling VS Code URIs.
	 */
	function uriToFilePath(uri) {
	    let parsed = url.parse(uri);
	    if (parsed.protocol !== 'file:' || !parsed.path) {
	        return undefined;
	    }
	    let segments = parsed.path.split('/');
	    for (var i = 0, len = segments.length; i < len; i++) {
	        segments[i] = decodeURIComponent(segments[i]);
	    }
	    if (process.platform === 'win32' && segments.length > 1) {
	        let first = segments[0];
	        let second = segments[1];
	        // Do we have a drive letter and we started with a / which is the
	        // case if the first segement is empty (see split above)
	        if (first.length === 0 && second.length > 1 && second[1] === ':') {
	            // Remove first slash
	            segments.shift();
	        }
	    }
	    return path.normalize(segments.join('/'));
	}
	files.uriToFilePath = uriToFilePath;
	function isWindows() {
	    return process.platform === 'win32';
	}
	function resolve(moduleName, nodePath, cwd, tracer) {
	    const nodePathKey = 'NODE_PATH';
	    const app = [
	        'var p = process;',
	        'p.on(\'message\',function(m){',
	        'if(m.c===\'e\'){',
	        'p.exit(0);',
	        '}',
	        'else if(m.c===\'rs\'){',
	        'try{',
	        'var r=require.resolve(m.a);',
	        'p.send({c:\'r\',s:true,r:r});',
	        '}',
	        'catch(err){',
	        'p.send({c:\'r\',s:false});',
	        '}',
	        '}',
	        '});'
	    ].join('');
	    return new Promise((resolve, reject) => {
	        let env = process.env;
	        let newEnv = Object.create(null);
	        Object.keys(env).forEach(key => newEnv[key] = env[key]);
	        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
	            if (newEnv[nodePathKey]) {
	                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
	            }
	            else {
	                newEnv[nodePathKey] = nodePath;
	            }
	            if (tracer) {
	                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
	            }
	        }
	        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
	        try {
	            let cp = (0, child_process_1.fork)('', [], {
	                cwd: cwd,
	                env: newEnv,
	                execArgv: ['-e', app]
	            });
	            if (cp.pid === void 0) {
	                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
	                return;
	            }
	            cp.on('error', (error) => {
	                reject(error);
	            });
	            cp.on('message', (message) => {
	                if (message.c === 'r') {
	                    cp.send({ c: 'e' });
	                    if (message.s) {
	                        resolve(message.r);
	                    }
	                    else {
	                        reject(new Error(`Failed to resolve module: ${moduleName}`));
	                    }
	                }
	            });
	            let message = {
	                c: 'rs',
	                a: moduleName
	            };
	            cp.send(message);
	        }
	        catch (error) {
	            reject(error);
	        }
	    });
	}
	files.resolve = resolve;
	/**
	 * Resolve the global npm package path.
	 * @deprecated Since this depends on the used package manager and their version the best is that servers
	 * implement this themselves since they know best what kind of package managers to support.
	 * @param tracer the tracer to use
	 */
	function resolveGlobalNodePath(tracer) {
	    let npmCommand = 'npm';
	    const env = Object.create(null);
	    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
	    env['NO_UPDATE_NOTIFIER'] = 'true';
	    const options = {
	        encoding: 'utf8',
	        env
	    };
	    if (isWindows()) {
	        npmCommand = 'npm.cmd';
	        options.shell = true;
	    }
	    let handler = () => { };
	    try {
	        process.on('SIGPIPE', handler);
	        let stdout = (0, child_process_1.spawnSync)(npmCommand, ['config', 'get', 'prefix'], options).stdout;
	        if (!stdout) {
	            if (tracer) {
	                tracer(`'npm config get prefix' didn't return a value.`);
	            }
	            return undefined;
	        }
	        let prefix = stdout.trim();
	        if (tracer) {
	            tracer(`'npm config get prefix' value is: ${prefix}`);
	        }
	        if (prefix.length > 0) {
	            if (isWindows()) {
	                return path.join(prefix, 'node_modules');
	            }
	            else {
	                return path.join(prefix, 'lib', 'node_modules');
	            }
	        }
	        return undefined;
	    }
	    catch (err) {
	        return undefined;
	    }
	    finally {
	        process.removeListener('SIGPIPE', handler);
	    }
	}
	files.resolveGlobalNodePath = resolveGlobalNodePath;
	/*
	 * Resolve the global yarn pakage path.
	 * @deprecated Since this depends on the used package manager and their version the best is that servers
	 * implement this themselves since they know best what kind of package managers to support.
	 * @param tracer the tracer to use
	 */
	function resolveGlobalYarnPath(tracer) {
	    let yarnCommand = 'yarn';
	    let options = {
	        encoding: 'utf8'
	    };
	    if (isWindows()) {
	        yarnCommand = 'yarn.cmd';
	        options.shell = true;
	    }
	    let handler = () => { };
	    try {
	        process.on('SIGPIPE', handler);
	        let results = (0, child_process_1.spawnSync)(yarnCommand, ['global', 'dir', '--json'], options);
	        let stdout = results.stdout;
	        if (!stdout) {
	            if (tracer) {
	                tracer(`'yarn global dir' didn't return a value.`);
	                if (results.stderr) {
	                    tracer(results.stderr);
	                }
	            }
	            return undefined;
	        }
	        let lines = stdout.trim().split(/\r?\n/);
	        for (let line of lines) {
	            try {
	                let yarn = JSON.parse(line);
	                if (yarn.type === 'log') {
	                    return path.join(yarn.data, 'node_modules');
	                }
	            }
	            catch (e) {
	                // Do nothing. Ignore the line
	            }
	        }
	        return undefined;
	    }
	    catch (err) {
	        return undefined;
	    }
	    finally {
	        process.removeListener('SIGPIPE', handler);
	    }
	}
	files.resolveGlobalYarnPath = resolveGlobalYarnPath;
	var FileSystem;
	(function (FileSystem) {
	    let _isCaseSensitive = undefined;
	    function isCaseSensitive() {
	        if (_isCaseSensitive !== void 0) {
	            return _isCaseSensitive;
	        }
	        if (process.platform === 'win32') {
	            _isCaseSensitive = false;
	        }
	        else {
	            // convert current file name to upper case / lower case and check if file exists
	            // (guards against cases when name is already all uppercase or lowercase)
	            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
	        }
	        return _isCaseSensitive;
	    }
	    FileSystem.isCaseSensitive = isCaseSensitive;
	    function isParent(parent, child) {
	        if (isCaseSensitive()) {
	            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
	        }
	        else {
	            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
	        }
	    }
	    FileSystem.isParent = isParent;
	})(FileSystem || (files.FileSystem = FileSystem = {}));
	function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
	    if (nodePath) {
	        if (!path.isAbsolute(nodePath)) {
	            nodePath = path.join(workspaceRoot, nodePath);
	        }
	        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
	            if (FileSystem.isParent(nodePath, value)) {
	                return value;
	            }
	            else {
	                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
	            }
	        }).then(undefined, (_error) => {
	            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
	        });
	    }
	    else {
	        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
	    }
	}
	files.resolveModulePath = resolveModulePath;
	return files;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node$1;
var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1;
	hasRequiredNode$1 = 1;

	node$1 = requireMain$1();
	return node$1;
}

var api = {};

var inlineCompletion_proposed = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredInlineCompletion_proposed;

function requireInlineCompletion_proposed () {
	if (hasRequiredInlineCompletion_proposed) return inlineCompletion_proposed;
	hasRequiredInlineCompletion_proposed = 1;
	Object.defineProperty(inlineCompletion_proposed, "__esModule", { value: true });
	inlineCompletion_proposed.InlineCompletionFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$1();
	const InlineCompletionFeature = (Base) => {
	    return class extends Base {
	        get inlineCompletion() {
	            return {
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params));
	                    });
	                }
	            };
	        }
	    };
	};
	inlineCompletion_proposed.InlineCompletionFeature = InlineCompletionFeature;
	return inlineCompletion_proposed;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		var __createBinding = (api && api.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (api && api.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;
		const semanticTokens_1 = requireSemanticTokens();
		Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });
		const ic = requireInlineCompletion_proposed();
		__exportStar(requireMain$1(), exports);
		const textDocuments_1 = requireTextDocuments();
		Object.defineProperty(exports, "TextDocuments", { enumerable: true, get: function () { return textDocuments_1.TextDocuments; } });
		const notebook_1 = requireNotebook();
		Object.defineProperty(exports, "NotebookDocuments", { enumerable: true, get: function () { return notebook_1.NotebookDocuments; } });
		__exportStar(requireServer(), exports);
		var ProposedFeatures;
		(function (ProposedFeatures) {
		    ProposedFeatures.all = {
		        __brand: 'features',
		        languages: ic.InlineCompletionFeature
		    };
		})(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {})); 
	} (api));
	return api;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main$3;
	hasRequiredMain = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		/// <reference path="../../typings/thenable.d.ts" />
		var __createBinding = (main$3 && main$3.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$3 && main$3.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createConnection = exports.Files = void 0;
		const node_util_1 = require$$0$2;
		const Is = requireIs$2();
		const server_1 = requireServer();
		const fm = requireFiles();
		const node_1 = requireNode$1();
		__exportStar(requireNode$1(), exports);
		__exportStar(requireApi(), exports);
		var Files;
		(function (Files) {
		    Files.uriToFilePath = fm.uriToFilePath;
		    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
		    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
		    Files.resolve = fm.resolve;
		    Files.resolveModulePath = fm.resolveModulePath;
		})(Files || (exports.Files = Files = {}));
		function endProtocolConnection() {
		    {
		        return;
		    }
		}
		let _shutdownReceived = false;
		let exitTimer = undefined;
		function setupExitTimer() {
		    const argName = '--clientProcessId';
		    function runTimer(value) {
		        try {
		            let processId = parseInt(value);
		            if (!isNaN(processId)) {
		                exitTimer = setInterval(() => {
		                    try {
		                        process.kill(processId, 0);
		                    }
		                    catch (ex) {
		                        // Parent process doesn't exist anymore. Exit the server.
		                        endProtocolConnection();
		                        process.exit(_shutdownReceived ? 0 : 1);
		                    }
		                }, 3000);
		            }
		        }
		        catch (e) {
		            // Ignore errors;
		        }
		    }
		    for (let i = 2; i < process.argv.length; i++) {
		        let arg = process.argv[i];
		        if (arg === argName && i + 1 < process.argv.length) {
		            runTimer(process.argv[i + 1]);
		            return;
		        }
		        else {
		            let args = arg.split('=');
		            if (args[0] === argName) {
		                runTimer(args[1]);
		            }
		        }
		    }
		}
		setupExitTimer();
		const watchDog = {
		    initialize: (params) => {
		        const processId = params.processId;
		        if (Is.number(processId) && exitTimer === undefined) {
		            // We received a parent process id. Set up a timer to periodically check
		            // if the parent is still alive.
		            setInterval(() => {
		                try {
		                    process.kill(processId, 0);
		                }
		                catch (ex) {
		                    // Parent process doesn't exist anymore. Exit the server.
		                    process.exit(_shutdownReceived ? 0 : 1);
		                }
		            }, 3000);
		        }
		    },
		    get shutdownReceived() {
		        return _shutdownReceived;
		    },
		    set shutdownReceived(value) {
		        _shutdownReceived = value;
		    },
		    exit: (code) => {
		        process.exit(code);
		    }
		};
		function createConnection(arg1, arg2, arg3, arg4) {
		    let factories;
		    let input;
		    let output;
		    let options;
		    if (arg1 !== void 0 && arg1.__brand === 'features') {
		        factories = arg1;
		        arg1 = arg2;
		        arg2 = arg3;
		        arg3 = arg4;
		    }
		    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
		        options = arg1;
		    }
		    else {
		        input = arg1;
		        output = arg2;
		        options = arg3;
		    }
		    return _createConnection(input, output, options, factories);
		}
		exports.createConnection = createConnection;
		function _createConnection(input, output, options, factories) {
		    let stdio = false;
		    if (!input && !output && process.argv.length > 2) {
		        let port = void 0;
		        let pipeName = void 0;
		        let argv = process.argv.slice(2);
		        for (let i = 0; i < argv.length; i++) {
		            let arg = argv[i];
		            if (arg === '--node-ipc') {
		                input = new node_1.IPCMessageReader(process);
		                output = new node_1.IPCMessageWriter(process);
		                break;
		            }
		            else if (arg === '--stdio') {
		                stdio = true;
		                input = process.stdin;
		                output = process.stdout;
		                break;
		            }
		            else if (arg === '--socket') {
		                port = parseInt(argv[i + 1]);
		                break;
		            }
		            else if (arg === '--pipe') {
		                pipeName = argv[i + 1];
		                break;
		            }
		            else {
		                var args = arg.split('=');
		                if (args[0] === '--socket') {
		                    port = parseInt(args[1]);
		                    break;
		                }
		                else if (args[0] === '--pipe') {
		                    pipeName = args[1];
		                    break;
		                }
		            }
		        }
		        if (port) {
		            let transport = (0, node_1.createServerSocketTransport)(port);
		            input = transport[0];
		            output = transport[1];
		        }
		        else if (pipeName) {
		            let transport = (0, node_1.createServerPipeTransport)(pipeName);
		            input = transport[0];
		            output = transport[1];
		        }
		    }
		    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
		    if (!input) {
		        throw new Error('Connection input stream is not set. ' + commandLineMessage);
		    }
		    if (!output) {
		        throw new Error('Connection output stream is not set. ' + commandLineMessage);
		    }
		    // Backwards compatibility
		    if (Is.func(input.read) && Is.func(input.on)) {
		        let inputStream = input;
		        inputStream.on('end', () => {
		            process.exit(_shutdownReceived ? 0 : 1);
		        });
		        inputStream.on('close', () => {
		            process.exit(_shutdownReceived ? 0 : 1);
		        });
		    }
		    const connectionFactory = (logger) => {
		        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
		        if (stdio) {
		            patchConsole(logger);
		        }
		        return result;
		    };
		    return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
		}
		function patchConsole(logger) {
		    function serialize(args) {
		        return args.map(arg => typeof arg === 'string' ? arg : (0, node_util_1.inspect)(arg)).join(' ');
		    }
		    const counters = new Map();
		    console.assert = function assert(assertion, ...args) {
		        if (assertion) {
		            return;
		        }
		        if (args.length === 0) {
		            logger.error('Assertion failed');
		        }
		        else {
		            const [message, ...rest] = args;
		            logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
		        }
		    };
		    console.count = function count(label = 'default') {
		        const message = String(label);
		        let counter = counters.get(message) ?? 0;
		        counter += 1;
		        counters.set(message, counter);
		        logger.log(`${message}: ${message}`);
		    };
		    console.countReset = function countReset(label) {
		        if (label === undefined) {
		            counters.clear();
		        }
		        else {
		            counters.delete(String(label));
		        }
		    };
		    console.debug = function debug(...args) {
		        logger.log(serialize(args));
		    };
		    console.dir = function dir(arg, options) {
		        // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66626
		        logger.log((0, node_util_1.inspect)(arg, options));
		    };
		    console.log = function log(...args) {
		        logger.log(serialize(args));
		    };
		    console.error = function error(...args) {
		        logger.error(serialize(args));
		    };
		    console.trace = function trace(...args) {
		        const stack = new Error().stack.replace(/(.+\n){2}/, '');
		        let message = 'Trace';
		        if (args.length !== 0) {
		            message += `: ${serialize(args)}`;
		        }
		        logger.log(`${message}\n${stack}`);
		    };
		    console.warn = function warn(...args) {
		        logger.warn(serialize(args));
		    };
		} 
	} (main$3));
	return main$3;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;

	node = requireMain();
	return node;
}

var nodeExports = requireNode();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const dedent = createDedent({});
function createDedent(options) {
  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings),
      trimWhitespace = true
    } = options;

    // first, perform interpolation
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      let next = raw[i];
      if (escapeSpecialCharacters) {
        // handle escaped newlines, backticks, and interpolation characters
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
      }
      result += next;
      if (i < values.length) {
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        result += values[i];
      }
    }

    // now strip indentation
    const lines = result.split("\n");
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          // this is the first indented line
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent; // appease TypeScript
      result = lines
      // https://github.com/typescript-eslint/typescript-eslint/issues/7140
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      .map(l => l[0] === " " || l[0] === "\t" ? l.slice(m) : l).join("\n");
    }

    // dedent eats leading and trailing whitespace too
    if (trimWhitespace) {
      result = result.trim();
    }

    // handle escaped newlines at the end to ensure they don't get stripped too
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, "\n");
    }
    return result;
  }
}

let Position$2 = class Position {
    line;
    column;
    static from(position) {
        return new Position(position.line, position.column);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Location$2 = class Location {
    start;
    end;
    static from(location) {
        const start = Position$2.from(location.start);
        const end = Position$2.from(location.end);
        return new Location(start, end);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Range$2 = class Range {
    start;
    end;
    static from(range) {
        return new Range(range[0], range[1]);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Token$2 = class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range$2.from(token.range), Location$2.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/errors.ts.erb
let HerbError$2 = class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError$2(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
};
let UnexpectedError$2 = class UnexpectedError extends HerbError$2 {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── description: ${JSON.stringify(this.description)}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnexpectedTokenError$2 = class UnexpectedTokenError extends HerbError$2 {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token$2.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;
        return output;
    }
};
let MissingOpeningTagError$2 = class MissingOpeningTagError extends HerbError$2 {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            closing_tag: data.closing_tag ? Token$2.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let MissingClosingTagError$2 = class MissingClosingTagError extends HerbError$2 {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            opening_tag: data.opening_tag ? Token$2.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let TagNamesMismatchError$2 = class TagNamesMismatchError extends HerbError$2 {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            opening_tag: data.opening_tag ? Token$2.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token$2.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let QuotesMismatchError$2 = class QuotesMismatchError extends HerbError$2 {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            opening_quote: data.opening_quote ? Token$2.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token$2.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
        output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;
        return output;
    }
};
let VoidElementClosingTagError$2 = class VoidElementClosingTagError extends HerbError$2 {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            tag_name: data.tag_name ? Token$2.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnclosedElementError$2 = class UnclosedElementError extends HerbError$2 {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            opening_tag: data.opening_tag ? Token$2.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let RubyParseError$2 = class RubyParseError extends HerbError$2 {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location$2.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
        output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += `└── level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
};
function fromSerializedError$2(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError$2.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError$2.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError$2.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError$2.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError$2.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError$2.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError$2.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError$2.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError$2.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}
function convertToUTF8$2(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/nodes.ts.erb
let Node$2 = class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode$2(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "∅\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length == 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError$2) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "│   ", isLast, false);
            }
            else {
                const symbol = isLast ? "└── " : "├── ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "∅\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? "└── " : "├── ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index == 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
};
let DocumentNode$2 = class DocumentNode extends Node$2 {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let LiteralNode$2 = class LiteralNode extends Node$2 {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$2(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
};
let HTMLOpenTagNode$2 = class HTMLOpenTagNode extends Node$2 {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$2.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
};
let HTMLCloseTagNode$2 = class HTMLCloseTagNode extends Node$2 {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$2.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let HTMLElementNode$2 = class HTMLElementNode extends Node$2 {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            open_tag: data.open_tag ? fromSerializedNode$2((data.open_tag)) : null,
            tag_name: data.tag_name ? Token$2.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode$2(node)),
            close_tag: data.close_tag ? fromSerializedNode$2((data.close_tag)) : null,
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
};
let HTMLAttributeValueNode$2 = class HTMLAttributeValueNode extends Node$2 {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            open_quote: data.open_quote ? Token$2.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            close_quote: data.close_quote ? Token$2.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
        output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;
        return output;
    }
};
let HTMLAttributeNameNode$2 = class HTMLAttributeNameNode extends Node$2 {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let HTMLAttributeNode$2 = class HTMLAttributeNode extends Node$2 {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            name: data.name ? fromSerializedNode$2((data.name)) : null,
            equals: data.equals ? Token$2.from(data.equals) : null,
            value: data.value ? fromSerializedNode$2((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
        output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
        output += `└── value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
};
let HTMLTextNode$2 = class HTMLTextNode extends Node$2 {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$2(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
};
let HTMLCommentNode$2 = class HTMLCommentNode extends Node$2 {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            comment_start: data.comment_start ? Token$2.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            comment_end: data.comment_end ? Token$2.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;
        return output;
    }
};
let HTMLDoctypeNode$2 = class HTMLDoctypeNode extends Node$2 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let XMLDeclarationNode$2 = class XMLDeclarationNode extends Node$2 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let CDATANode$2 = class CDATANode extends Node$2 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let WhitespaceNode$2 = class WhitespaceNode extends Node$2 {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            value: data.value ? Token$2.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;
        return output;
    }
};
let ERBContentNode$2 = class ERBContentNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        // no-op for analyzed_ruby
        output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
        output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;
        return output;
    }
};
let ERBEndNode$2 = class ERBEndNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let ERBElseNode$2 = class ERBElseNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBIfNode$2 = class ERBIfNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            subsequent: data.subsequent ? fromSerializedNode$2((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBBlockNode$2 = class ERBBlockNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode$2(node)),
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhenNode$2 = class ERBWhenNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBCaseNode$2 = class ERBCaseNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$2(node)),
            else_clause: data.else_clause ? fromSerializedNode$2((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBCaseMatchNode$2 = class ERBCaseMatchNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$2(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$2(node)),
            else_clause: data.else_clause ? fromSerializedNode$2((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhileNode$2 = class ERBWhileNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUntilNode$2 = class ERBUntilNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBForNode$2 = class ERBForNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBRescueNode$2 = class ERBRescueNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            subsequent: data.subsequent ? fromSerializedNode$2((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
};
let ERBEnsureNode$2 = class ERBEnsureNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBBeginNode$2 = class ERBBeginNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode$2((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode$2((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode$2((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUnlessNode$2 = class ERBUnlessNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
            else_clause: data.else_clause ? fromSerializedNode$2((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$2((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBYieldNode$2 = class ERBYieldNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let ERBInNode$2 = class ERBInNode extends Node$2 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location$2.from(data.location),
            errors: (data.errors || []).map(error => HerbError$2.from(error)),
            tag_opening: data.tag_opening ? Token$2.from(data.tag_opening) : null,
            content: data.content ? Token$2.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$2.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$2(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
function fromSerializedNode$2(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode$2.from(node);
        case "AST_LITERAL_NODE": return LiteralNode$2.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode$2.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode$2.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode$2.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode$2.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode$2.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode$2.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode$2.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode$2.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode$2.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode$2.from(node);
        case "AST_CDATA_NODE": return CDATANode$2.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode$2.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode$2.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode$2.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode$2.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode$2.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode$2.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode$2.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode$2.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode$2.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode$2.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode$2.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode$2.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode$2.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode$2.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode$2.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode$2.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode$2.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode$2.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

let Result$2 = class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
};

let HerbWarning$2 = class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location$2.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
};

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
let ParseResult$2 = class ParseResult extends Result$2 {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode$2.from(result.value), result.source, result.warnings.map((warning) => HerbWarning$2.from(warning)), result.errors.map((error) => HerbError$2.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
};

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/node-type-guards.ts.erb
/**
 * Type guard functions for AST nodes.
 * These functions provide type checking by combining both instanceof
 * checks and type string comparisons for maximum reliability across different
 * runtime scenarios (e.g., serialized/deserialized nodes).
 */
/**
 * Checks if a node is a DocumentNode
 */
function isDocumentNode$1(node) {
    return node instanceof DocumentNode$2 || node.type === "AST_DOCUMENT_NODE" || node.constructor.type === "AST_DOCUMENT_NODE";
}
/**
 * Checks if a node is a LiteralNode
 */
function isLiteralNode$1(node) {
    return node instanceof LiteralNode$2 || node.type === "AST_LITERAL_NODE" || node.constructor.type === "AST_LITERAL_NODE";
}
/**
 * Checks if a node is a HTMLOpenTagNode
 */
function isHTMLOpenTagNode$1(node) {
    return node instanceof HTMLOpenTagNode$2 || node.type === "AST_HTML_OPEN_TAG_NODE" || node.constructor.type === "AST_HTML_OPEN_TAG_NODE";
}
/**
 * Checks if a node is a HTMLCloseTagNode
 */
function isHTMLCloseTagNode$1(node) {
    return node instanceof HTMLCloseTagNode$2 || node.type === "AST_HTML_CLOSE_TAG_NODE" || node.constructor.type === "AST_HTML_CLOSE_TAG_NODE";
}
/**
 * Checks if a node is a HTMLElementNode
 */
function isHTMLElementNode$1(node) {
    return node instanceof HTMLElementNode$2 || node.type === "AST_HTML_ELEMENT_NODE" || node.constructor.type === "AST_HTML_ELEMENT_NODE";
}
/**
 * Checks if a node is a HTMLAttributeValueNode
 */
function isHTMLAttributeValueNode$1(node) {
    return node instanceof HTMLAttributeValueNode$2 || node.type === "AST_HTML_ATTRIBUTE_VALUE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNameNode
 */
function isHTMLAttributeNameNode$1(node) {
    return node instanceof HTMLAttributeNameNode$2 || node.type === "AST_HTML_ATTRIBUTE_NAME_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NAME_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNode
 */
function isHTMLAttributeNode$1(node) {
    return node instanceof HTMLAttributeNode$2 || node.type === "AST_HTML_ATTRIBUTE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NODE";
}
/**
 * Checks if a node is a HTMLTextNode
 */
function isHTMLTextNode$1(node) {
    return node instanceof HTMLTextNode$2 || node.type === "AST_HTML_TEXT_NODE" || node.constructor.type === "AST_HTML_TEXT_NODE";
}
/**
 * Checks if a node is a HTMLCommentNode
 */
function isHTMLCommentNode$1(node) {
    return node instanceof HTMLCommentNode$2 || node.type === "AST_HTML_COMMENT_NODE" || node.constructor.type === "AST_HTML_COMMENT_NODE";
}
/**
 * Checks if a node is a HTMLDoctypeNode
 */
function isHTMLDoctypeNode$1(node) {
    return node instanceof HTMLDoctypeNode$2 || node.type === "AST_HTML_DOCTYPE_NODE" || node.constructor.type === "AST_HTML_DOCTYPE_NODE";
}
/**
 * Checks if a node is a XMLDeclarationNode
 */
function isXMLDeclarationNode$1(node) {
    return node instanceof XMLDeclarationNode$2 || node.type === "AST_XML_DECLARATION_NODE" || node.constructor.type === "AST_XML_DECLARATION_NODE";
}
/**
 * Checks if a node is a CDATANode
 */
function isCDATANode$1(node) {
    return node instanceof CDATANode$2 || node.type === "AST_CDATA_NODE" || node.constructor.type === "AST_CDATA_NODE";
}
/**
 * Checks if a node is a WhitespaceNode
 */
function isWhitespaceNode$1(node) {
    return node instanceof WhitespaceNode$2 || node.type === "AST_WHITESPACE_NODE" || node.constructor.type === "AST_WHITESPACE_NODE";
}
/**
 * Checks if a node is a ERBContentNode
 */
function isERBContentNode$1(node) {
    return node instanceof ERBContentNode$2 || node.type === "AST_ERB_CONTENT_NODE" || node.constructor.type === "AST_ERB_CONTENT_NODE";
}
/**
 * Checks if a node is a ERBEndNode
 */
function isERBEndNode$1(node) {
    return node instanceof ERBEndNode$2 || node.type === "AST_ERB_END_NODE" || node.constructor.type === "AST_ERB_END_NODE";
}
/**
 * Checks if a node is a ERBElseNode
 */
function isERBElseNode$1(node) {
    return node instanceof ERBElseNode$2 || node.type === "AST_ERB_ELSE_NODE" || node.constructor.type === "AST_ERB_ELSE_NODE";
}
/**
 * Checks if a node is a ERBIfNode
 */
function isERBIfNode$1(node) {
    return node instanceof ERBIfNode$2 || node.type === "AST_ERB_IF_NODE" || node.constructor.type === "AST_ERB_IF_NODE";
}
/**
 * Checks if a node is a ERBBlockNode
 */
function isERBBlockNode$1(node) {
    return node instanceof ERBBlockNode$2 || node.type === "AST_ERB_BLOCK_NODE" || node.constructor.type === "AST_ERB_BLOCK_NODE";
}
/**
 * Checks if a node is a ERBWhenNode
 */
function isERBWhenNode$1(node) {
    return node instanceof ERBWhenNode$2 || node.type === "AST_ERB_WHEN_NODE" || node.constructor.type === "AST_ERB_WHEN_NODE";
}
/**
 * Checks if a node is a ERBCaseNode
 */
function isERBCaseNode$1(node) {
    return node instanceof ERBCaseNode$2 || node.type === "AST_ERB_CASE_NODE" || node.constructor.type === "AST_ERB_CASE_NODE";
}
/**
 * Checks if a node is a ERBCaseMatchNode
 */
function isERBCaseMatchNode$1(node) {
    return node instanceof ERBCaseMatchNode$2 || node.type === "AST_ERB_CASE_MATCH_NODE" || node.constructor.type === "AST_ERB_CASE_MATCH_NODE";
}
/**
 * Checks if a node is a ERBWhileNode
 */
function isERBWhileNode$1(node) {
    return node instanceof ERBWhileNode$2 || node.type === "AST_ERB_WHILE_NODE" || node.constructor.type === "AST_ERB_WHILE_NODE";
}
/**
 * Checks if a node is a ERBUntilNode
 */
function isERBUntilNode$1(node) {
    return node instanceof ERBUntilNode$2 || node.type === "AST_ERB_UNTIL_NODE" || node.constructor.type === "AST_ERB_UNTIL_NODE";
}
/**
 * Checks if a node is a ERBForNode
 */
function isERBForNode$1(node) {
    return node instanceof ERBForNode$2 || node.type === "AST_ERB_FOR_NODE" || node.constructor.type === "AST_ERB_FOR_NODE";
}
/**
 * Checks if a node is a ERBRescueNode
 */
function isERBRescueNode$1(node) {
    return node instanceof ERBRescueNode$2 || node.type === "AST_ERB_RESCUE_NODE" || node.constructor.type === "AST_ERB_RESCUE_NODE";
}
/**
 * Checks if a node is a ERBEnsureNode
 */
function isERBEnsureNode$1(node) {
    return node instanceof ERBEnsureNode$2 || node.type === "AST_ERB_ENSURE_NODE" || node.constructor.type === "AST_ERB_ENSURE_NODE";
}
/**
 * Checks if a node is a ERBBeginNode
 */
function isERBBeginNode$1(node) {
    return node instanceof ERBBeginNode$2 || node.type === "AST_ERB_BEGIN_NODE" || node.constructor.type === "AST_ERB_BEGIN_NODE";
}
/**
 * Checks if a node is a ERBUnlessNode
 */
function isERBUnlessNode$1(node) {
    return node instanceof ERBUnlessNode$2 || node.type === "AST_ERB_UNLESS_NODE" || node.constructor.type === "AST_ERB_UNLESS_NODE";
}
/**
 * Checks if a node is a ERBYieldNode
 */
function isERBYieldNode$1(node) {
    return node instanceof ERBYieldNode$2 || node.type === "AST_ERB_YIELD_NODE" || node.constructor.type === "AST_ERB_YIELD_NODE";
}
/**
 * Checks if a node is a ERBInNode
 */
function isERBInNode$1(node) {
    return node instanceof ERBInNode$2 || node.type === "AST_ERB_IN_NODE" || node.constructor.type === "AST_ERB_IN_NODE";
}
/**
 * Checks if a node is any ERB node type
 */
function isERBNode$1(node) {
    return isERBContentNode$1(node) ||
        isERBEndNode$1(node) ||
        isERBElseNode$1(node) ||
        isERBIfNode$1(node) ||
        isERBBlockNode$1(node) ||
        isERBWhenNode$1(node) ||
        isERBCaseNode$1(node) ||
        isERBCaseMatchNode$1(node) ||
        isERBWhileNode$1(node) ||
        isERBUntilNode$1(node) ||
        isERBForNode$1(node) ||
        isERBRescueNode$1(node) ||
        isERBEnsureNode$1(node) ||
        isERBBeginNode$1(node) ||
        isERBUnlessNode$1(node) ||
        isERBYieldNode$1(node) ||
        isERBInNode$1(node);
}
/**
 * Map of node classes to their corresponding type guard functions
 *
 * @example
 * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const NODE_TYPE_GUARDS$1 = new Map([
    [DocumentNode$2, isDocumentNode$1],
    [LiteralNode$2, isLiteralNode$1],
    [HTMLOpenTagNode$2, isHTMLOpenTagNode$1],
    [HTMLCloseTagNode$2, isHTMLCloseTagNode$1],
    [HTMLElementNode$2, isHTMLElementNode$1],
    [HTMLAttributeValueNode$2, isHTMLAttributeValueNode$1],
    [HTMLAttributeNameNode$2, isHTMLAttributeNameNode$1],
    [HTMLAttributeNode$2, isHTMLAttributeNode$1],
    [HTMLTextNode$2, isHTMLTextNode$1],
    [HTMLCommentNode$2, isHTMLCommentNode$1],
    [HTMLDoctypeNode$2, isHTMLDoctypeNode$1],
    [XMLDeclarationNode$2, isXMLDeclarationNode$1],
    [CDATANode$2, isCDATANode$1],
    [WhitespaceNode$2, isWhitespaceNode$1],
    [ERBContentNode$2, isERBContentNode$1],
    [ERBEndNode$2, isERBEndNode$1],
    [ERBElseNode$2, isERBElseNode$1],
    [ERBIfNode$2, isERBIfNode$1],
    [ERBBlockNode$2, isERBBlockNode$1],
    [ERBWhenNode$2, isERBWhenNode$1],
    [ERBCaseNode$2, isERBCaseNode$1],
    [ERBCaseMatchNode$2, isERBCaseMatchNode$1],
    [ERBWhileNode$2, isERBWhileNode$1],
    [ERBUntilNode$2, isERBUntilNode$1],
    [ERBForNode$2, isERBForNode$1],
    [ERBRescueNode$2, isERBRescueNode$1],
    [ERBEnsureNode$2, isERBEnsureNode$1],
    [ERBBeginNode$2, isERBBeginNode$1],
    [ERBUnlessNode$2, isERBUnlessNode$1],
    [ERBYieldNode$2, isERBYieldNode$1],
    [ERBInNode$2, isERBInNode$1],
]);
/**
 * Map of AST node type strings to their corresponding type guard functions
 *
 * @example
 * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const AST_TYPE_GUARDS$1 = new Map([
    ["AST_DOCUMENT_NODE", isDocumentNode$1],
    ["AST_LITERAL_NODE", isLiteralNode$1],
    ["AST_HTML_OPEN_TAG_NODE", isHTMLOpenTagNode$1],
    ["AST_HTML_CLOSE_TAG_NODE", isHTMLCloseTagNode$1],
    ["AST_HTML_ELEMENT_NODE", isHTMLElementNode$1],
    ["AST_HTML_ATTRIBUTE_VALUE_NODE", isHTMLAttributeValueNode$1],
    ["AST_HTML_ATTRIBUTE_NAME_NODE", isHTMLAttributeNameNode$1],
    ["AST_HTML_ATTRIBUTE_NODE", isHTMLAttributeNode$1],
    ["AST_HTML_TEXT_NODE", isHTMLTextNode$1],
    ["AST_HTML_COMMENT_NODE", isHTMLCommentNode$1],
    ["AST_HTML_DOCTYPE_NODE", isHTMLDoctypeNode$1],
    ["AST_XML_DECLARATION_NODE", isXMLDeclarationNode$1],
    ["AST_CDATA_NODE", isCDATANode$1],
    ["AST_WHITESPACE_NODE", isWhitespaceNode$1],
    ["AST_ERB_CONTENT_NODE", isERBContentNode$1],
    ["AST_ERB_END_NODE", isERBEndNode$1],
    ["AST_ERB_ELSE_NODE", isERBElseNode$1],
    ["AST_ERB_IF_NODE", isERBIfNode$1],
    ["AST_ERB_BLOCK_NODE", isERBBlockNode$1],
    ["AST_ERB_WHEN_NODE", isERBWhenNode$1],
    ["AST_ERB_CASE_NODE", isERBCaseNode$1],
    ["AST_ERB_CASE_MATCH_NODE", isERBCaseMatchNode$1],
    ["AST_ERB_WHILE_NODE", isERBWhileNode$1],
    ["AST_ERB_UNTIL_NODE", isERBUntilNode$1],
    ["AST_ERB_FOR_NODE", isERBForNode$1],
    ["AST_ERB_RESCUE_NODE", isERBRescueNode$1],
    ["AST_ERB_ENSURE_NODE", isERBEnsureNode$1],
    ["AST_ERB_BEGIN_NODE", isERBBeginNode$1],
    ["AST_ERB_UNLESS_NODE", isERBUnlessNode$1],
    ["AST_ERB_YIELD_NODE", isERBYieldNode$1],
    ["AST_ERB_IN_NODE", isERBInNode$1],
]);
/**
 * Checks if a node matches any of the provided type identifiers with proper type narrowing
 * Supports AST type strings, node classes, or type guard functions
 *
 * @example
 * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 *
 * @example
 * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 */
function isAnyOf$1(node, ...types) {
    return types.some(type => {
        if (typeof type === 'string') {
            return isNode$1(node, type);
        }
        else if (typeof type === 'function' && type.prototype && type.prototype.constructor === type && NODE_TYPE_GUARDS$1.has(type)) {
            return isNode$1(node, type);
        }
        else if (typeof type === 'function') {
            return type(node);
        }
        else {
            return false;
        }
    });
}
/**
 * Checks if a node does NOT match any of the provided type identifiers
 * Supports AST type strings, node classes, or type guard functions
 * This is the logical inverse of isAnyOf
 *
 * @example
 * if (isNoneOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 *
 * @example
 * if (isNoneOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 *
 * @example
 * if (isNoneOf(node, isHTMLTextNode, isLiteralNode)) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 */
function isNoneOf(node, ...types) {
    return !isAnyOf$1(node, ...types);
}
function filterNodes$1(nodes, ...types) {
    if (!nodes)
        return [];
    return nodes.filter(node => isAnyOf$1(node, ...types));
}
function isNode$1(node, type) {
    if (!node)
        return false;
    if (typeof type === 'string') {
        const guard = AST_TYPE_GUARDS$1.get(type);
        return guard ? guard(node) : false;
    }
    else if (typeof type === 'function') {
        const guard = NODE_TYPE_GUARDS$1.get(type);
        return guard ? guard(node) : false;
    }
    else {
        return false;
    }
}
function isToken$1(object) {
    return (object instanceof Token$2) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
}
function isParseResult$1(object) {
    return (object instanceof ParseResult$2) || (object?.constructor?.name === "ParseResult" && "value" in object);
}

/**
 * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
 */
function isERBOutputNode$1(node) {
    return isNode$1(node, ERBContentNode$2) && ["<%=", "<%=="].includes(node.tag_opening?.value);
}
/**
 * Checks if a node is a non-output ERB node (control flow: <% %>)
 */
function isERBControlFlowNode(node) {
    return isAnyOf$1(node, ERBIfNode$2, ERBUnlessNode$2, ERBBlockNode$2, ERBCaseNode$2, ERBCaseMatchNode$2, ERBWhileNode$2, ERBForNode$2, ERBBeginNode$2);
}
/**
 * Checks if an array of nodes contains any ERB output nodes (dynamic content)
 */
function hasERBOutput$1(nodes) {
    return nodes.some(isERBOutputNode$1);
}
/**
 * Extracts a combined string from nodes, including ERB content
 * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
 * This is useful for debugging or displaying the full attribute name
 */
function getCombinedStringFromNodes$1(nodes) {
    return nodes.map(node => {
        if (isLiteralNode$1(node)) {
            return node.content;
        }
        else if (isERBContentNode$1(node)) {
            const opening = node.tag_opening?.value || "";
            const content = node.content?.value || "";
            const closing = node.tag_closing?.value || "";
            return `${opening}${content}${closing}`;
        }
        else {
            // For other node types, return a placeholder or empty string
            return `[${node.type}]`;
        }
    }).join("");
}
/**
 * Gets the combined string representation of an HTML attribute name node
 * This includes both static and dynamic content, useful for debugging
 */
function getCombinedAttributeName$1(attributeNameNode) {
    if (!attributeNameNode.children) {
        return "";
    }
    return getCombinedStringFromNodes$1(attributeNameNode.children);
}
/**
 * Gets the tag name of an HTML element node
 */
function getTagName$2(node) {
    return node.tag_name?.value ?? "";
}
/**
 * Check if a node is a comment (HTML comment or ERB comment)
 */
function isCommentNode(node) {
    return isNode$1(node, HTMLCommentNode$2) || (isERBNode$1(node) && !isERBControlFlowNode(node));
}
/**
 * Compares two positions to determine if the first comes before the second
 * Returns true if pos1 comes before pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionBefore$1(position1, position2, inclusive = false) {
    if (position1.line < position2.line)
        return true;
    if (position1.line > position2.line)
        return false;
    return inclusive ? position1.column <= position2.column : position1.column < position2.column;
}
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionAfter$1(position1, position2, inclusive = false) {
    if (position1.line > position2.line)
        return true;
    if (position1.line < position2.line)
        return false;
    return inclusive ? position1.column >= position2.column : position1.column > position2.column;
}
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
function getNodesBeforePosition$1(nodes, position, inclusive = false) {
    return nodes.filter(node => node.location && isPositionBefore$1(node.location.end, position, inclusive));
}
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
function getNodesAfterPosition$1(nodes, position, inclusive = true) {
    return nodes.filter(node => node.location && isPositionAfter$1(node.location.start, position, inclusive));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/visitor.ts.erb
let Visitor$2 = class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitDocumentNode(node) {
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitChildNodes(node);
    }
};

let PrintContext$1 = class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
};

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS$1 = {
    ignoreErrors: false
};
let Printer$1 = class Printer extends Visitor$2 {
    context = new PrintContext$1();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS$1) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS$1) {
        if (isToken$1(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult$1(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
};

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
let IdentityPrinter$1 = class IdentityPrinter extends Printer$1 {
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition$1(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition$1(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
};

({
    ...DEFAULT_PRINT_OPTIONS$1});

// TODO: we can probably expand this list with more tags/attributes
const FORMATTABLE_ATTRIBUTES = {
    '*': ['class'],
    'img': ['srcset', 'sizes']
};
/**
 * Printer traverses the Herb AST using the Visitor pattern
 * and emits a formatted string with proper indentation, line breaks, and attribute wrapping.
 */
class FormatPrinter extends Printer$1 {
    /**
     * @deprecated integrate indentWidth into this.options and update FormatOptions to extend from @herb-tools/printer options
     */
    indentWidth;
    /**
     * @deprecated integrate maxLineLength into this.options and update FormatOptions to extend from @herb-tools/printer options
     */
    maxLineLength;
    /**
     * @deprecated refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
     */
    lines = [];
    indentLevel = 0;
    inlineMode = false;
    currentAttributeName = null;
    elementStack = [];
    elementFormattingAnalysis = new Map();
    source;
    // TODO: extract
    static INLINE_ELEMENTS = new Set([
        'a', 'abbr', 'acronym', 'b', 'bdo', 'big', 'br', 'cite', 'code',
        'dfn', 'em', 'i', 'img', 'kbd', 'label', 'map', 'object', 'q',
        'samp', 'small', 'span', 'strong', 'sub', 'sup',
        'tt', 'var', 'del', 'ins', 'mark', 's', 'u', 'time', 'wbr'
    ]);
    static CONTENT_PRESERVING_ELEMENTS = new Set([
        'script', 'style', 'pre', 'textarea'
    ]);
    static SPACEABLE_CONTAINERS = new Set([
        'div', 'section', 'article', 'main', 'header', 'footer', 'aside',
        'figure', 'details', 'summary', 'dialog', 'fieldset'
    ]);
    static TIGHT_GROUP_PARENTS = new Set([
        'ul', 'ol', 'nav', 'select', 'datalist', 'optgroup', 'tr', 'thead',
        'tbody', 'tfoot'
    ]);
    static TIGHT_GROUP_CHILDREN = new Set([
        'li', 'option', 'td', 'th', 'dt', 'dd'
    ]);
    static SPACING_THRESHOLD = 3;
    constructor(source, options) {
        super();
        this.source = source;
        this.indentWidth = options.indentWidth;
        this.maxLineLength = options.maxLineLength;
    }
    print(input) {
        if (isToken$1(input))
            return input.value;
        const node = isParseResult$1(input) ? input.value : input;
        // TODO: refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
        this.lines = [];
        this.indentLevel = 0;
        this.visit(node);
        return this.lines.join("\n");
    }
    /**
     * Get the current element (top of stack)
     */
    get currentElement() {
        return this.elementStack.length > 0 ? this.elementStack[this.elementStack.length - 1] : null;
    }
    /**
     * Get the current tag name from the current element context
     */
    get currentTagName() {
        return this.currentElement?.open_tag?.tag_name?.value ?? "";
    }
    /**
     * Append text to the last line instead of creating a new line
     */
    pushToLastLine(text) {
        if (this.lines.length > 0) {
            this.lines[this.lines.length - 1] += text;
        }
        else {
            this.lines.push(text);
        }
    }
    /**
     * Capture output from a callback into a separate lines array
     * Useful for testing what output would be generated without affecting the main output
     */
    capture(callback) {
        const previousLines = this.lines;
        const previousInlineMode = this.inlineMode;
        this.lines = [];
        try {
            callback();
            return this.lines;
        }
        finally {
            this.lines = previousLines;
            this.inlineMode = previousInlineMode;
        }
    }
    /**
     * Capture all nodes that would be visited during a callback
     * Returns a flat list of all nodes without generating any output
     */
    captureNodes(callback) {
        const capturedNodes = [];
        const previousLines = this.lines;
        const previousInlineMode = this.inlineMode;
        const originalPush = this.push.bind(this);
        const originalPushToLastLine = this.pushToLastLine.bind(this);
        const originalVisit = this.visit.bind(this);
        this.lines = [];
        this.push = () => { };
        this.pushToLastLine = () => { };
        this.visit = (node) => {
            capturedNodes.push(node);
            originalVisit(node);
        };
        try {
            callback();
            return capturedNodes;
        }
        finally {
            this.lines = previousLines;
            this.inlineMode = previousInlineMode;
            this.push = originalPush;
            this.pushToLastLine = originalPushToLastLine;
            this.visit = originalVisit;
        }
    }
    /**
     * @deprecated refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
     */
    push(line) {
        this.lines.push(line);
    }
    /**
     * @deprecated refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
     */
    pushWithIndent(line) {
        const indent = line.trim() === "" ? "" : this.indent;
        this.push(indent + line);
    }
    withIndent(callback) {
        this.indentLevel++;
        const result = callback();
        this.indentLevel--;
        return result;
    }
    get indent() {
        return " ".repeat(this.indentLevel * this.indentWidth);
    }
    /**
     * Format ERB content with proper spacing around the inner content.
     * Returns empty string if content is empty, otherwise wraps content with single spaces.
     */
    formatERBContent(content) {
        return content.trim() ? ` ${content.trim()} ` : "";
    }
    /**
     * Count total attributes including those inside ERB conditionals
     */
    getTotalAttributeCount(attributes, inlineNodes = []) {
        let totalAttributeCount = attributes.length;
        inlineNodes.forEach(node => {
            if (isERBControlFlowNode(node)) {
                const capturedNodes = this.captureNodes(() => this.visit(node));
                const attributeNodes = filterNodes$1(capturedNodes, HTMLAttributeNode$2);
                totalAttributeCount += attributeNodes.length;
            }
        });
        return totalAttributeCount;
    }
    /**
     * Extract inline nodes (non-attribute, non-whitespace) from a list of nodes
     */
    extractInlineNodes(nodes) {
        return nodes.filter(child => isNoneOf(child, HTMLAttributeNode$2, WhitespaceNode$2));
    }
    /**
     * Determine if spacing should be added between sibling elements
     *
     * This implements the "rule of three" intelligent spacing system:
     * - Adds spacing between 3 or more meaningful siblings
     * - Respects semantic groupings (e.g., ul/li, nav/a stay tight)
     * - Groups comments with following elements
     * - Preserves user-added spacing
     *
     * @param parentElement - The parent element containing the siblings
     * @param siblings - Array of all sibling nodes
     * @param currentIndex - Index of the current node being evaluated
     * @param hasExistingSpacing - Whether user-added spacing already exists
     * @returns true if spacing should be added before the current element
     */
    shouldAddSpacingBetweenSiblings(parentElement, siblings, currentIndex, hasExistingSpacing) {
        if (hasExistingSpacing) {
            return true;
        }
        const hasMixedContent = siblings.some(child => isNode$1(child, HTMLTextNode$2) && child.content.trim() !== "");
        if (hasMixedContent) {
            return false;
        }
        const meaningfulSiblings = siblings.filter(child => this.isNonWhitespaceNode(child));
        if (meaningfulSiblings.length < FormatPrinter.SPACING_THRESHOLD) {
            return false;
        }
        const parentTagName = parentElement ? getTagName$2(parentElement) : null;
        if (parentTagName && FormatPrinter.TIGHT_GROUP_PARENTS.has(parentTagName)) {
            return false;
        }
        const isSpaceableContainer = !parentTagName || (parentTagName && FormatPrinter.SPACEABLE_CONTAINERS.has(parentTagName));
        if (!isSpaceableContainer && meaningfulSiblings.length < 5) {
            return false;
        }
        const currentNode = siblings[currentIndex];
        const previousMeaningfulIndex = this.findPreviousMeaningfulSibling(siblings, currentIndex);
        const isCurrentComment = isCommentNode(currentNode);
        if (previousMeaningfulIndex !== -1) {
            const previousNode = siblings[previousMeaningfulIndex];
            const isPreviousComment = isCommentNode(previousNode);
            if (isPreviousComment && !isCurrentComment && (isNode$1(currentNode, HTMLElementNode$2) || isERBNode$1(currentNode))) {
                return false;
            }
            if (isPreviousComment && isCurrentComment) {
                return false;
            }
        }
        if (isNode$1(currentNode, HTMLElementNode$2)) {
            const currentTagName = getTagName$2(currentNode);
            if (FormatPrinter.INLINE_ELEMENTS.has(currentTagName)) {
                return false;
            }
            if (FormatPrinter.TIGHT_GROUP_CHILDREN.has(currentTagName)) {
                return false;
            }
            if (currentTagName === 'a' && parentTagName === 'nav') {
                return false;
            }
        }
        const isBlockElement = this.isBlockLevelNode(currentNode);
        const isERBBlock = isERBNode$1(currentNode) && isERBControlFlowNode(currentNode);
        const isComment = isCommentNode(currentNode);
        return isBlockElement || isERBBlock || isComment;
    }
    /**
     * Token list attributes that contain space-separated values and benefit from
     * spacing around ERB content for readability
     */
    static TOKEN_LIST_ATTRIBUTES = new Set([
        'class', 'data-controller', 'data-action'
    ]);
    /**
     * Check if we're currently processing a token list attribute that needs spacing
     */
    isInTokenListAttribute() {
        return this.currentAttributeName !== null &&
            FormatPrinter.TOKEN_LIST_ATTRIBUTES.has(this.currentAttributeName);
    }
    /**
     * Find the previous meaningful (non-whitespace) sibling
     */
    findPreviousMeaningfulSibling(siblings, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            if (this.isNonWhitespaceNode(siblings[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Check if a node represents a block-level element
     */
    isBlockLevelNode(node) {
        if (!isNode$1(node, HTMLElementNode$2)) {
            return false;
        }
        const tagName = getTagName$2(node);
        if (FormatPrinter.INLINE_ELEMENTS.has(tagName)) {
            return false;
        }
        return true;
    }
    /**
     * Render attributes as a space-separated string
     */
    renderAttributesString(attributes) {
        if (attributes.length === 0)
            return "";
        return ` ${attributes.map(attribute => this.renderAttribute(attribute)).join(" ")}`;
    }
    /**
     * Determine if a tag should be rendered inline based on attribute count and other factors
     */
    shouldRenderInline(totalAttributeCount, inlineLength, indentLength, maxLineLength = this.maxLineLength, hasComplexERB = false, hasMultilineAttributes = false, attributes = []) {
        if (hasComplexERB || hasMultilineAttributes)
            return false;
        if (totalAttributeCount === 0) {
            return inlineLength + indentLength <= maxLineLength;
        }
        if (totalAttributeCount === 1 && attributes.length === 1) {
            const attribute = attributes[0];
            const attributeName = this.getAttributeName(attribute);
            if (attributeName === 'class') {
                const attributeValue = this.getAttributeValue(attribute);
                const wouldBeMultiline = this.wouldClassAttributeBeMultiline(attributeValue, indentLength);
                if (!wouldBeMultiline) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        if (totalAttributeCount > 3 || inlineLength + indentLength > maxLineLength) {
            return false;
        }
        return true;
    }
    getAttributeName(attribute) {
        return attribute.name ? getCombinedAttributeName$1(attribute.name) : "";
    }
    wouldClassAttributeBeMultiline(content, indentLength) {
        const normalizedContent = content.replace(/\s+/g, ' ').trim();
        const hasActualNewlines = /\r?\n/.test(content);
        if (hasActualNewlines && normalizedContent.length > 80) {
            const lines = content.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            if (lines.length > 1) {
                return true;
            }
        }
        const attributeLine = `class="${normalizedContent}"`;
        const currentIndent = indentLength;
        if (currentIndent + attributeLine.length > this.maxLineLength && normalizedContent.length > 60) {
            if (/<%[^%]*%>/.test(normalizedContent)) {
                return false;
            }
            const classes = normalizedContent.split(' ');
            const lines = this.breakTokensIntoLines(classes, currentIndent);
            return lines.length > 1;
        }
        return false;
    }
    getAttributeValue(attribute) {
        if (isNode$1(attribute.value, HTMLAttributeValueNode$2)) {
            return attribute.value.children.map(child => isNode$1(child, HTMLTextNode$2) ? child.content : IdentityPrinter$1.print(child)).join('');
        }
        return '';
    }
    hasMultilineAttributes(attributes) {
        return attributes.some(attribute => {
            if (isNode$1(attribute.value, HTMLAttributeValueNode$2)) {
                const content = getCombinedStringFromNodes$1(attribute.value.children);
                if (/\r?\n/.test(content)) {
                    const name = attribute.name ? getCombinedAttributeName$1(attribute.name) : "";
                    if (name === "class") {
                        const normalizedContent = content.replace(/\s+/g, ' ').trim();
                        return normalizedContent.length > 80;
                    }
                    const lines = content.split(/\r?\n/);
                    if (lines.length > 1) {
                        return lines.slice(1).some(line => /^\s+/.test(line));
                    }
                }
            }
            return false;
        });
    }
    formatClassAttribute(content, name, equals, open_quote, close_quote) {
        const normalizedContent = content.replace(/\s+/g, ' ').trim();
        const hasActualNewlines = /\r?\n/.test(content);
        if (hasActualNewlines && normalizedContent.length > 80) {
            const lines = content.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            if (lines.length > 1) {
                return open_quote + this.formatMultilineAttributeValue(lines) + close_quote;
            }
        }
        const currentIndent = this.indentLevel * this.indentWidth;
        const attributeLine = `${name}${equals}${open_quote}${normalizedContent}${close_quote}`;
        if (currentIndent + attributeLine.length > this.maxLineLength && normalizedContent.length > 60) {
            if (/<%[^%]*%>/.test(normalizedContent)) {
                return open_quote + normalizedContent + close_quote;
            }
            const classes = normalizedContent.split(' ');
            const lines = this.breakTokensIntoLines(classes, currentIndent);
            if (lines.length > 1) {
                return open_quote + this.formatMultilineAttributeValue(lines) + close_quote;
            }
        }
        return open_quote + normalizedContent + close_quote;
    }
    isFormattableAttribute(attributeName, tagName) {
        const globalFormattable = FORMATTABLE_ATTRIBUTES['*'] || [];
        const tagSpecificFormattable = FORMATTABLE_ATTRIBUTES[tagName.toLowerCase()] || [];
        return globalFormattable.includes(attributeName) || tagSpecificFormattable.includes(attributeName);
    }
    formatMultilineAttribute(content, name, open_quote, close_quote) {
        if (name === 'srcset' || name === 'sizes') {
            const normalizedContent = content.replace(/\s+/g, ' ').trim();
            return open_quote + normalizedContent + close_quote;
        }
        const lines = content.split('\n');
        if (lines.length <= 1) {
            return open_quote + content + close_quote;
        }
        const formattedContent = this.formatMultilineAttributeValue(lines);
        return open_quote + formattedContent + close_quote;
    }
    formatMultilineAttributeValue(lines) {
        const indent = " ".repeat((this.indentLevel + 1) * this.indentWidth);
        const closeIndent = " ".repeat(this.indentLevel * this.indentWidth);
        return "\n" + lines.map(line => indent + line).join("\n") + "\n" + closeIndent;
    }
    breakTokensIntoLines(tokens, currentIndent, separator = ' ') {
        const lines = [];
        let currentLine = '';
        for (const token of tokens) {
            const testLine = currentLine ? currentLine + separator + token : token;
            if (testLine.length > (this.maxLineLength - currentIndent - 6)) {
                if (currentLine) {
                    lines.push(currentLine);
                    currentLine = token;
                }
                else {
                    lines.push(token);
                }
            }
            else {
                currentLine = testLine;
            }
        }
        if (currentLine)
            lines.push(currentLine);
        return lines;
    }
    /**
     * Render multiline attributes for a tag
     */
    renderMultilineAttributes(tagName, allChildren = [], isSelfClosing = false) {
        this.pushWithIndent(`<${tagName}`);
        this.withIndent(() => {
            allChildren.forEach(child => {
                if (isNode$1(child, HTMLAttributeNode$2)) {
                    this.pushWithIndent(this.renderAttribute(child));
                }
                else if (!isNode$1(child, WhitespaceNode$2)) {
                    this.visit(child);
                }
            });
        });
        if (isSelfClosing) {
            this.pushWithIndent("/>");
        }
        else {
            this.pushWithIndent(">");
        }
    }
    /**
     * Reconstruct the text representation of an ERB node
     * @param withFormatting - if true, format the content; if false, preserve original
     */
    reconstructERBNode(node, withFormatting = true) {
        const open = node.tag_opening?.value ?? "";
        const close = node.tag_closing?.value ?? "";
        const content = node.content?.value ?? "";
        const inner = withFormatting ? this.formatERBContent(content) : content;
        return open + inner + close;
    }
    /**
     * Print an ERB tag (<% %> or <%= %>) with single spaces around inner content.
     */
    printERBNode(node) {
        const indent = this.inlineMode ? "" : this.indent;
        const erbText = this.reconstructERBNode(node, true);
        this.push(indent + erbText);
    }
    // --- Visitor methods ---
    visitDocumentNode(node) {
        let lastWasMeaningful = false;
        let hasHandledSpacing = false;
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (isNode$1(child, HTMLTextNode$2)) {
                const isWhitespaceOnly = child.content.trim() === "";
                if (isWhitespaceOnly) {
                    const hasPreviousNonWhitespace = i > 0 && this.isNonWhitespaceNode(node.children[i - 1]);
                    const hasNextNonWhitespace = i < node.children.length - 1 && this.isNonWhitespaceNode(node.children[i + 1]);
                    const hasMultipleNewlines = child.content.includes('\n\n');
                    if (hasPreviousNonWhitespace && hasNextNonWhitespace && hasMultipleNewlines) {
                        this.push("");
                        hasHandledSpacing = true;
                    }
                    continue;
                }
            }
            if (this.isNonWhitespaceNode(child) && lastWasMeaningful && !hasHandledSpacing) {
                this.push("");
            }
            this.visit(child);
            if (this.isNonWhitespaceNode(child)) {
                lastWasMeaningful = true;
                hasHandledSpacing = false;
            }
        }
    }
    visitHTMLElementNode(node) {
        this.elementStack.push(node);
        this.elementFormattingAnalysis.set(node, this.analyzeElementFormatting(node));
        this.visit(node.open_tag);
        if (node.body.length > 0) {
            this.visitHTMLElementBody(node.body, node);
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        this.elementStack.pop();
    }
    visitHTMLElementBody(body, element) {
        if (this.isContentPreserving(element)) {
            element.body.map(child => this.pushToLastLine(IdentityPrinter$1.print(child)));
            return;
        }
        const analysis = this.elementFormattingAnalysis.get(element);
        const hasTextFlow = this.isInTextFlowContext(null, body);
        const children = this.filterSignificantChildren(body, hasTextFlow);
        if (analysis?.elementContentInline) {
            if (children.length === 0)
                return;
            const oldInlineMode = this.inlineMode;
            const nodesToRender = hasTextFlow ? body : children;
            this.inlineMode = true;
            const lines = this.capture(() => {
                nodesToRender.forEach(child => {
                    if (isNode$1(child, HTMLTextNode$2)) {
                        if (hasTextFlow) {
                            const normalizedContent = child.content.replace(/\s+/g, ' ');
                            if (normalizedContent && normalizedContent !== ' ') {
                                this.push(normalizedContent);
                            }
                            else if (normalizedContent === ' ') {
                                this.push(' ');
                            }
                        }
                        else {
                            const normalizedContent = child.content.replace(/\s+/g, ' ').trim();
                            if (normalizedContent) {
                                this.push(normalizedContent);
                            }
                        }
                    }
                    else if (isNode$1(child, WhitespaceNode$2)) {
                        return;
                    }
                    else {
                        this.visit(child);
                    }
                });
            });
            const content = lines.join('');
            const inlineContent = hasTextFlow ? content.replace(/\s+/g, ' ').trim() : content.trim();
            if (inlineContent) {
                this.pushToLastLine(inlineContent);
            }
            this.inlineMode = oldInlineMode;
            return;
        }
        if (children.length === 0)
            return;
        this.withIndent(() => {
            if (hasTextFlow) {
                this.visitTextFlowChildren(children);
            }
            else {
                this.visitElementChildren(body, element);
            }
        });
    }
    /**
     * Visit element children with intelligent spacing logic
     */
    visitElementChildren(body, parentElement) {
        let lastWasMeaningful = false;
        let hasHandledSpacing = false;
        for (let i = 0; i < body.length; i++) {
            const child = body[i];
            if (isNode$1(child, HTMLTextNode$2)) {
                const isWhitespaceOnly = child.content.trim() === "";
                if (isWhitespaceOnly) {
                    const hasPreviousNonWhitespace = i > 0 && this.isNonWhitespaceNode(body[i - 1]);
                    const hasNextNonWhitespace = i < body.length - 1 && this.isNonWhitespaceNode(body[i + 1]);
                    const hasMultipleNewlines = child.content.includes('\n\n');
                    if (hasPreviousNonWhitespace && hasNextNonWhitespace && hasMultipleNewlines) {
                        this.push("");
                        hasHandledSpacing = true;
                    }
                    continue;
                }
            }
            if (this.isNonWhitespaceNode(child) && lastWasMeaningful && !hasHandledSpacing) {
                const element = body[i - 1];
                const hasExistingSpacing = i > 0 && isNode$1(element, HTMLTextNode$2) && element.content.trim() === "" && (element.content.includes('\n\n') || element.content.split('\n').length > 2);
                const shouldAddSpacing = this.shouldAddSpacingBetweenSiblings(parentElement, body, i, hasExistingSpacing);
                if (shouldAddSpacing) {
                    this.push("");
                }
            }
            this.visit(child);
            if (this.isNonWhitespaceNode(child)) {
                lastWasMeaningful = true;
                hasHandledSpacing = false;
            }
        }
    }
    visitHTMLOpenTagNode(node) {
        const attributes = filterNodes$1(node.children, HTMLAttributeNode$2);
        const inlineNodes = this.extractInlineNodes(node.children);
        const isSelfClosing = node.tag_closing?.value === "/>";
        if (this.currentElement && this.elementFormattingAnalysis.has(this.currentElement)) {
            const analysis = this.elementFormattingAnalysis.get(this.currentElement);
            if (analysis.openTagInline) {
                const inline = this.renderInlineOpen(getTagName$2(node), attributes, isSelfClosing, inlineNodes, node.children);
                this.push(this.inlineMode ? inline : this.indent + inline);
                return;
            }
            else {
                this.renderMultilineAttributes(getTagName$2(node), node.children, isSelfClosing);
                return;
            }
        }
        const inline = this.renderInlineOpen(getTagName$2(node), attributes, isSelfClosing, inlineNodes, node.children);
        const totalAttributeCount = this.getTotalAttributeCount(attributes, inlineNodes);
        const shouldKeepInline = this.shouldRenderInline(totalAttributeCount, inline.length, this.indent.length, this.maxLineLength, false, this.hasMultilineAttributes(attributes), attributes);
        if (shouldKeepInline) {
            this.push(this.inlineMode ? inline : this.indent + inline);
        }
        else {
            this.renderMultilineAttributes(getTagName$2(node), node.children, isSelfClosing);
        }
    }
    visitHTMLCloseTagNode(node) {
        const closingTag = IdentityPrinter$1.print(node);
        const analysis = this.currentElement && this.elementFormattingAnalysis.get(this.currentElement);
        const closeTagInline = analysis?.closeTagInline;
        if (this.currentElement && closeTagInline) {
            this.pushToLastLine(closingTag);
        }
        else {
            this.pushWithIndent(closingTag);
        }
    }
    visitHTMLTextNode(node) {
        if (this.inlineMode) {
            const normalizedContent = node.content.replace(/\s+/g, ' ').trim();
            if (normalizedContent) {
                this.push(normalizedContent);
            }
            return;
        }
        let text = node.content.trim();
        if (!text)
            return;
        const wrapWidth = this.maxLineLength - this.indent.length;
        const words = text.split(/\s+/);
        const lines = [];
        let line = "";
        for (const word of words) {
            if ((line + (line ? " " : "") + word).length > wrapWidth && line) {
                lines.push(this.indent + line);
                line = word;
            }
            else {
                line += (line ? " " : "") + word;
            }
        }
        if (line)
            lines.push(this.indent + line);
        lines.forEach(line => this.push(line));
    }
    visitHTMLAttributeNode(node) {
        this.pushWithIndent(this.renderAttribute(node));
    }
    visitHTMLAttributeNameNode(node) {
        this.pushWithIndent(getCombinedAttributeName$1(node));
    }
    visitHTMLAttributeValueNode(node) {
        this.pushWithIndent(IdentityPrinter$1.print(node));
    }
    // TODO: rework
    visitHTMLCommentNode(node) {
        const open = node.comment_start?.value ?? "";
        const close = node.comment_end?.value ?? "";
        let inner;
        if (node.children && node.children.length > 0) {
            inner = node.children.map(child => {
                if (isNode$1(child, HTMLTextNode$2) || isNode$1(child, LiteralNode$2)) {
                    return child.content;
                }
                else if (isERBNode$1(child) || isNode$1(child, ERBContentNode$2)) {
                    return this.reconstructERBNode(child, false);
                }
                else {
                    return "";
                }
            }).join("");
            const hasNewlines = inner.includes('\n');
            if (hasNewlines) {
                const lines = inner.split('\n');
                const childIndent = " ".repeat(this.indentWidth);
                const firstLineHasContent = lines[0].trim() !== '';
                if (firstLineHasContent && lines.length > 1) {
                    const contentLines = lines.map(line => line.trim()).filter(line => line !== '');
                    inner = '\n' + contentLines.map(line => childIndent + line).join('\n') + '\n';
                }
                else {
                    const contentLines = lines.filter((line, index) => {
                        return line.trim() !== '' && !(index === 0 || index === lines.length - 1);
                    });
                    const minIndent = contentLines.length > 0 ? Math.min(...contentLines.map(line => line.length - line.trimStart().length)) : 0;
                    const processedLines = lines.map((line, index) => {
                        const trimmedLine = line.trim();
                        if ((index === 0 || index === lines.length - 1) && trimmedLine === '') {
                            return line;
                        }
                        if (trimmedLine !== '') {
                            const currentIndent = line.length - line.trimStart().length;
                            const relativeIndent = Math.max(0, currentIndent - minIndent);
                            return childIndent + " ".repeat(relativeIndent) + trimmedLine;
                        }
                        return line;
                    });
                    inner = processedLines.join('\n');
                }
            }
            else {
                inner = ` ${inner.trim()} `;
            }
        }
        else {
            inner = "";
        }
        this.pushWithIndent(open + inner + close);
    }
    visitERBCommentNode(node) {
        const open = node.tag_opening?.value || "<%#";
        const content = node?.content?.value || "";
        const close = node.tag_closing?.value || "%>";
        const contentLines = content.split("\n");
        const contentTrimmedLines = content.trim().split("\n");
        if (contentLines.length === 1 && contentTrimmedLines.length === 1) {
            const startsWithSpace = content[0] === " ";
            const before = startsWithSpace ? "" : " ";
            this.pushWithIndent(open + before + content.trimEnd() + ' ' + close);
            return;
        }
        if (contentTrimmedLines.length === 1) {
            this.pushWithIndent(open + ' ' + content.trim() + ' ' + close);
            return;
        }
        const firstLineEmpty = contentLines[0].trim() === "";
        const dedentedContent = dedent(firstLineEmpty ? content : content.trimStart());
        this.pushWithIndent(open);
        this.withIndent(() => {
            dedentedContent.split("\n").forEach(line => this.pushWithIndent(line));
        });
        this.pushWithIndent(close);
    }
    visitHTMLDoctypeNode(node) {
        this.pushWithIndent(IdentityPrinter$1.print(node));
    }
    visitXMLDeclarationNode(node) {
        this.pushWithIndent(IdentityPrinter$1.print(node));
    }
    visitCDATANode(node) {
        this.pushWithIndent(IdentityPrinter$1.print(node));
    }
    visitERBContentNode(node) {
        // TODO: this feels hacky
        if (node.tag_opening?.value === "<%#") {
            this.visitERBCommentNode(node);
        }
        else {
            this.printERBNode(node);
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        this.visitAll(node.conditions);
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitElementChildren(node.body, null));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBIfNode(node) {
        if (this.inlineMode) {
            this.printERBNode(node);
            node.statements.forEach(child => {
                if (isNode$1(child, HTMLAttributeNode$2)) {
                    this.lines.push(" ");
                    this.lines.push(this.renderAttribute(child));
                }
                else {
                    const shouldAddSpaces = this.isInTokenListAttribute();
                    if (shouldAddSpaces) {
                        this.lines.push(" ");
                    }
                    this.visit(child);
                    if (shouldAddSpaces) {
                        this.lines.push(" ");
                    }
                }
            });
            const hasHTMLAttributes = node.statements.some(child => isNode$1(child, HTMLAttributeNode$2));
            const isTokenList = this.isInTokenListAttribute();
            if ((hasHTMLAttributes || isTokenList) && node.end_node) {
                this.lines.push(" ");
            }
            if (node.subsequent)
                this.visit(node.end_node);
            if (node.end_node)
                this.visit(node.end_node);
        }
        else {
            this.printERBNode(node);
            this.withIndent(() => {
                node.statements.forEach(child => this.visit(child));
            });
            if (node.subsequent)
                this.visit(node.subsequent);
            if (node.end_node)
                this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        this.withIndent(() => node.statements.forEach(statement => this.visit(statement)));
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        this.visitAll(node.conditions);
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.rescue_clause)
            this.visit(node.rescue_clause);
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.ensure_clause)
            this.visit(node.ensure_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    // --- Element Formatting Analysis Helpers ---
    /**
     * Analyzes an HTMLElementNode and returns formatting decisions for all parts
     */
    analyzeElementFormatting(node) {
        const openTagInline = this.shouldRenderOpenTagInline(node);
        const elementContentInline = this.shouldRenderElementContentInline(node);
        const closeTagInline = this.shouldRenderCloseTagInline(node, elementContentInline);
        return {
            openTagInline,
            elementContentInline,
            closeTagInline
        };
    }
    /**
     * Determines if the open tag should be rendered inline
     */
    shouldRenderOpenTagInline(node) {
        const children = node.open_tag?.children || [];
        const attributes = filterNodes$1(children, HTMLAttributeNode$2);
        const inlineNodes = this.extractInlineNodes(children);
        const hasERBControlFlow = inlineNodes.some(node => isERBControlFlowNode(node)) || children.some(node => isERBControlFlowNode(node));
        const hasComplexERB = hasERBControlFlow && this.hasComplexERBControlFlow(inlineNodes);
        if (hasComplexERB)
            return false;
        const totalAttributeCount = this.getTotalAttributeCount(attributes, inlineNodes);
        const hasMultilineAttrs = this.hasMultilineAttributes(attributes);
        if (hasMultilineAttrs)
            return false;
        const inline = this.renderInlineOpen(getTagName$2(node), attributes, node.open_tag?.tag_closing?.value === "/>", inlineNodes, children);
        return this.shouldRenderInline(totalAttributeCount, inline.length, this.indent.length, this.maxLineLength, hasComplexERB, hasMultilineAttrs, attributes);
    }
    /**
     * Determines if the element content should be rendered inline
     */
    shouldRenderElementContentInline(node) {
        const tagName = getTagName$2(node);
        const children = this.filterSignificantChildren(node.body, this.isInTextFlowContext(null, node.body));
        const isInlineElement = this.isInlineElement(tagName);
        const openTagInline = this.shouldRenderOpenTagInline(node);
        if (!openTagInline)
            return false;
        if (children.length === 0)
            return true;
        if (isInlineElement) {
            const fullInlineResult = this.tryRenderInlineFull(node, tagName, filterNodes$1(node.open_tag?.children, HTMLAttributeNode$2), children);
            if (fullInlineResult) {
                const totalLength = this.indent.length + fullInlineResult.length;
                return totalLength <= this.maxLineLength || totalLength <= 120;
            }
            return false;
        }
        const allNestedAreInline = this.areAllNestedElementsInline(children);
        const hasMultilineText = this.hasMultilineTextContent(children);
        const hasMixedContent = this.hasMixedTextAndInlineContent(children);
        if (allNestedAreInline && (!hasMultilineText || hasMixedContent)) {
            const fullInlineResult = this.tryRenderInlineFull(node, tagName, filterNodes$1(node.open_tag?.children, HTMLAttributeNode$2), children);
            if (fullInlineResult) {
                const totalLength = this.indent.length + fullInlineResult.length;
                if (totalLength <= this.maxLineLength) {
                    return true;
                }
            }
        }
        const inlineResult = this.tryRenderInline(children, tagName);
        if (inlineResult) {
            const openTagResult = this.renderInlineOpen(tagName, filterNodes$1(node.open_tag?.children, HTMLAttributeNode$2), false, [], node.open_tag?.children || []);
            const childrenContent = this.renderChildrenInline(children);
            const fullLine = openTagResult + childrenContent + `</${tagName}>`;
            if ((this.indent.length + fullLine.length) <= this.maxLineLength) {
                return true;
            }
        }
        return false;
    }
    /**
     * Determines if the close tag should be rendered inline (usually follows content decision)
     */
    shouldRenderCloseTagInline(node, elementContentInline) {
        if (node.is_void)
            return true;
        if (node.open_tag?.tag_closing?.value === "/>")
            return true;
        if (this.isContentPreserving(node))
            return true;
        const children = this.filterSignificantChildren(node.body, this.isInTextFlowContext(null, node.body));
        if (children.length === 0)
            return true;
        return elementContentInline;
    }
    // --- Utility methods ---
    isNonWhitespaceNode(node) {
        if (isNode$1(node, WhitespaceNode$2))
            return false;
        if (isNode$1(node, HTMLTextNode$2))
            return node.content.trim() !== "";
        return true;
    }
    /**
     * Check if an element should be treated as inline based on its tag name
     */
    isInlineElement(tagName) {
        return FormatPrinter.INLINE_ELEMENTS.has(tagName.toLowerCase());
    }
    /**
     * Check if we're in a text flow context (parent contains mixed text and inline elements)
     */
    visitTextFlowChildren(children) {
        let currentLineContent = "";
        for (const child of children) {
            if (isNode$1(child, HTMLTextNode$2)) {
                const content = child.content;
                let processedContent = content.replace(/\s+/g, ' ').trim();
                if (processedContent) {
                    const hasLeadingSpace = /^\s/.test(content);
                    if (currentLineContent && hasLeadingSpace && !currentLineContent.endsWith(' ')) {
                        currentLineContent += ' ';
                    }
                    currentLineContent += processedContent;
                    const hasTrailingSpace = /\s$/.test(content);
                    if (hasTrailingSpace && !currentLineContent.endsWith(' ')) {
                        currentLineContent += ' ';
                    }
                    if ((this.indent.length + currentLineContent.length) > Math.max(this.maxLineLength, 120)) {
                        children.forEach(child => this.visit(child));
                        return;
                    }
                }
            }
            else if (isNode$1(child, HTMLElementNode$2)) {
                const childTagName = getTagName$2(child);
                if (this.isInlineElement(childTagName)) {
                    const childInline = this.tryRenderInlineFull(child, childTagName, filterNodes$1(child.open_tag?.children, HTMLAttributeNode$2), this.filterEmptyNodes(child.body));
                    if (childInline) {
                        currentLineContent += childInline;
                        if ((this.indent.length + currentLineContent.length) > this.maxLineLength) {
                            children.forEach(child => this.visit(child));
                            return;
                        }
                    }
                    else {
                        if (currentLineContent.trim()) {
                            this.pushWithIndent(currentLineContent.trim());
                            currentLineContent = "";
                        }
                        this.visit(child);
                    }
                }
                else {
                    if (currentLineContent.trim()) {
                        this.pushWithIndent(currentLineContent.trim());
                        currentLineContent = "";
                    }
                    this.visit(child);
                }
            }
            else if (isNode$1(child, ERBContentNode$2)) {
                const oldLines = this.lines;
                const oldInlineMode = this.inlineMode;
                // TODO: use this.capture
                try {
                    this.lines = [];
                    this.inlineMode = true;
                    this.visit(child);
                    const erbContent = this.lines.join("");
                    currentLineContent += erbContent;
                    if ((this.indent.length + currentLineContent.length) > Math.max(this.maxLineLength, 120)) {
                        this.lines = oldLines;
                        this.inlineMode = oldInlineMode;
                        children.forEach(child => this.visit(child));
                        return;
                    }
                }
                finally {
                    this.lines = oldLines;
                    this.inlineMode = oldInlineMode;
                }
            }
            else {
                if (currentLineContent.trim()) {
                    this.pushWithIndent(currentLineContent.trim());
                    currentLineContent = "";
                }
                this.visit(child);
            }
        }
        if (currentLineContent.trim()) {
            const finalLine = this.indent + currentLineContent.trim();
            if (finalLine.length > Math.max(this.maxLineLength, 120)) {
                this.visitAll(children);
                return;
            }
            this.push(finalLine);
        }
    }
    isInTextFlowContext(_parent, children) {
        const hasTextContent = children.some(child => isNode$1(child, HTMLTextNode$2) && child.content.trim() !== "");
        const nonTextChildren = children.filter(child => !isNode$1(child, HTMLTextNode$2));
        if (!hasTextContent)
            return false;
        if (nonTextChildren.length === 0)
            return false;
        const allInline = nonTextChildren.every(child => {
            if (isNode$1(child, ERBContentNode$2))
                return true;
            if (isNode$1(child, HTMLElementNode$2)) {
                return this.isInlineElement(getTagName$2(child));
            }
            return false;
        });
        if (!allInline)
            return false;
        return true;
    }
    renderInlineOpen(name, attributes, selfClose, inlineNodes = [], allChildren = []) {
        const parts = attributes.map(attribute => this.renderAttribute(attribute));
        if (inlineNodes.length > 0) {
            let result = `<${name}`;
            if (allChildren.length > 0) {
                const lines = this.capture(() => {
                    allChildren.forEach(child => {
                        if (isNode$1(child, HTMLAttributeNode$2)) {
                            this.lines.push(" " + this.renderAttribute(child));
                        }
                        else if (!(isNode$1(child, WhitespaceNode$2))) {
                            const wasInlineMode = this.inlineMode;
                            this.inlineMode = true;
                            this.lines.push(" ");
                            this.visit(child);
                            this.inlineMode = wasInlineMode;
                        }
                    });
                });
                result += lines.join("");
            }
            else {
                if (parts.length > 0) {
                    result += ` ${parts.join(" ")}`;
                }
                const lines = this.capture(() => {
                    inlineNodes.forEach(node => {
                        const wasInlineMode = this.inlineMode;
                        if (!isERBControlFlowNode(node)) {
                            this.inlineMode = true;
                        }
                        this.visit(node);
                        this.inlineMode = wasInlineMode;
                    });
                });
                result += lines.join("");
            }
            result += selfClose ? " />" : ">";
            return result;
        }
        return `<${name}${parts.length ? " " + parts.join(" ") : ""}${selfClose ? " />" : ">"}`;
    }
    renderAttribute(attribute) {
        const name = attribute.name ? getCombinedAttributeName$1(attribute.name) : "";
        const equals = attribute.equals?.value ?? "";
        this.currentAttributeName = name;
        let value = "";
        if (isNode$1(attribute.value, HTMLAttributeValueNode$2)) {
            const attributeValue = attribute.value;
            let open_quote = attributeValue.open_quote?.value ?? "";
            let close_quote = attributeValue.close_quote?.value ?? "";
            let htmlTextContent = "";
            const content = attributeValue.children.map((child) => {
                if (isNode$1(child, HTMLTextNode$2) || isNode$1(child, LiteralNode$2)) {
                    htmlTextContent += child.content;
                    return child.content;
                }
                else if (isNode$1(child, ERBContentNode$2)) {
                    return IdentityPrinter$1.print(child);
                }
                else {
                    const printed = IdentityPrinter$1.print(child);
                    if (this.currentAttributeName && FormatPrinter.TOKEN_LIST_ATTRIBUTES.has(this.currentAttributeName)) {
                        return printed.replace(/%>([^<\s])/g, '%> $1').replace(/([^>\s])<%/g, '$1 <%');
                    }
                    return printed;
                }
            }).join("");
            if (open_quote === "" && close_quote === "") {
                open_quote = '"';
                close_quote = '"';
            }
            else if (open_quote === "'" && close_quote === "'" && !htmlTextContent.includes('"')) {
                open_quote = '"';
                close_quote = '"';
            }
            if (this.isFormattableAttribute(name, this.currentTagName)) {
                if (name === 'class') {
                    value = this.formatClassAttribute(content, name, equals, open_quote, close_quote);
                }
                else {
                    value = this.formatMultilineAttribute(content, name, open_quote, close_quote);
                }
            }
            else {
                value = open_quote + content + close_quote;
            }
        }
        this.currentAttributeName = null;
        return name + equals + value;
    }
    /**
     * Try to render a complete element inline including opening tag, children, and closing tag
     */
    tryRenderInlineFull(_node, tagName, attributes, children) {
        let result = `<${tagName}`;
        result += this.renderAttributesString(attributes);
        result += ">";
        const childrenContent = this.tryRenderChildrenInline(children);
        if (!childrenContent)
            return null;
        result += childrenContent;
        result += `</${tagName}>`;
        return result;
    }
    /**
     * Try to render just the children inline (without tags)
     */
    tryRenderChildrenInline(children) {
        let result = "";
        for (const child of children) {
            if (isNode$1(child, HTMLTextNode$2)) {
                const normalizedContent = child.content.replace(/\s+/g, ' ');
                const hasLeadingSpace = /^\s/.test(child.content);
                const hasTrailingSpace = /\s$/.test(child.content);
                const trimmedContent = normalizedContent.trim();
                if (trimmedContent) {
                    let finalContent = trimmedContent;
                    if (hasLeadingSpace && result && !result.endsWith(' ')) {
                        finalContent = ' ' + finalContent;
                    }
                    if (hasTrailingSpace) {
                        finalContent = finalContent + ' ';
                    }
                    result += finalContent;
                }
                else if (hasLeadingSpace || hasTrailingSpace) {
                    if (result && !result.endsWith(' ')) {
                        result += ' ';
                    }
                }
            }
            else if (isNode$1(child, HTMLElementNode$2)) {
                const tagName = getTagName$2(child);
                if (!this.isInlineElement(tagName)) {
                    return null;
                }
                const childInline = this.tryRenderInlineFull(child, tagName, filterNodes$1(child.open_tag?.children, HTMLAttributeNode$2), this.filterEmptyNodes(child.body));
                if (!childInline) {
                    return null;
                }
                result += childInline;
            }
            else {
                result += this.capture(() => this.visit(child)).join("");
            }
        }
        return result.trim();
    }
    /**
     * Try to render children inline if they are simple enough.
     * Returns the inline string if possible, null otherwise.
     */
    tryRenderInline(children, tagName) {
        for (const child of children) {
            if (isNode$1(child, HTMLTextNode$2)) {
                if (child.content.includes('\n')) {
                    return null;
                }
            }
            else if (isNode$1(child, HTMLElementNode$2)) {
                const isInlineElement = this.isInlineElement(getTagName$2(child));
                if (!isInlineElement) {
                    return null;
                }
            }
            else if (isNode$1(child, ERBContentNode$2)) ;
            else {
                return null;
            }
        }
        let content = "";
        this.capture(() => {
            content = this.renderChildrenInline(children);
        });
        return `<${tagName}>${content}</${tagName}>`;
    }
    /**
     * Check if children contain mixed text and inline elements (like "text<em>inline</em>text")
     * or mixed ERB output and text (like "<%= value %> text")
     * This indicates content that should be formatted inline even with structural newlines
     */
    hasMixedTextAndInlineContent(children) {
        let hasText = false;
        let hasInlineElements = false;
        for (const child of children) {
            if (isNode$1(child, HTMLTextNode$2)) {
                if (child.content.trim() !== "") {
                    hasText = true;
                }
            }
            else if (isNode$1(child, HTMLElementNode$2)) {
                if (this.isInlineElement(getTagName$2(child))) {
                    hasInlineElements = true;
                }
            }
        }
        return (hasText && hasInlineElements) || (hasERBOutput$1(children) && hasText);
    }
    /**
     * Check if children contain any text content with newlines
     */
    hasMultilineTextContent(children) {
        for (const child of children) {
            if (isNode$1(child, HTMLTextNode$2)) {
                return child.content.includes('\n');
            }
            if (isNode$1(child, HTMLElementNode$2)) {
                const nestedChildren = this.filterEmptyNodes(child.body);
                if (this.hasMultilineTextContent(nestedChildren)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Check if all nested elements in the children are inline elements
     */
    areAllNestedElementsInline(children) {
        for (const child of children) {
            if (isNode$1(child, HTMLElementNode$2)) {
                if (!this.isInlineElement(getTagName$2(child))) {
                    return false;
                }
                const nestedChildren = this.filterEmptyNodes(child.body);
                if (!this.areAllNestedElementsInline(nestedChildren)) {
                    return false;
                }
            }
            else if (isAnyOf$1(child, HTMLDoctypeNode$2, HTMLCommentNode$2, isERBControlFlowNode)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Check if element has complex ERB control flow
     */
    hasComplexERBControlFlow(inlineNodes) {
        return inlineNodes.some(node => {
            if (isNode$1(node, ERBIfNode$2)) {
                if (node.statements.length > 0 && node.location) {
                    const startLine = node.location.start.line;
                    const endLine = node.location.end.line;
                    return startLine !== endLine;
                }
                return false;
            }
            return false;
        });
    }
    /**
     * Filter children to remove insignificant whitespace
     */
    filterSignificantChildren(body, hasTextFlow) {
        return body.filter(child => {
            if (isNode$1(child, WhitespaceNode$2))
                return false;
            if (isNode$1(child, HTMLTextNode$2)) {
                if (hasTextFlow && child.content === " ")
                    return true;
                return child.content.trim() !== "";
            }
            return true;
        });
    }
    /**
     * Filter out empty text nodes and whitespace nodes
     */
    filterEmptyNodes(nodes) {
        return nodes.filter(child => !isNode$1(child, WhitespaceNode$2) && !(isNode$1(child, HTMLTextNode$2) && child.content.trim() === ""));
    }
    renderElementInline(element) {
        const children = this.filterEmptyNodes(element.body);
        return this.renderChildrenInline(children);
    }
    renderChildrenInline(children) {
        let content = '';
        for (const child of children) {
            if (isNode$1(child, HTMLTextNode$2)) {
                content += child.content;
            }
            else if (isNode$1(child, HTMLElementNode$2)) {
                const tagName = getTagName$2(child);
                const attributes = filterNodes$1(child.open_tag?.children, HTMLAttributeNode$2);
                const attributesString = this.renderAttributesString(attributes);
                const childContent = this.renderElementInline(child);
                content += `<${tagName}${attributesString}>${childContent}</${tagName}>`;
            }
            else if (isNode$1(child, ERBContentNode$2)) {
                content += this.reconstructERBNode(child, true);
            }
        }
        return content.replace(/\s+/g, ' ').trim();
    }
    isContentPreserving(element) {
        const tagName = getTagName$2(element);
        return FormatPrinter.CONTENT_PRESERVING_ELEMENTS.has(tagName);
    }
}

/**
 * Default values for formatting options.
 */
const defaultFormatOptions = {
    indentWidth: 2,
    maxLineLength: 80,
};
/**
 * Merge provided options with defaults for any missing values.
 * @param options partial formatting options
 * @returns a complete set of formatting options
 */
function resolveFormatOptions(options = {}) {
    return {
        indentWidth: options.indentWidth ?? defaultFormatOptions.indentWidth,
        maxLineLength: options.maxLineLength ?? defaultFormatOptions.maxLineLength,
    };
}

/**
 * Formatter uses a Herb Backend to parse the source and then
 * formats the resulting AST into a well-indented, wrapped string.
 */
class Formatter {
    herb;
    options;
    constructor(herb, options = {}) {
        this.herb = herb;
        this.options = resolveFormatOptions(options);
    }
    /**
     * Format a source string, optionally overriding format options per call.
     */
    format(source, options = {}) {
        const result = this.parse(source);
        if (result.failed)
            return source;
        const resolvedOptions = resolveFormatOptions({ ...this.options, ...options });
        return new FormatPrinter(source, resolvedOptions).print(result.value);
    }
    parse(source) {
        this.herb.ensureBackend();
        return this.herb.parse(source);
    }
}

class Settings {
    constructor(params, connection) {
        // The global settings, used when the `workspace/configuration` request is not supported by the client.
        // Please note that this is not the case when using this server with the client provided in this example
        // but could happen with other clients.
        this.defaultSettings = {
            linter: {
                enabled: true,
                excludedRules: ["parser-no-errors"] // Default exclusion since parser errors are handled by ParserService
            },
            formatter: {
                enabled: false,
                indentWidth: defaultFormatOptions.indentWidth,
                maxLineLength: defaultFormatOptions.maxLineLength
            }
        };
        this.globalSettings = this.defaultSettings;
        this.documentSettings = new Map();
        this.hasConfigurationCapability = false;
        this.hasWorkspaceFolderCapability = false;
        this.hasDiagnosticRelatedInformationCapability = false;
        this.params = params;
        this.capabilities = params.capabilities;
        this.connection = connection;
        // Does the client support the `workspace/configuration` request?
        // If not, we fall back using global settings.
        this.hasConfigurationCapability = !!(this.capabilities.workspace && !!this.capabilities.workspace.configuration);
        this.hasWorkspaceFolderCapability = !!(this.capabilities.workspace && !!this.capabilities.workspace.workspaceFolders);
        this.hasDiagnosticRelatedInformationCapability = !!(this.capabilities.textDocument &&
            this.capabilities.textDocument.publishDiagnostics &&
            this.capabilities.textDocument.publishDiagnostics.relatedInformation);
    }
    get projectPath() {
        var _a, _b;
        return ((_b = (_a = this.params.workspaceFolders) === null || _a === void 0 ? void 0 : _a.at(0)) === null || _b === void 0 ? void 0 : _b.uri) || "";
    }
    getDocumentSettings(resource) {
        if (!this.hasConfigurationCapability) {
            return Promise.resolve(this.globalSettings);
        }
        let result = this.documentSettings.get(resource);
        if (!result) {
            result = this.connection.workspace.getConfiguration({
                scopeUri: resource,
                section: "languageServerHerb",
            });
            this.documentSettings.set(resource, result);
        }
        return result;
    }
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(changes, version) {
        for (const change of changes) {
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                const range = getWellformedRange(change.range);
                // update content
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
            return lineOffset;
        }
        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
    }
    ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
            offset--;
        }
        return offset;
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
    static isIncremental(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    static isFull(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
}
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            const diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
            const startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = (data.length / 2) | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        const ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text.length; i++) {
        const ch = text.charCodeAt(i);
        if (isEOL(ch)) {
            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function isEOL(char) {
    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;
}
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range };
    }
    return textEdit;
}

class DocumentService {
    constructor(connection) {
        this.documents = new nodeExports.TextDocuments(TextDocument);
        // Make the text document manager listen on the connection
        // for open, change and close text document events
        this.documents.listen(connection);
    }
    get(uri) {
        return this.documents.get(uri);
    }
    getAll() {
        return this.documents.all();
    }
    get onDidChangeContent() {
        return this.documents.onDidChangeContent;
    }
    get onDidOpen() {
        return this.documents.onDidOpen;
    }
    get onDidClose() {
        return this.documents.onDidClose;
    }
}

class Diagnostics {
    constructor(connection, documentService, parserService, linterService) {
        this.diagnostics = new Map();
        this.connection = connection;
        this.documentService = documentService;
        this.parserService = parserService;
        this.linterService = linterService;
    }
    async validate(textDocument) {
        const parseResult = this.parserService.parseDocument(textDocument);
        const lintResult = await this.linterService.lintDocument(textDocument);
        const allDiagnostics = [
            ...parseResult.diagnostics,
            ...lintResult.diagnostics,
        ];
        this.diagnostics.set(textDocument, allDiagnostics);
        this.sendDiagnosticsFor(textDocument);
    }
    async refreshDocument(document) {
        await this.validate(document);
    }
    async refreshAllDocuments() {
        const documents = this.documentService.getAll();
        await Promise.all(documents.map(document => this.refreshDocument(document)));
    }
    sendDiagnosticsFor(textDocument) {
        const diagnostics = this.diagnostics.get(textDocument) || [];
        this.connection.sendDiagnostics({
            uri: textDocument.uri,
            diagnostics,
        });
        this.diagnostics.delete(textDocument);
    }
}

let Position$1 = class Position {
    line;
    column;
    static from(position) {
        return new Position(position.line, position.column);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Location$1 = class Location {
    start;
    end;
    static from(location) {
        const start = Position$1.from(location.start);
        const end = Position$1.from(location.end);
        return new Location(start, end);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Range$1 = class Range {
    start;
    end;
    static from(range) {
        return new Range(range[0], range[1]);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Token$1 = class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range$1.from(token.range), Location$1.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/errors.ts.erb
let HerbError$1 = class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError$1(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
};
let UnexpectedError$1 = class UnexpectedError extends HerbError$1 {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── description: ${JSON.stringify(this.description)}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnexpectedTokenError$1 = class UnexpectedTokenError extends HerbError$1 {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token$1.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;
        return output;
    }
};
let MissingOpeningTagError$1 = class MissingOpeningTagError extends HerbError$1 {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            closing_tag: data.closing_tag ? Token$1.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let MissingClosingTagError$1 = class MissingClosingTagError extends HerbError$1 {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let TagNamesMismatchError$1 = class TagNamesMismatchError extends HerbError$1 {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token$1.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let QuotesMismatchError$1 = class QuotesMismatchError extends HerbError$1 {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_quote: data.opening_quote ? Token$1.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token$1.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
        output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;
        return output;
    }
};
let VoidElementClosingTagError$1 = class VoidElementClosingTagError extends HerbError$1 {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnclosedElementError$1 = class UnclosedElementError extends HerbError$1 {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
};
let RubyParseError$1 = class RubyParseError extends HerbError$1 {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
        output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += `└── level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
};
function fromSerializedError$1(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError$1.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError$1.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError$1.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError$1.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError$1.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError$1.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError$1.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError$1.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError$1.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}

function ensureString(object) {
    if (typeof object === "string") {
        return object;
    }
    throw new TypeError("Argument must be a string");
}
function convertToUTF8$1(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/nodes.ts.erb
let Node$1 = class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode$1(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "∅\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length == 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError$1) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "│   ", isLast, false);
            }
            else {
                const symbol = isLast ? "└── " : "├── ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "∅\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? "└── " : "├── ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index == 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
};
let DocumentNode$1 = class DocumentNode extends Node$1 {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let LiteralNode$1 = class LiteralNode extends Node$1 {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$1(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
};
let HTMLOpenTagNode$1 = class HTMLOpenTagNode extends Node$1 {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
};
let HTMLCloseTagNode$1 = class HTMLCloseTagNode extends Node$1 {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let HTMLElementNode$1 = class HTMLElementNode extends Node$1 {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            open_tag: data.open_tag ? fromSerializedNode$1((data.open_tag)) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode$1(node)),
            close_tag: data.close_tag ? fromSerializedNode$1((data.close_tag)) : null,
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
};
let HTMLAttributeValueNode$1 = class HTMLAttributeValueNode extends Node$1 {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            open_quote: data.open_quote ? Token$1.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            close_quote: data.close_quote ? Token$1.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
        output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;
        return output;
    }
};
let HTMLAttributeNameNode$1 = class HTMLAttributeNameNode extends Node$1 {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let HTMLAttributeNode$1 = class HTMLAttributeNode extends Node$1 {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            name: data.name ? fromSerializedNode$1((data.name)) : null,
            equals: data.equals ? Token$1.from(data.equals) : null,
            value: data.value ? fromSerializedNode$1((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
        output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
        output += `└── value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
};
let HTMLTextNode$1 = class HTMLTextNode extends Node$1 {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$1(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
};
let HTMLCommentNode$1 = class HTMLCommentNode extends Node$1 {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            comment_start: data.comment_start ? Token$1.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            comment_end: data.comment_end ? Token$1.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;
        return output;
    }
};
let HTMLDoctypeNode$1 = class HTMLDoctypeNode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let XMLDeclarationNode$1 = class XMLDeclarationNode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let CDATANode$1 = class CDATANode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let WhitespaceNode$1 = class WhitespaceNode extends Node$1 {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            value: data.value ? Token$1.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;
        return output;
    }
};
let ERBContentNode$1 = class ERBContentNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        // no-op for analyzed_ruby
        output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
        output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;
        return output;
    }
};
let ERBEndNode$1 = class ERBEndNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let ERBElseNode$1 = class ERBElseNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBIfNode$1 = class ERBIfNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            subsequent: data.subsequent ? fromSerializedNode$1((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBBlockNode$1 = class ERBBlockNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhenNode$1 = class ERBWhenNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBCaseNode$1 = class ERBCaseNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBCaseMatchNode$1 = class ERBCaseMatchNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhileNode$1 = class ERBWhileNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUntilNode$1 = class ERBUntilNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBForNode$1 = class ERBForNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBRescueNode$1 = class ERBRescueNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            subsequent: data.subsequent ? fromSerializedNode$1((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
};
let ERBEnsureNode$1 = class ERBEnsureNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBBeginNode$1 = class ERBBeginNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode$1((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode$1((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUnlessNode$1 = class ERBUnlessNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBYieldNode$1 = class ERBYieldNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
};
let ERBInNode$1 = class ERBInNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
function fromSerializedNode$1(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode$1.from(node);
        case "AST_LITERAL_NODE": return LiteralNode$1.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode$1.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode$1.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode$1.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode$1.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode$1.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode$1.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode$1.from(node);
        case "AST_CDATA_NODE": return CDATANode$1.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode$1.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode$1.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode$1.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode$1.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode$1.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode$1.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode$1.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode$1.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode$1.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode$1.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode$1.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode$1.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode$1.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode$1.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode$1.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode$1.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode$1.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode$1.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

let Result$1 = class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
};

let HerbWarning$1 = class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location$1.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
};

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
let ParseResult$1 = class ParseResult extends Result$1 {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode$1.from(result.value), result.source, result.warnings.map((warning) => HerbWarning$1.from(warning)), result.errors.map((error) => HerbError$1.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
};

var name$1 = "@herb-tools/core";
var version$1 = "0.6.1";
var packageJSON = {
	name: name$1,
	version: version$1};

class TokenList {
    list;
    static from(list) {
        return new TokenList(list.map((token) => Token$1.from(token)));
    }
    constructor(list) {
        this.list = list;
    }
    get length() {
        return this.list.length;
    }
    get tokens() {
        return this.list;
    }
    [Symbol.iterator]() {
        return this.list[Symbol.iterator]();
    }
    at(index) {
        return this.list.at(index);
    }
    forEach(callback) {
        this.list.forEach(callback);
    }
    map(callback) {
        return this.list.map(callback);
    }
    filter(predicate) {
        return this.list.filter(predicate);
    }
    __getobj__() {
        return this.list;
    }
    inspect() {
        return this.list.map((token) => token.inspect()).join("\n") + "\n";
    }
    toString() {
        return this.inspect();
    }
}

/**
 * Represents the result of a lexical analysis, extending the base `Result` class.
 * It contains the token list, source code, warnings, and errors.
 */
class LexResult extends Result$1 {
    /** The list of tokens generated from the source code. */
    value;
    /**
     * Creates a `LexResult` instance from a serialized result.
     * @param result - The serialized lexical result containing tokens, source, warnings, and errors.
     * @returns A new `LexResult` instance.
     */
    static from(result) {
        return new LexResult(TokenList.from(result.tokens || []), result.source, result.warnings.map((warning) => HerbWarning$1.from(warning)), result.errors.map((error) => HerbError$1.from(error)));
    }
    /**
     * Constructs a new `LexResult`.
     * @param value - The list of tokens.
     * @param source - The source code that was lexed.
     * @param warnings - An array of warnings encountered during lexing.
     * @param errors - An array of errors encountered during lexing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the lexing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the lexing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
    /**
     * Converts the `LexResult` to a JSON representation.
     * @returns An object containing the token list, source, warnings, and errors.
     */
    toJSON() {
        return {
            value: this.value,
            source: this.source,
            warnings: this.warnings,
            errors: this.errors,
        };
    }
}

const DEFAULT_PARSER_OPTIONS = {
    track_whitespace: false,
};

/**
 * The main Herb parser interface, providing methods to lex and parse input.
 */
class HerbBackend {
    /** The backend instance handling lexing and parsing. */
    backend = undefined;
    backendPromise;
    /**
     * Creates a new Herb instance.
     * @param backendPromise - A promise resolving to a `LibHerbBackend` implementation for lexing and parsing.
     * @throws Error if no valid backend is provided.
     */
    constructor(backendPromise) {
        if (!backendPromise) {
            throw new Error("No LibHerb backend provided");
        }
        this.backendPromise = backendPromise;
    }
    /**
     * Loads the backend by resolving the backend promise.
     * @returns A promise containing the resolved `HerbBackend` instance after loading it.
     */
    async load() {
        const backend = await this.backendPromise();
        this.backend = backend;
        return this;
    }
    /**
     * Lexes the given source string into a `LexResult`.
     * @param source - The source code to lex.
     * @returns A `LexResult` instance.
     * @throws Error if the backend is not loaded.
     */
    lex(source) {
        this.ensureBackend();
        return LexResult.from(this.backend.lex(ensureString(source)));
    }
    /**
     * Lexes a file.
     * @param path - The file path to lex.
     * @returns A `LexResult` instance.
     * @throws Error if the backend is not loaded.
     */
    lexFile(path) {
        this.ensureBackend();
        return LexResult.from(this.backend.lexFile(ensureString(path)));
    }
    /**
     * Parses the given source string into a `ParseResult`.
     * @param source - The source code to parse.
     * @param options - Optional parsing options.
     * @returns A `ParseResult` instance.
     * @throws Error if the backend is not loaded.
     */
    parse(source, options) {
        this.ensureBackend();
        const mergedOptions = { ...DEFAULT_PARSER_OPTIONS, ...options };
        return ParseResult$1.from(this.backend.parse(ensureString(source), mergedOptions));
    }
    /**
     * Parses a file.
     * @param path - The file path to parse.
     * @returns A `ParseResult` instance.
     * @throws Error if the backend is not loaded.
     */
    parseFile(path) {
        this.ensureBackend();
        return ParseResult$1.from(this.backend.parseFile(ensureString(path)));
    }
    /**
     * Extracts embedded Ruby code from the given source.
     * @param source - The source code to extract Ruby from.
     * @returns The extracted Ruby code as a string.
     * @throws Error if the backend is not loaded.
     */
    extractRuby(source) {
        this.ensureBackend();
        return this.backend.extractRuby(ensureString(source));
    }
    /**
     * Extracts HTML from the given source.
     * @param source - The source code to extract HTML from.
     * @returns The extracted HTML as a string.
     * @throws Error if the backend is not loaded.
     */
    extractHTML(source) {
        this.ensureBackend();
        return this.backend.extractHTML(ensureString(source));
    }
    /**
     * Gets the Herb version information, including the core and backend versions.
     * @returns A version string containing backend, core, and libherb versions.
     * @throws Error if the backend is not loaded.
     */
    get version() {
        this.ensureBackend();
        const backend = this.backendVersion();
        const core = `${packageJSON.name}@${packageJSON.version}`;
        const libherb = this.backend.version();
        return `${backend}, ${core}, ${libherb}`;
    }
    /**
     * Ensures that the backend is loaded.
     * @throws Error if the backend is not loaded.
     */
    ensureBackend() {
        if (!this.isLoaded) {
            throw new Error("Herb backend is not loaded. Call `await Herb.load()` first.");
        }
    }
    /**
     * Checks if the backend is loaded.
     * @returns True if the backend is loaded, false otherwise.
     */
    get isLoaded() {
        return this.backend !== undefined;
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/visitor.ts.erb
let Visitor$1 = class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitDocumentNode(node) {
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitChildNodes(node);
    }
};

var name = "@herb-tools/node-wasm";
var version$2 = "0.6.1";

class HerbBackendNodeWASM extends HerbBackend {
    backendVersion() {
        return `${name}@${version$2}`;
    }
}

// This code implements the `-sMODULARIZE` settings by taking the generated
// JS program code (INNER_JS_CODE) and wrapping it in a factory function.

// When targetting node and ES6 we use `await import ..` in the generated code
// so the outer function needs to be marked as async.
async function Herb$1(moduleArg = {}) {
  var moduleRtn;

// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = moduleArg;

{
  // When building an ES module `require` is not normally available.
  // We need to use `createRequire()` to construct the require()` function.
  const { createRequire } = await import('module');
  /** @suppress{duplicate} */
  var require$1 = createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('herb-language-server.js', document.baseURI).href)));

}
var quit_ = (status, toThrow) => {
  throw toThrow;
};

var _scriptName = (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('herb-language-server.js', document.baseURI).href));

// Hooks that are implemented differently in different runtime environments.
var readBinary;

{
  const isNode = typeof process == 'object' && process.versions?.node && process.type != 'renderer';
  if (!isNode) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  var nodeVersion = process.versions.node;
  var numericVersion = nodeVersion.split('.').slice(0, 3);
  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);
  if (numericVersion < 160000) {
    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');
  }

  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require$1('fs');

  if (_scriptName.startsWith('file:')) {
    require$1('path').dirname(require$1('url').fileURLToPath(_scriptName)) + '/';
  }

// include: node_shell_read.js
readBinary = (filename) => {
  // We need to re-wrap `file://` strings to URLs.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename);
  assert(Buffer.isBuffer(ret));
  return ret;
};
// end include: node_shell_read.js
  if (process.argv.length > 1) {
    process.argv[1].replace(/\\/g, '/');
  }

  process.argv.slice(2);

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

}

var out = console.log.bind(console);
var err = console.error.bind(console);

// perform assertions in shell.js after we set up out() and err(), as otherwise
// if an assertion fails it cannot print the message

assert(true, 'web environment detected but not enabled at build time.  Add `web` to `-sENVIRONMENT` to enable.');

assert(true, 'worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.');

assert(true, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');

// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;

if (typeof WebAssembly != 'object') {
  err('no native wasm support detected');
}

// Wasm globals

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');

// include: runtime_common.js
// include: runtime_stack_check.js
// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // If the stack ends at address zero we write our cookies 4 bytes into the
  // stack.  This prevents interference with SAFE_HEAP and ASAN which also
  // monitor writes to address zero.
  if (max == 0) {
    max += 4;
  }
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAPU32[((max)>>2)] = 0x02135467;
  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[((0)>>2)] = 1668509029;
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  // See writeStackCookie().
  if (max == 0) {
    max += 4;
  }
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {
    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
  }
}

// Endianness check
(() => {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
})();

function consumedModuleProp(prop) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      set() {
        abort(`Attempt to set \`Module.${prop}\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);

      }
    });
  }
}

function makeInvalidEarlyAccess(name) {
  return () => assert(false, `call to '${name}' via reference taken before Wasm module initialization`);

}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
  }
}

// forcing the filesystem exports a few things by default
function isExportedByForceFilesystem(name) {
  return name === 'FS_createPath' ||
         name === 'FS_createDataFile' ||
         name === 'FS_createPreloadedFile' ||
         name === 'FS_unlink' ||
         name === 'addRunDependency' ||
         // The old FS has some functionality that WasmFS lacks.
         name === 'FS_createLazyFile' ||
         name === 'FS_createDevice' ||
         name === 'removeRunDependency';
}

/**
 * Intercept access to a global symbol.  This enables us to give informative
 * warnings/errors when folks attempt to use symbols they did not include in
 * their build, or no symbols that no longer exist.
 */
function hookGlobalSymbolAccess(sym, func) {
  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        func();
        return undefined;
      }
    });
  }
}

function missingGlobal(sym, msg) {
  hookGlobalSymbolAccess(sym, () => {
    warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
  });
}

missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
missingGlobal('asm', 'Please use wasmExports instead');

function missingLibrarySymbol(sym) {
  hookGlobalSymbolAccess(sym, () => {
    // Can't `abort()` here because it would break code that does runtime
    // checks.  e.g. `if (typeof SDL === 'undefined')`.
    var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
    // library.js, which means $name for a JS name with no prefix, or name
    // for a JS name like _name.
    var librarySymbol = sym;
    if (!librarySymbol.startsWith('_')) {
      librarySymbol = '$' + sym;
    }
    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
    if (isExportedByForceFilesystem(sym)) {
      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
    }
    warnOnce(msg);
  });

  // Any symbol that is not included from the JS library is also (by definition)
  // not exported on the Module object.
  unexportedRuntimeSymbol(sym);
}

function unexportedRuntimeSymbol(sym) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get() {
        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        abort(msg);
      }
    });
  }
}

// end include: runtime_debug.js
var readyPromiseResolve, readyPromiseReject;

// Memory management

var wasmMemory;

var
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

// BigInt64Array type is not correctly defined in closure
var
/** not-@type {!BigInt64Array} */
  HEAP64,
/* BigUint64Array type is not correctly defined in closure
/** not-@type {!BigUint64Array} */
  HEAPU64;

var runtimeInitialized = false;



function updateMemoryViews() {
  var b = wasmMemory.buffer;
  HEAP8 = new Int8Array(b);
  HEAP16 = new Int16Array(b);
  HEAPU8 = new Uint8Array(b);
  HEAPU16 = new Uint16Array(b);
  HEAP32 = new Int32Array(b);
  HEAPU32 = new Uint32Array(b);
  HEAPF32 = new Float32Array(b);
  HEAPF64 = new Float64Array(b);
  HEAP64 = new BigInt64Array(b);
  HEAPU64 = new BigUint64Array(b);
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// end include: runtime_common.js
assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  consumedModuleProp('preRun');
  // Begin ATPRERUNS hooks
  callRuntimeCallbacks(onPreRuns);
  // End ATPRERUNS hooks
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();

  // No ATINITS hooks

  wasmExports['__wasm_call_ctors']();

  // No ATPOSTCTORS hooks
}

function postRun() {
  checkStackCookie();
   // PThreads reuse the runtime from the main thread.

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  consumedModuleProp('postRun');

  // Begin ATPOSTRUNS hooks
  callRuntimeCallbacks(onPostRuns);
  // End ATPOSTRUNS hooks
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};
var runDependencyWatcher = null;

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

  {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(() => {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err(`dependency: ${dep}`);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  }
}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject?.(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// show errors on likely calls to FS when it was not included
var FS = {
  error() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
  },
  init() { FS.error(); },
  createDataFile() { FS.error(); },
  createPreloadedFile() { FS.error(); },
  createLazyFile() { FS.error(); },
  open() { FS.error(); },
  mkdev() { FS.error(); },
  registerDevice() { FS.error(); },
  analyzePath() { FS.error(); },

  ErrnoError() { FS.error(); },
};


function createExportWrapper(name, nargs) {
  return (...args) => {
    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
    var f = wasmExports[name];
    assert(f, `exported native function \`${name}\` not found`);
    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.
    assert(args.length <= nargs, `native function \`${name}\` called with ${args.length} args but expects ${nargs}`);
    return f(...args);
  };
}

var wasmBinaryFile;

function findWasmBinary() {
  return base64Decode('AGFzbQEAAAABhwMzYAJ/fwF/YAAAYAJ/fwBgA39/fwBgAX8AYAR/f39/AGADf39/AX9gA39+fwF+YAZ/fH9/f38Bf2AGf39/f39/AGAFf39/f38AYAF/AX9gBX9/f39/AXxgCH9/f39/f39/AGAAAX9gBX9/f35+AGAEf39/fwF/YAR/fn9/AX9gBn9/f39/fgF/YAZ/f39/f38Bf2AFf39/f38Bf2AIf39/f39/f38Bf2AHf39/f39/fwF/YAl/f39/f39/f38Bf2AKf39/f39/f39/fwF/YAt/f39/f39/f39/fwF/YAF8AX9gAXwAYA1/f39/f39/f39/f39/AX9gAn9/AXxgBH9/f38BfmABfQF/YAF8AX5gAn9/AX5gBH9/fn4AYAN/fn4AYAR/f39+AGAFf39/f34AYAJ+fgF/YAJ/fgBgAnx/AXxgBX9+fn5+AGAEf35+fwBgB39/f39/f38AYAR/f39+AX5gA35/fwF/YAJ+fwF/YAR+fn5+AX9gAn98AGACf30AYAJ+fgF8ApcGHgNlbnYEZXhpdAAEA2VudhFfZW12YWxfZ2V0X2dsb2JhbAALA2VudhNfZW12YWxfc2V0X3Byb3BlcnR5AAMDZW52DV9lbXZhbF9kZWNyZWYABANlbnYVX2VtdmFsX2NyZWF0ZV9pbnZva2VyAAYDZW52DV9lbXZhbF9pbnZva2UADANlbnYWX2VtdmFsX3J1bl9kZXN0cnVjdG9ycwAEA2VudhJfZW12YWxfbmV3X2NzdHJpbmcACwNlbnYNX2VtdmFsX3R5cGVvZgALA2VudhNfZW12YWxfZ2V0X3Byb3BlcnR5AAADZW52DV9lbXZhbF9pbmNyZWYABANlbnYZX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbgANA2VudhFfZW12YWxfbmV3X29iamVjdAAOA2VudhBfZW12YWxfbmV3X2FycmF5AA4DZW52DV9fYXNzZXJ0X2ZhaWwABQNlbnYVX2VtYmluZF9yZWdpc3Rlcl92b2lkAAIDZW52FV9lbWJpbmRfcmVnaXN0ZXJfYm9vbAAFA2VudhhfZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIACgNlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQADwNlbnYWX2VtYmluZF9yZWdpc3Rlcl9mbG9hdAADA2VudhtfZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcAAgNlbnYcX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwADA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsAAQDZW52HF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcAAwNlbnYJX2Fib3J0X2pzAAEWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF9jbG9zZQALFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUAEBZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsAEQNlbnYKX211bm1hcF9qcwASA2VudhZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwAAsDmg2YDQELCwsLCwsLCwsLCwsLCwsLCwsAAAAAAAAAAAAACwsLCwsLCwsAAgAAAgsGCxMUExMAAAsEDgsCAAsCCwsECgsQEBUWFRYQExATExMTEBcTFhcVFhgYFRUVFRYZFxMWCwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAsECwsAAAACAgMCBAQFFAkQCgYFBgUQChAKFAkGBRQLBAQEBAQEBAQEBAQCAgILCwAEDg4LCwsAEAAAAAAAAAAAAAAAAgILDgALCwsLCwYACwsACwYGCwQCAgQLDgAQCwQLAAsABgACAAsLCwsLAgQFCwMFAAYGAwAOAAsLAwIDBAsLCwsLCwALCwAAAgsCAwMLCwIECwYOAAsLCwQLABAOAAsLCwsEAAAGDgYLCwQLCwYLCwMDAgQCAgMLAwMDAwALAwMACwMDAwMCAwMCAgICAgICAgIDAwsLCwsaAAILDgsECwIACwsACxsBDgsLAgsLAgIDAwMDAgMDAgMDAgADAwMLCwMDAAUDAAULCwALDgsCCwsACw4LCwsLAAsOCwILCwsLCwsLCwsLCwILAwsLAgIAAAMLBQMDEAMGAgIEAwABCwEAAwMQCwsGCxoLDgsLCwICAgIACwYLCwsACwsLCwsLCwIGDg4OCwsACxoOCwsOAAIEAQIEAgQCAwICAwMCAgMCAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMABQsLAAsOCwILEAsLFAQAAAYGAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAICBAICAwMAAAUGAAYCAAYDBQUGCgIFBAQEBAQECwsABAYCBQACCwMGFAQLAAQAAAQABAsEAgALAgQLAAsAAAMACwALCwYAAxQLCwsACwYCCwsLBgsLCwsGCwALAAACAgICBQIAAgICAgIGBgAAEwUABAMLBgACBhAGAgsACxACAgYABgsAAgQAAAMWCwAAAAoLAwYJBQULCwAAAAAAAAULAAYGBhMLCxMUAgMAAAIQAhMGFxADAgICBAMCFAsDEAMQAAIQCxAAEAsLFAYAEBAAAAAAAAAACwICAAIDAhQUAAIGAhACAwAGBgYGAAAABhAQCwoQAAIDAgICEBQQEBQCEAICAgIGCQIUCgYCBgYCBgYUAhYWBQsXAgMAAAAAFQsQCxwUFBAVFAAAAhAWAAACFhYQAhAAAhAUAhAAAgMQAgIGEAMUBAYTAgsQFhAACxATEBATEBAQABAQBhMQAAIDEBAQEBAQExAQEBAQEBATEBAQEBAQFBQUEwYAAxAQAAICBgAABgACAAAQEBATAAsdAAsQBgYeEAAQFAAYAAAAAAICFAICAgICEAIDAgYCAAsGCwICAAYGBAIAAgAQAgAAAgYGAgYGAgAQAAAUFhQCAgILAwAFEwoCAAILBgYQAgACFAMDCxMLHyAAAAMGFQYFBgIGBgYUEBAQBhALAgICAAMLAhAQEBATEAALBgMCAgoAAAYGEA0LCwAABQALAAAACwQDAAAAAAsAFAYUBgYGBgAhCwQECgMfIAsLAAsLAAsLAgADAwMDAgAFAAUEBgYAAAsACwYQBgAGBgAGCwALCwsCAAMABAALAAsABhALBgYEBQsFAwUAAgIiBCMkJAQlAhQGBAAGBQQDAwMECwsABAYLFBQUFBQDAwsEAQEOJgELCwQLBgcGCwYABgYLCwYQCwsOBwYGAAQEAAABAA4BDg4ODgEAEAsHAAAAAAsLBgYGCycLKCkqKSMF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C60BAQR/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggARDTgICAABCAgoCAADYCBCABKAIEQQA2AgQgASgCCCECIAEoAgQgAjYCCCABKAIIQQJ0EIKCgIAAIQMgASgCBCADNgIAAkACQCABKAIEKAIAQQBHQQFxDQAgASgCBBCajICAACABQQA2AgwMAQsgASABKAIENgIMCyABKAIMIQQgAUEQaiSAgICAACAEDwuiAwEFfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAAkAgAigCHCgCBCACKAIcKAIIT0EBcUUNAAJAAkAgAigCHCgCCA0AIAJBATYCFAwBCwJAAkAgAigCHCgCCEH/////AUtBAXFFDQBBACgCwPCIgABBsbmGgABBABDHi4CAABogAiACKAIcKAIIQYACajYCFAJAIAIoAhQgAigCHCgCCElBAXFFDQAgAkH/////AzYCFAsMAQsgAiACKAIcKAIIQQF0NgIUCwsCQCACKAIUQf////8DS0EBcUUNAEEAKALA8IiAAEHWuIaAAEEAEMeLgIAAGgwCCyACIAIoAhRBAnQ2AhAgAiACKAIcKAIAIAIoAhAQg4KAgAA2AgwCQCACKAIMQQBGQX9zQX9zQQFxRQ0ADAILIAIoAgwhAyACKAIcIAM2AgAgAigCFCEEIAIoAhwgBDYCCAsgAigCGCEFIAIoAhwoAgAgAigCHCgCBEECdGogBTYCACACKAIcIQYgBiAGKAIEQQFqNgIECyACQSBqJICAgIAADwtfAQF/I4CAgIAAQRBrIQIgAiAANgIIIAIgATYCBAJAAkAgAigCBCACKAIIKAIET0EBcUUNACACQQA2AgwMAQsgAiACKAIIKAIAIAIoAgRBAnRqKAIANgIMCyACKAIMDwtlAQF/I4CAgIAAQRBrIQEgASAANgIIAkACQAJAIAEoAghBAEdBAXFFDQAgASgCCCgCBA0BCyABQQA2AgwMAQsgASABKAIIKAIAIAEoAggoAgRBAWtBAnRqKAIANgIMCyABKAIMDwtBAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCCBDVgICAACACQRBqJICAgIAADwuLAQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIAkACQAJAIAEo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DwvYAQEBfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACIAIoAhwQzoGAgAA2AhQgAkEANgIQAkADQCACKAIQIAIoAhQQ2oCAgABJQQFxRQ0BIAIgAigCFCACKAIQENaAgIAANgIMAkACQCACKAIMKAIMQXFqQQJLDQAgAigCGCACKAIMKAIEEMOCgIAAEKmBgIAADAELIAIoAhggAigCDCgCABCmgYCAAAsgAiACKAIQQQFqNgIQDAALCyACQRRqENCBgIAAIAJBIGokgICAgAAPC0kBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABEJ+BgIAAGiABKAIMIAEQyoGAgAAgASgCACECIAFBEGokgICAgAAgAg8LrQEBA38jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwQ5YGAgAA2AgggAUEANgIEIAFBgAEQ1ICAgAA2AgACQANAIAEoAggQ6IGAgAAhAiABIAI2AgQgAigCDEEiR0EBcUUNASABKAIAIAEoAgQQ1YCAgAAMAAsLIAEoAgAgASgCBBDVgICAACABKAIIEPmBgIAAIAEoAgAhAyABQRBqJICAgIAAIAMPC3oBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIcEOWBgIAANgIUIAIgAigCFCACKAIYEJmCgIAANgIQIAIgAigCEBCagoCAADYCDCACKAIQEJ+CgIAAIAIoAgwhAyACQSBqJICAgIAAIAMPC8gBAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQAJAAkAgASgCDEEAR0EBcUUNACABKAIMKAIAQQBHQQFxDQELDAELIAFBADYCCAJAA0AgASgCCCABKAIMKAIAENqAgIAASUEBcUUNASABIAEoAgwoAgAgASgCCBDWgICAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBDNgoCAAAsgASABKAIIQQFqNgIIDAALCyABKAIMENuAgIAACyABQRBqJICAgIAADwsJAEHNnIaAAA8LCQBB0J2GgAAPC88CAwJ/BX4DfyOAgICAAEHQAGshASABJICAgIAAIAEgADYCSAJAAkAgASgCSEEARkEBcUUNACABQQBBAXE6AE8MAQtBACECIAIpA6C7hoAAIQMgAUHAAGogAzcDACACKQOYu4aAACEEIAFBOGogBDcDACACKQOQu4aAACEFIAFBMGogBTcDACACKQOIu4aAACEGIAFBKGogBjcDACACKQOAu4aAACEHIAFBIGogBzcDACABIAIpA/i6hoAANwMYIAEgAikD8LqGgAA3AxAgAUEANgIMAkADQCABKAIMQQ5JQQFxRQ0BIAEoAkghCCABKAIMIQkCQCAIIAFBEGogCUECdGooAgAQ54uAgAANACABQQFBAXE6AE8MAwsgASABKAIMQQFqNgIMDAALCyABQQBBAXE6AE8LIAEtAE9BAXEhCiABQdAAaiSAgICAACAKDwuFAgEFfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIAkACQCABKAIIQQBGQQFxRQ0AIAFBopSGgAAQ0oKAgAA2AgwMAQsgASABKAIIEOyLgIAANgIEIAEgASgCBEEEahCYjICAADYCAAJAIAEoAgBBAEZBAXFFDQAgAUEANgIMDAELIAEoAgBBPDoAACABKAIAQS86AAEgASgCAEECaiECIAEoAgghAyABKAIEIQQCQCAERQ0AIAIgAyAE/AoAAAsgASgCACABKAIEQQJqakE+OgAAIAEoAgAgASgCBEEDampBADoAACABIAEoAgA2AgwLIAEoAgwhBSABQRBqJICAgIAAIAUPC6ECAQV/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghBAEZBAXFFDQAgAUGmlIaAABDSgoCAADYCDAwBCyABIAEoAggQ7IuAgAA2AgQgASABKAIEQQVqEJiMgIAANgIAAkAgASgCAEEARkEBcUUNACABQQA2AgwMAQsgASgCAEE8OgAAIAEoAgBBAWohAiABKAIIIQMgASgCBCEEAkAgBEUNACACIAMgBPwKAAALIAEoAgAgASgCBEEBampBIDoAACABKAIAIAEoAgRBAmpqQS86AAAgASgCACABKAIEQQNqakE+OgAAIAEoAgAgASgCBEEEampBADoAACABIAEoAgA2AgwLIAEoAgwhBSABQRBqJICAgIAAIAUPC30BBX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwoAgAhAwJAAkAgAigCDCgCECACKAIIaiACKAIMKAIESUEBcUUNACACKAIMKAIQIAIoAghqIQQMAQsgAigC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A0AgAigCBCACKAIISUEBcUUNASACKAIMEPaBgIAAIAIgAigCBEEBajYCBAwACwsgAkEQaiSAgICAAA8LSwEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQCABKAIMQQBGQQFxRQ0ADAELIAEoAgwQmoyAgAALIAFBEGokgICAgAAPCysBAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCECABKAIMKAIESUEBcQ8LBQBBCA8LbQEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACEPuBgIAAEICCgIAANgIEIAIoAgwhAyACKAIEIAM2AgAgAigCCCEEIAIoAgQgBDYCBCACKAIEIQUgAkEQaiSAgICAACAFDwtpAQJ/I4CAgIAAQRBrIQQgBCSAgICAACAEIAA2AgwgBCABNgIIIAQgAjYCBCAEIAM2AgAgBCgCDCAEKAIIELeCgIAAIAQoAgQgBCgCABC3goCAABD8gYCAACEFIARBEGokgICAgAAgBQ8LdwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIAkACQCABKAIIQQBGQQFxRQ0AIAFBADYCDAwBCyABIAEoAggoAgAQuoKAgAAgASgCCCgCBBC6goCAABD8gYCAADYCDAsgASgCDCECIAFBEGokgICAgAAgAg8LeQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCAEEAR0EBcUUNACABKAIMKAIAELuCgIAACwJAIAEoAgwoAgRBAEdBAXFFDQAgASgCDCgCBBC7goCAAAsgASgCDBCajICAACABQRBqJICAgIAADws+AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEEBQQFxEIGCgIAAIQIgAUEQaiSAgICAACACDwvQAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgAToAFwJAAkAgAigCGA0AIAJBADYCHAwBCyACIAIoAhgQmIyAgAA2AhACQCACKAIQQQBHQQFxDQBBACgCwPCIgAAhAyACIAIoAhg2AgAgA0GLuYaAACACEMeLgIAAGkEAKALA8IiAABDCi4CAABoCQCACLQAXQQFxRQ0AQQEQgICAgAAACyACQQA2AhwMAQsgAiACKAIQNgIcCyACKAIc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CCABKAIMKAIAEOiBgIAAIQIgASgCDCACNgIEIAEoAgghAyABQRBqJICAgIAAIAMPC2wBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgggAygCDCgCBCADKAIMKAIEKAIIKAIAIAMoAgwoAgQoAggoAgQgAygCBBCwgYCAACADQRBqJICAgIAADwurAQEBfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgATYCGCAEIAI2AhQgBCADNgIQAkACQCAEKAIYEKKBgIAADQAMAQsgBCAEKAIYEKGBgIAAIAQoAhAgBCgCHCgCBCgCCCgCAEEAEN+AgIAANgIMAkAgBCgCFEEAR0EBcUUNACAEKAIUIAQoAgwQ1YCAgAALIAQoAhgQqoGAgAALIARBIGokgICAgAAPC3ABAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQCQAJAIAIoAggoAgQoAgwgAigCBEdBAXFFDQAgAkEANgIMDAELIAIgAigCCBCQgoCAADYCDAsgAigCDCEDIAJBEGokgICAgAAgAw8LogEBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMgAygCDCADKAIIEJOCgIAANgIAAkAgAygCAEEARkEBcUUNACADIAMoAgwQkIKAgAA2AgAgAygCCCADKAIAIAMoAgAoAggoAgAgAygCACgCCCgCBCADKAIEELCBgIAACyADKAIAIQQgA0EQaiSAgICAACAEDwu9AQEIfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCgCECADKAIMKAIQKAIIKAIAIAMoAgwoAhAoAggoAgQgAygCBBC0gYCAACADKAIMIQQgAygCDCgCECEFIAMoAgghBiADKAIMKAIEKAIAIQcgAygCDCgCBCgCBCEIIAMoAgQhCSAEIAUgBkEAQQBBAXEgByAIIAkQ4oCAgAAhCiADQRBqJICAgIAAIAoPC9EBAQF/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFAJAAkAgAygCHCgCCBDagICAAEEAS0EBcUUNACADIAMoAhwoAggQ14CAgAA2AhAgAyADKAIYKAIQNgIMIAMoAhAgAygCDCADKAIMKAIIKAIAIAMoAgwoAggoAgQgAygCFBC2gYCAAAwBCyADKAIYKAIQIAMoAhgoAhAoAggoAgAgAygCGCgCECgCCCgCBCADKAIUELKBgIAACyADQSBqJICAgIAADwuYAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACIAIoAgQQjIKAgAA2AgACQAJAAkAgAigCAEEARkEBcQ0AIAIoAghBAEZBAXFFDQELIAJBAEEBcToADwwBCyACIAIoAgggAigCABDqi4CAAEEARkEBcToADwsgAi0AD0EBcSEDIAJBEGokgICAgAAgAw8LBQBBGA8L9QEBCX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggQmIKAgAAhAyACQQEgAxChjICAADYCBCACKAIMIQQgAigCBCAENgIAIAIoAgwQ6IGAgAAhBSACKAIEIAU2AgRBEBDUgICAACEGIAIoAgQgBjYCCCACKAIEQQA2AgwgAigCBEEANgIQAkACQCACKAIIQQBHQQFxRQ0AQQEhByAHIAcQoYyAgAAhCCACKAIEIAg2AhQgAigCCC0AACEJIAIoAgQoAhQgCUEBcToAAAwBCyACKAIEQQA2AhQLIAIoAgQhCiACQRBqJICAgIAAIAoPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEJuCgIAAIQIgAUEQaiSAgICAACACDwv6AQEEfyOAgICAAEEgayEBIAEkgICAgAAgASAANgIcIAFBCBDUgICAADYCGCABQQgQ1ICAgAA2AhQgASABKAIcKAIEKAIIKAIAELqCgIAANgIQIAEoAhwgASgCGCABKAIUEJyCgIAAIAEoAhwgASgCFBCdgoCAACABKAIcIAEoAhggASgCFBCegoCAACABKAIcIQIgASgCFCEDIAEgAkEiIAMQlIKAgAA2AgwgASABKAIYIAEoAhAgASgCDCgCCCgCBCABKAIUEN6AgIAANgIIIAEoAhAQu4KAgAAgASgCDBDNgoCAACABKAIIIQQgAUEgaiSAgICAACAEDwuXBQEJfyOAgICAAEHgAGshAyADJICAgIAAIAMgADYCXCADIAE2AlggAyACNgJUAkADQCADKAJcKAIEKAIMIQQgA0H/wdcvNgJE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ADcDACADIAMpAiw3AwAgCCADEOSBgIAAAkAgAygCKEEAR0EBcUUNACADKAIoEM2CgIAACwJAIAMtACdBAXFFDQAgAygCbCEMIAMoAmghDSADKAJUIQ4gDCADQdgAaiANIA4QkoKAgAAgAygCbBCOgoCAACADKAJUELuCgIAAIANB2ABqEKuBgIAADAQLCyADIAMoAmwQkIKAgAA2AiAgAygCICgCACEPIANB2ABqIA8QpoGAgAAgAygCIBDNgoCAAAwACwsgAygCbCEQIAMoAmghESADKAJUIRIgECADQdgAaiARIBIQkoKAgAAgAygCbBCOgoCAACADKAJUELuCgIAAIANB2ABqEKuBgIAACyADQfAAaiSAgICAAA8LsAEBAX8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUAkAgAygCHCgCFEEAR0EBcUUNACADKAIcKAIULQAAQQFxRQ0AIANBCBDUgICAADYCECADIAMoAhggAygCGCgCCCgCACADKAIYKAIIKAIEIAMoAhAQ64CAgAA2AgwgAygCFCADKAIMENWAgIAACyADKAIYEM2CgIAAIANBIGokgICAgAAPC6sFAQt/I4CAgIAAQdAAayEBIAEkgICAgAAgASAANgJMIAFBCBDUgICAADYCSCABQQgQ1ICAgAA2AkQgAUE4ahCggYCAACABIAEoAkwoAgQoAggoAgAQuoKAgAA2AjQCQANAIAEoAkwoAgQoAgwhAkEUIQMgASADakH/wdcvNgIAIAFBEGpBIjYCACABQQw2AgwgAUELNgIIIAFBAjYCBCABQQA2AgAgAiADIAEQyIKAgABBf3NBAXFFDQECQCABKAJMQQ8QxoKAgABBAXFFDQAgASgCTCEEIAEoAkQhBSABKAI0IQYgBCABQThqIAUgBhCSgoCAACABIAEoAkwQoIKAgAA2AjAgASgCRCABKAIwENWAgIAAIAEoAjQQu4KAgAAgASABKAJMKAIEKAIIKAIAELqCgIAANgI0DAELIAEgASgCTBCQgoCAADYCLCABKAIsKAIAIQcgAUE4aiAHEKaBgIAAIAEoAiwQzYKAgAAMAAsLIAEoAkwhCCABKAJEIQkgASgCNCEKIAggAUE4aiAJIAoQkoKAgAAgAUEANgIoIAFBADYCJAJAAkAgASgCRCgCBEEAS0EBcUUNACABIAEoAkRBABDWgICAADYCICABIAEoAkQgASgCRCgCBEEBaxDWgICAADYCHCABIAEoAiAoAgQoAgAQuoKAgAA2AiggASABKAIcKAIEKAIEELqCgIAANgIkDAELIAEgASgCTCgCBCgCCCgCABC6goCAADYCKCABIAEoAkwoAgQoAggoAgAQuoKAgAA2AiQLIAEgASgCRCABKAIoIAEoAiQgASgCSBDkgICAADYCGCABKAI0ELuCgIAAIAEoAigQu4KAgAAgASgCJBC7goCAACABQThqEKuBgIAAIAEoAhghCyABQdAAaiSAgICAACALDwvUBgEffyOAgICAAEHAAGshASABJICAgIAAIAEgADYCOCABQQgQ1ICAgAA2AjQgAUEIENSAgIAANgIwAkACQCABKAI4QQ8QxoKAgABBAXFFDQAgASABKAI4EKCCgIAANgIsIAEoAjQgASgCLBDVgICAACABKAI0IQIgASgCLCgCBCgCACEDIAEoAiwoAgQoAgQhBCABKAIwIQVBACEGIAEgBiACIAZBAEEBcSADIAQgBRDjgICAADYCPAwBCwJAIAEoAjhBAxDGgoCAAEEBcUUNACABKAI4IQcgASgCMCEIIAEgB0EDIAgQlIKAgAA2AiggASABKAIoEN2AgIAANgIkIAEoAigQzYKAgAAgASgCNCABKAIkENWAgIAAIAEoAjQhCSABKAIkKAIEKAIAIQogASgCJCgCBCgCBCELIAEoAjAhDEEAIQ0gASANIAkgDUEAQQFxIAogCyAMEOOAgIAANgI8DAELAkAgASgCOEEVEMaCgIAAQQFxRQ0AIAEgASgCOCABKAI0IAEoAjAQtYKAgAA2AjwMAQsCQCABKAI4QRYQxoKAgABBAXFFDQAgASABKAI4EJCCgIAANgIgIAEgASgCICgCCCgCABC6goCAADYCHCABIAEoAiAoAggoAgQQuoKAgAA2AhggASgCHCEOIAEoAhghDyABKAIwIRBBu5CFgABB462GgABB06WGgAAgDiAPIBAQroGAgAAgASgCNCERIAEoAhwhEiABKAIYIRMgASgCMCEUQQAhFSABIBUgESAVQQBBAXEgEiATIBQQ44CAgAA2AhQgASgCHBC7goCAACABKAIYELuCgIAAIAEoAiAQzYKAgAAgASABKAIUNgI8DAELIAEgASgC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IAMoArQBKAIAEOqLgIAADQAgAygCzAEoAgAhHiADQewAaiAeEOOBgIAAIAMgAygCzAEoAgQ2AmggAygCzAEoAgAQ6IGAgAAhHyADKALMASAfNgIEAkACQAJAIAMoAswBQQMQxoKAgABBAXENACADKALMAUEgEMaCgIAAQQFxRQ0BCyADKAK0ASgCACEgIAMoAmgoAggoAgAhISADKAJoKAIIKAIEISIgAygCxAEhI0Glj4WAAEGIroaAACAgICEgIiAjEK6BgIAAIAMoAswBKAIAISRBGCElICUgA0EgamogJSADQewAamopAgA3AwBBECEmICYgA0EgamogJiADQewAamopAgA3AwBBCCEnICcgA0EgamogJyADQewAamopAgA3AwAgAyADKQJsNwMgICQgA0EgahDkgYCAACADKALMASgCBBDNgoCAACADKAJoISggAygCzAEgKDYCBCADKALMASgCBCgCACEpIANBuAFqICkQpoGAgAAgAygCzAEoAgQQzYKAgAAgAygCzAEoAgAQ6IGAgAAhKiADKALMASAqNgIEA0AgAygCzAFBIhDGgoCAACErQQAhLCArQQFxIS0gLCEuAkAgLQ0AIAMoAswBQRUQxoKAgAAhL0EAITAgL0EBcSExIDAhMgJAIDFFDQAgAygCtAFBAEchM0EAITQgM0EBcSE1IDQhMiA1RQ0AIAMoAswBKAIEKAIAIAMoArQBKAIAEOqLgIAAQQBGITILIDJBf3MhLgsCQCAuQQFxRQ0AAkAgAygCzAFBDxDGgoCAAEEBcUUNACADKALMASE2IAMoAsgBITcgAygCsAEhOCA2IANBuAFqIDcgOBCSgoCAACADKALIASADKALMARCggoCAABDVgICAACADKAKwARC7goCAACADIAMoAswBKAIEKAIIKAIAELqCgIAANgKwAQwCCyADKALMASgCBCgCACE5IANBuAFqIDkQpoGAgAAgAygCzAEoAgQQzYKAgAAgAygCzAEoAgAQ6IGAgAAhOiADKALMASA6NgIEDAELCwwBCyADKALMASgCBBDNgoCAACADKAJoITsgAygCzAEgOzYCBCADKALMASgCACE8QRghPSA9IANBwABqaiA9IANB7ABqaikCADcDAEEQIT4gPiADQcAAamogPiADQewAamopAgA3AwBBCCE/ID8gA0HAAGpq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QeABRkEBcUUNACABQQM2AgwMAQsCQCABLQALQf8BcUH4AXFB8AFGQQFxRQ0AIAFBBDYCDAwBCyABQQE2AgwLIAEoAgwPCysBAX8jgICAgABBEGshASABIAA6AA8gAS0AD0H/AXFBwAFxQYABRkEBcQ8LogIBAn8jgICAgABBIGshAyADJICAgIAAIAMgADYCGCADIAE2AhQgAyACNgIQAkACQCADKAIUIAMoAhBPQQFxRQ0AIANBADYCHAwBCyADIAMoAhggAygCFGotAAA6AA8gAyADLQAPQf8BcRDOgoCAADYCCAJAIAMoAhQgAygCCGogAygCEEtBAXFFDQAgA0EBNgIcDAELAkAgAygCCEEBSkEBcUUNACADQQE2AgQCQANAIAMoAgQgAygCCEhBAXFFDQECQCADKAIYIAMoAhQgAygCBGpqLQAAQf8BcRDPgoCAAEEBcQ0AIANBATYCHAwECyADIAMoAgRBAWo2AgQMAAsLCyADIAMoAgg2AhwLIAMoAhwhBCADQSBqJICAgIAAIAQPC0YBBX8jgICAgABBEGshASABIAA2AgwgASgCDEENRiECQQEhAyACQQFxIQQgAyEFAkAgBA0AIAEoAgxBCkYhBQsgBUEBcQ8LjgEBBX8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwQ7IuAgABBAWo2AgggASABKAIIEJiMgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEIQIgASgCDCEDIAEoAgghBAJAIARFDQAgAiADIAT8CgAACwsgASgCBCEFIAFBEGokgICAgAAgBQ8LggEBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgghBAJAIAMoAgwgAygCBCAEEYCAgIAAgICAgABBAXFFDQAgAygCDEEAR0EBcUUNACADKAIMIAMoAgggAygCBBDUgoCAAAsgA0EQaiSAgICAAA8LiyMBAn8jgICAgABB4AFrIQMgAySAgICAACADIAA2AtwBIAMgATYC2AEgAyACNgLUAQJAAkAgAygC3AFBAEZBAXFFDQAMAQsgAygC3AEoAgAhBCAEQR5LGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBA4fABkBAgMEBQYZBwgJChkZGQsMDQ4PEBESExQVFhcZGBkLIAMgAygC3AE2AtABAkAgAygC0AEoAgxBAEdBAXFFDQAgA0EANgLMAQJAA0AgAygCzAEgAygC0AEoAgwQ2oCAgABJQQFxRQ0BIAMoAtABKAIMIAMoAswBENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCzAFBAWo2AswBDAALCwsMGQsgAyADKALcATYCyAECQCADKALIASgCGEEAR0EBcUUNACADQQA2AsQBAkADQCADKALEASADKALIASgCGBDagICAAElBAXFFDQEgAygCyAEoAhggAygCxAEQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKALEAUEBajYCxAEMAAsLCwwYCyADIAMoAtwBNgLAAQJAIAMoAsABKAIUQQBHQQFxRQ0AIANBADYCvAECQANAIAMoArwBIAMoAsABKAIUENqAgIAASUEBcUUNASADKALAASgCFCADKAK8ARDWgICAACADKALYASADKALUARDTgoCAACADIAMoArwBQQFqNgK8AQwACwsLDBcLIAMgAygC3AE2ArgBAkAgAygCuAEoAgxBAEdBAXFFDQAgAygCuAEoAgwgAygC2AEgAygC1AEQ04KAgAALAkAgAygCuAEoAhRBAEdBAXFFDQAgA0EANgK0AQJAA0AgAygCtAEgAygCuAEoAhQQ2oCAgABJQQFxRQ0BIAMoArgBKAIUIAMoArQBENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCtAFBAWo2ArQBDAALCwsCQCADKAK4ASgCGEEAR0EBcUUNACADKAK4ASgCGCADKALYASADKALUARDTgoCAAAsMFgsgAyADKALcATYCsAECQCADKAKwASgCEEEAR0EBcUUNACADQQA2AqwBAkADQCADKAKsASADKAKwASgCEBDagICAAElBAXFFDQEgAygCsAEoAhAgAygCrAEQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAKsAUEBajYCrAEMAAsLCwwVCyADIAMoAtwBNgKoAQJAIAMoAqgBKAIMQQBHQQFxRQ0AIANBADYCpAECQANAIAMoAqQBIAMoAqgBKAIMENqAgIAASUEBcUUNASADKAKoASgCDCADKAKkARDWgICAACADKALYASADKALUARDTgoCAACADIAMoAqQBQQFqNgKkAQwACwsLDBQLIAMgAygC3AE2AqABAkAgAygCoAEoAgxBAEdBAXFFDQAgAygCoAEoAgwgAygC2AEgAygC1AEQ04KAgAALAkAgAygCoAEoAhRBAEdBAXFFDQAgAygCoAEoAhQgAygC2AEgAygC1AEQ04KAgAALDBMLIAMgAygC3AE2ApwBAkAgAygCnAEoAhBBAEdBAXFFDQAgA0EANgKYAQJAA0AgAygCmAEgAygCnAEoAhAQ2oCAgABJQQFxRQ0BIAMoApwBKAIQIAMoApgBENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCmAFBAWo2ApgBDAALCwsMEgsgAyADKALcATYClAECQCADKAKUASgCEEEAR0EBcUUNACADQQA2ApABAkADQCADKAKQASADKAKUASgCEBDagICAAElBAXFFDQEgAygClAEoAhAgAygCkAEQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAKQAUEBajYCkAEMAAsLCwwRCyADIAMoAtwBNgKMAQJAIAMoAowBKAIQQQBHQQFxRQ0AIANBADYCiAECQANAIAMoAogBIAMoAowBKAIQENqAgIAASUEBcUUNASADKAKMASgCECADKAKIARDWgICAACADKALYASADKALUARDTgoCAACADIAMoAogBQQFqNgKIAQwACwsLDBALIAMgAygC3AE2AoQBAkAgAygChAEoAhBBAEdBAXFFDQAgA0EANgKAAQJAA0AgAygCgAEgAygChAEoAhAQ2oCAgABJQQFxRQ0BIAMoAoQBKAIQIAMoAoABENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCgAFBAWo2AoABDAALCwsMDwsgAyADKALcATYCfAJAIAMoAnwoAhhBAEdBAXFFDQAgA0EANgJ4AkADQCADKAJ4IAMoAnwoAhgQ2oCAgABJQQFxRQ0BIAMoAnwoAhggAygCeBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAnhBAWo2AngMAAsLCwwOCyADIAMoAtwBNgJ0AkAgAygCdCgCGEEAR0EBcUUNACADQQA2AnACQANAIAMoAnAgAygCdCgCGBDagICAAElBAXFFDQEgAygCdCgCGCADKAJwENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCcEEBajYCcAwACwsLAkAgAygCdCgCHEEAR0EBcUUNACADKAJ0KAIcIAMoAtgBIAMoAtQBENOCgIAACwJAIAMoAnQoAiBBAEdBAXFFDQAgAygCdCgCICADKALYASADKALUARDTgoCAAAsMDQsgAyADKALcATYCbAJAIAMoAmwoAhhBAEdBAXFFDQAgA0EANgJoAkADQCADKAJoIAMoAmwoAhgQ2oCAgABJQQFxRQ0BIAMoAmwoAhggAygCaBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAmhBAWo2AmgMAAsLCwJAIAMoAmwoAhxBAEdBAXFFDQAgAygCbCgCHCADKALYASADKALUARDTgoCAAAsMDAsgAyADKALcATYCZAJAIAMoAmQoAhhBAEdBAXFFDQAgA0EANgJgAkADQCADKAJgIAMoAmQoAhgQ2oCAgABJQQFxRQ0BIAMoAmQoAhggAygCYBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAmBBAWo2AmAMAAsLCwwLCyADIAMoAtwBNgJcAkAgAygCXCgCGEEAR0EBcUUNACADQQA2AlgCQANAIAMoAlggAygCXCgCGBDagICAAElBAXFFDQEgAygCXCgCGCADKAJYENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCWEEBajYCWAwACwsLAkAgAygCXCgCHEEAR0EBcUUNACADQQA2AlQCQANAIAMoAlQgAygCXCgCHBDagICAAElBAXFFDQEgAygCXCgCHCADKAJUENaAgIAAIAMoAtgBIAMoAtQBENOCgIAAIAMgAygCVEEBajYCVAwACwsLAkAgAygCXCgCIEEAR0EBcUUNACADKAJcKAIgIAMoAtgBIAMoAtQBENOCgIAACwJAIAMoAlwoAiRBAEdBAXFFDQAgAygCXCgCJCADKALYASADKALUARDTgoCAAAsMCgsgAyADKALcATYCUAJAIAMoAlAoAhhBAEdBAXFFDQAgA0EANgJMAkADQCADKAJMIAMoAlAoAhgQ2oCAgABJQQFxRQ0BIAMoAlAoAhggAygCTBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAkxBAWo2AkwMAAsLCwJAIAMoAlAoAhxBAEdBAXFFDQAgA0EANgJIAkADQCADKAJIIAMoAlAoAhwQ2oCAgABJQQFxRQ0BIAMoAlAoAhwgAygCSBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAkhBAWo2AkgMAAsLCwJAIAMoAlAoAiBBAEdBAXFFDQAgAygCUCgCICADKALYASADKALUARDTgoCAAAsCQCADKAJQKAIkQQBHQQFxRQ0AIAMoAlAoAiQgAygC2AEgAygC1AEQ04KAgAALDAkLIAMgAygC3AE2AkQCQCADKAJEKAIYQQBHQQFxRQ0AIANBADYCQAJAA0AgAygCQCADKAJEKAIYENqAgIAASUEBcUUNASADKAJEKAIYIAMoAkAQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAJAQQFqNgJADAALCwsCQCADKAJEKAIcQQBHQQFxRQ0AIAMoAkQoAhwgAygC2AEgAygC1AEQ04KAgAALDAgLIAMgAygC3AE2AjwCQCADKAI8KAIYQQBHQQFxRQ0AIANBADYCOAJAA0AgAygCOCADKAI8KAIYENqAgIAASUEBcUUNASADKAI8KAIYIAMoAjgQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAI4QQFqNgI4DAALCwsCQCADKAI8KAIcQQBHQQFxRQ0AIAMoAjwoAhwgAygC2AEgAygC1AEQ04KAgAALDAcLIAMgAygC3AE2AjQCQCADKAI0KAIYQQBHQQFxRQ0AIANBADYCMAJAA0AgAygCMCADKAI0KAIYENqAgIAASUEBcUUNASADKAI0KAIYIAMoAjAQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAIwQQFqNgIwDAALCwsCQCADKAI0KAIcQQBHQQFxRQ0AIAMoAjQoAhwgAygC2AEgAygC1AEQ04KAgAALDAYLIAMgAygC3AE2AiwCQCADKAIsKAIYQQBHQQFxRQ0AIANBADYCKAJAA0AgAygCKCADKAIsKAIYENqAgIAASUEBcUUNASADKAIsKAIYIAMoAigQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAIoQQFqNgIoDAALCwsCQCADKAIsKAIcQQBHQQFxRQ0AIAMoAiwoAhwgAygC2AEgAygC1AEQ04KAgAALDAULIAMgAygC3AE2AiQCQCADKAIkKAIYQQBHQQFxRQ0AIANBADYCIAJAA0AgAygCICADKAIkKAIYENqAgIAASUEBcUUNASADKAIkKAIYIAMoAiAQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAIgQQFqNgIgDAALCwsMBAsgAyADKALcATYCHAJAIAMoAhwoAhhBAEdBAXFFDQAgA0EANgIYAkADQCADKAIYIAMoAhwoAhgQ2oCAgABJQQFxRQ0BIAMoAhwoAhggAygCGBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAhhBAWo2AhgMAAsLCwJAIAMoAhwoAhxBAEdBAXFFDQAgAygCHCgCHCADKALYASADKALUARDTgoCAAAsCQCADKAIcKAIgQQBHQQFxRQ0AIAMoAhwoAiAgAygC2AEgAygC1AEQ04KAgAALAkAgAygCHCgCJEEAR0EBcUUNACADKAIcKAIkIAMoAtgBIAMoAtQBENOCgIAACwJAIAMoAhwoAihBAEdBAXFFDQAgAygCHCgCKCADKALYASADKALUARDTgoCAAAsMAwsgAyADKALcATYCFAJAIAMoAhQoAhhBAEdBAXFFDQAgA0EANgIQAkADQCADKAIQIAMoAhQoAhgQ2oCAgABJQQFxRQ0BIAMoAhQoAhggAygCEBDWgICAACADKALYASADKALUARDTgoCAACADIAMoAhBBAWo2AhAMAAsLCwJAIAMoAhQoAhxBAEdBAXFFDQAgAygCFCgCHCADKALYASADKALUARDTgoCAAAsCQCADKAIUKAIgQQBHQQFxRQ0AIAMoAhQoAiAgAygC2AEgAygC1AEQ04KAgAALDAILIAMgAygC3AE2AgwCQCADKAIMKAIYQQBHQQFxRQ0AIANBADYCCAJAA0AgAygCCCADKAIMKAIYENqAgIAASUEBcUUNASADKAIMKAIYIAMoAggQ1oCAgAAgAygC2AEgAygC1AEQ04KAgAAgAyADKAIIQQFqNgIIDAALCwsMAQsLIANB4AFqJICAgIAADwvuAwEHfyOAgICAAEHQAGshAiACJICAgIAAIAIgADYCTCACIAE2AkgCQAJAIAIoAkhBAEdBAXENACAAENaCgIAADAELIAJBwABqQeKphIAAENeCgIAAIAJBAEEBcToAPyAAIAJBwABqENiCgIAAIAIoAkgQvoGAgAAhAyACQTRqIAMQkYOAgAAgAEHEqYWAACACQTRqENmCgIAAIAJBNGoQ2oKAgAAaIAIoAkgoAgghBCACQSxqIAQQkYOAgAAgAEHxt4WAACACQSxqENuCgIAAIAJBLGoQ2oKAgAAaIAIoAkgoAgQhBSACQSRqIAUQl4OAgAAgAEHU5YSAACACQSRqENyCgIAAIAJBJGoQ2oKAgAAaIAIoAkgoAgwhBiACQRxqIAYQkYOAgAAgAEGR4ISAACACQRxqEN2CgIAAIAJBHGoQ2oKAgAAaIAIoAkgoAhAhByACQRRqIAcQkYOAgAAgAEGSxYWAACACQRRqENyCgIAAIAJBFGoQ2oKAgAAaIAIoAkgoAhQhCCACQQxqIAgQkYOAgAAgAEHdvYWAACACQQxqEN6CgIAAIAJBDGoQ2oKAgAAaIAJBAUEBcToAPwJAIAItAD9BAXENACAAENqCgIAAGgsgAkHAAGoQ2oKAgAAaCyACQdAAaiSAgICAAA8LNQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIABBBBDfgoCAABogAUEQaiSAgICAAA8LRQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAggQgYCAgAAQ34KAgAAaIAJBEGokgICAgAAPC0YBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggACACKAIIEOCCgIAAQQAQ4YKAgAAgAkEQaiSAgICAAA8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEEOCCgIAAIQUgAygCGCEGIANBDGogBCAGEOKCgIAAIAUgA0EMahDggoCAACAEIAMoAhQQ44KAgAAQ4IKAgAAQgoCAgAAgA0EMahDagoCAABogA0EgaiSAgICAAA8LZwEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAEoAgghAiABIAI2AgwCQCACEOSCgIAAQQFxRQ0AIAIQ4IKAgAAQg4CAgAAgAkEANgIECyABKAIMIQMgAUEQaiSAgICAACADDwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ5YKAgAAgBSADQQxqEOCCgIAAIAQgAygCFBDjgoCAABDggoCAABCCgICAACADQQxqENqCgIAAGiADQSBqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ5oKAgAAgBSADQQxqEOCCgIAAIAQgAygCFBDjgoCAABDggoCAABCCgICAACADQQxqENqCgIAAGiADQSBqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ54KAgAAgBSADQQxqEOCCgIAAIAQgAygCFBDjgoCAABDggoCAABCCgICAACADQQxqENqCgIAAGiADQSBqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ6IKAgAAgBSADQQxqEOCCgIAAIAQgAygCFBDjgoCAABDggoCAABCCgICAACADQQxqENqCgIAAGiADQSBqJICAgIAADwtPAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwhAyADEN6LgIAANgIAIAMgAigCCDYCBCACQRBqJICAgIAAIAMPCx8BAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCBA8LoQIBCn8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkQQAtANihiYAAQQFxIQRBACEFAkAgBEH/AXEgBUH/AXFGQQFxRQ0AQcy7hoAAEPeCgIAAQcy7hoAAEPiCgIAAQQIQhICAgAAhBkEAIAY2AtShiYAAQQEhB0EAIAc6ANihiYAACyADQRhqEPmCgIAAGiADQQA2AhRBACgC1KGJgAAhCCADKAIoIQkgAygCJCEKIANBGGoQ+oKAgAAhCyADIAggCSAKIANBFGogCxCFgICAABD7goCAADYCECADKAIUIQwgA0EMaiAMEPyCgIAAGiAAIAMoAhAQ/YKAgAAgA0EMahD+goCAABogA0EwaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEISDgIAAGiADQRBqJICAgIAADwsjAQF/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIDwslAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoAgRBCEtBAXEPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCEg4CAABogA0EQaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEISDgIAAGiADQRBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQhIOAgAAaIANBEGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCEg4CAABogA0EQaiSAgICAAA8LuwMBBn8jgICAgABBwABrIQIgAiSAgICAACACIAA2AjwgAiABNgI4AkACQCACKAI4QQBHQQFxDQAgABDWgoCAAAwBCyACQTBqQeKphIAAENeCgIAAIAJBAEEBcToALyAAIAJBMGoQ2IKAgAAgAigCOBC+gYCAACEDIAJBJGogAxCRg4CAACAAQcSphYAAIAJBJGoQ2YKAgAAgAkEkahDagoCAABogAigCOCgCCCEEIAJBHGogBBCRg4CAACAAQfG3hYAAIAJBHGoQ24KAgAAgAkEcahDagoCAABogAigCOCgCBCEFIAJBFGogBRCXg4CAACAAQdTlhIAAIAJBFGoQ3IKAgAAgAkEUahDagoCAABogAigCOCgCDBDLgoCAACEGIAJBDGogBhCRg4CAACAAQaCphYAAIAJBDGoQ6oKAgAAgAkEMahDagoCAABogAigCOCgCECEHIAJBBGogBxCdg4CAACAAQd29hYAAIAJBBGoQ3oKAgAAgAkEEahDagoCAABogAkEBQQFxOgAvAkAgAi0AL0EBcQ0AIAAQ2oKAgAAaCyACQTBqENqCgIAAGgsgAkHAAGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCAD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7gMBB38jgICAgABB0ABrIQIgAiSAgICAACACIAA2AkwgAiABNgJIAkACQCACKAJIQQBHQQFxDQAgABDWgoCAAAwBCyACQcAAakHiqYSAABDXgoCAACACQQBBAXE6AD8gACACQcAAahDYgoCAACACKAJIEL6BgIAAIQMgAkE0aiADEJGDgIAAIABBxKmFgAAgAkE0ahDZgoCAACACQTRqENqCgIAAGiACKAJIKAIIIQQgAkEsaiAEEJGDgIAAIABB8beFgAAgAkEsahDbgoCAACACQSxqENqCgIAAGiACKAJIKAIEIQUgAkEkaiAFEJeDgIAAIABB1OWEgAAgAkEkahDcgoCAACACQSRqENqCgIAAGiACKAJIKAIMIQYgAkEcaiAGEJGDgIAAIABB1beFgAAgAkEcahDqgoCAACACQRxqENqCgIAAGiACKAJIKAIQIQcgAkEUaiAHEJGDgIAAIABBusKFgAAgAkEUahDqgoCAACACQRRqENqCgIAAGiACKAJIKAIUIQggAkEMaiAIEJGDgIAAIABByvaEgAAgAkEMahDegoCAACACQQxqENqCgIAAGiACQQFBAXE6AD8CQCACLQA/QQFxDQAgABDagoCAABoLIAJBwABqENqCgIAAGgsgAkHQAGokgICAgAAPC6ICAQJ/I4CAgIAAQTBrIQIgAiSAgICAACACIAA2AiwgAiABNgIoIAJBIGpBmoaEgAAQ14KAgAAgAkEAQQFxOgAfIAAgAkEgahDYgoCAAAJAIAIoAihBAEdBAXFFDQAgAkEANgIYAkADQCACKAIYIAIoAigQ2oCAgABJQQFxRQ0BIAIgAigCKCACKAIYENaAgIAANgIUAkAgAigCFEEAR0EBcUUNACACKAIUIQMgAkEMaiADEPSCgIAAIABBgISFgAAgAkEMahD1goCAACACQQxqENqCgIAAGgsgAiACKAIYQQFqNgIYDAALCwsgAkEBQQFxOgAfAkAgAi0AH0EBcQ0AIAAQ2oKAgAAaCyACQSBqENqCgIAAGiACQTBqJICAgIAADwuZAgECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAAkAgAigCCEEAR0EBcQ0AIAAQ1oKAgAAMAQsgAigCCCgCACEDIANBCEsaAkACQAJAAkACQAJAAkACQAJAAkAgAw4JAAECAwQFBgcICQsgACACKAIIENWCgIAADAkLIAAgAigCCBDpgoCAAAwICyAAIAIoAggQ7IKAgAAMBwsgACACKAIIEO2CgIAADAYLIAAgAigCCBDugoCAAAwFCyAAIAIoAggQ74KAgAAMBAsgACACKAIIEPCCgIAADAMLIAAgAigCCBDxgoCAAAwCCyAAIAIoAggQ8oKAgAAMAQsgABDWgoCAAAsgAkEQaiSAgICAAA8LUwEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDBDggoCAACADKAIIIAMoAgQQ9oKAgAAgA0EQaiSAgICAAA8LngIBC38jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkQQAtAOChiYAAQQFxIQRBACEFAkAgBEH/AXEgBUH/AXFGQQFxRQ0AQe+7hoAAEIWDgIAAQe+7hoAAEIaDgIAAQQEQhICAgAAhBkEAIAY2AtyhiYAAQQEhB0EAIAc6AOChiYAACyADKAIkIQggA0EYaiAIEIeDgIAAGiADQQA2AhRBACgC3KGJgAAhCSADKAIsIQogAygCKCELIANBGGoQiIOAgAAhDCAJIAogCyADQRRqIAwQhYCAgAAQiYOAgAAgAygCFCENIANBDGogDRD8goCAABoQioOAgAAgA0EMahD+goCAABogA0EwaiSAgICAAA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEEBDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQ/4KAgAAhAiABQRBqJICAgIAAIAIPC0sBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQIgASACEICDgIAANgIIIAFBCGoQgYOAgAAgAUEQaiSAgICAACACDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCCg4CAACECIAFBEGokgICAgAAgAg8LHgEBfyOAgICAAEEQayEBIAEgADkDCCABKwMI/AMPCzEBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwhAyADIAIoAgg2AgAgAw8LPgEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAggQg4OAgAAgAkEQaiSAgICAAA8LXQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAEoAgghAiABIAI2AgwCQCACKAIAQQBHQQFxRQ0AIAIoAgAQhoCAgAALIAEoAgwhAyABQRBqJICAgIAAIAMPCwkAQdC7hoAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQAPCxcBAX8jgICAgABBEGshASABIAA2AgwPCxkBAX8jgICAgABBEGshASABIAA2AgxBAA8LPwEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAggQ34KAgAAaIAJBEGokgICAgAAPC04BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAMgAigCCBCHgICAABDfgoCAABogAkEQaiSAgICAACADDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCLg4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxCMg4CAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQjYOAgAAQjoOAgAAgAigCHBCBg4CAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEI+DgIAAIQIgAUEQaiSAgICAACACDwsXAQF/I4CAgIAAQRBrIQEgASAAOQMIDwsNACOAgICAAEEQaxoPCwkAQfC7hoAADwscAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIEJCDgIAAIQIgAUEQaiSAgICAACACDwtGAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPCxwBAX8jgICAgABBEGshASABIAA2AgwgASgCDA8LTgEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwhAiABIAIQ4IKAgAA2AgggAkEANgIEIAEoAgghAyABQRBqJICAgIAAIAMPC10BAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQAJAIAIoAghBAEdBAXFFDQAgACACKAIIEISDgIAAGgwBCyAAENaCgIAACyACQRBqJICAgIAADwvTAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAAkAgAigCGEEAR0EBcQ0AIAAQ1oKAgAAMAQsgAkEQakHiqYSAABDXgoCAACACQQBBAXE6AA8gACACQRBqENiCgIAAIAIoAhghAyAAQf6rhYAAIAMQk4OAgAAgAigCGEEEaiEEIABB1+qEgAAgBBCUg4CAACACQQFBAXE6AA8CQCACLQAPQQFxDQAgABDagoCAABoLIAJBEGoQ2oKAgAAaCyACQSBqJICAgIAADwuvAQEGfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ4oKAgAAgA0EMahDggoCAACEHIAMoAhQhCCADQQRqIAQgCBCVg4CAACAFIAcgA0EEahDggoCAABCCgICAACADQQRqENqCgIAAGiADQQxqENqCgIAAGiADQSBqJICAgIAADwuvAQEGfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQloOAgAAgA0EMahDggoCAACEHIAMoAhQhCCADQQRqIAQgCBCVg4CAACAFIAcgA0EEahDggoCAABCCgICAACADQQRqENqCgIAAGiADQQxqENqCgIAAGiADQSBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQqYOAgAAaIANBEGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCEg4CAABogA0EQaiSAgICAAA8LjgIBA38jgICAgABBMGshAiACJICAgIAAIAIgADYCLCACIAE2AigCQAJAIAIoAihBAEdBAXENACAAENaCgIAADAELIAJBIGpB4qmEgAAQ14KAgAAgAkEAQQFxOgAfIAAgAkEgahDYgoCAACACKAIoKAIAIQMgAkEUaiADEJKDgIAAIABBro+EgAAgAkEUahDegoCAACACQRRqENqCgIAAGiACKAIoKAIEIQQgAkEMaiAEEJKDgIAAIABB9sCFgAAgAkEMahCYg4CAACACQQxqENqCgIAAGiACQQFBAXE6AB8CQCACLQAfQQFxDQAgABDagoCAABoLIAJBIGoQ2oKAgAAaCyACQTBqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ4IKAgAAhBSADKAIYIQYgA0EMaiAEIAYQmYOAgAAgBSADQQxqEOCCgIAAIAQgAygCFBDjgoCAABDggoCAABCCgICAACADQQxqENqCgIAAGiADQSBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQhIOAgAAaIANBEGokgICAgAAPC9MBAQN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYAkACQCACKAIYQQBHQQFxDQAgABDWgoCAAAwBCyACQRBqQZqGhIAAENeCgIAAIAJBAEEBcToADyAAIAJBEGoQ2IKAgAAgAigCGCEDIABBgISFgAAgAxCbg4CAACACKAIYQQRqIQQgAEGAhIWAACAEEJuDgIAAIAJBAUEBcToADwJAIAItAA9BAXENACAAENqCgIAAGgsgAkEQahDagoCAABoLIAJBIGokgICAgAAPC1MBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgwQ4IKAgAAgAygCCCADKAIEEJyDgIAAIANBEGokgICAgAAPC54CAQt/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJEEALQDwoYmAAEEBcSEEQQAhBQJAIARB/wFxIAVB/wFxRkEBcUUNAEGEvIaAABCyg4CAAEGEvIaAABCzg4CAAEEBEISAgIAAIQZBACAGNgLsoYmAAEEBIQdBACAHOgDwoYmAAAsgAygCJCEIIANBGGogCBC0g4CAABogA0EANgIUQQAoAuyhiYAAIQkgAygCLCEKIAMoAighCyADQRhqELWD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44KAgAAQ4IKAgAAQgoCAgAAgA0EMahDagoCAABogA0EgaiSAgICAAA8LUwEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAigCCCEEQQAhBSADIAUgBSAEEKeDgIAAIAJBEGokgICAgAAgAw8LsQIBC38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQD4oYmAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEGQvIaAABC5g4CAAEGQvIaAABC6g4CAAEEDEISAgIAAIQdBACAHNgL0oYmAAEEBIQhBACAIOgD4oYmAAAsgBCgCICEJIARBGGogCRC7g4CAABogBEEANgIUQQAoAvShiYAAIQogBCgCKCELIAQoAiQhDCAEQRhqELyDgIAAIQ0gBCAKIAsgDCAEQRRqIA0QhYCAgAAQ+4KAgAA2AhAgBCgCFCEOIARBDGogDhD8goCAABogACAEKAIQEP2CgIAAIARBDGoQ/oKAgAAaIARBMGokgICAgAAPC+cCAQN/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQgA0EsakHiqYSAABDXgoCAACADQSRqQZqGhIAAENeCgIAAIANBAEEBcToAIyAAIANBLGoQ2IKAgAAgAygCOCEEIANBGGogBBCahICAACADQRBqIANBJGoQ2IKAgAAgA0EIaiADQSRqENiCgIAAIABB+4+FgAAgA0EYahDegoCAACADKAI0IQUgAyAFEKaDgIAAGiAAQbO5hYAAIAMQpYOAgAAgAxDagoCAABogAEHKuoSAACADQQhqENyCgIAAIABBwrKEgAAgA0EQahClg4CAACADQQFBAXE6ACMgA0EIahDagoCAABogA0EQahDagoCAABogA0EYahDagoCAABoCQCADLQAjQQFxDQAgABDagoCAABoLIANBJGoQ2oKAgAAaIANBLGoQ2oKAgAAaIANBwABqJICAgIAADwtTAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwhAyACKAIIIQRBACEFIAMgBSAFIAQQqoOAgAAgAkEQaiSAgICAACADDwuxAgELfyOAgICAAEEwayEEIAQkgICAgAAgBCAANgIsIAQgATYCKCAEIAI2AiQgBCADNgIgQQAtAOihiYAAQQFxIQVBACEGAkAgBUH/AXEgBkH/AXFGQQFxRQ0AQfi7hoAAEKuDgIAAQfi7hoAAEKyDgIAAQQMQhICAgAAhB0EAIAc2AuShiYAAQQEhCEEAIAg6AOihiYAACyAEKAIgIQkgBEEYaiAJEK2DgIAAGiAEQQA2AhRBACgC5KGJgAAhCiAEKAIoIQsgBCgCJCEMIARBGGoQroOAgAAhDSAEIAogCyAMIARBFGogDRCFgICAABD7goCAADYCECAEKAIUIQ4gBEEMaiAOEPyCgIAAGiAAIAQoAhAQ/YKAgAAgBEEMahD+goCAABogBEEwaiSAgICAAA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEECDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQr4OAgAAhAiABQRBqJICAgIAAIAIPC4ABAQN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhQgAiABNgIQIAIoAhQhAyACIAMQjIOAgAA2AgwgAigCECEEIAIgAkEMajYCHCACIAQ2AhggAigCHCACKAIYELCDgIAAELGDgIAAIAIoAhwQgYOAgAAgAkEgaiSAgICAACADDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCPg4CAACECIAFBEGokgICAgAAgAg8LCQBB/LuGgAAPCx8BAX8jgICAgABBEGshASABIAA2AgggASgCCCgCAA8LRgEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCEDIAIoAgwoAgAgAzYCACACKAIMIQQgBCAEKAIAQQhqNgIADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBC2g4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxCMg4CAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQsIOAgAAQsYOAgAAgAigCHBCBg4CAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEI+DgIAAIQIgAUEQaiSAgICAACACDwsJAEGIvIaAAA8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBDsi4CAACECIAFBEGokgICAgAAgAg8LGQEBfyOAgICAAEEQayEBIAEgADYCDEECDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQvYOAgAAhAiABQRBqJICAgIAAIAIPC4ABAQN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhQgAiABNgIQIAIoAhQhAyACIAMQjIOAgAA2AgwgAigCECEEIAIgAkEMajYCHCACIAQ2AhggAigCHCACKAIYEL6DgIAAEL+DgIAAIAIoAhwQgYOAgAAgAkEgaiSAgICAACADDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCPg4CAACECIAFBEGokgICAgAAgAg8LCQBBlLyGgAAPC58BAQZ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASABKAIIEMCDgIAAQQB0QQRqEJiMgIAANgIEIAEoAggQwIOAgAAhAiABKAIEIAI2AgAgASgCBEEEaiEDIAEoAggQwYOAgAAhBCABKAIIEMCDgIAAQQB0IQUCQCAFRQ0AIAMgBCAF/AoAAAsgASgCBCEGIAFBEGokgICAgAAgBg8LRgEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCEDIAIoAgwoAgAgAzYCACACKAIMIQQgBCAEKAIAQQhqNgIADws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBDCg4CAACECIAFBEGokgICAgAAgAg8LPwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQw4OAgAAQxIOAgAAhAiABQRBqJICAgIAAIAIPC2EBBH8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQICQAJAIAIQxYOAgABBAXFFDQAgAhDGg4CAACEDDAELIAIQx4OAgAAhAwsgAyEEIAFBEGokgICAgAAgBA8LYQEEfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwhAgJAAkAgAhDFg4CAAEEBcUUNACACEMiDgIAAIQMMAQsgAhDJg4CAACEDCyADIQQgAUEQaiSAgICAACAEDwscAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwPCzgBA38jgICAgABBEGshASABIAA2AgwgASgCDC0AC0EHdiECQQAhAyACQf8BcSADQf8BcUdBAXEPCx8BAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCBA8LJwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQALQf8AcUH/AXEPCx8BAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCAA8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQyoOAgAAhAiABQRBqJICAgIAAIAIPCxwBAX8jgICAgABBEGshASABIAA2AgwgASgCDA8LjgEBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAiACKAIIEMyDgIAAEM6BgIAANgIEIAJBAEEBcToAAyAAIAIoAgQgAigCCBCkg4CAACACQQRqENCBgIAAIAJBAUEBcToAAwJAIAItAANBAXENACAAENqCgIAAGgsgAkEQaiSAgICAAA8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQwYOAgAAhAiABQRBqJICAgIAAIAIPC4QEAQp/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQgA0EANgIwIANBADoALyACEM6DgIAAIQQgA0EAQQFxOgAXIANBAEEBcToAFkEAIQUgBEEBcSEGIAUhBwJAIAYNACACEM+DgIAAIQhBACEJIAhBAXEhCiAJIQcgCg0AIANBGGogAhDQg4CAACADQQFBAXE6ABcgA0EgaiADQRhqENGDgIAAIANBAUEBcToAFiADQSBqQduphIAAENKDgIAAIQcLIAchCwJAIAMtABZBAXFFDQAgA0EgahD3jICAABoLAkAgAy0AF0EBcUUNACADQRhqENqCgIAAGgsCQCALQQFxRQ0AAkAgAkHMu4WAABDTg4CAAEEBcUUNACADQQxqIAJBzLuFgAAQ1IOAgAAgA0EMahDVg4CAACEMIANBDGoQ2oKAgAAaIAMgDEEBcToAFQJAIAMtABVBAXFFDQAgA0EBOgAvIAMgA0EvajYCMAsLCyADIAMoAjgQzIOAgAAgAygCMBDPgYCAADYCCCADKAIIIAMoAjgQzIOAgAAQxICAgAAgA0EAQQFxOgAHIAAgAygCCCADKAI4EKiDgIAAIAMoAggQ/4CAgAAgA0EBQQFxOgAHAkAgAy0AB0EBcQ0AIAAQ2oKAgAAaCyADQcAAaiSAgICAAA8LPwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQ4IKAgABBAkZBAXEhAiABQRBqJICAgIAAIAIPCz8BAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEOCCgIAAQQRGQQFxIQIgAUEQaiSAgICAACACDwtLAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAAgAigCCBDggoCAABCIgICAABDfgoCAABogAkEQaiSAgICAAA8LTAECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIIIQMgACADEOCCgIAAQQAgAxDWg4CAACACQRBqJICAgIAADwumAQEFfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACIAIoAgQQo4OAgAA2AgACQAJAIAIoAgAgAigCCBDCg4CAAEdBAXFFDQAgAkEAQQFxOgAPDAELIAIoAgghAyACKAIEIQQgAigCACEFIAIgA0EAQX8gBCAFEP6MgIAAQQBGQQFxOgAPCyACLQAPQQFxIQYgAkEQaiSAgICAACAGDwvdAQEFfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKCACKAIsIQMgAkEQakHiqYSAABDXgoCAACACQRhqIAJBEGpBlqmFgAAQ14OAgAAgAkEgaiACQRhqQYKAhIAAENiDgIAAIAIoAighBCACQQhqIAQQhIOAgAAaIAJBIGpBk/WEgAAgAyACQQhqENmDgIAAIQUgAkEIahDagoCAABogAkEgahDagoCAABogAkEYahDagoCAABogAkEQahDagoCAABogBUEBcSEGIAJBMGokgICAgAAgBg8LhwEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhghBCAEEOCCgIAAIQUgAygCFCEGIANBDGog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gICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgggAygCBBCAjYCAABDgg4CAABogA0EQaiSAgICAAA8L3wEBCH8jgICAgABBIGshAiACJICAgIAAIAIgADYCGCACIAE2AhQgAigCGCEDIAIgAzYCHCACKAIUIQQgAkETaiAEEJKEgIAAIQUgAyAFKQIANwIAQQghBiADIAZqIAUgBmooAgA2AgAgAkEIakEANgIAIAJCADcDACACKAIUIQcgByACKQIANwIAQQghCCAHIAhqIAIgCGooAgA2AgAgAigCFEEAEJOEgIAAAkAgAxDFg4CAAEEBcQ0AIAMgAxDCg4CAABCThICAAAsgAigCHCEJIAJBIGokgICAgAAgCQ8LEABB/KGJgAAQ4oOAgAAaDwtCAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECIAJBjYCAgAAQ5IOAgAAaIAFBEGokgICAgAAgAg8LXQBBgoiEgABBjoCAgAAQ8oOAgABB5aWFgABBj4CAgAAQ84OAgABBjYWEgABBkICAgAAQ9IOAgABB/PSFgABBkYCAgAAQ9IOAgABBuuqEgABBkoCAgAAQ9YOAgAAPC2MBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAMgAigCCDYCACADQQA2AgQgAigCCBGBgICAAICAgIAAIAMQuYuAgAAgAkEQaiSAgICAACADDwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQhIOAgAAaIANBEGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCEg4CAABogA0EQaiSAgICAAA8LyQIBDn8jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQCIoomAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEHjvIaAABDog4CAAEHjvIaAABDpg4CAAEEBEISAgIAAIQdBACAHNgKEoomAAEEBIQhBACAIOgCIoomAAAsgBCgCJCEJIAQoAiAhCiAEQRBqIAkgChDqg4CAABogBEEANgIMQQAoAoSiiYAAIQsgBCgCLCEMIAQoAighDSAEQRBqEOuDgIAAIQ4gBCALIAwgDSAEQQxqIA4QhYCAgAAQ7IOAgABBAXE6AAsgBCgCDCEPIARBBGogDxD8goCAABogBC0AC0EBcRDtg4CAACEQIARBBGoQ/oKAgAAaIBBBAXEhESAEQTBqJICAgIAAIBEPCxkBAX8jgICAgABBEGshASABIAA2AgxBAw8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEO6DgIAAIQIgAUEQaiSAgICAACACDwvHAQEGfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIYIAMgATYCFCADIAI2AhAgAygCGCEEIAMgBBDvg4CAADYCDCADKAIUIQUgAygCECEGIAMgA0EMajYCJCADIAU2AiAgAyAGNgIcIAMoAiQgAygCIBDwg4CAABCOg4CAACADKAIkIQcgAygCHCEIIAMgBzYCLCADIAg2AiggAygCLCADKAIoEI2DgIAAEI6DgIAAIAMoAiwQgYOAgAAgA0EwaiSAgICAACAEDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBDxg4CAACECIAFBEGokgICAgAAgAg8LIwEBfyOAgICAAEEQayEBIAEgADkDCCABKwMIQQC3YkEBcQ8LHwEBfyOAgICAAEEQayEBIAEgADoADyABLQAPQQFxDwsJAEHkvIaAAA8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDwtiAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASABKAIIEOCCgIAANgIEAkAgASgCCBDkgoCAAEEBcUUNACABKAIEEIqAgIAACyABKAIEIQIgAUEQaiSAgICAACACDwscAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwPC5gBAQh/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBk4CAgAA2AgAgAigCDCEDIAJBB2oQuYOAgAAhBCACQQdqELqDgIAAIQUgAigCABD3g4CAACEGIAIoAgAhByACKAIIIQhBACEJIAMgBCAFIAYgByAIIAlBAXEgCUEBcRCLgICAACACQRBqJICAgIAADwuYAQEIfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACQZSAgIAANgIAIAIoAgwhAyACQQdqEPmDgIAAIQQgAkEHahD6g4CAACEFIAIoAgAQ+4OAgAAhBiACKAIAIQcgAigCCCEIQQAhCSADIAQgBSAGIAcgCCAJQQFxIAlBAXEQi4CAgAAgAkEQaiSAgICAAA8LmAEBCH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkGVgICAADYCACACKAIMIQMgAkEHahD9g4CAACEEIAJBB2oQ/oOAgAAhBSACKAIAEP+DgIAAIQYgAigCACEHIAIoAgghCEEAIQkgAyAEIAUgBiAHIAggCUEBcSAJQQFxEIuAgIAAIAJBEGokgICAgAAPC5gBAQh/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBloCAgAA2AgAgAigCDCEDIAJBB2oQgYSAgAAhBCACQQdqEIKEgIAAIQUgAigCABCDhICAACEGIAIoAgAhByACKAIIIQhBACEJIAMgBCAFIAYgByAIIAlBAXEgCUEBcRCLgICAACACQRBqJICAgIAADwuKAQEEfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACKAIcIQMgAigCGCEEIAJBBGogBBCEhICAACACQRBqIAJBBGogAxGCgICAAICAgIAAIAJBEGoQjYOAgAAhBSACQRBqENqCgIAAGiACQQRqEPeMgIAAGiACQSBqJICAgIAAIAUPCx0BAX8jgICAgABBEGshASABIAA2AgxB8LyGgAAPC7YBAQV/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADKAIsIQQgAygCKCEFIANBEGogBRCEhICAACADKAIkIQYgA0EIaiAGEP2CgIAAIANBHGogA0EQaiADQQhqIAQRg4CAgACAgICAACADQRxqEI2DgIAAIQcgA0EcahDagoCAABogA0EIahDagoCAABogA0EQahD3jICAABogA0EwaiSAgICAACAHDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQMPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCGhICAACECIAFBEGokgICAgAAgAg8LHQEBfyOAgICAAEEQayEBIAEgADYCDEGAvYaAAA8LigEBBH8jgICAgABBMGshAiACJICAgIAAIAIgADYCLCACIAE2AiggAigCLCEDIAIoAighBCACQRBqIAQQhISAgAAgAkEcaiACQRBqIAMRgoCAgACAgICAACACQRxqEL6DgIAAIQUgAkEcahD3jICAABogAkEQahD3jICAABogAkEwaiSAgICAACAFDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCHhICAACECIAFBEGokgICAgAAgAg8LHQEBfyOAgICAAEEQayEBIAEgADYCDEGQvYaAAA8LXgEDfyOAgICAAEEgayEBIAEkgICAgAAgASAANgIcIAEoAhwhAiABQRBqIAIRhICAgACAgICAACABQRBqEL6DgIAAIQMgAUEQahD3jICAABogAUEgaiSAgICAACADDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQEPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCIhICAACECIAFBEGokgICAgAAgAg8LHQEBfyOAgICAAEEQayEBIAEgADYCDEGYvYaAAA8LSgEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAghBBGogAigCCCgCABCFhICAABogAkEQaiSAgICAAA8LXAECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCEEIAQQooOAgAAaIAQgAygCCCADKAIEEPmMgIAAIANBEGokgICAgAAgBA8LCQBB9LyGgAAPCwkAQYi9hoAADwsJAEGUvYaAAA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEECDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQjoSAgAAhAiABQRBqJICAgIAAIAIPC4ABAQN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhQgAiABNgIQIAIoAhQhAyACIAMQjIOAgAA2AgwgAigCECEEIAIgAkEMajYCHCACIAQ2AhggAigCHCACKAIYEPCDgIAAEI6DgIAAIAIoAhwQgYOAgAAgAkEgaiSAgICAACADDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCPg4CAACECIAFBEGokgICAgAAgAg8LHgEBfyOAgICAAEEQayEBIAEgADkDCCABKwMI/AMPCwkAQZy9hoAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCRhICAACECIAFBEGokgICAgAAgAg8LCQBBqL2GgAAPC1gBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIIEMWDgIAAQQFxDQAgAigCCBCUhICAAAsgAigCCCEDIAJBEGokgICAgAAgAw8LHgEBfyOAgICAAEEQayECIAIgADYCDCACIAE2AggPCxcBAX8jgICAgABBEGshASABIAA2AgwPCwkAEOGDgIAADwvbAgEFfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKAJAAkAgAigCKEEAR0EBcQ0AIAAQ1oKAgAAMAQsgAkEAQQFxOgAnIAAQl4SAgAAgAigCKBD9gICAACEDIAJBHGogAxCRg4CAACAAQcSphYAAIAJBHGoQ2YKAgAAgAkEcahDagoCAABogAigCKCgCBCEEIAJBFGogBBCXg4CAACAAQdTlhIAAIAJBFGoQ3IKAgAAgAkEUahDagoCAABogAigCKCgCCCEFIAJBDGogBRDzgoCAACAAQcKyhIAAIAJBDGoQpYOAgAAgAkEMahDagoCAABogAigCKCgCDCEGIAJBBGogBhCYhICAACAAQcXshIAAIAJBBGoQ3IKAgAAgAkEEahDagoCAABogAkEBQQFxOgAnAkAgAi0AJ0EBcQ0AIAAQ2oKAgAAaCwsgAkEwaiSAgICAAA8LOQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAAQjICAgAAQ34KAgAAaIAFBEGokgICAgAAPC4sCAQJ/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYAkACQCACKAIYQQBHQQFxDQAgABDWgoCAAAwBCyACQQBBAXE6ABcgABCZhICAACACQQA2AhACQANAIAIoAhAgAigCGBDagICAAElBAXFFDQEgAiACKAIYIAIoAhAQ1oCAgAA2AgwCQCACKAIMQQBHQQFxRQ0AIAIoAgwhAyACQQRqIAMQmoSAgAAgACACQRBqIAJBBGoQm4SAgAAgAkEEahDagoCAABoLIAIgAigCEEEBajYCEAwACwsgAkEBQQFxOgAXAkAgAi0AF0EBcQ0AIAAQ2oKAgAAaCwsgAkEgaiSAgICAAA8LOQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAAQjYCAgAAQ34KAgAAaIAFBEGokgICAgAAPC7sFAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIIQQBHQQFxDQAgABDWgoCAAAwBCyACKAIIKAIAIQMgA0EeSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMOHwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fCyAAIAIoAggQloSAgAAMHwsgACACKAIIEJyEgIAADB4LIAAgAigCCBCdhICAAAwdCyAAIAIoAggQoISAgAAMHAsgACACKAIIEKGEgIAADBsLIAAgAigCCBCjhICAAAwaCyAAIAIoAggQpISAgAAMGQsgACACKAIIEKWEgIAADBgLIAAgAigCCBCmhICAAAwXCyAAIAIoAggQp4SAgAAMFgsgACACKAIIEKiEgIAADBULIAAgAigCCBCphICAAAwUCyAAIAIoAggQqoSAgAAMEwsgACACKAIIEKuEgIAADBILIAAgAigCCBCshICAAAwRCyAAIAIoAggQrYSAgAAMEAsgACACKAIIEK6EgIAADA8LIAAgAigCCBCvhICAAAwOCyAAIAIoAggQsISAgAAMDQsgACACKAIIELGEgIAADAwLIAAgAigCCBCyhICAAAwLCyAAIAIoAggQs4SAgAAMCgsgACACKAIIELSEgIAADAkLIAAgAigCCBC1hICAAAwICyAAIAIoAggQtoSAgAAMBwsgACACKAIIELeEgIAADAYLIAAgAigCCBC4hICAAAwFCyAAIAIoAggQuYSAgAAMBAsgACACKAIIELqEgIAADAMLIAAgAigCCBC7hICAAAwCCyAAIAIoAggQvISAgAAMAQsgABDWgoCAAAsgAkEQaiSAgICAAA8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEEOCCgIAAIQUgAygCGCEGIANB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BxCdg4CAACAAQcOQhIAAIAJBLGoQ24KAgAAgAkEsahDagoCAABogAigCWCgCFCEIIAJBJGogCBCdg4CAACAAQdKGhYAAIAJBJGoQ3YKAgAAgAkEkahDagoCAABogAigCWCgCGCEJIAJBHGogCRCYhICAACAAQcXshIAAIAJBHGoQ3IKAgAAgAkEcahDagoCAABogAigCWCgCHCEKIAJBFGogChCYhICAACAAQey1hIAAIAJBFGoQvYSAgAAgAkEUahDagoCAABogAigCWCgCICELIAJBDGogCxCahICAACAAQdKihYAAIAJBDGoQ3YKAgAAgAkEMahDagoCAABogAigCWCgCJCEMIAJBBGogDBCahICAACAAQZi4hYAAIAJBBGoQ3IKAgAAgAkEEahDagoCAABogAkEBQQFxOgBXAkAgAi0AV0EBcQ0AIAAQ2oKAgAAaCwsgAkHgAGokgICAgAAPC6cFAQt/I4CAgIAAQeAAayECIAIkgICAgAAgAiAANgJcIAIgATYCWAJAAkAgAigCWEEAR0EBcQ0AIAAQ1oKAgAAMAQsgAkEAQQFxOgBXIAAQl4SAgAAgAigCWBD9gICAACEDIAJBzABqIAMQkYOAgAAgAEHEqYWAACACQcwAahDZgoCAACACQcwAahDagoCAABogAigCWCgCBCEEIAJBxABqIAQQl4OAgAAgAEHU5YSAACACQcQAahDcgoCAACACQcQAahDagoCAABogAigCWCgCCCEFIAJBPGogBRDzgoCAACAAQcKyhIAAIAJBPGoQpYOAgAAgAkE8ahDagoCAABogAigCWCgCDCEGIAJBNGogBhCdg4CAACAAQfSIhYAAIAJBNGoQ3YKAgAAgAkE0ahDagoCAABogAigCWCgCECEHIAJBLGogBxCdg4CAACAAQcOQhIAAIAJBLGoQ24KAgAAgAkEsahDagoCAABogAigCWCgCFCEIIAJBJGogCBCdg4CAACAAQdKGhYAAIAJBJGoQ3YKAgAAgAkEkahDagoCAABogAigCWCgCGCEJIAJBHGogCRCYhICAACAAQcXshIAAIAJBHGoQ3IKAgAAgAkEcahDagoCAABogAigCWCgCHCEKIAJBFGogChCYhICAACAAQey1hIAAIAJBFGoQvYSAgAAgAkEUahDagoCAABogAigCWCgCICELIAJBDGogCxCa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ahDagoCAABogAigCSCgCECEHIAJBHGogBxCdg4CAACAAQcOQhIAAIAJBHGoQ24KAgAAgAkEcahDagoCAABogAigCSCgCFCEIIAJBFGogCBCdg4CAACAAQdKGhYAAIAJBFGoQ3YKAgAAgAkEUahDagoCAABogAigCSCgCGCEJIAJBDGogCRCYhICAACAAQfashIAAIAJBDGoQvYSAgAAgAkEMahDagoCAABogAkEBQQFxOgBHAkAgAi0AR0EBcQ0AIAAQ2oKAgAAaCwsgAkHQAGokgICAgAAPC+MFAQx/I4CAgIAAQfAAayECIAIkgICAgAAgAiAANgJsIAIgATYCaAJAAkAgAigCaEEAR0EBcQ0AIAAQ1oKAgAAMAQsgAkEAQQFxOgBnIAAQl4SAgAAgAigCaBD9gICAACEDIAJB3ABqIAMQkYOAgAAgAEHEqYWAACACQdwAahDZgoCAACACQdwAahDagoCAABogAigCaCgCBCEEIAJB1ABqIAQQl4OAgAAgAEHU5YSAACACQdQAahDcgoCAACACQdQAahDagoCAABogAigCaCgCCCEFIAJBzABqIAUQ84KAgAAgAEHCsoSAACACQcwAahClg4CAACACQcwAahDagoCAABogAigCaCgCDCEGIAJBxABqIAYQnYOAgAAgAEH0iIWAACACQcQAahDdgoCAACACQcQAahDagoCAABogAigCaCgCECEHIAJBPGogBxCdg4CAACAAQcOQhIAAIAJBPGoQ24KAgAAgAkE8ahDagoCAABogAigCaCgCFCEIIAJBNGogCBCdg4CAACAAQdKGhYAAIAJBNGoQ3YKAgAAgAkE0ahDagoCAABogAigCaCgCGCEJIAJBLGogCRCYhICAACAAQfashIAAIAJBLGoQvYSAgAAgAkEsahDagoCAABogAigCaCgCHCEKIAJBJGogChCahICAACAAQcSihYAAIAJBJGoQ6oKAgAAgAkEkahDagoCAABogAigCaCgCICELIAJBHGogCxCahICAACAAQdKihYAAIAJBHGoQ3YKAgAAgAkEcahDagoCAABogAigCaCgCJCEMIAJBFGogDBCahICAACAAQd6ihYAAIAJBFGoQ6oKAgAAgAkEUahDagoCAABogAigCaCgCKCENIAJBDGogDRCahICAACAAQZi4hYAAIAJBDGoQ3IKAgAAg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gAAPC68BAQZ/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDggoCAACEFIAMoAhghBiADQQxqIAQgBhCWg4CAACADQQxqEOCCgIAAIQcgAygCFCEIIANBBGogBCAIEJ+EgIAAIAUgByADQQRqEOCCgIAAEIKAgIAAIANBBGoQ2oKAgAAaIANBDGoQ2oKAgAAaIANBIGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCEg4CAABogA0EQaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEEOCCgIAAIQUgAygCGCEGIANBDGogBCAGEOiCgIAAIANBDGoQ4IKAgAAhByADKAIUIQggA0EEaiAEIAgQn4SAgAAgBSAHIANBBGoQ4IKAgAAQgoCAgAAgA0EEahDagoCAABogA0EMahDagoCAABogA0EgaiSAgICAAA8LUwEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAigCCCEEQQAhBSADIAUgBSAEEMKEgIAAIAJBEGokgICAgAAgAw8LsQIBC38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQCgoomAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEGwvYaAABDDhICAAEGwvYaAABDEhICAAEEDEISAgIAAIQdBACAHNgKcoomAAEEBIQhBACAIOgCgoomAAAsgBCgCICEJIARBGGogCRDFhICAABogBEEANgIUQQAoApyiiYAAIQogBCgCKCELIAQoAiQhDCAEQRhqEMaEgIAAIQ0gBCAKIAsgDCAEQRRqIA0QhYCAgAAQ+4KAgAA2AhAgBCgCFCEOIARBDGogDhD8goCAABogACAEKAIQEP2CgIAAIARBDGoQ/oKAgAAaIARBMGokgICAgAAPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEMeEgIAAIQIgAUEQaiSAgICAACACDwuJAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIUIAIgATYCECACKAIUIQMgAiADEIyDgIAANgIMIAIoAhAhBCACIAJBDGo2AhwgAiAENgIYIAIoAhwgAigCGC0AAEEBcRDIhICAAEEBcRDJhICAACACKAIcEIGDgIAAIAJBIGokgICAgAAgAw8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQj4OAgAAhAiABQRBqJICAgIAAIAIPCwkAQbS9hoAADwsfAQF/I4CAgIAAQRBrIQEgASAAOgAOIAEtAA5BAXEPC0kBA38jgICAgABBEGshAiACIAA2AgwgAiABOgALIAItAAtBAXEhAyACKAIMKAIAIAM2AgAgAigCDCEEIAQgBCgCAEEIajYCAA8LmC4BA38jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIIQIgAkG+AksaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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hIAANgIMDHgLIAFB/IGFgAA2AgwMdwsgAUHHgoWAADYCDAx2CyABQZnYhIAANgIMDHULIAFBk42EgAA2AgwMdAsgAUHVrIWAADYCDAxzCyABQcTGhYAANgIMDHILIAFBvqKEgAA2AgwMcQsgAUHfiISAADYCDAxwCyABQeDEhYAANgIMDG8LIAFBh9WEgAA2AgwMbgsgAUHmgYWAADYCDAxtCyABQZbXhIAANgIMDGwLIAFBpbyFgAA2AgwMawsgAUH3iISAADYCDAxqCyABQc/YhYAANgIMDGkLIAFB26uEgAA2AgwMaAsgAUHdoIWAADYCDAxnCyABQemohIAANgIMDGYLIAFBltiFgAA2AgwMZQsgAUGsqISAADYCDAxkCyABQZnrhIAANgIMDGMLIAFB7oKEgAA2AgwMYgsgAUH77ISAADYCDAxhCyABQd7qhIAANgIMDGALIAFByamFgAA2AgwMXwsgAUHdtoWAADYCDAxeCyABQfWMhIAANgIMDF0LIAFBlNOEgAA2AgwMXAsgAUHxo4SAADYCDAxbCyABQYuDhIAANgIMDFoLIAFBwqCFgAA2AgwMWQsgAUGbxYWAADYCDAxYCyABQdD2hIAANgIMDFcLIAFBqrmEgAA2AgwMVgsgAUGQqISAADYCDAxVCyABQbXYhYAANgIMDFQLIAFBuY2EgAA2AgwMUwsgAUHyuoWAADYCDAxSCyABQYqphIAANgIMDFELIAFBxO2EgAA2AgwMUAsgAUHh64SAADYCDAxPCyABQdyFhYAANgIMDE4LIAFBjYqFgAA2AgwMTQsgAUGPt4WAADYCDAxMCyABQZzMhYAANgIMDEsLIAFBnMuEgAA2AgwMSgsgAUGt8ISAADYCDAxJCyABQci1hIAANgIMDEgLIAFBmNmEgAA2AgwMRwsgAUH95YSAADYCDAxGCyABQc2OhYAANgIMDEULIAFBlPGEgAA2AgwMRAsgAUHVs4WAADYCDAxDCyABQZzChYAANgIMDEILIAFB0r2FgAA2AgwMQQsgAUHnuISAADYCDAxACyABQa6+hIAANgIMDD8LIAFB47+FgAA2AgwMPgsgAUH76oSAADYCDAw9CyABQdGMhYAANgIMDDwLIAFBgOWEgAA2AgwMOwsgAUGm8oSAADYCDAw6CyABQfiLhYAANgIMDDkLIAFBz/CEgAA2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EGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw+4eAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/YeAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/YeAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/YeAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/4eAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/4eAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/4eAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwg4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwg4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwg4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwh4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwh4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwh4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwiYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwiYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwiYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwi4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwi4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwi4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwj4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwj4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwj4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwk4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwk4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwk4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwlYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwlYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwlYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwl4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwl4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwl4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwm4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwm4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwm4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwn4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwn4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwn4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwoYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwoYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwoYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwo4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwo4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwo4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwp4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwp4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwp4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwq4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwq4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwq4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwrYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwrYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwrYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwr4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwr4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwr4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCws4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCws4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCws4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwt4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwt4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwt4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwu4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwu4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwu4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwv4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwv4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwv4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCww4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCww4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCww4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwx4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwx4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwx4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwy4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwy4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwy4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzYiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzYiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzYiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwz4iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwz4iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwz4iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0YiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0YiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0YiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw04iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw04iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw04iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1YiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1YiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1YiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw14iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw14iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw14iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2YiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2YiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2YiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw24iAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw24iAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw24iAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2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AgggAigCDCgCAEECdGohAyACKAIIKAIIIQQgAigCCCgCAEECdCEFAkAgBUUNACADIAQgBfwKAAALIAIoAggoAgAhBiACKAIMIQcgByAGIAcoAgBqNgIACyACQRBqJICAgIAADwuGAQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCBEEAS0EBcUUNACABKAIMKAIIEJqMgIAAIAEoAgwhAiABQQA2AgAgAUEANgIEIAFBADYCCCACIAEpAgA3AgBBCCEDIAIgA2ogASADaigCADYCAAsgAUEQaiSAgICAAA8L60ABAn8jgICAgABB4ANrIQIgAiSAgICAACACIAA2AtwDIAIgATYC2AMgAigC2AMvAQBBf2ohAyADQZYBSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAw6XAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBCyACIAIoAtgDNgLUAyACKALcAyACKALUAygCEBChhoCAACACKALcAyACKALUAygCFBChhoCAAAyXAQsgAiACKALYAzYC0AMgAigC3AMgAigC0AMoAhAQoYaAgAAgAigC3AMgAigC0AMoAhQQoYaAgAAMlgELIAIgAigC2AM2AswDIAIoAtwDIAIoAswDKAIQEKGGgIAAIAIoAtwDIAIoAswDKAIUEKGGgIAADJUBCyACIAIoAtgDNgLIAyACKALcAyACKALIAygCEBChhoCAACACKALcAyACKALIAygCFBChhoCAAAyUAQsgAiACKALYAzYCxAMgAigC3AMgAigCxANBEGoQooaAgAAMkwELIAIgAigC2AM2AsADIAIoAtwDIAIoAsADQRBqEKKGgIAADJIBCyACIAIoAtgDNgK8AwJAIAIoArwDKAIQQQBHQQFxRQ0AIAIoAtwDIAIoArwDKAIQEKGGgIAACyACKALcAyACKAK8A0EUahCihoCAAAJAIAIoArwDKAIgQQBHQQFxRQ0AIAIoAtwDIAIoArwDKAIgEKGGgIAACyACKALcAyACKAK8A0EkahCihoCAAAyRAQsgAiACKALYAzYCuAMgAigC3AMgAigCuAMoAhAQoYaAgAAgAigC3AMgAigCuAMoAhQQoYaAgAAMkAELIAIgAigC2AM2ArQDAkAgAigCtAMoAhBBAEdBAXFFDQAgAigC3AMgAigCtAMoAhAQoYaAgAALDI8BCwyOAQsgAiACKALYAzYCsAMCQCACKAKwAygCGEEAR0EBcUUNACACKALcAyACKAKwAygCGBChhoCAAAsCQCACKAKwAygCHEEAR0EBcUUNACACKALcAyACKAKwAygCHBChhoCAAAsCQCACKAKwAygCIEEAR0EBcUUNACACKALcAyACKAKwAygCIBChhoCAAAsCQCACKAKwAygCJEEAR0EBcUUNACACKALcAyACKAKwAygCJBChhoCAAAsMjQELIAIgAigC2AM2AqwDAkAgAigCrAMoAhBBAEdBAXFFDQAgAigC3AMgAigCrAMoAhAQoYaAgAALDIwBCwyLAQsgAiACKALYAzYCqAMgAigCqANBEGoQhIuAgAACQCACKAKoAygCHEEAR0EBcUUNACACKALcAyACKAKoAygCHBChhoCAAAsCQCACKAKoAygCIEEAR0EBcUUNACACKALcAyACKAKoAygCIBChhoCAAAsMigELDIkBCyACIAIoAtgDNgKkAwJAIAIoAqQDKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAqQDKAIQEKGGgIAACyACKALcAyACKAKkA0EUahCihoCAAAyIAQsgAiACKALYAzYCoAMCQCACKAKgAygCEEEAR0EBcUUNACACKALcAyACKAKgAygCEBChhoCAAAsMhwELIAIgAigC2AM2ApwDAkAgAigCnAMoAhBBAEdBAXFFDQAgAigC3AMgAigCnAMoAhAQoYaAgAALIAIoAtwDIAIoApwDKAI0EKGGgIAADIYBCyACIAIoAtgDNgKYAwJAIAIoApgDKAIQQQBHQQFxRQ0AIAIoAtwDIAIoApgDKAIQEKGGgIAACwJAIAIoApgDKAIwQQBHQQFxRQ0AIAIoAtwDIAIoApgDKAIwEKGGgIAACwJAIAIoApgDKAI8QQBHQQFxRQ0AIAIoAtwDIAIoApgDKAI8EKGGgIAACwyFAQsgAiACKALYAzYClAMCQCACKAKUAygCEEEAR0EBcUUNACACKALcAyACKAKUAygCEBChhoCAAAsgAigC3AMgAigClAMoAjgQoYaAgAAMhAELIAIgAigC2AM2ApADAkAgAigCkAMoAhBBAEdBAXFFDQAgAigC3AMgAigCkAMoAhAQoYaAgAALIAIoAtwDIAIoApADKAI0EKGGgIAADIMBCyACIAIoAtgDNgKMAyACKALcAyACKAKMAygCEBChhoCAAAyCAQsgAiACKALYAzYCiAMgAigC3AMgAigCiAMoAhAQoYaAgAAgAigC3AMgAigCiAMoAhQQoYaAgAAMgQELIAIgAigC2AM2AoQDAkAgAigChAMoAhBBAEdBAXFFDQAgAigC3AMgAigChAMoAhAQoYaAgAALIAIoAtwDIAIoAoQDQRRqEKKGgIAAAkAgAigChAMoAiBBAEdBAXFFDQAgAigC3AMgAigChAMoAiAQoYaAgAALDIABCyACIAIoAtgDNgKAAwJAIAIoAoADKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAoADKAIQEKGGgIAACyACKALcAyACKAKAA0EUahCihoCAAAJAIAIoAoADKAIgQQBHQQFxRQ0AIAIoAtwDIAIoAoADKAIgEKGGgIAACwx/CyACIAIoAtgDNgL8AiACKAL8AkEQahCEi4CAACACKALcAyACKAL8AigCJBChhoCAAAJAIAIoAvwCKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAvwCKAIwEKGGgIAACwJAIAIoAvwCKAI0QQBHQQFxRQ0AIAIoAtwDIAIoAvwCKAI0EKGGgIAACwx+CyACIAIoAtgDNgL4AiACKALcAyACKAL4AigCJBChhoCAAAx9CyACIAIoAtgDNgL0AiACKALcAyACKAL0AigCJBChhoCAAAx8CyACIAIoAtgDNgLwAiACKALcAyACKALwAigCJBChhoCAAAx7Cwx6Cwx5CyACIAIoAtgDNgLsAiACKALcAyACKALsAigCHBChhoCAAAx4CyACIAIoAtgDNgLoAiACKALcAyACKALoAigCJBChhoCAAAx3CyACIAIoAtgDNgLkAiACKALcAyACKALkAigCJBChhoCAAAx2CyACIAIoAtgDNgLgAiACKALcAyACKALgAigCJBChhoCAAAx1CyACIAIoAtgDNgLcAiACKALcAyACKALcAigCEBChhoCAACACKALcAyACKALcAigCHBChhoCAAAx0CyACIAIoAtgDNgLYAgJAIAIoAtgCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAtgCKAIQEKGGgIAACwxzCyACIAIoAtgDNgLUAiACKALcAyACKALUAigCEBChhoCAACACKALcAyACKALUAigCHBChhoCAAAxyCyACIAIoAtgDNgLQAiACKALcAyACKALQAigCEBChhoCAACACKALcAyACKALQAigCHBChhoCAAAxxCyACIAIoAtgDNgLMAgJAIAIoAswCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAswCKAIQEKGGgIAACwxwCyACIAIoAtgDNgLIAiACKALcAyACKALIAigCEBChhoCAACACKALcAyACKALIAigCHBChhoCAAAxvCwxuCwxtCyACIAIoAtgDNgLEAiACKALcAyACKALEAigCHBChhoCAAAxsCyACIAIoAtgDNgLAAgJAIAIoAsACKAIcQQBHQQFxRQ0AIAIoAtwDIAIoAsACKAIcEKGGgIAACwJAIAIoAsACKAIgQQBHQQFxRQ0AIAIoAtwDIAIoAsACKAIgEKGGgIAACwJAIAIoAsACKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAsACKAIkEKGGgIAACyACKALAAkEoahCEi4CAAAxrCyACIAIoAtgDNgK8AiACKALcAyACKAK8AigCGBChhoCAAAxqCyACIAIoAtgDNgK4AgJAIAIoArgCKAIYQQBHQQFxRQ0AIAIoAtwDIAIoArgCKAIYEKGGgIAACwxpCyACIAIoAtgDNgK0AgJAIAIoArQCKAIYQQBHQQFxRQ0AIAIoAtwDIAIoArQCKAIYEKGGgIAACwxoCyACIAIoAtgDNgKwAiACKALcAyACKAKwAigCGBChhoCAAAxnCyACIAIoAtgDNgKsAgJAIAIoAqwCKAIYQQBHQQFxRQ0AIAIoAtwDIAIoAqwCKAIYEKGGgIAACwxmCwxlCyACIAIoAtgDNgKoAgJAIAIoAqgCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAqgCKAIQEKGGgIAACyACKALcAyACKAKoAigCFBChhoCAACACKALcAyACKAKoAkEYahCihoCAACACKALcAyACKAKoAigCJBChhoCAAAxkCyACIAIoAtgDNgKkAgJAIAIoAqQCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAqQCKAIQEKGGgIAACwJAIAIoAqQCKAIUQQBHQQFxRQ0AIAIoAtwDIAIoAqQCKAIUEKGGgIAACwxjCwxiCyACIAIoAtgDNgKgAiACKALcAyACKAKgAigCEBChhoCAACACKALcAyACKAKgAigCFBChhoCAAAJAIAIoAqACKAIYQQBHQQFxRQ0AIAIoAtwDIAIoAqACKAIYEKGGgIAACwxhCwxgCwxfCyACIAIoAtgDNgKcAgJAIAIoApwCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoApwCKAIQEKGGgIAACwxeCyACIAIoAtgDNgKYAiACKALcAyACKAKYAigCJBChhoCAAAxdCyACIAIoAtgDNgKUAiACKALcAyACKAKUAigCJBChhoCAAAxcCyACIAIoAtgDNgKQAiACKALcAyACKAKQAigCJBChhoCAAAxbCwxaCwxZCyACIAIoAtgDNgKMAiACKALcAyACKAKMAigCHBChhoCAAAxYCyACIAIoAtgDNgKIAiACKALcAyACKAKIAkEYahCihoCAAAxXCyACIAIoAtgDNgKEAgJAIAIoAoQCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAoQCKAIQEKGGgIAACyACKALcAyACKAKEAkEUahCihoCAAAJAIAIoAoQCKAIgQQBHQQFxRQ0AIAIoAtwDIAIoAoQCKAIgEKGGgIAACwxWCyACIAIoAtgDNgKAAiACKALcAyACKAKAAigCGBChhoCAAAJAIAIoAoACKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAoACKAIkEKGGgIAACwJAIAIoAoACKAIoQQBHQQFxRQ0AIAIoAtwDIAIoAoACKAIoEKGGgIAACwxVCyACIAIoAtgDNgL8ASACKALcAyACKAL8ASgCEBChhoCAAAxUCyACIAIoAtgDNgL4ASACKALcAyACKAL4ASgCEBChhoCAAAxTCwxSCyACIAIoAtgDNgL0ASACKALcAyACKAL0ASgCEBChhoCAAAJAIAIoAvQBKAIUQQBHQQFxRQ0AIAIoAtwDIAIoAvQBKAIUEKGGgIAACwxRCyACIAIoAtgDNgLwAQJAIAIoAvABKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAvABKAIQEKGGgIAACwJAIAIoAvABKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAvABKAIkEKGGgIAACwJAIAIoAvABKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAvABKAIwEKGGgIAACyACKALcAyACKALwASgCPBChhoCAAAxQCyACIAIoAtgDNgLsAQJAIAIoAuwBKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAuwBKAIQEKGGgIAACwJAIAIoAuwBKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAuwBKAIkEKGGgIAACwJAIAIoAuwBKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAuwBKAIwEKGGgIAACyACKALcAyACKALsASgCQBChhoCAAAxPCyACIAIoAtgDNgLoAQJAIAIoAugBKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIQEKGGgIAACwJAIAIoAugBKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIkEKGGgIAACwJAIAIoAugBKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIwEKGGgIAACyACKALcAyACKALoASgCPBChhoCAAAxOCyACIAIoAtgDNgLkASACKALcAyACKALkASgCEBChhoCAAAJAIAIoAuQBKAIcQQBHQQFxRQ0AIAIoAtwDIAIoAuQBKAIcEKGGgIAACwJAIAIoAuQBKAIoQQBHQQFxRQ0AIAIoAtwDIAIoAuQBKAIoEKGGgIAACwxNCyACIAIoAtgDNgLgASACKALcAyACKALgASgCJBChhoCAAAxMCyACIAIoAtgDNgLcASACKALcAyACKALcASgCJBChhoCAAAxLCyACIAIoAtgDNgLYASACKALcAyACKALYASgCJBChhoCAAAxKCwxJCwxICyACIAIoAtgDNgLUASACKALcAyACKALUASgCHBChhoCAAAxHCyACIAIoAtgDNgLQASACKALQAUEQahCZi4CAAAxGCyACIAIoAtgDNgLMASACKALcAyACKALMAUEYahCihoCAAAxFCyACIAIoAtgDNgLIASACKALcAyACKALIAUEYahCihoCAAAxECyACIAIoAtgDNgLEASACKALcAyACKALEAUEYahCihoCAAAxDCyACIAIoAtgDNgLAASACKALcAyACKALAAUEYahCihoCAAAxCCyACIAIoAtgDNgK8ASACKALcAyACKAK8AUEYahCihoCAAAxBCwxACww/CyACIAIoAtgDNgK4ASACKALcAyACKAK4AUEQahCihoCAAAw+Cww9CyACIAIoAtgDNgK0ASACKAK0AUEQahCEi4CAAAJAIAIoArQBKAI0QQBHQQFxRQ0AIAIoAtwDIAIoArQBKAI0EKGGgIAACwJAIAIoArQBKAI4QQBHQQFxRQ0AIAIoAtwDIAIoArQBKAI4EKGGgIAACww8CyACIAIoAtgDNgKwASACKALcAyACKAKwASgCIBChhoCAAAw7CyACIAIoAtgDNgKsASACKALcAyACKAKsASgCIBChhoCAAAw6CyACIAIoAtgDNgKoASACKALcAyACKAKoASgCIBChhoCAAAw5Cww4Cww3CyACIAIoAtgDNgKkASACKALcAyACKAKkASgCIBChhoCAAAw2CyACIAIoAtgDNgKgASACKAKgAUEoahCui4CAAAw1CyACIAIoAtgDNgKcASACKALcAyACKAKcASgCEBChhoCAACACKALcAyACKAKcASgCFBChhoCAAAw0CyACIAIoAtgDNgKYASACKALcAyACKAKYASgCEBChhoCAACACKALcAyACKAKYASgCFBChhoCAAAwzCyACIAIoAtgDNgKUASACKALcAyACKAKUASgCEBChhoCAACACKALcAyACKAKUAUEUahCihoCAAAwyCwwxCyACIAIoAtgDNgKQASACKAKQAUEQahCEi4CAACACKALcAyACKAKQASgCJBChhoCAAAJAIAIoApABKAIoQQBHQQFxRQ0AIAIoAtwDIAIoApABKAIoEKGGgIAACwwwCyACIAIoAtgDNgKMASAC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KAIcKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAhwoAiQQoYaAgAALAkAgAigCHCgCKEEAR0EBcUUNACACKALcAyACKAIcKAIoEKGGgIAACwwGCyACIAIoAtgDNgIYIAIoAtwDIAIoAhgoAigQoYaAgAACQCACKAIYKAIsQQBHQQFxRQ0AIAIoAtwDIAIoAhgoAiwQoYaAgAALDAULIAIgAigC2AM2AhQgAigC3AMgAigCFEEYahCihoCAAAJAIAIoAhQoAixBAEdBAXFFDQAgAigC3AMgAigCFCgCLBChhoCAAAsMBAsgAiACKALYAzYCECACKALcAyACKAIQKAIoEKGGgIAAAkAgAigCECgCLEEAR0EBcUUNACACKALcAyACKAIQKAIsEKGGgIAACwwDCyACIAIoAtgDNgIMIAIoAgxBKGoQrouAgAAMAgsgAiACKALYAzYCCAJAIAIoAggoAiBBAEdBAXFFDQAgAigC3AMgAigCCCgCIBChhoCAAAsMAQtB4raGgABBlteFgABBjAFBtYKEgAAQjoCAgAAACyACKALYAxCajICAACACQeADaiSAgICAAA8LuwEBBn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIAA0AgAigCACACKAIIKAIASSEDQQAhBCADQQFxIQUgBCEGAkAgBUUNACACKAIIKAIIIAIoAgBBAnRqKAIAIQcgAiAHNgIEIAdBAEchBgsCQCAGQQFxRQ0AIAIoAgwgAigCBBChhoCAACACIAIoAgBBAWo2AgAMAQsLIAIoAggQoIaAgAAgAkEQaiSAgICAAA8LdAECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCCCEEAkAgAygCDCADKAIEIAQRgICAgACAgICAAEEBcUUNACADKAIMIAMoAgggAygCBBCkhoCAAAsgA0EQaiSAgICAAA8LnVkBAn8jgICAgABBsAVrIQMgAySAgICAACADIAA2AqwFIAMgATYCqAUgAyACNgKkBSADKAKsBS8BAEF/aiEEIARBlwFLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEDpgBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAQsgAyADKAKsBTYCoAUgAygCoAUoAhAgAygCqAUgAygCpAUQo4aAgAAgAygCoAUoAhQgAygCqAUgAygCpAUQo4aAgAAMlwELIAMgAygCrAU2ApwFIAMoApwFKAIQIAMoAqgFIAMoAqQFEKOGgIAAIAMoApwFKAIUIAMoAqgFIAMoAqQFEKOGgIAADJYBCyADIAMoAqwFNgKYBSADKAKYBSgCECADKAKoBSADKAKkBRCjhoCAACADKAKYBSgCFCADKAKoBSADKAKkBRCjhoCAAAyVAQsgAyADKAKsBTYClAUgAygClAUoAhAgAygCqAUgAygCpAUQo4aAgAAgAygClAUoAhQgAygCqAUgAygCpAUQo4aAgAAMlAELIAMgAygCrAU2ApAFIAMgAygCkAVBEGo2AowFIANBADYCiAUCQANAIAMoAogFIAMoAowFKAIASUEBcUUNASADKAKMBSgCCCADKAKIBUECdGooAgAgAygCqAUgAygCpAUQo4aAgAAgAyADKAKIBUEBajYCiAUMAAsLDJMBCyADIAMoAqwFNgKEBSADIAMoAoQFQRBqNgKABSADQQA2AvwEAkADQCADKAL8BCADKAKABSgCAElBAXFFDQEgAygCgAUoAgggAygC/ARBAnRqKAIAIAMoAqgFIAMo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AhAgAygCqAUgAygCpAUQo4aAgAAgAygC6AMoAhwgAygCqAUgAygCpAUQo4aAgAAMcgsgAyADKAKsBTYC5AMgAygC5AMoAhAgAygCqAUgAygCpAUQo4aAgAAgAygC5AMoAhwgAygCqAUgAygCpAUQo4aAgAAMcQsgAyADKAKsBTYC4AMCQCADKALgAygCEEEAR0EBcUUNACADKALgAygCECADKAKoBSADKAKkBRCjhoCAAAsMcAsgAyADKAKsBTYC3AMgAygC3AMoAhAgAygCqAUgAygCpAUQo4aAgAAgAygC3AMoAhwgAygCqAUgAygCpAUQo4aAgAAMbwsMbgsMbQsgAyADKAKsBTYC2AMgAygC2AMoAhwgAygCqAUgAygCpAUQo4aAgAAMbAsgAyADKAKsBTYC1AMCQCADKALUAygCHEEAR0EBcUUNACADKALUAygCHCADKAKoBSADKAKkBRCjhoCAAAsCQCADKALUAygCIEEAR0EBcUUNACADKALUAygCICADKAKoBSADKAKkBRCjhoCAAAsCQCADKALUAygCJEEAR0EBcUUNACADKALUAygCJCADKAKoBSADKAKkBRCjhoCAAAsMawsgAyADKAKsBTYC0AMgAygC0AMoAhggAygCqAUgAygCpAUQo4aAgAAMagsgAyADKAKsBTYCzAMCQCADKALMAygCGEEAR0EBcUUNACADKALMAygCGCADKAKoBSADKAKkBRCjhoCAAAsMaQsgAyADKAKsBTYCyAMCQCADKALIAygCGEEAR0EBcUUNACADKALIAygCGCADKAKoBSADKAKkBRCjhoCAAAsMaAsgAyADKAKsBTYCxAMgAygCxAMoAhggAygCqAUgAygCpAUQo4aAgAAMZwsgAyADKAKsBTYCwAMCQCADKALAAygCGEEAR0EBcUUNACADKALAAygCGCADKAKoBSADKAKkBRCjhoCAAAsMZgsMZQsgAyADKAKsBTYCvAMCQCADKAK8AygCEEEAR0EBcUUNACADKAK8AygCECADKAKoBSADKAKkBRCjhoCAAAsgAygCvAMoAhQgAygCqAUgAygCpAUQo4aAgAAgAyADKAK8A0EYajYCuAMgA0EANgK0AwJAA0AgAygCtAMgAygCuAMoAgBJQQFxRQ0BIAMoArgDKAIIIAMoArQDQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoArQDQQFqNgK0AwwACwsgAygCvAMoAiQgAygCqAUgAygCpAUQo4aAgAAMZAsgAyADKAKsBTYCsAMCQCADKAKwAygCEEEAR0EBcUUNACADKAKwAygCECADKAKoBSADKAKkBRCjhoCAAAsCQCADKAKwAygCFEEAR0EBcUUNACADKAKwAygCFCADKAKoBSADKAKkBRCjhoCAAAsMYwsMYgsgAyADKAKsBTYCrAMgAygCrAMoAhAgAygCqAUgAygCpAUQo4aAgAAgAygCrAMoAhQgAygCqAUgAygCpAUQo4aAgAACQCADKAKsAygCGEEAR0EBcUUNACADKAKsAygCGCADKAKoBSADKAKkBRCjhoCAAAsMYQsMYAsMXwsgAyADKAKsBTYCqAMCQCADKAKoAygCEEEAR0EBcUUNACADKAKoAygCECADKAKoBSADKAKkBRCjhoCAAAsMXgsgAyADKAKsBTYCpAMgAygCpAMoAiQgAygCqAUgAygCpAUQo4aAgAAMXQsgAyADKAKsBTYCoAMgAygCoAMoAiQgAygCqAUgAygCpAUQo4aAgAAMXAsgAyADKAKsBTYCnAMgAygCnAMoAiQgAygCqAUgAygCpAUQo4aAgAAMWwsMWgsMWQsgAyADKAKsBTYCmAMgAygCmAMoAhwgAygCqAUgAygCpAUQo4aAgAAMWAsgAyADKAKsBTYClAMgAyADKAKUA0EYajYCkAMgA0EANgKMAwJAA0AgAygCjAMgAygCkAMoAgBJQQFxRQ0BIAMoApADKAIIIAMoAowDQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAowDQQFqNgKMAwwACwsMVwsgAyADKAKsBTYCiAMCQCADKAKIAygCEEEAR0EBcUUNACADKAKIAygCECADKAKoBSADKAKkBRCjhoCAAAsgAyADKAKIA0EUajYChAMgA0EANgKAAwJAA0AgAygCgAMgAygChAMoAgBJQQFxRQ0BIAMoAoQDKAIIIAMoAoADQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAoADQQFqNgKAAwwACwsCQCADKAKIAygCIEEAR0EBcUUNACADKAKIAygCICADKAKoBSADKAKkBRCjhoCAAAsMVgsgAyADKAKsBTYC/AIgAygC/AIoAhggAygCqAUgAygCpAUQo4aAgAACQCADKAL8AigCJEEAR0EBcUUNACADKAL8AigCJCADKAKoBSADKAKkBRCjhoCAAAsCQCADKAL8AigCKEEAR0EBcUUNACADKAL8AigCKCADKAKoBSADKAKkBRCjhoCAAAsMVQsgAyADKAKsBTYC+AIgAygC+AIoAhAgAygCqAUgAygCpAUQo4aAgAAMVAsgAyADKAKsBTYC9AIgAygC9AIoAhAgAygCqAUgAygCpAUQo4aAgAAMUwsMUgsgAyADKAKsBTYC8AIgAygC8AIoAhAgAygCqAUgAygCpAUQo4aAgAACQCADKALwAigCFEEAR0EBcUUNACADKALwAigCFCADKAKoBSADKAKkBRCjhoCAAAsMUQsgAyADKAKsBTYC7AICQCADKALsAigCEEEAR0EBcUUNACADKALsAigCECADKAKoBSADKAKkBRCjhoCAAAsCQCADKALsAigCJEEAR0EBcUUNACADKALsAigCJCADKAKoBSADKAKkBRCjhoCAAAsCQCADKALsAigCMEEAR0EBcUUNACADKALsAigCMCADKAKoBSADKAKkBRCjhoCAAAsgAygC7AIoAjwgAygCqAUgAygCpAUQo4aAgAAMUAsgAyADKAKsBTYC6AICQCADKALoAigCEEEAR0EBcUUNACADKALoAigCECADKAKoBSADKAKkBRCjhoCAAAsCQCADKALoAigCJEEAR0EBcUUNACADKALoAigCJCADKAKoBSADKAKkBRCjhoCAAAsCQCADKALoAigCMEEAR0EBcUUNACADKALoAigCMCADKAKoBSADKAKkBRCjhoCAAAsgAygC6AIoAkAgAygCqAUgAygCpAUQo4aAgAAMTwsgAyADKAKsBTYC5AICQCADKALkAigCEEEAR0EBcUUNACADKALkAigCECADKAKoBSADKAKkBRCjhoCAAAsCQCADKALkAigCJEEAR0EBcUUNACADKALkAigCJCADKAKoBSADKAKkBRCjhoCAAAsCQCADKALkAigCMEEAR0EBcUUNACADKALkAigCMCADKAKoBSADKAKkBRCjhoCAAAsgAygC5AIoAjwgAygCqAUgAygCpAUQo4aAgAAMTgsgAyADKAKsBTYC4AIgAygC4AIoAhAgAygCqAUgAygCpAUQo4aAgAACQCADKALgAigCHEEAR0EBcUUNACADKALgAigCHCADKAKoBSADKAKkBRCjhoCAAAsCQCADKALgAigCKEEAR0EBcUUNACADKALgAigCKCADKAKoBSADKAKkBRCjhoCAAAsMTQsgAyADKAKsBTYC3AIgAygC3AIoAiQgAygCqAUgAygCpAUQo4aAgAAMTAsgAyADKAKsBTYC2AIgAygC2AIoAiQgAygCqAUgAygCpAUQo4aAgAAMSwsgAyADKAKsBTYC1AIgAygC1AIoAiQgAygCqAUgAygCpAUQo4aAgAAMSgsMSQsMSAsgAyADKAKsBTYC0AIgAygC0AIoAhwgAygCqAUgAygCpAUQo4aAgAAMRwsMRgsgAyADKAKsBTYCzAIgAyADKALMAkEYajYCyAIgA0EANgLEAgJAA0AgAygCxAIgAygCyAIoAgBJQQFxRQ0BIAMoAsgCKAIIIAMoAsQCQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAsQCQQFqNgLEAgwACwsMRQsgAyADKAKsBTYCwAIgAyADKALAAkEYajYCvAIgA0EANgK4AgJAA0AgAygCuAIgAygCvAIoAgBJQQFxRQ0BIAMoArwCKAIIIAMoArgCQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoArgCQQFqNgK4AgwACwsMRAsgAyADKAKsBTYCtAIgAyADKAK0AkEYajYCsAIgA0EANgKsAgJAA0AgAygCrAIgAygCsAIoAgBJQQFxRQ0BIAMoArACKAIIIAMoAqwCQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAqwCQQFqNgKsAgwACwsMQwsgAyADKAKsBTYCqAIgAyADKAKoAkEYajYCpAIgA0EANgKgAgJAA0AgAygCoAIgAygCpAIoAgBJQQFxRQ0BIAMoAqQCKAIIIAMoAqACQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAqACQQFqNgKgAgwACwsMQgsgAyADKAKsBTYCnAIgAyADKAKcAkEYajYCmAIgA0EANgKUAgJAA0AgAygClAIgAygCmAIoAgBJQQFxRQ0BIAMoApgCKAIIIAMoApQCQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoApQCQQFqNgKUAgwACwsMQQsMQAsMPwsgAyADKAKsBTYCkAIgAyADKAKQAkEQajYCjAIgA0EANgKIAgJAA0AgAygCiAIgAygCjAIoAgBJQQFxRQ0BIAMoAowCKAIIIAMoAogCQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAogCQQFqNgKIAgwACwsMPgsMPQsgAyADKAKsBTYChAICQCADKAKEAigCNEEAR0EBcUUNACADKAKEAigCNCADKAKoBSADKAKkBRCjhoCAAAsCQCADKAKEAigCOEEAR0EBcUUNACADKAKEAigCOCADKAKoBSADKAKkBRCjhoCAAAsMPAsgAyADKAKsBTYCgAIgAygCgAIoAiAgAygCqAUgAygCpAUQo4aAgAAMOwsgAyADKAKsBTYC/AEgAygC/AEoAiAgAygCqAUgAygCpAUQo4aAgAAMOgsgAyADKAKsBTYC+AEgAygC+AEoAiAgAygCqAUgAygCpAUQo4aAgAAMOQsMOAsMNwsgAyADKAKsBTYC9AEgAygC9AEoAiAgAygCqAUgAygCpAUQo4aAgAAMNgsMNQsgAyADKAKsBTYC8AEgAygC8AEoAhAgAygCqAUgAygCpAUQo4aAgAAgAygC8AEoAhQgAygCqAUgAygCpAUQo4aAgAAMNAsgAyADKAKsBTYC7AEgAygC7AEoAhAgAygCqAUgAygCpAUQo4aAgAAgAygC7AEoAhQgAygCqAUgAygCpAUQo4aAgAAMMwsgAyADKAKsBTYC6AEgAygC6AEoAhAgAygCqAUgAygCpAUQo4aAgAAgAyADKALoAUEUajYC5AEgA0EANgLgAQJAA0AgAygC4AEgAygC5AEoAgBJQQFxRQ0BIAMoAuQBKAIIIAMoAuABQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAuABQQFqNgLgAQwACwsMMgsMMQsgAyADKAKsBTYC3AEgAygC3AEoAiQgAygCqAUgAygCpAUQo4aAgAACQCADKALcASgCKEEAR0EBcUUNACADKALcASgCKCADKAKoBSADKAKkBRCjhoCAAAsMMAsgAyADKAKsBTYC2AEgAyADKALYAUEQajYC1AEgA0EANgLQAQJAA0AgAygC0AEgAygC1AEoAgBJQQFxRQ0BIAMoAtQBKAIIIAMoAtABQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAtABQQFqNgLQAQwACwsCQCADKALYASgCHEEAR0EBcUUNACADKALYASgCHCADKAKoBSADKAKkBRCjhoCAAAsgAyADKALYAUEgajYCzAEgA0EANgLIAQJAA0AgAygCyAEgAygCzAEoAgBJQQFxRQ0BIAMoAswBKAIIIAMoAsgBQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoAsgBQQFqNgLIAQwACwsMLwsgAyADKAKsBTYCxAEgAyADKALEAUEQajYCwAEgA0EANgK8AQJAA0AgAygCvAEgAygCwAEoAgBJQQFxRQ0BIAMoAsABKAIIIAMoArwBQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoArwBQQFqNgK8AQwACwsCQCADKALEASgCHEEAR0EBcUUNACADKALEASgCHCADKAKoBSADKAKkBRCjhoCAAAsgAyADKALEAUEgajYCuAEgA0EANgK0AQJAA0AgAygCtAEgAygCuAEoAgBJQQFxRQ0BIAMoArgBKAIIIAMoArQBQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoArQBQQFqNgK0AQwACwsgAygCxAEoAkQgAygCqAUgAygCpAUQo4aAgAAMLgsgAyADKAKsBTYCsAECQCADKAKwASgCEEEAR0EBcUUNACADKAKwASgCECADKAKoBSADKAKkBRCjhoCAAAsMLQsMLAsMKwsMKgsMKQsgAyADKAKsBTYCrAEgAygCrAEoAhwgAygCqAUgAygCpAUQo4aAgAAMKAsgAyADKAKsBTYCqAEgAygCqAEoAiQgAygCqAUgAygCpAUQo4aAgAAMJwsgAyADKAKsBTYCpAEgAygCpAEoAhAgAygCqAUgAygCpAUQo4aAgAAgAygCpAEoAhQgAygCqAUgAygCpAUQo4aAgAAMJgsgAyADKAKsBTYCoAEgAyADKAKgAUEQajYCnAEgA0EANgKYAQJAA0AgAygCmAEgAygCnAEoAgBJQQFxRQ0BIAMoApwBKAIIIAMoApgBQQJ0aigCACADKAKoBSADKAKkBRCjhoCAACADIAMoApgBQQFqNgKYAQwACwsgAyADKAKgAUEcajYClAEgA0EANgKQAQJAA0AgAygCkAEgAygClAEoAgBJQQFxRQ0BIAMoApQBKAIIIAMoApABQQJ0aigCACADKAKoBSADKAKkBRCjhoCA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IAIgADYCKCACIAE6ACcgAkEgEJiMgIAANgIgAkACQCACKAIgQQBGQQFxRQ0AIAJBAEEBcToALwwBCyACKAIgIQMgAkEYaiEEQgAhBSAEIAU3AwAgAkEQaiAFNwMAIAJBCGogBTcDACACIAU3AwAgAiACKAIoKAKUAjYCACACQQA6ABwgAkEdaiEGAkACQCACKAIoKAKUAkEARkEBcUUNAEEAIQcMAQsgAigCKCgClAItAB1B/wFxIQcLIAYgBzoAACACIAItACdBAXE6AB4gAyACKQMANwIAQRghCCADIAhqIAIgCGopAwA3AgBBECEJIAMgCWogAiAJaikDADcCAEEIIQogAyAKaiACIApqKQMANwIAIAIoAiAhCyACKAIoIAs2ApQCIAJBAUEBcToALwsgAi0AL0EBcSEMIAJBMGokgICAgAAgDA8LigEBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMgAygCDCADKAIIIAMoAgQQsYaAgAA2AgACQCADKAIARQ0AIAMoAgwgAygCACADKAIMKAK0ASADKAIMKAK0AUEBELKGgIAACyADKAIAIQQgA0EQaiSAgICAACAEDwtKAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABOgALIAIoAgxBGGogAi0AC0F/c0EBcRCzhoCAACACQRBqJICAgIAADwt8AQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkAgAigCCEEATkEBcQ0AQb+ehoAAQbPQhYAAQanAAEG4qoWAABCOgICAAAALIAIoAgwhAyACKAIIIQQgA0EKIAQQ04uAgAAhBSACQRBqJICAgIAAIAUPC+4BAQd/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhggAyABNgIUIAMgAjYCECADIAMoAhQQ7IuAgAA2AgwgAyADKAIYIAMoAhBqNgIIAkACQANAIAMoAhggAygCCElBAXFFDQEgAygCGC0AACEEQRghBSAEIAV0IAV1IQYgAygCFC0AACEHQRghCAJAIAYgByAIdCAIdUZBAXFFDQAgAygCGCADKAIUIAMoAgwQ1IuAgAANACADIAMoAhg2AhwMAwsgAyADKAIYQQFqNgIYDAALCyADQQA2AhwLIAMoAhwhCSADQSBqJICAgIAAIAkPC6MBAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBAJAIAMoAgRBAktBAXFFDQAgAygCCCADKAIEQQJrai0AAEH/AXFBDUZBAXFFDQAgAygCCCADKAIEQQFrai0AAEH/AXFBCkZBAXFFDQAgAygCDCADKAIIIAMoAgggAygCBGpBugIQtIaAgAALIANBEGokgICAgAAPC4kEDQV/AX4BfwF+AX8BfgF/AX4BfwF+AX8Bfgd/I4CAgIAAQeAAayEEIAQkgICAgAAgBCAANgJcIAQgATYCWCAEIAI2AlQgBCADNgJQIAQoAlQhBSAEKAJQIQYgBCAFQfakhoAAIAYQrYaAgAA2AkwCQAJAIAQoAkxBAEZBAXFFDQAMAQsgBCgCWCEHQTAhCCAHIAhqKQIAIQkgCCAEQRBqaiAJNwMAQSghCiAHIApqKQIAIQsgCiAEQRBqaiALNwMAQSAhDCAHIAxqKQIAIQ0gDCAEQRBqaiANNwMAQRghDiAHIA5qKQIAIQ8gDiAEQRBqaiAPNwMAQRAhECAHIBBqKQIAIREgECAEQRBqaiARNwMAQQghEiAHIBJqKQIAIRMgEiAEQRBqaiATNwMAIAQgBykCADcDECAEKAJYKAIAIRQgBCgCTEEBaiEVIAQoAlAgBCgCTCAEKAJUa2tBAWshFiAEKAJYKAIEIRcgBEEQaiAVIBYgFyAUEYWAgIAAgICAgAAgBEEQakEYahCri4CAACEYIAQgGDYCDAJAIBhBAEtBAXFFDQAgBCAEQRBqQRhqEKyLgIAANgIIIAQoAlwgBCgCCCAEKAIIIAQoAgxqEKiGgIAAGgsgBC0AQCEZIAQoAlwgGToA/AIgBC0AQSEaIAQoAlwgGjoA/QILIARB4ABqJICAgIAADwteAQF/I4CAgIAAQRBrIQQgBCSAgICAACAEIAA2AgwgBCABNgIIIAQgAjYCBCAEIAM2AgAgBCgCDEGIAmogBCgCCCAEKAIEIAQoAgAQy4SAgAAaIARBEGokgICAgAAPC1UBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgxBvAJqIAMoAgggAygCBBCNi4CAACEEIANBEGokgICAgAAgBA8LbQEBfyOAgICAAEEgayEFIAUkgICAgAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSADNgIQIAUgBDYCDCAFKAIcKAKUAkEEaiAFKAIYIAUoAhQgBSgCECAFKAIMEMeGgIAAGiAFQSBqJICAgIAADwtBAQJ/I4CAgIAAQRBrIQIgAiAANgIMIAIgAToACyACKAIMKAIAQQF0IAItAAtBAXFBAXFyIQMgAigCDCADNgIADwteAQF/I4CAgIAAQRBrIQQgBCSAgICAACAEIAA2AgwgBCABNgIIIAQgAjYCBCAEIAM2AgAgBCgCDEH8AWogBCgCCCAEKAIEIAQoAgAQy4SAgAAaIARBEGokgICAgAAPC90BAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEGwAmoQrouAgAAgASgCDEGIAmoQz4SAgAAgASgCDEH8AWoQz4SAgAAgASgCDEHcAWoQtoaAgAAgASgCDEHoAWoQt4aAgAAgASgCDEG8AmoQj4uAgAAgASgCDEHMAmoQpouAgAACQANAIAEoAgwoApQCQQBHQQFxRQ0BIAEoAgwQuIaAgAAMAAsLAkADQCABKAIMKAKwAUEET0EBcUUNASABKAIMELmGgIAADAALCyABQRBqJICAgIAADwt5AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASABKAIMKAIENgIIAkADQCABKAIIQQBHQQFxRQ0BIAEgASgCCCgCADYCBCABIAEoAgg2AgAgASgCABCajICAACABIAEoAgQ2AggMAAsLIAFBEGokgICAgAAPC3kBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwoAgQ2AggCQANAIAEoAghBAEdBAXFFDQEgASABKAIIKAIANgIEIAEgASgCCDYCACABKAIAEJqMgIAAIAEgASgCBDYCCAwACwsgAUEQaiSAgICAAA8LdAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEgASgCDCgClAI2AgggASgCCCgCACECIAEoAgwgAjYClAIgASgCCEEEahC6hoCAACABKAIIQRBqEKCGgIAAIAEoAggQmoyAgAAgAUEQaiSAgICAAA8L4wEBBX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDCgCsAENACABKAIMKAIcQQA2AgAMAQsCQAJA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AswBIAEoAvwFKAK0AUtBAXFFDQAgASgC/AUoAswBQX9qLQAAQf8BcUEKRkEBcUUNACABKAL8BSEVIBUgFSgCzAFBf2o2AswBCyABKAL8BUEBNgLIASABKAL8BRDLhoCAAAwICyABKAL8BSEWIBYoAtABIRcgFiAXQQFqNgLQASAXLQAAIRggGEH+AEsaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgGA5/ACEhIQAhISEhIQIhIQIhISEhISEhISEhISEAISEhISEhDBABHx4UEgQFCxYDFxgbGRkZGRkZGRkZGRoGDg0PEyAhISEhISEhISEhISEhISEhISEhISEhISEhIQchCBwhESEhISEhISEhISEhISEhISEhISEhISEhISEhCRUKHSELIAEoAvwFIRkgGSAZKALQAUF/ajYC0AEgASgC/AVBATYCyAEgASgC/AUQy4aAgAAMKAsgASABKAL8BSgC0AEgASgC/AUoArgBIAEoAvwFKALQAWsQrIaAgAA2AugFAkACQCABKALoBUEARkEBcUUNACABKAL8BSgCuAEhGgwBCyABKALoBSEaCyAaIRsgASgC/AUgGzYC0AEgASABKAL8BUEAEMyGgIAANgLkBSABKAL8BUHcAWogASgC5AUQn4uAgAACQCABKALoBUEAR0EBcUUNACABKAL8BSEcIBwgHCgC0AFBAWo2AtABCyABKAL8BUEcNgLIASABKAL8BRDLhoCAAAJAIAEoAvwFIAEoAvQFQQBHQQFxEM2GgIAAQQFxDQAgASgC/AUoAswBIAEoAvwFKAKoAkZBAXFFDQAgASABKAL8BSgC0AEgASgC/AUoAswBazYC4AUCQCABKALgBUEKTkEBcUUNACABKAL8BS0AggNBAXENACABKAL8BRDOhoCAAAsLIAFBAToA+gULIAEoAvQFQQFxQQBHIR0gASgC/AUgHUEBcToAhgMgASABKAL8BSABKAL8BSgC0AFBf2oQz4aAgAA2AtwFAkAgASgC3AVFDQACQCABLQD6BUEBcQ0AIAEoAtwFQQFrIR4gASgC/AUhHyAfIB4gHygC0AFqNgLQAQsCQCABKAL8BSgC2AFBAEZBAXFFDQAgASgC/AVBzAJqIAEoAvwFKALQAUF/ahCji4CAABoLCwJAIAEoAvwFKALYAUEAR0EBcUUNACABKAL8BRDQhoCAAAsgASgC/AUQ0YaAgAAhICAgQQJLGgJAAkACQAJAICAOAwACAQMLDAILAkACQCABKAL8BS0AhANBAXENACABKAL8BS0AhQNBAXFFDQELAkAgAS0A+gVBAXENACABKAL8BRDShoCAAAsgASgC/AVBARDThoCAACABKAL8BUEBOgCAAyABKAL8BUH5ADYCyAEMKQsLAkAgAS0A+gVBAXENACABKAL8BRDShoCAAAsgAUEAOgD6BQwgCwJAAkAgASgC/AUoAtQBQQBGQQFxRQ0AIAEoAvwFKALQASEhDAELIAEoAvwFKALUASEhCyABICE2AtgFIAEgASgC2AUgASgC/AUoArgBIAEoAtgFaxDuioCAACABKALYBWo2AtgFAkAgASgC2AUgASgC/AUoArgBSUEBcUUNAAJAIAEoAtgFLQAAQf8BcUEjRkEBcUUNACABIAEoAtgFIAEoAvwFKAK4ASABKALYBWsQrIaAgAA2AtQFA0AgASgC1AVBAEchIkEAISMgIkEBcSEkICMhJQJAICRFDQAgASgC1AVBAWogASgC/AUoArgBSSElCwJAICVBAXFFDQAgASABKALUBUEBajYC1AUgASABKALUBSABKAL8BSgCuAEgASgC1AVrEO6KgIAAIAEoAtQFajYC1AUCQCABKAL8BSABKALUBRDUhoCAAEH/AXFBI0dBAXFFDQAMAQsgASABKALUBSABKAL8BSgCuAEgASgC1AVrEKyGgIAANgLUBQwBCwsCQAJAIAEoAvwFENGGgIAADQAgASgC1AVBAEdBAXFFDQEgASgC/AUgASgC1AUQ1IaAgABB/wFxQS5GQQFxDQAgASgC/AUgASgC1AUQ1IaAgABB/wFxQSZGQQFxRQ0BIAEoAvwFIAEoAtQFQQFqENSGgIAAQf8BcUEuRkEBcUUNAQsCQCABLQD6BUEBcQ0AIAEoAvwFENKGgIAACyABQQA6APoFDCILCwJAIAEoAtgFLQAAQf8BcUEuRkEBcUUNAAJAIAEoAvwFIAEoAtgFQQFqENSGgIAAQf8BcUEuRkEBcUUNAAJAIAEtAPoFQQFxDQAgASgC/AUQ0oaAgAALIAEoAvwFQQEQ04aAgAAgASgC/AVBAToAgAMgASgC/AVB+QA2AsgBDCkLAkAgAS0A+gVBAXENACABKAL8BRDShoCAAAsgASgC/AVBgAIQ04aAgAAgASgC2AUhJiABKAL8BSAmNgLMASABKALYBUEBaiEnIAEoAvwFICc2AtABIAEoAvwFQQA2AtQBIAEoAvwFQR42AsgBIAEoAvwFEMuGgIAADCgLAkAgASgC/AUgASgC2AUQ1IaAgABB/wFxQSZGQQFxRQ0AIAEoAvwFIAEoAtgFQQFqENSGgIAAQf8BcUEuRkEBcUUNAAJAIAEtAPoFQQFxDQAgASgC/AUQ0oaAgAALIAEoAvwFQYACENOGgIAAIAEoAtgFISggASgC/AUgKDYCzAEgASgC2AVBAmohKSABKAL8BSApNgLQASABKAL8BUEANgLUASABKAL8BUEHNgLIASABKAL8BRDLhoCAAAwoCwsgASgC/AVBARDThoCAACABKAL8BUEBOgCAAyABKAL8BUH5ADYCyAECQCABLQD6BUEBcQ0AIAEoAvwFEMuGgIAACwwmCwJAIAEoAvwFKAK8AUEbRkEBcUUNACABKAL8BSgCCEEASkEBcUUNACABKAL8BUGIAmohKiABKAL8BSgCzAEhKyABKAL8BSgC0AEhLCABIAEoAvwFKALIARDcioCAADYCkAEgKiArICxBHCABQZABahDOhICAABoLIAEoAvwFQYEIENOGgIAAIAEoAvwFQRs2AsgBIAEoAvwFEMuGgIAADCULIAFB+wA2AtAFAkAgAS0A8wVBAXFFDQACQCABKAL8BRDVhoCAAEEBcQ0AIAEoAvwFKAIEQYIIRkEBcUUNAQsgAUH8ADYC0AULIAEoAvwFIS0gLSAtKAIIQQFqNgIIIAEoAvwFQYEIENOGgIAAIAEoAvwFQQBBAXEQ1oaAgAAgASgC0AUhLiABKAL8BSAuNgLIASABKAL8BRDLhoCAAAwkCyABKAL8BSEvIC8gLygCCEF/ajYCCCABKAL8BUEIENOGgIAAIAEoAvwFENeGgIAAIAEoAvwFQf0ANgLIASABKAL8BRDLhoCAAAwjCyABKAL8BUEBENOGgIAAIAEoAvwFQQE6AIADIAEoAvwFQY4BNgLIASABKAL8BRDLhoCAAAwiCyABKAL8BSEwIDAgMCgCCEEBajYCCCABQRA2AswFAkAgASgC/AUQ2IaAgABBAXFFDQACQCABKAL8BUHdAEH/AXEQ2YaAgABBAXFFDQAgASgC/AUhMSAxIDEoAghBf2o2AgggASgC/AVBEBDThoCAACABKAL8BUE9Qf8BcRDZhoCAACEyQRNBEiAyQQFxGyEzIAEoAvwFIDM2AsgBIAEoAvwFEMuGgIAADCMLIAEoAvwFQZAIENOGgIAAIAEoAswFITQgASgC/AUgNDYCyAEgASgC/AUQy4aAgAAMIgsCQAJAIAEoAvwFENqGgIAAQQFxDQAgASgC/AUQ1YaAgABBAXFFDQEgAS0A8wVBAXENACABKAL8BUGAEBDbhoCAAEEBcUUNAQsgAUERNgLMBQsgASgC/AVBgQgQ04aAgAAgASgC/AVBAEEBcRDWhoCAACABKALMBSE1IAEoAvwFIDU2AsgBIAEoAvwFEMuGgIAADCELIAEoAvwFITYgNiA2KAIIQX9qNgIIIAEoAvwFQQIQ04aAgAAgASgC/AUQ14aAgAAgASgC/AVBFDYCyAEgASgC/AUQy4aAgAAMIAsgAUEONgLIBQJAAkAgASgC/AUoAgggASgC/AUoAgxGQQFxRQ0AIAEoAvwFQQE6AIADIAEoAvwFQQEQ04aAgAAgAUHvADYCyAUMAQsCQAJAIAEoAvwFQYAQENuGgIAAQQFxRQ0AIAEoAvwFQYEIENOGgIAADAELAkACQCABKAL8BUE6ENuGgIAAQQFxRQ0AIAEoAvwFQQE6AIADIAEoAvwFQQEQ04aAgAAMAQsCQAJAIAEoAvwFQQQQ24aAgABBAXFFDQAgASgC/AVBAToAgAMgASgC/AVBARDThoCAAAwBCyABKAL8BUGBCBDThoCAAAsLCwsgASgC/AUhNyA3IDcoAghBAWo2AgggASgC/AUhOCA4IDgoAhBBAWo2AhAgASgC/AVBAEEBcRDWhoCAACABKALIBSE5IAEoAvwFIDk2AsgBIAEoAvwFEMuGgIAADB8LIAEoAvwFITogOiA6KAIIQX9qNgIIIAEoAvwFENeGgIAAAkAgASgC/AUoAhwoAgBBAUZBAXFFDQAgASgC/AUoAhANACABKAL8BRC5hoCAACABKAL8BUElNgLIASABKAL8BRDLhoCAAAwfCyABKAL8BSE7IDsgOygCEEF/ajYCECABKAL8BUECENOGgIAAIAEoAvwFQQ82AsgBIAEoAvwFEMuGgIAADB4LAkAgASgC/AVBKkH/AXEQ2YaAgABBAXFFDQACQCABKAL8BUE9Qf8BcRDZhoCAAEEBcUUNACABKAL8BUEBENOGgIAAIAEoAvwFQZQBNgLIASABKAL8BRDLhoCAAAwfCyABQZMBNgLEBQJAAkAgASgC/AUgAS0A8wVBAXEQ3IaAgABBAXFFDQAgASgC/AUgASgC/AVByAFqQaYCEN2GgIAAIAFBogE2AsQFDAELAkACQCABKAL8BRDahoCAAEEBcUUNACABQaIBNgLEBQwBCwJAIAEoAvwFIAEtAPMFQQFxEN6GgIAAQQFxRQ0AIAEoAvwFQfwBaiE8IAEoAvwFKALMASE9IAEoAvwFKALQASE+IAFB64eEgAA2AqQBIAFB+6SGgAA2AqABIDwgPSA+QaECIAFBoAFqEM6EgIAAGgsLCwJAAkAgASgC/AUQ2IaAgABBAXFFDQAgASgC/AVBEBDThoCAAAwBCyABKAL8BUEBENOGgIAACyABKALEBSE/IAEoAvwFID82AsgBIAEoAvwFEMuGgIAADB4LAkAgASgC/AVBPUH/AXEQ2YaAgABBAXFFDQAgASgC/AVBARDThoCAACABKAL8BUGSATYCyAEgASgC/AUQy4aAgAAMHgsgAUGRATYCwAUCQAJAIAEoAvwFIAEtAPMFQQFxENyGgIAAQQFxRQ0AIAEoAvwFIAEoAvwFQcgBakGlAhDdhoCAACABQaEBNgLABQwBCwJAAkAgASgC/AUQ2oaAgABBAXFFDQAgAUGhATYCwAUMAQsCQCABKAL8BSABLQDzBUEBcRDehoCAAEEBcUUNACABKAL8BUH8AWohQCABKAL8BSgCzAEhQSABKAL8BSgC0AEhQiABQeuHhIAANgK0ASABQfykhoAANgKwASBAIEEgQkGhAiABQbABahDOhICAABoLCwsCQAJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAAMAQsgASgC/AVBARDThoCAAAsgASgCwAUhQyABKAL8BSBDNgLIASABKAL8BRDLhoCAAAwdCwJAAkAgASgC/AUQ2IaAgABBAXFFDQAgASgC/AVBEBDThoCAAAJAIAEoAvwFQcAAQf8BcRDZhoCAAEEBcUUNACABKAL8BUELNgLIASABKAL8BRDLhoCAAAwfCwwBCyABKAL8BUEBENOGgIAACwJAIAEoAvwFQT1B/wFxENmGgIAAQQFxRQ0AIAEoAvwFQQw2AsgBIAEoAvwFEMuGgIAADB0LAkAgASgC/AVB/gBB/wFxENmGgIAAQQFxRQ0AIAEoAvwFQQ02AsgBIAEoAvwFEMuGgIAADB0LIAEoAvwFQQs2AsgBIAEoAvwFEMuGgIAADBwLAkAgASgC/AUQ34aAgABBAXFFDQAgASgC/AUoAtABQQVqIAEoAvwFKAK4AU1BAXFFDQAgASgC/AUoAtABQYzrhIAAQQUQ1IuAgAANAAJAIAEoAvwFQQUQ4IaAgABB/wFxEPCKgIAAQQFxDQAgASgC/AVBBRDghoCAAEH/AXENAQsgASABKAL8BRDhhoCAADYCvAUCQCABKAK8BUEBRkEBcUUNACABKAK8BSFEIAEoAvwFIEQ2AsgBIAEoAvwFEMuGgIAADB0LDBULAkACQCABKAL8BRDYhoCAAEEBcUUNACABKAL8BUEQENOGgIAADAELIAEoAvwFQQEQ04aAgAALAkAgASgC/AVBPkH/AXEQ2YaAgABBAXFFDQAgASgC/AVBKjYCyAEgASgC/AUQy4aAgAAMHAsCQCABKAL8BUH+AEH/AXEQ2YaAgABBAXFFDQAgASgC/AVBKzYCyAEgASgC/AUQy4aAgAAMHAsCQCABKAL8BUE9Qf8BcRDZhoCAAEEBcUUNACABKAL8BUE9Qf8BcRDZhoCAACFFQSlBKCBFQQFxGyFGIAEoAvwFIEY2AsgBIAEoAvwFEMuGgIAADBwLIAEoAvwFQSc2AsgBIAEoAvwFEMuGgIAADBsLAkAgASgC/AVBPEH/AXEQ2YaAgABBAXFFDQACQCABKAL8BUGABhDbhoCAAEEBcQ0AIAEoAvwFEOKGgIAAQQFxDQACQCABKAL8BUEwENuGgIAAQQFxRQ0AIAEoAvwFQYAQENuGgIAAQQFxDQAgAS0A8wVBAXFFDQELIAEgASgC/AUoAtABNgK4BSABQQA2ArQFIAFBADYCsAUCQAJAIAEoAvwFQS1B/wFxENmGgIAAQQFxRQ0AIAFBATYCsAUMAQsCQCABKAL8BUH+AEH/AXEQ2YaAgABBAXFFDQAgAUECNgKwBQsLAkACQCABKAL8BUHgAEH/AXEQ2YaAgABBAXFFDQAgAUHgADYCtAUMAQsCQAJAIAEoAvwFQSJB/wFxENmGgIAAQQFxRQ0AIAFBIjYCtAUMAQsCQCABKAL8BUEnQf8BcRDZhoCAAEEBcUUNACABQSc2ArQFCwsLIAEgASgC/AUoAtABNgKsBSABQQA2AqgFAkACQCABKAL8BSgC0AEgASgC/AUoArgBT0EBcUUNACABKAK4BSFHIAEoAvwFIEc2AtABDAELAkACQCABKAK0BQ0AIAEoAvwFIAEoAvwFKALQASABKAL8BSgCuAEgASgC/AUoAtABaxDjhoCAACFIIAEgSDYCqAUgSA0AIAEoArgFIUkgASgC/AUgSTYC0AEMAQsCQAJAIAEoArQFDQAgASgCqAUhSiABKAL8BSFLIEsgSiBLKALQAWo2AtABAkADQCABKAL8BSABKAL8BSgC0AEgASgC/AUoArgBIAEoAvwFKALQAWsQ44aAgAAhTCABIEw2AqgFIExFDQEgASgCqAUhTSABKAL8BSFOIE4gTSBOKALQAWo2AtABDAALCwwBCwNAIAEoAvwFKALQASABKAL8BSgCuAFJIU9BACFQIE9BAXEhUSBQIVICQCBRRQ0AIAEoArQFIAEoAvwFKALQAS0AAEH/AXFHIVILAkAgUkEBcUUNAAJAAkAgASgC/AUoAtABLQAAQf8BcUENRkEBcQ0AIAEoAvwFKALQAS0AAEH/AXFBCkZBAXFFDQELDAELIAEoAvwFIVMgUyBTKALQAUEBajYC0AEMAQsLCyABIAEoAvwFKALQASABKAKsBWs2AqQFIAFBADoAowUCQCABKAK0BUUNACABKAL8BSABKAK0BUH/AXEQ2YaAgABBAXENACABKAL8BSABKAKsBSABKAKsBSABKAKkBWpBhAEQsIaAgAAgAUEBOgCjBQsgASgC/AVBADYC8AIgASgC/AUhVCABQQM2AvwEIAFB/ARqQQRqIVUgASABKAKsBTYCgAUgASABKAKkBTYChAUgASABKAK0BTYCiAUgASABKAKwBTYCjAUgASABKAL8BSgC0AE2ApAFIAFBADYClAUgAUEAOgCYBSBVQRlqIVZBACFXIFYgVzsAACBWQQJqIFc6AAAgAUEANgKcBUEgIVggWCABQcgBamogWCABQfwEamooAgA2AgBBGCFZIFkgAUHIAWpqIFkgAUH8BGpqKQIANwMAQRAhWiBaIAFByAFqaiBaIAFB/ARqaikCADcDAEEIIVsgWyABQcgBamogWyABQfwEamopAgA3AwAgASABKQL8BDcDyAEgVCABQcgBahDkhoCAABoCQAJAIAEoAvwFKALYAUEARkEBcUUNACABIAEoAvwFKALQASABKAL8BSgCuAEgASgC/AUoAtABaxCshoCAADYC+AQCQAJAIAEoAvgEQQBGQQFxRQ0AAkAgAS0AowVBAXENACABKAL8BSABKAKsBSABKAKkBRDlhoCAAAsgASABKAL8BSgCuAE2AvgEDAELIAEoAvwFQcwCaiABKAL4BBCji4CAABogASABKAL4BEEBajYC+AQLIAEoAvgEIVwgASgC/AUgXDYC1AEMAQsgASgC/AUoAtgBIV0gASgC/AUgXTYC1AELIAEoAvwFQTY2AsgBIAEoAvwFEMuGgIAADB4LCwsCQCABKAL8BUE9Qf8BcRDZhoCAAEEBcUUNACABKAL8BUEBENOGgIAAIAEoAvwFQfQANgLIASABKAL8BRDLhoCAAAwcCwJAIAEoAvwFIAEtAPMFQQFxEN6GgIAAQQFxRQ0AIAEoAvwFQfwBaiFeIAEoAvwFKALMASFfIAEoAvwFKALQASFgIAFBzpSEgAA2AsQBIAFBr5WGgAA2AsABIF4gXyBgQaECIAFBwAFqEM6EgIAAGgsCQAJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAAMAQsCQCABKAL8BUGABBDbhoCAAEEBcUUNACABKAL8BUEBOgCAAwsgASgC/AVBARDThoCAAAsgASgC/AVB8wA2AsgBIAEoAvwFEMuGgIAADBsLAkACQCABKAL8BRDYhoCAAEEBcUUNACABKAL8BUEQENOGgIAADAELAkAgASgC/AVBgAQQ24aAgABBAXFFDQAgASgC/AVBAToAgAMLIAEoAvwFQQEQ04aAgAALAkAgASgC/AVBPUH/AXEQ2YaAgABBAXFFDQACQCABKAL8BUE+Qf8BcRDZhoCAAEEBcUUNACABKAL8BUHyADYCyAEgASgC/AUQy4aAgAAMHAsgASgC/AVB8QA2AsgBIAEoAvwFEMuGgIAADBsLIAEoAvwFQfAANgLIASABKAL8BRDLhoCAAAwaCwJAIAEoAvwFQT5B/wFxENmGgIAAQQFxRQ0AAkACQCABKAL8BRDYhoCAAEEBcUUNACABKAL8BUEQENOGgIAADAELIAEoAvwFQQEQ04aAgAALIAEoAvwFQT1B/wFxENmGgIAAIWFBNEEzIGFBAXEbIWIgASgC/AUgYjYCyAEgASgC/AUQy4aAgAAMGgsCQAJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAAMAQsgASgC/AVBARDThoCAAAsgASgC/AVBPUH/AXEQ2YaAgAAhY0EyQTEgY0EBcRshZCABKAL8BSBkNgLIASABKAL8BRDLhoCAAAwZCwJAAkAgASgC/AVBiAgQ24aAgABBAXFFDQAgAS0A+wUhZUEBIWYgZUEBcSFnIGYhaCBnRQ0BCyABKAL8BRDVhoCAACFoCyABIGhBAXE6APcEIAEoAvwFIWkgAS0A9wQhakEBIWtBACFsQSIhbSBpIGtBAXEgakEBcSBsQf8BcSBtQf8BcRDmhoCAABogASgC/AVBlQE2AsgBIAEoAvwFEMuGgIAADBgLAkAgASgC/AVBgAEQ24aAgABBAXFFDQAgASgC/AVBCBDThoCAACABKAL8BUEJNgLIASABKAL8BRDLhoCAAAwYCwJAIAEoAvwFQYACENuGgIAAQQFxRQ0AAkACQCABLQD7BUEBcUUNACABKAL8BUEgENOGgIAADAELIAEoAvwFQRAQ04aAgAALIAEoAvwFQQk2AsgBIAEoAvwFEMuGgIAADBgLIAEoAvwFIW5BASFvQQAhcEEAIXFB4AAhciBuIG9BAXEgcEEBcSBxQf8BcSByQf8BcRDmhoCAABogASgC/AVBCTYCyAEgASgC/AUQy4aAgAAMFwsCQAJAIAEoAvwFQYgIENuGgIAAQQFxRQ0AIAEtAPsFIXNBASF0IHNBAXEhdSB0IXYgdUUNAQsgASgC/AUQ1YaAgAAhdgsgASB2QQFxOgD2BCABKAL8BSF3IAEtAPYEIXhBACF5QQAhekEnIXsgdyB5QQFxIHhBAXEgekH/AXEge0H/AXEQ5oaAgAAaIAEoAvwFQZUBNgLIASABKAL8BRDLhoCAAAwWCyABKAL8BRDnhoCAACF8IAEoAvwFIHw2AsgBIAEoAvwFEMuGgIAADBULAkAgASgC/AVBJkH/AXEQ2YaAgABBAXFFDQAgASgC/AVBARDThoCAAAJAIAEoAvwFQT1B/wFxENmGgIAAQQFxRQ0AIAEoAvwFQQY2AsgBIAEoAvwFEMuGgIAADBYLIAEoAvwFQQU2AsgBIAEoAvwFEMuGgIAADBULAkAgASgC/AVBPUH/AXEQ2YaAgABBAXFFDQAgASgC/AVBARDThoCAACABKAL8BUEINgLIASABKAL8BRDLhoCAAAwVCwJAIAEoAvwFQS5B/wFxENmGgIAAQQFxRQ0AIAEoAvwFQYACENOGgIAAIAEoAvwFQQc2AsgBIAEoAvwFEMuGgIAADBULIAFBBDYC8AQCQAJAIAEoAvwFIAEtAPMFQQFxENyGgIAAQQFxRQ0AAkACQAJAIAEoAvwFEOiGgIAAQf8BcUE6R0EBcQ0AIAEoAvwFQQEQ4IaAgABB/wFxDQELIAEoAvwFIAEoAvwFQcgBakGkAhDdhoCAAAwBCyABIAEoAvwFQQEQ4IaAgAA6AO8EAkAgAS0A7wRB/wFxQSdHQQFxRQ0AIAEtAO8EQf8BcUEiR0EBcUUNACABKAL8BSABKAL8BSgC0AFBAWogASgC/AUoArgBIAEoAvwFKALQAUEBamsQ44aAgAANACABKAL8BSABKAL8BUHIAWpBpAIQ3YaAgAALCyABQZoBNgLwBAwBCwJAAkAgASgC/AUQ2oaAgABBAXFFDQAgAUGaATYC8AQMAQsCQCABKAL8BSABLQDzBUEBcRDehoCAAEEBcUUNACABKAL8BUH8AWohfSABKAL8BSgCzAEhfiABKAL8BSgC0AEhfyABQeuHhIAANgL0ASABQea0hoAANgLwASB9IH4gf0GhAiABQfABahDOhICAABoLCwsCQAJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAAMAQsgASgC/AVBARDThoCAAAsgASgC8AQhgAEgASgC/AUggAE2AsgBIAEoAvwFEMuGgIAADBQLAkAgASgC/AVB/ABB/wFxENmGgIAAQQFxRQ0AAkAgASgC/AVBPUH/AXEQ2YaAgABBAXFFDQAgASgC/AVBARDThoCAACABKAL8BUGIATYCyAEgASgC/AUQy4aAgAAMFQsCQCABKAL8BUEBENuGgIAAQQFxRQ0AIAEoAvwFIYEBIIEBIIEBKALQAUF/ajYC0AEgASgC/AVBhQE2AsgBIAEoAvwFEMuGgIAADBULIAEoAvwFQQEQ04aAgAAgASgC/AVBhwE2AsgBIAEoAvwFEMuGgIAADBQLAkAgASgC/AVBPUH/AXEQ2YaAgABBAXFFDQAgASgC/AVBARDThoCAACABKAL8BUGGATYCyAEgASgC/AUQy4aAgAAMFAsCQAJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAAMAQsgASgC/AVBgQgQ04aAgAALIAEoAvwFQYUBNgLIASABKAL8BRDLhoCAAAwTCwJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAACQCABKAL8BUHAAEH/AXEQ2YaAgABBAXFFDQAgASgC/AVBoAE2AsgBIAEoAvwFEMuGgIAADBQLIAEoAvwFQYkBNgLIASABKAL8BRDLhoCAAAwTCwJAIAEoAvwFQT1B/wFxENmGgIAAQQFxRQ0AIAEoAvwFQQEQ04aAgAAgASgC/AVBigE2AsgBIAEoAvwFEMuGgIAADBMLAkACQCABKAL8BRDahoCAAEEBcQ0AAkAgASgC/AUgAS0A8wVBAXEQ3IaAgABBAXFFDQAgASgC/AUgASgC/AVByAFqQaMCEN2GgIAAQQFBAXENAQwCC0EAQQFxRQ0BCyABKAL8BUEBENOGgIAAAkAgASgC/AUQ6IaAgABB/wFxEP6KgIAAQQFxRQ0AIAEoAvwFIYIBIIIBIIIBKALQAUEBajYC0AEgASABKAL8BRDphoCAADYC6AQgASgC/AVBAhDThoCAACABKALoBCGDASABKAL8BSCDATYCyAEgASgC/AUQy4aAgAAMFAsgASgC/AVBoAE2AsgBIAEoAvwFEMuGgIAADBMLAkAgASgC/AUgAS0A8wVBAXEQ3oaAgABBAXFFDQAgASgC/AVB/AFqIYQBIAEoAvwFKALMASGFASABKAL8BSgC0AEhhgEgAUG9w4SAADYChAIgAUH5pIaAADYCgAIghAEghQEghgFBoQIgAUGAAmoQzoSAgAAaCyABKAL8BUEBENOGgIAAIAEoAvwFQYkBNgLIASABKAL8BRDLhoCAAAwSCwJAIAEoAvwFENiGgIAAQQFxRQ0AIAEoAvwFQRAQ04aAgAACQCABKAL8BUHAAEH/AXEQ2YaAgABBAXFFDQAgASgC/AVBngE2AsgBIAEoAvwFEMuGgIAADBMLIAEoAvwFQfYANgLIASABKAL8BRDLhoCAAAwSCwJAIAEoAvwFQT1B/wFxENmGgIAAQQFxRQ0AIAEoAvwFQQEQ04aAgAAgASgC/AVB9wA2AsgBIAEoAvwFEMuGgIAADBILAkAgASgC/AVBPkH/AXEQ2YaAgABBAXFFDQAgASgC/AVBCBDThoCAACABKAL8BUH4ADYCyAEgASgC/AUQy4aAgAAMEgsgASABKAL8BSABLQDzBUEBcRDchoCAAEEBcToA5wQgASABKAL8BRDahoCAAEEBcToA5gQCQCABLQDmBEEBcQ0AIAEtAOcEQQFxRQ0AIAEoAvwFIAEoAvwFQcgBakGiAhDdhoCAAAsCQAJAIAEtAOYEQQFxDQAgAS0A5wRBAXFFDQELIAEoAvwFQQEQ04aAgAAgASgC/AUQ6IaAgABB/wFxEP6KgIAAIYcBQZ8BQZ4BIIcBQQFxGyGIASABKAL8BSCIATYCyAEgASgC/AUQy4aAgAAMEgsCQCABKAL8BSABLQDzBUEBcRDehoCAAEEBcUUNACABKAL8BUH8AWohiQEgASgC/AUoAswBIYoBIAEoAvwFKALQASGLASABQb3DhIAANgKUAiABQfekhoAANgKQAiCJASCKASCLAUGhAiABQZACahDOhICAABoLIAEoAvwFQQEQ04aAgAAgASgC/AVB9gA2AsgBIAEoAvwFEMuGgIAADBELIAEgASgC/AUQ2oaAgABBAXE6AOUEAkAgASgC/AVBLkH/AXEQ2YaAgABBAXFFDQACQCABKAL8BUEuQf8BcRDZhoCAAEEBcUUNAAJAIAEoAvwFQRYQ6oaAgABBAXENACABKAL8BUEUEOqGgIAAQQFxRQ0AAkACQCABKAL8BUECENuGgIAAQQFxRQ0AIAEoAvwFQQEQ04aAgAAMAQsgASgC/AVBBBDThoCAAAsgASgC/AVBnQE2AsgBIAEoAvwFEMuGgIAADBMLAkAgASgC/AUoAggNACABKAL8BRDrhoCAAEEBcUUNACABKAL8BSABKAL8BUHIAWpBqQIQ3YaAgAALIAEoAvwFQQEQ04aAgAAgAS0A5QQhjAFBnQFBICCMAUEBcRshjQEgASgC/AUgjQE2AsgBIAEoAvwFEMuGgIAADBILIAEoAvwFQQEQ04aAgAAgAS0A5QQhjgFBnAFBHyCOAUEBcRshjwEgASgC/AUgjwE2AsgBIAEoAvwFEMuGgIAADBELIAEoAvwFQYACENOGgIAAIAEoAvwFQR42AsgBIAEoAvwFEMuGgIAADBALIAEgASgC/AUQ6YaAgAA2AuAEIAEoAvwFQQIQ04aAgAAgASgC4AQhkAEgASgC/AUgkAE2AsgBIAEoAvwFEMuGgIAADA8LAkAgASgC/AVBOkH/AXEQ2YaAgABBAXFFDQACQAJAIAEoAvwFENqGgIAAQQFxDQAgASgC/AVBgAQQ24aAgABBAXENACABKAL8BUEwENuGgIAAQQFxRQ0BIAEtAPMFQQFxRQ0BCyABKAL8BUEBENOGgIAAIAEoAvwFQZsBNgLIASABKAL8BRDLhoCAAAwQCyABKAL8BUGAAhDThoCAACABKAL8BUEaNgLIASABKAL8BRDLhoCAAAwPCwJAAkAgASgC/AUQ4oaAgABBAXENACABKAL8BRDohoCAAEH/AXEQ8IqAgABBAXENACABKAL8BRDohoCAAEH/AXFBI0ZBAXFFDQELIAEoAvwFQQEQ04aAgAAgASgC/AVBGTYCyAEgASgC/AUQy4aAgAAMDwsCQAJAIAEoAvwFEOiGgIAAQf8BcUEiRkEBcQ0AIAEoAvwFEOiGgIAAQf8BcUEnRkEBcUUNAQsgASgC/AUhkQEgASgC/AUQ6IaAgABB/wFxQSJGIZIBIAEoAvwFKALQAS0AACGTAUEAIZQBQQAhlQEgkQEgkgFBAXEglAFBAXEglQFB/wFxIJMBQf8BcRDmhoCAABogASgC/AUhlgEglgEglgEoAtABQQFqNgLQAQsgASgC/AVBgAEQ04aAgAAgASgC/AVBmAE2AsgBIAEoAvwFEMuGgIAADA4LAkAgASgC/AUQ2oaAgABBAXFFDQAgASgC/AUhlwFBACGYAUEvIZkBIJcBIJgBQf8BcSCZAUH/AXEQ7IaAgAAaIAEoAvwFQYwBNgLIASABKAL8BRDLhoCAAAwOCwJAIAEoAvwFQT1B/wFxENmGgIAAQQFxRQ0AIAEoAvwFQQEQ04aAgAAgASgC/AVBkAE2AsgBIAEoAvwFEMuGgIAADA4LAkAgASgC/AUgAS0A8wVBAXEQ3IaAgABBAXFFDQAgASgC/AUgASgC/AVByAFqQacCEN2GgIAAIAEoAvwFIZoBQQAhmwFBLyGcASCaASCbAUH/AXEgnAFB/wFxEOyGgIAAGiABKAL8BUGMATYCyAEgASgC/AUQy4aAgAAMDgsCQCABKAL8BSABLQDzBUEBcRDehoCAAEEBcUUNACABKAL8BUH8AWohnQEgASgC/AUoAswBIZ4BIAEoAvwFKALQASGfASABQaf4hIAANgKkAiABQc2ghoAANgKgAiCdASCeASCfAUGhAiABQaACahDOhICAABoLAkACQCABKAL8BRDYhoCAAEEBcUUNACABKAL8BUEQENOGgIAADAELIAEoAvwFQQEQ04aAgAALIAEoAvwFQY8BNgLIASABKAL8BRDLhoCAAAwNCwJAAkAgASgC/AUQ2IaAgABBAXFFDQAgASgC/AVBEBDThoCAAAwBCyABKAL8BUEBENOGgIAACyABKAL8BUE9Qf8BcRDZhoCAACGgAUEWQRUgoAFBAXEbIaEBIAEoAvwFIKEBNgLIASABKAL8BRDLhoCAAAwMCwJAAkAgASgC/AUQ2IaAgABBAXFFDQAgASgC/AVBwABB/wFxENmGgIAAGiABKAL8BUEQENOGgIAADAELIAEoAvwFQQEQ04aAgAALIAEoAvwFQZkBNgLIASABKAL8BRDLhoCAAAwLCwJAAkAgASgC/AUQ2oaAgABBAXENACABKAL8BRDVhoCAAEEBcUUNAQsgASgC/AUoAtABIAEoAvwFKAK4AU9BAXFFDQAgASgC/AVBnwEQ7YaAgAAgASgC/AVB/gA2AsgBIAEoAvwFEMuGgIAADAsLAkAgASgC/AUQ2oaAgABBAXENACABKAL8BUE9Qf8BcRDZhoCAAEEBcUUNACABKAL8BUEBENOGgIAAIAEoAvwFQf8ANgLIASABKAL8BRDLhoCAAAwLCwJAAkAgASgC/AUQ2oaAgABBAXENAAJAIAEoAvwFQYAgENuGgIAAQQFxRQ0AIAEoAvwFEOiGgIAAQf8BcUHzAEZBAXENAQsgASgC/AUgAS0A8wVBAXEQ3IaAgABBAXFFDQELIAEoAvwFKAKgAigCCCGiAQJAIAEoAvwFKALQASABKAL8BSgCuAEgASgC/AUoAtABayCiARGAgICAAICAgIAADQACQCABKAL8BSgC0AEtAABB/wFxQYABTkEBcUUNACABKAL8BUGeARDthoCAAAsgASABKAL8BRDuhoCAADoA3wQgASgC/AUhowEgAS0A3wRB/wFxEO+GgIAAIaQBIAEtAN8EQf8BcRDwhoCAACGlAUEBIaYBQQAhpwEgowEgpgFBAXEgpwFBAXEgpAFB/wFxIKUBQf8BcRDmhoCAABogASgC/AVBlQE2AsgBIAEoAvwFEMuGgIAADAwLIAEgASgC/AVBARDghoCAADoA3gQCQAJAIAEtAN4EQf8BcUGAAU5BAXENACABKAL8BSgCoAIoAgghqAEgAUHeBGpBASCoARGAgICAAICAgIAARQ0BCyABKAL8BUGeARDthoCAAAwFCyABKAL8BRDohoCAAEG3f2ohqQEgqQFBL0saAkACQAJAAkACQAJAAkACQAJAAkAgqQEOMAEJCQkJCQkJBAkJCQkJBwkJCQkJCQkJCQkJCQkJCQkJAAkJCQkJCQkDAgUJCQkGCAkLIAEoAvwFIaoBIKoBIKoBKALQAUEBajYC0AECQAJAIAEoAvwFKALQASABKAL8BSgCuAFJQQFxRQ0AIAEoAvwFIasBIAEoAvwFEO6GgIAAIawBIKsBQQBBAXEgrAFB/wFxEPGGgIAAGgwBCyABKAL8BRDyhoCAABoLIAEoAvwFQYABNgLIASABKAL8BRDLhoCAAAwUCyABKAL8BSGtASCtASCtASgC0AFBAWo2AtABAkACQCABKAL8BSgC0AEgASgC/AUoArgBSUEBcUUNACABKAL8BSGuASABKAL8BRDuhoCAACGvASCuAUEBQQFxIK8BQf8BcRDxhoCAABoMAQsgASgC/AUQ8oaAgAAaCyABKAL8BUGDATYCyAEgASgC/AUQy4aAgAAMEwsgASgC/AUhsAEgsAEgsAEoAtABQQFqNgLQAQJAAkAgASgC/AUoAtABIAEoAvwFKAK4AUlBAXFFDQAgASABKAL8BRDuhoCAADoA3QQgASgC/AUhsQEgAS0A3QRB/wFxEO+GgIAAIbIBIAEtAN0EQf8BcRDwhoCAACGzASCxASCyAUH/AXEgswFB/wFxEOyGgIAAGgwBCyABKAL8BSG0AUEAIbUBILQBILUBQf8BcSC1AUH/AXEQ7IaAgAAaCyABKAL8BUGMATYCyAEgASgC/AUQy4aAgAAMEgsgASgC/AUhtgEgtgEgtgEoAtABQQFqNgLQAQJAAkAgASgC/AUoAtABIAEoAvwFKAK4AUlBAXFFDQAgASABKAL8BRDuhoCAADoA3AQgASgC/AUhtwEgAS0A3ARB/wFxEO+GgIAAIbgBIAEtANwEQf8BcRDwhoCAACG5AUEAIboBILcBILoBQQFxILoBQQFxILgBQf8BcSC5AUH/AXEQ5oaAgAAaDAELIAEoAvwFEPOGgIAAGgsgASgC/AVBlQE2AsgBIAEoAvwFEMuGgIAADBELIAEoAvwFIbsBILsBILsBKALQAUEBajYC0AECQAJAIAEoAvwFKALQASABKAL8BSgCuAFJQQFxRQ0AIAEgASgC/AUQ7oaAgAA6ANsEIAEoAvwFIbwBIAEtANsEQf8BcRDvhoCAACG9ASABLQDbBEH/AXEQ8IaAgAAhvgFBASG/AUEAIcABILwBIL8BQQFxIMABQQFxIL0BQf8BcSC+AUH/AXEQ5oaAgAAaDAELIAEoAvwFEPOGgIAAGgsgASgC/AVBlQE2AsgBIAEoAvwFEMuGgIAADBALIAEoAvwFIcEBIMEBIMEBKALQAUEBajYC0AECQAJAIAEoAvwFKALQASABKAL8BSgCuAFJQQFxRQ0AIAEgASgC/AUQ7oaAgAA6ANoEIAEoAvwFIcIBIAEtANoEQf8BcRDvhoCAACHDASABLQDaBEH/AXEQ8IaAgAAhxAFBACHFASDCASDFAUEBcSDFAUEBcSDDAUH/AXEgxAFB/wFxEOaGgIAAGiABKAL8BUGAIRDThoCAAAwBCyABKAL8BRDzhoCAABoLIAEoAvwFQZgBNgLIASABKAL8BRDLhoCAAAwPCyABKAL8BSHGASDGASDGASgC0AFBAWo2AtABAkACQCABKAL8BSgC0AEgASgC/AUoArgBSUEBcUUNACABKAL8BSHHASABKAL8BRDuhoCAACHIASDHAUEAQQFxIMgBQf8BcRDxhoCAABoMAQsgASgC/AUQ8oaAgAAaCyABKAL8BUGBATYCyAEgASgC/AUQy4aAgAAMDgsgASgC/AUhyQEgyQEgyQEoAtABQQFqNgLQAQJAAkAgASgC/AUoAtABIAEoAvwFKAK4AUlBAXFFDQAgASgC/AUhygEgASgC/AUQ7oaAgAAhywEgygFBAUEBcSDLAUH/AXEQ8YaAgAAaDAELIAEoAvwFEPKGgIAAGgsgASgC/AVBhAE2AsgBIAEoAvwFEMuGgIAADA0LIAEoAvwFIcwBIMwBIMwBKALQAUEBajYC0AECQAJAIAEoAvwFKALQASABKAL8BSgCuAFJQQFxRQ0AIAEgASgC/AUQ7oaAgAA6ANkEIAEoAvwFIc0BIAEtANkEQf8BcRDvhoCAACHOASABLQDZBEH/AXEQ8IaAgAAhzwFBASHQAUEAIdEBIM0BINABQQFxINEBQQFxIM4BQf8BcSDPAUH/AXEQ5oaAgAAaDAELIAEoAvwFEPOGgIAAGgsgASgC/AVBggE2AsgBIAEoAvwFEMuGgIAADAwLIAEoAvwFQZ4BEO2GgIAADAQLAkAgASgC/AUgAS0A8wVBAXEQ3oaAgABBAXFFDQAgASgC/AVB/AFqIdIBIAEoAvwFKALMASHTASABKAL8BSgC0AEh1AEgAUHc+YSAADYCtAIgAUHttIaAADYCsAIg0gEg0wEg1AFBoQIgAUGwAmoQzoSAgAAaCyABKAL8BSHVASABKAL8BRDYhoCAACHWASDVAUEQQQEg1gFBAXEbENOGgIAAIAEoAvwFQf4ANgLIASABKAL8BRDLhoCAAAwKCyABIAEoAvwFEPSGgIAANgLUBAJAIAEoAvwFKAIcKAIAQQJGQQFxRQ0AIAEoAvwFELmGgIAACyABKAL8BUECENOGgIAAIAEoAtQEIdcBIAEoAvwFINcBNgLIASABKAL8BRDLhoCAAAwJCyABKAL8BSHYASABKAL8BSgCBEGAAXEh2QEg2AFBCEECINkBGxDThoCAACABKAL8BRD1hoCAACHaASABKAL8BSDaATYCyAEgASgC/AUQy4aAgAAMCAsgASgC/AUoAswBLQAAQf8BcUHfAEdBAXFFDQEgASABKAL8BSABKAL8BSgCzAEgASgC/AUoArgBIAEoAvwFKALMAWsQ9oaAgAA2AtAEAkAgASgC0AQNAAJAAkAgASgC/AUoAswBLQAAQf8BcUGAAU5BAXFFDQAgASgC/AVBiAJqIdsBIAEoAvwFKALMASHcASABKAL8BSgC0AEh3QEgASABKAL8BSgCzAEtAABB/wFxNgIAINsBINwBIN0BQZUBIAEQzoSAgAAaDAELAkACQCABKAL8BSgCzAEtAABB/wFxQdwARkEBcUUNACABKAL8BSHeASDeASDeASgCzAFBAWoQ1IaAgABBd2oh3wEg3wFBF0saAkACQAJAAkACQAJAAkAg3wEOGAIFAwEEBQUFBQUFBQUFBQUFBQUFBQUFAAULIAEoAvwFIeABIOABIOABKALQAUEBajYC0AEgASgC/AVBiAJqIeEBIAEoAvwFKALMASHiASABKAL8BSgC0AEh4wEgAUGXvIWAADYCICDhASDiASDjAUGZAiABQSBqEM6EgIAAGgwFCyABKAL8BSHkASDkASDkASgC0AFBAWo2AtABIAEoAvwFQYgCaiHlASABKAL8BSgCzAEh5gEgASgC/AUoAtABIecBIAFBicuFgAA2AjAg5QEg5gEg5wFBmQIgAUEwahDOhICAABoMBAsgASgC/AUh6AEg6AEg6AEoAtABQQFqNgLQASABKAL8BUGIAmoh6QEgASgC/AUoAswBIeoBIAEoAvwFKALQASHrASABQbXXhYAANgJAIOkBIOoBIOsBQZkCIAFBwABqEM6EgIAAGgwDCyABKAL8BSHsASDsASDsASgC0AFBAWo2AtABIAEoAvwFQYgCaiHtASABKAL8BSgCzAEh7gEgASgC/AUoAtABIe8BIAFBzNeFgAA2AlAg7QEg7gEg7wFBmQIgAUHQAGoQzoSAgAAaDAILAkAgASgC/AUgASgC/AUoAswBQQJqENSGgIAAQf8BcUEKR0EBcUUNACABKAL8BSHwASDwASDwASgC0AFBAWo2AtABIAEoAvwFQYgCaiHxASABKAL8BSgCzAEh8gEgASgC/AUoAtABIfMBIAFB1tyEgAA2AmAg8QEg8gEg8wFBmQIgAUHgAGoQzoSAgAAaDAILCyABKAL8BUGIAmoh9AEgASgC/AUoAswBIfUBIAEoAvwFKALQASH2ASABQZCEhYAANgIQIPQBIPUBIPYBQZkCIAFBEGoQzoSAgAAaCwwBCwJAAkAgASgC/AUoAswBLQAAQf8BcRD3hoCAAEEBcUUNACABKAL8BUGIAmoh9wEgASgC/AUoAswBIfgBIAEoAvwFKALQASH5ASABIAEoAvwFKALMAS0AAEH/AXE2AnAg9wEg+AEg+QFBoAEgAUHwAGoQzoSAgAAaDAELIAEoAvwFQYgCaiH6ASABKAL8BSgCzAEh+wEgASgC/AUoAtABIfwBIAEgASgC/AUoAswBLQAAQf8BcTYCgAEg+gEg+wEg/AFBjQEgAUGAAWoQzoSAgAAaCwsLDAELCyABKAL8BSgCzAEgASgC0ARqIf0BIAEoAvwFIP0BNgLQAQsgASABKAL8BSABLQD7BUEBcRD4hoCAADYCzAQCQCABKAL8BSgC0AEgASgC/AUoAswBa0EHRkEBcUUNACABKAL8BRDfhoCAAEEBcUUNACABKAL8BSgCzAFB2OWFgABBBxDUi4CAAA0AAkAgASgC/AUoAtABIAEoAvwFKAK4AUZBAXENACABKAL8BRD5hoCAAEUNAQsgASABKAL8BSgC0AE2AsgEAkADQCABKALIBCABKAL8BSgCuAEgASgCyARrEKyGgIAAIf4BIAEg/gE2AsgEIP4BQQBHQQFxRQ0BIAEoAvwFQcwCaiH/ASABKALIBCGAAiABIIACQQFqNgLIBCD/ASCAAhCji4CAABoMAAsLIAEoAvwFKAK4ASGBAiABKAL8BSCBAjYC0AEgASgC/AVBpAE2AsgBIAEoAvwFEMuGgIAAIAEoAvwFKALMASGCAiABKAL8BSCCAjYC9AEgASgC/AUoAtABIYMCIAEoAvwFIIMCNgL4ASABKAL8BUEBNgLIASABKAL8BRDLhoCAAAwGCyABIAEoAvwFKAIENgLEBAJAAkAgASgCzARBN0ZBAXENACABKALMBEEdRkEBcQ0AIAEoAswEQfUARkEBcUUNAQsCQAJAIAEoAvwFQfEGENuGgIAAQQFxRQ0AAkACQCABLQD7BUEBcUUNACABKAL8BUEgENOGgIAADAELIAEoAvwFQRAQ04aAgAALDAELAkACQCABKAL8BSgCBEGAAUZBAXFFDQAgASgC/AVBCBDThoCAAAwBCyABKAL8BUECENOGgIAACwsLAkAgASgCxARBgANxDQAgASgCzARBN0ZBAXFFDQACQCABKAL8BSABKAL8BUHIAWoQ+oaAgABBf0dBAXENACABKAL8BSgCzAEgASgC/AUoAtABEPuGgIAAQQFxRQ0BCyABKAL8BUGCCBDThoCAAAsgASgCzAQhhAIgASgC/AUghAI2AsgBIAEoAvwFEMuGgIAADAULAkAgASgC/AUoAtQBQQBHQQFxRQ0AIAEoAvwFKALUASGFAiABKAL8BSCFAjYC0AEgASgC/AVBADYC1AELIAEoAvwFKALQASGGAiABKAL8BSCGAjYCzAECQAJAIAEoAvwFKALYAUEAR0EBcUUNACABIAEoAvwFKALQASABKAL8BSgCuAEgASgC/AUoAtABaxDuioCAADYCwAQCQCABKAL8BSABKALABBDghoCAAEH/AXFBCkZBAXFFDQAgASABKALABEEBajYCwAQLDAELIAEgASgC/AUoAtABIAEoAvwFKAK4ASABKAL8BSgC0AFrIAEoAvwFQcwCahDtioCAADYCwAQLAkAgASgCwARBAEtBAXFFDQAgASgCwAQhhwIgASgC/AUhiAIgiAIghwIgiAIoAtABajYC0AECQCABKAL8BUF/EOCGgIAAQf8BcUEKRkEBcUUNACABKAL8BRDQhoCAAAsgASgC/AVBowE2AsgBIAEoAvwFEMuGgIAADAULAkAgASgC/AUoAtABIAEoAvwFKAK4AU9BAXFFDQAgASgC/AVBATYCyAEgASgC/AUQy4aAgAAMBQsgASABKAL8BSgCHDYCvAQgASABKAK8BEEEakEHajYCuAQgASABKAL8BSABKAL8BSgC0AEgASgCuAQgASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCxi4CAADYCtAQgAUGoBGohiQJCACGKAiCJAiCKAjcDACABIIoCNwOgBAJAA0AgASgCtARBAEdBAXFFDQECQCABKAK0BC0AAEH/AXEQ8IqAgABBAXFFDQAgASgCtAQhiwIgASgC/AUgiwI2AtABIAEoAvwFIAFBoARqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwHCwJAIAEoArQELQAAQf8BcSABKAK8BC0ACkH/AXFGQQFxRQ0AAkAgASgCvAQoAgRBAEtBAXFFDQAgASgCtARBAWohjAIgASgC/AUgjAI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoArgEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2ArQEIAEoArwEIY0CII0CII0CKAIEQX9qNgIEDAILAkAgASgCtAQgASgC/AUoAswBS0EBcUUNACABKAK0BCGOAiABKAL8BSCOAjYC0AEgASgC/AUgAUGgBGoQ/IaAgAAgASgC/AVBlgE2AsgBIAEoAvwFEMuGgIAADAgLIAEoArQEQQFqIY8CIAEoAvwFII8CNgLQASABKAL8BRC5hoCAACABKAL8BUECENOGgIAAIAEoAvwFQZcBNgLIASABKAL8BRDLhoCAAAwHCwJAIAEoArQELQAAQf8BcQ0AIAEgASgC/AUgASgCtARBAWogASgCuAQgASgC/AUoArgBIAEoArQEQQFqa0EBQQFxELGLgIAANgK0BAwBCwJAIAEoArQELQAAQf8BcUHcAEZBAXFFDQAgASgCtARBAWohkAIgASgC/AUgkAI2AtABAkAgASgC/AUoAtABIAEoAvwFKAK4AUZBAXFFDQAgAUEANgK0BAwCCyABKAL8BSABQaAEahD9hoCAACABIAEoAvwFEOiGgIAAOgCfBCABLQCfBCGRAgJAAkACQAJAAkAgkQJBCUYNACCRAkEKRg0CIJECQXVqQQJJDQAgkQJBDUYNASCRAkEgRg0AIJECQdwARw0DCyABLQCfBCGSAiABQaAEaiCSAkH/AXEQ/oaAgAAgASgC/AUhkwIgkwIgkwIoAtABQQFqNgLQAQwDCyABKAL8BSGUAiCUAiCUAigC0AFBAWo2AtABAkAgASgC/AUQ6IaAgABB/wFxQQpHQQFxRQ0AIAFBoARqQQ1B/wFxEP6GgIAADAMLCyABQaAEakEKQf8BcRD+hoCAAAJAIAEoAvwFKALYAUEAR0EBcUUNACABKAL8BRDQhoCAACABKAL8BSABQaAEahD/hoCAACABKAL8BUGWATYCyAEgASgC/AUQy4aAgAAMCgsgASgC/AVBzAJqIAEoAvwFKALQARCji4CAABogASgC/AUhlQIglQIglQIoAtABQQFqNgLQAQwBCwJAAkACQCABLQCfBEH/AXEgASgCvAQtAAlB/wFxRkEBcQ0AIAEtAJ8EQf8BcSABKAK8BC0ACkH/AXFGQQFxRQ0BCyABLQCfBCGWAiABQaAEaiCWAkH/AXEQ/oaAgAAgASgC/AUhlwIglwIglwIoAtABQQFqNgLQAQwBCwJAAkAgASgCvAQtAAhBAXFFDQAgASgC/AUgAUGgBGpBAEEAQf8BcRCAh4CAAAwBCyABQaAEakHcAEH/AXEQ/oaAgAAgASgC/AUhmAIgAUGgBGogmAIQgYeAgAALCwsgASABKAL8BSgC0AE2AqwEIAEgASgC/AUgASgC/AUoAtABIAEoArgEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2ArQEDAELAkAgASgCtAQtAABB/wFxQSNGQQFxRQ0AIAEgASgC/AUgASgCtAQQgoeAgAA2ApgEAkAgASgCmARBA0ZBAXFFDQAgASABKAL8BSABKAL8BSgC0AEgASgCuAQgASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCxi4CAADYCtAQMAgsCQCABKAKYBEGWAUZBAXFFDQAgASgC/AUgAUGgBGoQ/IaAgAALIAEoApgEIZkCIAEoAvwFIJkCNgLIASABKAL8BRDLhoCAAAwHCwJAIAEoArQELQAAQf8BcSABKAK8BC0ACUH/AXFGQQFxDQBBosKEgABBs9CFgABBtt4AQfuHhIAAEI6AgIAAAAsgASgCtARBAWohmgIgASgC/AUgmgI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoArgEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2ArQEIAEoArwEIZsCIJsCIJsCKAIEQQFqNgIEDAALCwJAIAEoAvwFKALQASABKAL8BSgCzAFLQQFxRQ0AIAEoAvwFIAFBoARqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwFCyABKAL8BSgCuAEhnAIgASgC/AUgnAI2AtABIAEoAvwFIAFBoARqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwECwJAAkAgASgC/AUoAtQBQQBGQQFxRQ0AIAEoAvwFKALQASGdAiABKAL8BSCdAjYCzAEMAQsgASgC/AUoAtQBIZ4CIAEoAvwFIJ4CNgLMASABKAL8BSgC1AEhnwIgASgC/AUgnwI2AtABIAEoAvwFQQA2AtQBCwJAIAEoAvwFKALQASABKAL8BSgCuAFPQQFxRQ0AIAEoAvwFQQE2AsgBIAEoAvwFEMuGgIAADAQLIAEgASgC/AUoAhw2ApQEIAEgASgClARBBGpBBmo2ApAEIAEgASgC/AUgASgC/AUoAtABIAEoApAEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQBBAXEQsYuAgAA2AowEIAFBiARqQQA2AgAgAUGABGohoAJCACGhAiCgAiChAjcDACABQfgDaiChAjcDACABIKECNwPwAwJAA0AgASgCjARBAEdBAXFFDQEgASABKAKUBC0ACToA7wMgASABKAKMBC0AAEH/AXEgAS0A7wNB/wFxRkEBcToA7gMCQCABKAKMBC0AAEH/AXFBDUZBAXFFDQAgASgC/AUgASgCjARBAWoQ1IaAgABB/wFxQQpGQQFxRQ0AAkAgAS0A7wNB/wFxQQpGQQFxRQ0AIAFBAToA7gMLAkAgAS0A7wNB/wFxQQ1GQQFxRQ0AIAFBADoA7gMLCwJAIAEtAO4DQQFxRQ0AAkAgASgClAQoAgRBAEtBAXFFDQAgASgCjARBAWohogIgASgC/AUgogI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoApAEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQBBAXEQsYuAgAA2AowEIAEoApQEIaMCIKMCIKMCKAIEQX9qNgIEDAILAkAgASgCjAQgASgC/AUoAswBS0EBcUUNACABKAKMBCGkAiABKAL8BSCkAjYC0AEgASgC/AUgAUHwA2oQg4eAgAAgASgC/AVBlgE2AsgBIAEoAvwFEMuGgIAADAcLIAEgASgC/AUgASgCjAQQz4aAgAA2AugDAkACQCABKALoA0UNACABKAKMBCABKALoA2ohpQIgASgC/AUgpQI2AtABIAEoAvwFQcwCaiABKAL8BSgC0AFBf2oQo4uAgAAaDAELIAEoAowEQQFqIaYCIAEoAvwFIKYCNgLQAQsgASgC/AUoAtABIAEoAvwFKAK4ASABKAL8BSgC0AFrEO+KgIAAIacCIAEoAvwFIagCIKgCIKcCIKgCKALQAWo2AtABIAEoAvwFELmGgIAAIAEoAvwFQQIQ04aAgAAgASgC/AVBjQE2AsgBIAEoAvwFEMuGgIAADAYLAkAgASgCjAQtAABB/wFxRQ0AIAEoAowELQAAQf8BcSABKAKUBC0ACEH/AXFGQQFxRQ0AIAEoAowEQQFqIakCIAEoAvwFIKkCNgLQASABIAEoAvwFIAEoAvwFKALQASABKAKQBCABKAL8BSgCuAEgASgC/AUoAtABa0EAQQFxELGLgIAANgKMBCABKAKUBCGqAiCqAiCqAigCBEEBajYCBAwBCyABKAKMBC0AACGrAgJAAkACQAJAAkACQAJAIKsCRQ0AIKsCQQpGDQIgqwJBDUYNASCrAkEjRg0EIKsCQdwARg0DDAULIAEoAowEQQFqIawCIAEoAvwFIKwCNgLQASABIAEoAvwFIAEoAvwFKALQASABKAKQBCABKAL8BSgCuAEgASgC/AUoAtABa0EAQQFxELGLgIAANgKMBAwFCwJAIAEoAvwFIAEoAowEQQFqENSGgIAAQf8BcUEKR0EBcUUNACABKAKMBEEBaiGtAiABKAL8BSCtAjYC0AEgASABKAL8BSABKAL8BSgC0AEgASgCkAQgASgC/AUoArgBIAEoAvwFKALQAWtBAEEBcRCxi4CAADYCjAQMBQsgASABKAKMBEEBajYCjAQgASgCjAQhrgIgASgC/AUgrgI2AtABIAEoAvwFIAFB8ANqEISHgIAAIAEgASgCjAQ2AvwDCwJAIAEoAvwFKALYAUEARkEBcUUNACABKAL8BUHMAmogASgCjAQQo4uAgAAaIAEoAowEQQFqIa8CIAEoAvwFIK8CNgLQASABIAEoAvwFIAEoAvwFKALQASABKAKQBCABKAL8BSgCuAEgASgC/AUoAtABa0EAQQFxELGLgIAANgKMBAwECyABKAKMBEEBaiGwAiABKAL8BSCwAjYC0AEgASgC/AUQ0IaAgAAgASgC/AUgAUHwA2oQg4eAgAAgASgC/AVBlgE2AsgBIAEoAvwFEMuGgIAADAkLIAEoAowEQQFqIbECIAEoAvwFILECNgLQAQJAIAEoAvwFKALQASABKAL8BSgCuAFGQQFxRQ0AIAFBADYCjAQMAwsgASgC/AUgAUHwA2oQhIeAgAAgASABKAL8BRDohoCAADoA5wMgAS0A5wMhsgICQAJAAkACQCCyAkEKRg0AAkAgsgJBDUYNACCyAkHDAEYNAiCyAkHNAEYNAiCyAkHjAEYNAiCyAkH1AEYNAiCyAkH4AEYNAgwDCyABKAL8BSGzAiCzAiCzAigC0AFBAWo2AtABAkAgASgC/AUQ6IaAgABB/wFxQQpHQQFxRQ0AAkAgASgClAQtAAlB/wFxQQ1HQQFxRQ0AIAFB8ANqQdwAQf8BcRD+hoCAAAsgAUHwA2pBDUH/AXEQhYeAgAAgAUHwA2pBDUH/AXEQ/oaAgAAMBAsLAkAgASgC/AUoAtgBQQBHQQFxRQ0AIAEoAvwFENCGgIAAIAEoAvwFIAFB8ANqEIaHgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwMCyABKAL8BUHMAmogASgC/AUoAtABEKOLgIAAGiABKAL8BSG0AiC0AiC0AigC0AFBAWo2AtABDAILIAEoAvwFIAFB8ANqQRBqIAFB8ANqQQhB/wFxEICHgIAADAELAkAgASgClAQtAAlB/wFxIAEtAOcDQf8BcUZBAXFFDQAgAS0A5wNBXGohtQIgtQJB2QBLGgJAAkACQCC1Ag5aAAEBAQEAAAABAQABAQEBAQEBAQEBAQEBAQEAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAQsgAUHwA2pB3ABB/wFxEP6GgIAADAELCyABLQDnAyG2AiABQfADaiC2AkH/AXEQhYeAgAAgAUHwA2ogAS0A5wNB/wFxEP6GgIAAIAEoAvwFIbcCILcCILcCKALQAUEBajYC0AEMAQsCQCABLQDnA0H/AXFBgAFIQQFxRQ0AIAFB8ANqQdwAQf8BcRD+hoCAAAsgASgC/AUhuAIgAUHwA2oguAIQh4eAgAALIAEgASgC/AUoAtABNgL8AyABIAEoAvwFIAEoAvwFKALQASABKAKQBCABKAL8BSgCuAEgASgC/AUoAtABa0EAQQFxELGLgIAANgKMBAwCCyABIAEoAvwFIAEoAowEEIKHgIAANgLgAwJAIAEoAuADQQNGQQFxRQ0AIAEgASgC/AUgASgC/AUoAtABIAEoApAEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQBBAXEQsYuAgAA2AowEDAILAkAgASgC4ANBlgFGQQFxRQ0AIAEoAvwFIAFB8ANqEIOHgIAACyABKALgAyG5AiABKAL8BSC5AjYCyAEgASgC/AUQy4aAgAAMBwtB4raGgABBs9CFgABBquAAQfuHhIAAEI6AgIAAAAsMAAsLAkAgASgC/AUoAtABIAEoAvwFKALMAUtBAXFFDQAgASgC/AUgAUHwA2oQg4eAgAAgASgC/AVBlgE2AsgBIAEoAvwFEMuGgIAADAQLIAEoAvwFKAK4ASG6AiABKAL8BSC6AjYC0AEgASgC/AUgAUHwA2oQg4eAgAAgASgC/AVBlgE2AsgBIAEoAvwFEMuGgIAADAMLAkACQCABKAL8BSgC1AFBAEZBAXFFDQAgASgC/AUoAtABIbsCIAEoAvwFILsCNgLMAQwBCyABKAL8BSgC1AEhvAIgASgC/AUgvAI2AswBIAEoAvwFKALUASG9AiABKAL8BSC9AjYC0AEgASgC/AVBADYC1AELAkAgASgC/AUoAtABIAEoAvwFKAK4AU9BAXFFDQAgASgC/AVBATYCyAEgASgC/AUQy4aAgAAMAwsgASABKAL8BSgCHDYC3AMgASABKALcA0EEakEIajYC2AMgASABKAL8BSABKAL8BSgC0AEgASgC2AMgASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCxi4CAADYC1AMgAUHIA2ohvgJCACG/AiC+AiC/AjcDACABIL8CNwPAAwJAA0AgASgC1ANBAEdBAXFFDQECQCABKALcAy0ACkH/AXFFDQAgASgC1AMtAABB/wFxIAEoAtwDLQAKQf8BcUZBAXFFDQAgASgC3AMhwAIgwAIgwAIoAgRBAWo2AgQgASgC1ANBAWohwQIgASgC/AUgwQI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoAtgDIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2AtQDDAELIAEgASgC3AMtAAs6AL8DIAEgASgC1AMtAABB/wFxIAEtAL8DQf8BcUZBAXE6AL4DAkAgASgC1AMtAABB/wFxQQ1GQQFxRQ0AIAEoAvwFIAEoAtQDQQFqENSGgIAAQf8BcUEKRkEBcUUNAAJAIAEtAL8DQf8BcUEKRkEBcUUNACABQQE6AL4DCwJAIAEtAL8DQf8BcUENRkEBcUUNACABQQA6AL4DCwsCQCABLQC+A0EBcUUNAAJAIAEoAtwDKAIEQQBLQQFxRQ0AIAEoAtQDQQFqIcICIAEoAvwFIMICNgLQASABIAEoAvwFIAEoAvwFKALQASABKALYAyABKAL8BSgCuAEgASgC/AUoAtABa0EBQQFxELGLgIAANgLUAyABKALcAyHDAiDDAiDDAigCBEF/ajYCBAwCCwJAIAEoAtQDIAEoAvwFKALMAUtBAXFFDQAgASgC1AMhxAIgASgC/AUgxAI2AtABIAEoAvwFIAFBwANqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwGCyABIAEoAvwFIAEoAtQDEM+GgIAANgK4AwJAAkAgASgCuANFDQAgASgC1AMgASgCuANqIcUCIAEoAvwFIMUCNgLQASABKAL8BUHMAmogASgC/AUoAtABQX9qEKOLgIAAGgwBCyABKALUA0EBaiHGAiABKAL8BSDGAjYC0AELAkAgASgC3AMtAAlBAXFFDQAgASgC/AUQ6IaAgABB/wFxQTpGQQFxRQ0AIAEoAvwFQQEQ4IaAgABB/wFxQTpHQQFxRQ0AIAEoAvwFIccCIMcCIMcCKALQAUEBajYC0AEgASgC/AVBkBAQ04aAgAAgASgC/AUQuYaAgAAgASgC/AVB7gA2AsgBIAEoAvwFEMuGgIAADAYLIAEoAvwFQQIQ04aAgAAgASgC/AUQuYaAgAAgASgC/AVBlwE2AsgBIAEoAvwFEMuGgIAADAULIAEoAtQDLQAAIcgCAkACQAJAAkACQAJAAkAgyAJFDQAgyAJBCkYNAiDIAkENRg0BIMgCQSNGDQQgyAJB3ABGDQMMBQsgASgC1ANBAWohyQIgASgC/AUgyQI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoAtgDIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2AtQDDAULAkAgASgC/AUgASgC1ANBAWoQ1IaAgABB/wFxQQpHQQFxRQ0AIAEoAtQDQQFqIcoCIAEoAvwFIMoCNgLQASABIAEoAvwFIAEoAvwFKALQASABKALYAyABKAL8BSgCuAEgASgC/AUoAtABa0EBQQFxELGLgIAANgLUAwwFCyABIAEoAtQDQQFqNgLUAyABKALUAyHLAiABKAL8BSDLAjYC0AEgASgC/AUgAUHAA2oQ/YaAgAAgASABKALUAzYCzAMLAkAgASgC/AUoAtgBQQBGQQFxRQ0AIAEoAvwFQcwCaiABKALUAxCji4CAABogASgC1ANBAWohzAIgASgC/AUgzAI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoAtgDIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2AtQDDAQLIAEoAtQDQQFqIc0CIAEoAvwFIM0CNgLQASABKAL8BRDQhoCAACABKAL8BSABQcADahD8hoCAACABKAL8BUGWATYCyAEgASgC/AUQy4aAgAAMCAsgASgC1ANBAWohzgIgASgC/AUgzgI2AtABAkAgASgC/AUoAtABIAEoAvwFKAK4AUZBAXFFDQAgAUEANgLUAwwECyABKAL8BSABQcADahD9hoCAACABIAEoAvwFEOiGgIAAOgC3AyABLQC3AyHPAgJAAkACQCDPAkEKRg0AAkAgzwJBDUYNACDPAkHcAEcNAiABQcADakHcAEH/AXEQ/oaAgAAgASgC/AUh0AIg0AIg0AIoAtABQQFqNgLQAQwDCyABKAL8BSHRAiDRAiDRAigC0AFBAWo2AtABAkAgASgC/AUQ6IaAgABB/wFxQQpHQQFxRQ0AAkAgASgC3AMtAAhBAXENACABQcADakHcAEH/AXEQ/oaAgAALIAFBwANqQQ1B/wFxEP6GgIAADAMLCwJAIAEoAtwDLQAIQQFxDQAgAUHAA2pB3ABB/wFxEP6GgIAAIAFBwANqQQpB/wFxEP6GgIAACwJAIAEoAvwFKALYAUEAR0EBcUUNACABKAL8BRDQhoCAACABKAL8BSABQcADahD/hoCAACABKAL8BUGWATYCyAEgASgC/AUQy4aAgAAMCgsgASgC/AVBzAJqIAEoAvwFKALQARCji4CAABogASgC/AUh0gIg0gIg0gIoAtABQQFqNgLQAQwBCwJAAkAgASgC3AMtAApB/wFxRQ0AIAEtALcDQf8BcSABKALcAy0ACkH/AXFGQQFxRQ0AIAEtALcDIdMCIAFBwANqINMCQf8BcRD+hoCAACABKAL8BSHUAiDUAiDUAigC0AFBAWo2AtABDAELAkACQCABKALcAy0AC0H/AXFFDQAgAS0AtwNB/wFxIAEoAtwDLQALQf8BcUZBAXFFDQAgAS0AtwMh1QIgAUHAA2og1QJB/wFxEP6GgIAAIAEoAvwFIdYCINYCINYCKALQAUEBajYC0AEMAQsCQAJAIAEoAtwDLQAIQQFxRQ0AIAEoAvwFIAFBwANqQQBBAEH/AXEQgIeAgAAMAQsgAUHAA2pB3ABB/wFxEP6GgIAAIAEoAvwFIdcCIAFBwANqINcCEIGHgIAACwsLCyABIAEoAvwFKALQATYCzAMgASABKAL8BSABKAL8BSgC0AEgASgC2AMgASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCxi4CAADYC1AMMAgsgASABKAL8BSABKALUAxCCh4CAADYCsAMCQCABKAKwA0EDRkEBcUUNACABIAEoAvwFIAEoAvwFKALQASABKALYAyABKAL8BSgCuAEgASgC/AUoAtABa0EBQQFxELGLgIAANgLUAwwCCwJAIAEoArADQZYBRkEBcUUNACABKAL8BSABQcADahD8hoCAAAsgASgCsAMh2AIgASgC/AUg2AI2AsgBIAEoAvwFEMuGgIAADAYLQeK2hoAAQbPQhYAAQZriAEH7h4SAABCOgICAAAALDAALCwJAIAEoAvwFKALQASABKAL8BSgCzAFLQQFxRQ0AIAEoAvwFIAFBwANqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwDCyABKAL8BSgCuAEh2QIgASgC/AUg2QI2AtABIAEoAvwFIAFBwANqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwCCwJAAkAgASgC/AUoAtQBQQBGQQFxRQ0AIAEoAvwFKALQASHaAiABKAL8BSDaAjYCzAEMAQsgASgC/AUoAtQBIdsCIAEoAvwFINsCNgLMASABKAL8BSgC1AEh3AIgASgC/AUg3AI2AtABIAEoAvwFQQA2AtgBIAEoAvwFQQA2AtQBCyABIAEoAvwFKAIcNgKsAyABIAEoAqwDQQRqNgKoAyABIAEoAqwDLQAcQQFxOgCnAyABKAKsA0EAOgAcAkAgASgC/AUoAtABIAEoAvwFKAK4AU9BAXFFDQAgASgC/AUgASgCqAMoAgAgASgCqAMoAgQQ5YaAgAAgASgCrAMoAhQh3QIgASgC/AUg3QI2AtQBIAEoAvwFKALQASHeAiABKAL8BSDeAjYC2AEgASgC/AVBAhDThoCAACABKAL8BRC5hoCAACABKAL8BUE1NgLIASABKAL8BRDLhoCAAAwCCyABIAEoAqgDKAIANgKgAyABIAEoAqgDKAIENgKcAwJAIAEoAvwFEN+GgIAAQQFxRQ0AIAEgASgC/AUoAswBNgKYAwJAIAEtAKcDQQFxDQAgASgCmAMgASgCnANqIAEoAvwFKAK4AU1BAXFFDQAgASABKAKYAyABKAL8BSgCuAEgASgCmANrEKyGgIAANgKUAyABIAEoApQDNgKQAyABIAEoApQDNgKMAwJAAkAgASgClANBAEZBAXFFDQAgASABKAL8BSgCuAE2AowDIAEgASgC/AUoArgBNgKQAwwBCyABIAEoAowDQQFqNgKMAwJAIAEoApQDQX9qLQAAQf8BcUENRkEBcUUNACABIAEoApADQX9qNgKQAwsLIAEoApADId8CIAEoApwDIeACIAEg3wJBACDgAmtqNgKIAyABIAEoApgDNgKEAwJAAkAgASgCqAMoAgxBAUZBAXENACABKAKoAygCDEECRkEBcUUNAQsDQCABKAKEAyABKAKIA0kh4QJBACHiAiDhAkEBcSHjAiDiAiHkAgJAIOMCRQ0AIAEoAoQDLQAAQf8BcRDyioCAACHkAgsCQCDkAkEBcUUNACABIAEoAoQDQQFqNgKEAwwBCwsLAkAgASgChAMgASgCiANGQQFxRQ0AIAEoAogDIAEoAqADIAEoApwDENSLgIAADQACQCABKAKUA0EAR0EBcUUNACABKAL8BUHMAmogASgClAMQo4uAgAAaCyABKAKMAyHlAiABKAL8BSDlAjYC0AECQAJAIAEoAqwDKAIULQAAQf8BcUHcAEZBAXFFDQAgASgC/AVBADYC1AEMAQsgASgCrAMoAhQh5gIgASgC/AUg5gI2AtQBIAEoAvwFKALQASHnAiABKAL8BSDnAjYC2AELIAEoAvwFQQIQ04aAgAAgASgC/AUQuYaAgAAgASgC/AVBNTYCyAEgASgC/AUQy4aAgAAMBAsLIAEoAvwFIegCIAEoAqgDKAIMIekCIAEg6AIgAUGYA2og6QIQiIeAgAA2AoADAkAgASgCqAMoAgxBAkZBAXFFDQAgASgCrAMoAhhBAEdBAXFFDQAgASgCrAMoAhgoAgAgASgCgANLQQFxRQ0AIAEoAvwFIAEoApgDENSGgIAAQf8BcUEKR0EBcUUNACABKAKAAyHqAiABKAKsAygCGCDqAjYCAAsLQQAh6wIg6wItAPO0hoAAIewCIAFB/AJqIOwCOgAAIAEg6wIoAO+0hoAANgL4AiABIAEoAqgDKAIINgL0AgJAIAEoAvQCQSdGQQFxRQ0AIAFBADoA+wILIAEgASgC/AUgASgC/AUoAtABIAFB+AJqIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2AvACIAFB6AJqIe0CQgAh7gIg7QIg7gI3AwAgASDuAjcD4AIgAUEAOgDfAgJAA0AgASgC8AJBAEdBAXFFDQEgASgC8AItAAAh7wICQAJAAkACQAJAAkACQCDvAkUNACDvAkEKRg0CIO8CQQ1GDQEg7wJBI0YNBCDvAkHcAEYNAwwFCyABKALwAkEBaiHwAiABKAL8BSDwAjYC0AEgASABKAL8BSABKAL8BSgC0AEgAUH4AmogASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCxi4CAADYC8AIMBQsgASgC8AJBAWoh8QIgASgC/AUg8QI2AtABAkAgASgC/AUgASgC8AJBAWoQ1IaAgABB/wFxQQpHQQFxRQ0AIAEgASgC/AUgASgC/AUoAtABIAFB+AJqIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2AvACDAULIAEgASgC8AJBAWo2AvACIAEoAvwFIAFB4AJqEP2GgIAAIAEgASgC8AI2AuwCCwJAIAEoAvwFKALYAUEAR0EBcUUNACABKAL8BSgC2AEgASgC8AJLQQFxRQ0AIAEoAvwFENCGgIAAIAEoAvACQQFqIfICIAEoAvwFIPICNgLQASABKAL8BSABQeACahD8hoCAACABKAL8BUGWATYCyAEgASgC/AUQy4aAgAAMCAsgASgC/AVBzAJqIAEoAvACEKOLgIAAGiABIAEoAvACQQFqNgLYAgJAIAEtAN8CQQFxDQAgASgC2AIgASgCnANqIAEoAvwFKAK4AU1BAXFFDQAgASABKALYAiABKAL8BSgCuAEgASgC2AJrEKyGgIAANgLUAgJAAkAgASgC1AJBAEZBAXFFDQAgASABKAL8BSgCuAE2AtQCDAELAkAgASgC1AJBf2otAABB/wFxQQ1GQQFxRQ0AIAEgASgC1AJBf2o2AtQCCwsgASgC1AIh8wIgASgCnAMh9AIgASDzAkEAIPQCa2o2AtACIAEgASgC2AI2AswCAkACQCABKAKoAygCDEEBRkEBcQ0AIAEoAqgDKAIMQQJGQQFxRQ0BCwNAIAEoAswCIAEoAtACSSH1AkEAIfYCIPUCQQFxIfcCIPYCIfgCAkAg9wJFDQAgASgCzAItAABB/wFxEPKKgIAAIfgCCwJAIPgCQQFxRQ0AIAEgASgCzAJBAWo2AswCDAELCwsCQCABKALMAiABKALQAkZBAXFFDQAgASgC0AIgASgCoAMgASgCnAMQ1IuAgAANACABKALwAkEBaiH5AiABKAL8BSD5AjYC0AEgASgC/AUgAUHgAmoQ/IaAgAAgASgC/AVBlgE2AsgBIAEoAvwFEMuGgIAADAkLCyABKAL8BSH6AiABKAKsAygCECH7AiABIPoCIAFB2AJqIPsCEIiHgIAANgLIAgJAIAEoAqwDKAIQQQJGQQFxRQ0AAkAgASgCrAMoAhhBAEdBAXFFDQAgASgCrAMoAhgoAgAgASgCyAJLQQFxRQ0AIAEoAvwFIAEoAtgCENSGgIAAQf8BcUEKR0EBcUUNACABKALIAiH8AiABKAKsAygCGCD8AjYCAAsgASgC8AJBAWoh/QIgASgC/AUg/QI2AtABIAEoAvwFIAFB4AJqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwICyABKALwAkEBaiH+AiABKAL8BSD+AjYC0AEgASABKAL8BSABKAL8BSgC0AEgAUH4AmogASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCxi4CAADYC8AIMAwsgASgC8AJBAWoh/wIgASgC/AUg/wI2AtABAkAgASgC/AUoAtABIAEoAvwFKAK4AUZBAXFFDQAgAUEANgLwAgwECyABKAL8BSABQeACahD9hoCAACABIAEoAvwFEOiGgIAAOgDHAgJAAkAgASgC9AJBJ0ZBAXFFDQAgAS0AxwJBdmohgAMggANBA0saAkACQAJAAkAggAMOBAECAgACCyABKAL8BSGBAyCBAyCBAygC0AFBAWo2AtABAkAgASgC/AUQ6IaAgABB/wFxQQpHQQFxRQ0AIAFB4AJqQdwAQf8BcRD+hoCAACABQeACakENQf8BcRD+hoCAAAwDCwsgAUHgAmpB3ABB/wFxEP6GgIAAIAFB4AJqQQpB/wFxEP6GgIAAIAEgASgC/AUoAtABQQFqNgLsAiABIAEoAvwFKALQATYC8AIMBwsgAUHgAmpB3ABB/wFxEP6GgIAAIAEoAvwFIYIDIAFB4AJqIIIDEIGHgIAACwwBCyABLQDHAkF2aiGDAyCDA0EDSxoCQAJAAkACQCCDAw4EAQICAAILIAEoAvwFIYQDIIQDIIQDKALQAUEBajYC0AECQCABKAL8BRDohoCAAEH/AXFBCkdBAXFFDQAgAUHgAmpBDUH/AXEQ/oaAgAAMAwsLAkAgASgCqAMoAgxBAkZBAXFFDQAgASABKAL8BSgC0AE2AsACIAEoAvwFQcwCaiABKALAAhCji4CAABogASgC8AIhhQMgASgC/AUghQM2AtABIAEoAvwFIAFB4AJqEPyGgIAAIAEoAsACQQFqIYYDIAEoAvwFIIYDNgLQASABKAKsA0EBOgAcIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwKCyABQQE6AN8CIAEgASgC/AUoAtABQQFqNgLsAiABIAEoAvwFKALQATYC8AIMBgsgASgC/AUgAUHgAmpBAEEAQf8BcRCAh4CAAAsLIAEgASgC/AUoAtABNgLsAiABIAEoAvwFIAEoAvwFKALQASABQfgCaiABKAL8BSgCuAEgASgC/AUoAtABa0EBQQFxELGLgIAANgLwAgwCCyABIAEoAvwFIAEoAvACEIKHgIAANgK8AgJAIAEoArwCQQNGQQFxRQ0AIAEgASgC/AUgASgC/AUoAtABIAFB+AJqIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQsYuAgAA2AvACDAILAkAgASgCvAJBlgFGQQFxRQ0AIAEoAvwFIAFB4AJqEPyGgIAACyABKAK8AiGHAyABKAL8BSCHAzYCyAEgASgC/AUQy4aAgAAMBQtB4raGgABBs9CFgABB3OQAQfuHhIAAEI6AgIAAAAsgAUEAOgDfAgwACwsCQCABKAL8BSgC0AEgASgC/AUoAswBS0EBcUUNACABKAL8BSgCuAEhiAMgASgC/AUgiAM2AtABIAEoAvwFIAFB4AJqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwCCyABKAL8BSgCuAEhiQMgASgC/AUgiQM2AtABIAEoAvwFIAFB4AJqEPyGgIAAIAEoAvwFQZYBNgLIASABKAL8BRDLhoCAAAwBC0HitoaAAEGz0IWAAEHw5ABB+4eEgAAQjoCAgAAACyABQYAGaiSAgICAAA8LvwYBDX8jgICAgABBIGshAyADJICAgIAAIAMgADYCGCADIAE2AhQgAyACOwESAkADQCADKAIYQY4BQfkAEImHgIAAQQFxRQ0BDAALCwJAAkAgAygCFCADKAIYQcgBahCKh4CAAEEBcUUNACADQQA2AhwMAQsgAyADKAIYEMSGgIAANgIMIAMoAhggAygCFBCLh4CAABoCQANAIAMoAhghBCADLwESQf//A3FBAWohBUECIQZBASEHQQAhCEEmIQkgAyAEIAYgB0EBcSAIQQFxIAkgBUH//wNxEIyHgIAANgIIIAMoAhggAygCDCADKAIIQQFBAXEQjYeAgAACQCADKAIYLQCBA0EBcUUNAAJAIAMoAhQgAygCGEHIAWoQioeAgABBAXFFDQAgAygCGEEAOgCBAwsMAgsCQCADKAIYQfkAQY4BEImHgIAAQQFxRQ0AAkADQCADKAIYQfkAQY4BEImHgIAAQQFxRQ0BDAALCwJAIAMoAhQgAygCGEHIAWoQioeAgABBAXFFDQAMAwsMAQsCQCADKAIUIAMoAhhByAFqEIqHgIAAQQFxRQ0ADAILAkACQCADKAIILwEAQf//A3FB5wBGQQFxRQ0AIAMoAhgQvoaAgAACQCADKAIYQQEQjoeAgABBAXFFDQAgAygCGEEBOgCBAwwECwJAA0AgAygCGEH5AEGOARCJh4CAAEEBcUUNAQwACwsCQCADKAIUIAMoAhhByAFqEIqHgIAAQQFxRQ0ADAQLDAELAkAgAygCGEH5AEEBEImHgIAAQQFxDQAgAygCGEGIAmohCiADKAIYKALMASELIAMoAhgoAtABIQwgAyADKAIYKALIARDcioCAADYCACAKIAsgDEHXACADEM6EgIAAGiADKAIYKALEASENIAMoAhggDTYCwAEgAygCGEECNgK8AQsLDAALCyADKAIYEI+HgIAAIANBAToAByADKAIUQX5qIQ4gDkEPSxoCQAJAAkAgDg4QAAEBAQEBAQEBAQEBAQEBAAELIANBADoABwwBCwsgAygCGCADKAIMIAMtAAdBAXEQkIeAgAAgAyADKAIMNgIcCyADKAIcIQ8gA0EgaiSAgICAACAPDwvMCQEKfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKEEAIQMgAiADNgIkIAIgAzYCICACKAIoLwEAQXZqIQQgBEGGAUsaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBA6HAQALCwsLCwsLCwELCwsLCwsLCwsLAAsLCwsLCwILCwsLAwsLCwQLCwsLBQsLBgsLCwsLCwsACwsLCwsGCwsLCwsLCwsLCwALCwYLBgYLCwsLCwsLCwsLAAsLCwsLCwsLCwsLBwsLAAsLCwsLCwsLCwsIBgsGCwsLCwsLCwkLCwYGBgsLBgsGCgsLIAJB0raFgAA2AiQgAkEKNgIgDAsLIAIgAigCKDYCHAJAAkAgAigCHCgCFEEAR0EBcQ0AIAIoAhwoAiBBAEZBAXFFDQELDAsLIAIgAigCLEG8AmogAigCHCgCHBCHi4CAADYCGCACKAIYKAIEQX9qIQUgBUECSxoCQAJAAkACQCAFDgMAAQIDCyACKAIYKAIALQAAQVtqIQYgBkHXAEsaAkACQCAGDlgAAAEBAQAAAQABAAEBAQEBAQEBAQEBAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQsgAiACKAIYKAIANgIkIAJBATYCIAsMAgsgAigCGCgCAC0AAUFWaiEHIAdBFksaAkACQAJAAkAgBw4XAgMDAwMDAwMDAwMDAwMDAwMDAwADAwEDCwJAAkAgAigCGCgCAC0AAEH/AXFBPEZBAXENACACKAIYKAIALQAAQf8BcUE+RkEBcQ0AIAIoAhgoAgAtAABB/wFxQSFGQQFxDQAgAigCGCgCAC0AAEH/AXFBPUZBAXFFDQELIAIgAigCGCgCADYCJCACQQI2AiALDAILAkACQCACKAIYKAIALQAAQf8BcUErRkEBcQ0AIAIoAhgoAgAtAABB/wFxQS1GQQFxRQ0BCyACIAIoAhgoAgA2AiQgAkECNgIgCwwBCwJAIAIoAhgoAgAtAABB/wFxQSpGQQFxRQ0AIAIgAigCGCgCADYCJCACQQI2AiALCwwBCwJAIAIoAhgoAgBBnpSGgABBAxDUi4CAAA0AIAJBnpSGgAA2AiQgAkEDNgIgCwsMCgsgAkG1lYaAADYCJCACQQI2AiAMCQsgAkGzooSAADYCJCACQQo2AiAMCAsgAkH6joaAADYCJCACQQg2AiAMBwsgAkGpp4WAADYCJCACQQU2AiAMBgsgAkGa+oSAADYCJCACQQk2AiAMBQsgAkH+9YSAADYCJCACQQM2AiAMBAsgAiACKAIoNgIUAkACQCACKAIULwECQf//A3FBBHFFDQAgAkG7o4aAADYCJCACQQM2AiAMAQsgAkG8o4aAADYCJCACQQI2AiALDAMLIAJBxoyFgAA2AiQgAkEENgIgDAILIAJBk46FgAA2AiQgAkEENgIgDAELCwJAIAIoAiRBAEdBAXFFDQAgAigCLEH8AWohCCACKAIoKAIIIQkgAigCKCgCDCEKIAIoAiAhCyACIAIoAiQ2AgQgAiALNgIAIAggCSAKQb4CIAIQzoSAgAAaCyACQTBqJICAgIAADwvEBAEOfyOAgICAAEEwayEEIAQkgICAgAAgBCAANgIsIAQgATYCKCAEIAI2AiQgBCADOgAjIAQoAiQgBCgCKCgCABCAi4CAAAJAAkAgBCgCKCgCBEEJSUEBcUUNACAEKAIoKAIAIQUMAQsgBCgCKCgCBCEFCyAEIAU2AhwgBC0AIyEGQQEhByAGQQFxIQggByEJAkAgCEUNACAEKAIsLQD+AiEKQQAhCyAKQQFxIQwgCyENAkAgDA0AIAQoAiwtAPwCQf8BcUECcUEAR0F/cyENCyANIQkLIAQgCUEBcToAGyAEQQA2AhQCQANAIAQoAhQgBCgCHElBAXFFDQEgBCAEKAIoKAIIIAQoAhRBGGxqNgIQAkAgBCgCECgCAEUNACAEKAIkIAQoAhAoAgwgBCgCECgCABCCi4CAAAJAIAQtABtBAXFFDQAgBCgCECgCEA0AAkAgBCgCLCgC7AJBAE5BAXENACAEKAIsQcwCaiAEKAIQKAIEIAQoAiwoAuwCEKSLgIAAQQBOQQFxRQ0BCyAEIAQoAixBvAJqIAQoAhAoAgAQh4uAgAA2AgwCQCAEKAIMKAIEQQFPQQFxRQ0AIAQoAgwoAgAtAABB/wFxQd8AR0EBcUUNACAEKAIsQfwBaiEOIAQoAhAoAgQhDyAEKAIQKAIIIRAgBCgCDCgCBCERIAQgBCgCDCgCADYCBCAEIBE2AgAgDiAPIBBBvQIgBBDOhICAABoLCwsgBCAEKAIUQQFqNgIUDAALCyAEQTBqJICAgIAADwu+BgEJfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCPCACIAE2AjgCQCACKAI8LQD8AkH/AXFBEHFFDQACQCACKAI4QQBGQQFxRQ0AIAIgAigCPBDEhoCAADYCOAsgAiACKAI8EJGHgIAANgI0IAIoAjQgAigCPCACKAI8QeDlhYAAQQIQkoeAgAAQk4eAgAAQlIeAgAAgAigCPCACKAI4IAIoAjwgAigCNCACKAI8QfWPhIAAQQUQkoeAgAAQlYeAgABBAUEBcRCNh4CAAAsCQCACKAI8LQD8AkH/AXFBCHFFDQACQCACKAI8LQD8AkH/AXFBAXFFDQACQCACKAI4QQBGQQFxRQ0AIAIgAigCPBDEhoCAADYCOAsgAiACKAI8EJGHgIAANgIwIAIoAjAgAigCPCACKAI8QbKVhoAAQQIQkoeAgAAQk4eAgAAQlIeAgAAgAiACKAI8IAIoAjxB4OWFgABBAhCSh4CAABCTh4CAADYCLCACKAI8IQMgAigCLCEEIAIoAjAhBSACIAMgBEHUo4SAACAFEJaHgIAANgIoIAIgAigCPCACKAI8Qdn9hYAAQQIQkoeAgAAgAigCKBCXh4CAADYCJCACKAI4IAIoAiQQmIeAgAALIAIgAigCPBCRh4CAADYCICACKAIgIAIoAjwgAigCPEHMoIaAAEECEJKHgIAAEJOHgIAAEJSHgIAAAkAgAigCPC0A/AJB/wFxQQRxRQ0AIAIgAigCPBCZh4CAADYCHCACKAIcIQYgAigCPCEHIAIoAjxB89qEgAAQmoeAgAAhCCACQQM2AhAgAiACKAI8KAK0ATYCFCACIAIoAjwoArQBNgIYIAIoAjwQm4eAgAAhCSAGIAcgCCACQRBqIAkQnIeAgAAQnYeAgAAgAigCICACKAIcEJSHgIAAIAIoAiBBCEH//wNxEJ6HgIAACyACIAIoAjwQxIaAgAA2AgwgAigCPCACKAIMIAIoAjwgAigCPCACKAIgIAIoAjxBlLCEgABBBBCSh4CAABCVh4CAACACKAI4EJ+HgIAAQQFBAXEQjYeAgAAgAiACKAIMNgI4CyACKAI4IQogAkHAAGokgICAgAAgCg8L6wIBC38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAkEANgIQA0AgAigCECACKAIcKAL0AigCAEkhA0EAIQQgA0EBcSEFIAQhBgJAIAVFDQAgAigCHCgC9AIoAgggAigCEEECdGooAgAhByACIAc2AhQgB0EARyEGCwJAIAZBAXFFDQAgAigCFC8BACEIAkACQAJAAkACQCAIQRFGDQAgCEHrAEYNASAIQfwARg0CDAMLIAJB4IGFgAA2AgwMAwsgAkGMi4SAADYCDAwCCyACQfnbhIAANgIMDAELQeK2hoAAQbPQhYAAQab7AEHdrYSAABCOgICAAAALIAIoAhxBiAJqIQkgAigCFCgCCCEKIAIoAhQoAgwhCyACIAIoAgw2AgAgCSAKIAtBjAEgAhDOhICAABogAiACKAIQQQFqNgIQDAELCyACKAIYIQwgAigCHCAMNgL0AiACQSBqJICAgIAADwv6AQEIfyOAgICAAEEwayEBIAEkgICAgAAgASAANgIsIAEgASgCLEEcEKCHgIAANgIoIAEoAighAiABQYwBOwEMIAFBADsBDiABKAIsIQMgAygCAEEBaiEEIAMgBDYCACABIAQ2AhAgASABKAIsKAK0ATYCFCABIAEoAiwoArQBNgIYIAFBADYCHCABQQA2AiAgAUEANgIkIAIgASkCDDcCAEEYIQUgAiAFaiAFIAFBDGpqKAIANgIAQRAhBiACIAZqIAYgAUEMamopAgA3AgBBCCEHIAIgB2ogByABQQxqaikCADcCACABKAIoIQggAUEwaiSAgICAACAIDwtNAQJ/I4CAgIAAQSBrIQMgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHEEIaiEEIAMgAygCGDYCDCADIAMoAhQ2AhAgBCADKQIMNwIADwv6AgEQfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQgAyADKAIsQSAQoIeAgAA2AiAgAygCICEEIAMhBSADQfkAOwEAIANBADsBAiADKAIsIQYgBigCAEEBaiEHIAYgBzYCACADIAc2AgQgBUEIaiEIAkACQCADKAIkQQBGQQFxRQ0AIAMoAiwoArQBIQkMAQsgAygCJCgCCCEJCyAIIAk2AgAgCEEEaiEKAkACQCADKAIkQQBGQQFxRQ0AIAMoAiwoArgBIQsMAQsgAygCJCgCDCELCyAKIAs2AgAgA0EQaiEMIAMoAighDSAMIA0pAgA3AgBBCCEOIAwgDmogDSAOaigCADYCACADIAMoAiQ2AhwgBCADKQIANwIAQRghDyAEIA9qIAMgD2opAgA3AgBBECEQIAQgEGogAyAQaikCADcCAEEIIREgBCARaiADIBFqKQIANwIAIAMoAiAhEiADQTBqJICAgIAAIBIPC/gFAQx/I4CAgIAAQeAAayEFIAUkgICAgAAgBSAANgJYIAUgATYCVCAFIAI2AlAgBSADNgJMIAUgBDYCSAJAIAUoAlgoAgAgBSgCWCgCBEECdkEDbE9BAXFFDQAgBSgCWBDIhoCAAAsCQAJAAkAgBSgCWCgCBEEJSUEBcUUNACAFQQA2AkQCQANAIAUoAkQgBSgCWCgCBElBAXFFDQEgBSAFKAJYKAIIIAUoAkRBGGxqNgJAAkAgBSgCQCgCAA0AIAUoAkAhBiAFIAUoAlQ2AiggBSAFKAJQNgIsIAUgBSgCTDYCMCAFKAJYIQcgBygCACEIIAcgCEEBajYCACAFIAg2AjQgBSAFKAJINgI4IAVBADYCPCAGIAUpAig3AgBBECEJIAYgCWogCSAFQShqaikCADcCAEEIIQogBiAKaiAKIAVBKGpqKQIANwIAIAVBAUEBcToAXwwFCwJAIAUoAkAoAgAgBSgCVEZBAXFFDQAgBUEAQQFxOgBfDAULIAUgBSgCREEBajYCRAwACwsMAQsgBSAFKAJYKAIEQQFrNgIkIAUgBSgCVBDJhoCAADYCICAFIAUoAiA2AhwDQCAFIAUoAlgoAgggBSgCICAFKAIkcUEYbGo2AhgCQCAFKAIYKAIADQAgBSgCGCELIAUgBSgCVDYCACAFIAUoAlA2AgQgBSAFKAJMNgIIIAUoAlghDCAMKAIAIQ0gDCANQQFqNgIAIAUgDTYCDCAFIAUoAkg2AhAgBSAFKAIcNgIUIAsgBSkCADcCAEEQIQ4gCyAOaiAFIA5qKQIANwIAQQghDyALIA9qIAUgD2opAgA3AgAgBUEBQQFxOgBfDAMLAkAgBSgCGCgCACAFKAJURkEBcUUNACAFQQBBAXE6AF8MAwsgBSAFKAIgQQFqNgIgIAUoAiAgBSgCJHEgBSgCHEdBAXENAAsLQeK2hoAAQbPQhYAAQdwGQZmRhYAAEI6AgIAAAAsgBS0AX0EBcSEQIAVB4ABqJICAgIAAIBAPC94EAQx/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwCQAJAIAEoAhwoAgQNAEEEIQIMAQsgASgCHCgCBEEBdCECCyABIAI2AhgCQCABKAIYIAEoAhwoAgRLQQFxDQBBzoCEgABBs9CFgABB/AVB5IyFgAAQjoCAgAAACyABIAEoAhhBGBChjICAADYCFAJAIAEoAhRBAEZBAXFFDQAQvouAgAAACwJAAkAgASgCGEEJSUEBcUUNAAJAIAEoAhwoAgBBAEtBAXFFDQAgASgCFCEDIAEoAhwoAgghBCABKAIcKAIAQRhsIQUCQCAFRQ0AIAMgBCAF/AoAAAsLDAELIAEgASgCHCgCBEEJTUEBcToAEyABIAEoAhhBAWs2AgwgAUEANgIIAkADQCABKAIIIAEoAhwoAgRJQQFxRQ0BIAEgASgCHCgCCCABKAIIQRhsajYCBAJAIAEoAgQoAgBFDQACQCABLQATQQFxRQ0AIAEoAgQoAgAQyYaAgAAhBiABKAIEIAY2AhQLIAEgASgCBCgCFDYCAAJAA0AgASgCFCABKAIAIAEoAgxxQRhsaigCAEUNASABIAEoAgBBAWo2AgAMAAsLIAEoAhQgASgCACABKAIMcUEYbGohByABKAIEIQggByAIKQIANwIAQRAhCSAHIAlqIAggCWopAgA3AgBBCCEKIAcgCmogCCAKaikCADcCAAsgASABKAIIQQFqNgIIDAALCwsgASgCHBC6hoCAACABKAIUIQsgASgCHCALNgIIIAEoAhghDCABKAIcIAw2AgQgAUEgaiSAgICAAA8LYQEBfyOAgICAAEEQayEBIAEgADYCDCABIAEoAgxBEHYgASgCDHNBu772Imw2AgwgASABKAIMQRB2IAEoAgxzQbu+9iJsNgIMIAEgASgCDEEQdiABKAIMczYCDCABKAIMDwtPAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCDCgC0AEgAigCCGoQz4aAgAAhAyACQRBqJICAgIAAIAMPC3QBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAqwCQQBHQQFxRQ0AIAEoAgwoAqwCKAIEIQIgASgCDCgCrAIoAgAgASgCDCABKAIMQcgBaiACEYOAgIAAgICAgAALIAFBEGokgICAgAAPC8IBAQR/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhggAiABNgIUIAJBAUEQEKGMgIAANgIQAkACQCACKAIQQQBGQQFxRQ0AIAJBADYCHAwBCyACKAIQIQMgAkEANgIAIAIgAigCGCgCzAE2AgQgAiACKAIYKALQATYCCCACIAIoAhQ2AgwgAyACKQIANwIAQQghBCADIARqIAIgBGopAgA3AgAgAiACKAIQNgIcCyACKAIcIQUgAkEgaiSAgICAACAFDwveGgFofyOAgICAAEGQAWshAiACJICAgIAAIAIgADYCiAEgAiABOgCHASACQQE6AIYBIAIgAigCiAEoAswBQQFqNgKAASACIAIoAogBKALQATYCfAJAAkAgAigCfCACKAKAAWtBB0xBAXFFDQAgAkEAQQFxOgCPAQwBCyACQQA6AHcgAigCiAEgAigCgAEgAigCfBChh4CAACEDIAIgAzYCeAJAIANBAEdBAXFFDQAgAiACKAJ4QQNqNgKAASACKAKIASACKAKAASACKAJ8EKGHgIAAIQQgAiAENgJ4AkACQCAEQQBHQQFxRQ0AIAIgAigCeDYCfCACQQE6AHcMAQsgAkEAQQFxOgCPAQwCCwsgAiACKAKAATYCeAJAA0AgAigCeCACKAJ8SUEBcUUNAQNAIAIoAnggAigCfEkhBUEAIQYgBUEBcSEHIAYhCAJAIAdFDQAgAigCeC0AAEH/AXEQooeAgAAhCUEBIQogCUEBcSELIAohDAJAIAsNACACKAJ4LQAAQf8BcRDwioCAACEMCyAMIQgLAkAgCEEBcUUNACACIAIoAnhBAWo2AngMAQsLIAIgAigCeDYCcANAIAIoAnggAigCfEkhDUEAIQ4gDUEBcSEPIA4hEAJAIA9FDQAgAigCeC0AAEH/AXEQooeAgAAhEUEAIRIgEUEBcSETIBIhFAJAIBMNACACKAJ4LQAAQf8BcRDwioCAAEF/cyEUCyAUIRALAkAgEEEBcUUNACACIAIoAnhBAWo2AngMAQsLIAIgAigCeDYCbANAIAIoAnggAigCfEkhFUEAIRYgFUEBcSEXIBYhGAJAIBdFDQAgAigCeC0AAEH/AXEQ8IqAgAAhGAsCQCAYQQFxRQ0AIAIgAigCeEEBajYCeAwBCwsCQCACKAJ4IAIoAnxGQQFxRQ0ADAILAkACQCACKAJ4LQAAQf8BcUE6RkEBcUUNACACIAIoAnhBAWo2AngMAQsCQCACLQB3QQFxDQAgAkEAQQFxOgCPAQwECwwBCwNAIAIoAnggAigCfEkhGUEAIRogGUEBcSEbIBohHAJAIBtFDQAgAigCeC0AAEH/AXEQ8IqAgAAhHAsCQCAcQQFxRQ0AIAIgAigCeEEBajYCeAwBCwsCQCACKAJ4IAIoAnxGQQFxRQ0ADAILAkACQCACKAJ4LQAAQf8BcUEiRkEBcUUNACACKAJ4QQFqIR0gAiAdNgJ4IAIgHTYCaANAIAIoAnggAigCfEkhHkEAIR8gHkEBcSEgIB8hIQJAICBFDQAgAigCeC0AAEH/AXFBIkchIQsCQCAhQQFxRQ0AAkAgAigCeC0AAEH/AXFB3ABGQQFxRQ0AIAIoAnhBAWogAigCfElBAXFFDQAgAiACKAJ4QQFqNgJ4CyACIAIoAnhBAWo2AngMAQsLIAIgAigCeDYCZAJAIAIoAngtAABB/wFxQSJGQQFxRQ0AIAIgAigCeEEBajYCeAsMAQsgAiACKAJ4NgJoA0AgAigCeCACKAJ8SSEiQQAhIyAiQQFxISQgIyElAkAgJEUNACACKAJ4LQAAQf8BcUEiRyEmQQAhJyAmQQFxISggJyElIChFDQAgAigCeC0AAEH/AXFBO0chKUEAISogKUEBcSErICohJSArRQ0AIAIoAngtAABB/wFxEPCKgIAAQX9zISULAkAgJUEBcUUNACACIAIoAnhBAWo2AngMAQsLIAIgAigCeDYCZAsCQAJAIAItAHdBAXFFDQADQCACKAJ4IAIoAnxJISxBACEtICxBAXEhLiAtIS8CQCAuRQ0AIAIoAngtAABB/wFxQTtGITBBASExIDBBAXEhMiAxITMCQCAyDQAgAigCeC0AAEH/AXEQ8IqAgAAhMwsgMyEvCwJAIC9BAXFFDQAgAiACKAJ4QQFqNgJ4DAELCwwBCwNAIAIoAnggAigCfEkhNEEAITUgNEEBcSE2IDUhNwJAIDZFDQAgAigCeC0AAEH/AXEQ8IqAgAAhNwsCQCA3QQFxRQ0AIAIgAigCeEEBajYCeAwBCwsCQCACKAJ4IAIoAnxHQQFxRQ0AIAJBAEEBcToAjwEMBAsLIAIgAigCbCACKAJwazYCVCACKAJwITggAigCVCE5IAIoAogBLQCDAyE6IAIoAogBKAKgAiE7IAIgOEEtIDkgOkEBcSA7EKCLgIAANgJQAkACQCACKAJQQQBGQQFxRQ0AIAIoAnAhPCACKAJsIT0gAkHYAGogPCA9EKeLgIAADAELIAIgAigCVBCYjICAADYCTAJAIAIoAkxBAEZBAXFFDQAMAwsgAigCTCE+IAIoAnAhPyACKAJUIUACQCBARQ0AID4gPyBA/AoAAAsgAigCTCACKAJQIAIoAnBrakHfADoAAAJAA0AgAigCUEEBaiFBIAIoAmwgAigCUGtBAWshQiACKAKIAS0AgwMhQyACKAKIASgCoAIhRCBBQS0gQiBDQQFxIEQQoIuAgAAhRSACIEU2AlAgRUEAR0EBcUUNASACKAJMIAIoAlAgAigCcGtqQd8AOgAADAALCyACKAJMIUYgAigCVCFHIAJB2ABqIEYgRxCoi4CAAAsgAiACQdgAahCsi4CAADYCSCACIAIoAmQgAigCaGs2AkQCQCACKAKIASgCzAEgAigCiAEoAqgCRkEBcUUNACACKAKIAS0AggNBAXENAAJAAkACQCACKAJUQQhGQQFxRQ0AIAIoAkhB0oqFgABBCBCvi4CAAEUNAQsgAigCVEEGRkEBcUUNASACKAJIQdSKhYAAQQYQr4uAgAANAQsgAiACKAKIASACKAJoIAIoAmQQqIaAgABBAXE6AIYBCwsCQAJAIAIoAlRBC0ZBAXFFDQACQCACKAJIQYihhIAAQQsQr4uAgAANACACKAJoIAIoAkQQo4eAgAAhSCBIQQJLGgJAAkACQAJAIEgOAwIBAAMLIAIoAogBQfwBaiFJIAIoAogBKALMASFKIAIoAogBKALQASFLIAIoAlQhTCACKAJIIU0gAigCRCFOIAIgAigCaDYCDCACIE42AgggAiBNNgIEIAIgTDYCACBJIEogS0G0AiACEM6EgIAAGgwCCyACKAKIAUEAOgCIAwwBCyACKAKIAUEBOgCIAwsLDAELAkACQCACKAJUQRVGQQFxRQ0AAkAgAigCSEHg94SAAEEVEK+LgIAADQACQAJAIAItAIcBQQFxRQ0AIAIoAogBIAIoAogBQcgBakGwAhDdhoCAAAwBCyACKAJoIAIoAkQQo4eAgAAhTyBPQQJLGgJAAkACQAJAIE8OAwIBAAMLIAIoAogBQfwBaiFQIAIoAogBKALMASFRIAIoAogBKALQASFSIAIoAlQhUyACKAJIIVQgAigCRCFVIAIgAigCaDYCHCACIFU2AhggAiBUNgIUIAIgUzYCECBQIFEgUkG0AiACQRBqEM6EgIAAGgwCCyACKAKIAUH/AToA/QIMAQsgAigCiAFBAToA/QILCwsMAQsCQCACKAJUQRhGQQFxRQ0AAkAgAigCSEG0joWAAEEYEK+LgIAADQAgAiACKAKIASgCzAE2AkADQCACKAJAIAIoAogBKAK0AUshVkEAIVcgVkEBcSFYIFchWQJAIFhFDQAgAigCQEF/ai0AAEH/AXFBIEYhWkEBIVsgWkEBcSFcIFshXQJAIFwNACACKAJAQX9qLQAAQf8BcUEJRiFdCyBdIVkLAkAgWUEBcUUNACACIAIoAkBBf2o2AkAMAQsLAkACQCACKAJAIAIoAogBKAK0AUZBAXENACACKAJAQX9qLQAAQf8BcUEKRkEBcQ0AIAIoAogBIAIoAogBQcgBakG5AhDdhoCAAAwBCwJAAkAgAigCREEERkEBcUUNACACKAJoQbOqhYAAQQQQr4uAgAANACACKAKIAUEAQf8BcRCkh4CAAAwBCwJAAkAgAigCREEHRkEBcUUNACACKAJoQZz6hIAAQQcQr4uAgAANACACKAKIAUEEQf8BcRCkh4CAAAwBCwJAAkAgAigCREEXRkEBcUUNACACKAJoQaOJhYAAQRcQr4uAgAANACACKAKIAUEIQf8BcRCkh4CAAAwBCwJAAkAgAigCREERRkEBcUUNACACKAJoQaOChIAAQREQr4uAgAANACACKAKIAUEQQf8BcRCkh4CAAAwBCyACKAKIAUH8AWohXiACKAKIASgCzAEhXyACKAKIASgC0AEhYCACKAJUIWEgAigCSCFiIAIoAkQhYyACIAIoAmg2AiwgAiBjNgIoIAIgYjYCJCACIGE2AiAgXiBfIGBBtAIgAkEgahDOhICAABoLCwsLCwsLCwsgAkHYAGoQrouAgABBAUEUEKGMgIAAIWQgAiBkNgI8AkAgZEEAR0EBcUUNACACKAJwIWUgAigCPCBlNgIEIAIoAmghZiACKAI8IGY2AgggAigCVCFnIAIoAjwgZzYCDCACKAJEIWggAigCPCBoNgIQIAIoAogBQegBaiACKAI8EJ+LgIAACwwACwsgAiACLQCGAUEBcToAjwELIAItAI8BQQFxIWkgAkGQAWokgICAgAAgaQ8L+QUBB38jgICAgABBIGshASABJICAgIAAIAEgADYCHCABIAEoAhwoAswBQQFqNgIYIAEgASgCHCgC0AE2AhQgAUEAOgATAkADQAJAIAEoAhQgASgCGGtBBkxBAXFFDQAMAgsgASgCGC0ABkFGaiECIAJBNUsaAkACQAJAAkACQAJAAkACQAJAIAIONgYHBwYHBwcHBwACBwcFBwMHBwcHBAEHBwcHBwcHBwcHBwcHBwcHBwcHAAIHBwUHAwcHBwcEAQcLIAEgASgCGEEGajYCGAwICyABIAEoAhhBBWo2AhgMBwsgASABKAIYQQRqNgIYDAYLIAEgASgCGEEDajYCGAwFCyABIAEoAhhBAmo2AhgMBAsgASABKAIYQQFqNgIYDAMLIAFBAToAEyABIAEoAhhBBmo2AhgMAQsgASABKAIYQQZqNgIYAkAgASgCGC0AAEH/AXEQ8IqAgABBAXFFDQAMAQsMAQsCQAJAIAEoAhhBempB1IqFgABBBhCvi4CAAA0ADAELIAFBADoAEwwBCwsDQANAIAEoAhhBAWohAyABIAM2AhgCQCADIAEoAhRPQQFxRQ0ADAMLIAEoAhgtAABB/wFxEPCKgIAAQQFxDQALAkACQCABLQATQQFxRQ0ADAELAkAgASgCGC0AAEH/AXFBPUdBAXFFDQAgASgCGC0AAEH/AXFBOkdBAXFFDQAMAwsgAUEBOgATIAEgASgCGEEBajYCGAwBCwsgASABKAIYNgIMA0ACQAJAIAEoAhgtAABB/wFxQS1GQQFxDQAgASgCGC0AAEH/AXFB3wBGQQFxDQAgASgCHCgCoAIoAgghBCABKAIYQQEgBBGAgICAAICAgIAAIQVBACEGIAVFDQELIAEoAhhBAWohByABIAc2AhggByABKAIUSSEGCwJAIAZBAXFFDQAMAQsLIAEoAhwgASgCDCABKAIYEKiGgIAAQQFxDQAgASgCHCABKAIMIAEoAhhBjwEQsIaAgAALIAFBIGokgICAgAAPC7YBAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEAkACQCACKAIIIAIoAgQQ1IaAgABB/wFxQQpGQQFxRQ0AIAJBATYCDAwBCwJAIAIoAgggAigCBBDUhoCAAEH/AXFBDUZBAXFFDQAgAigCCCACKAIEQQFqENSGgIAAQf8BcUEKRkEBcUUNACACQQI2AgwMAQsgAkEANgIMCyACKAIMIQMgAkEQaiSAgICAACADDwuDAQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgC2AEgASgCDCgCuAFNQQFxDQBBp8CFgABBs9CFgABB1tAAQY7AhYAAEI6AgIAAAAsgASgCDCgC2AEhAiABKAIMIAI2AtQBIAEoAgxBADYC2AEgAUEQaiSAgICAAA8LugEBBn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIQYEHENuGgIAAIQJBACEDIAJBAXEhBCADIQUCQCAERQ0AIAEoAghBgBAQ24aAgABBf3MhBQsgASAFQQFxOgAHAkACQCABLQAHQQFxRQ0AIAFBATYCDAwBCwJAIAEoAggoAgRB/3dxQZAQRkEBcUUNACABQQI2AgwMAQsgAUEANgIMCyABKAIMIQYgAUEQaiSAgICAACAGDwtAAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEE4NgLIASABKAIMEMuGgIAAIAFBEGokgICAgAAPCy8BAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgghAyACKAIMIAM2AgQPC1gBAX8jgICAgABBEGshAiACIAA2AgggAiABNgIEAkACQCACKAIEIAIoAggoArgBSUEBcUUNACACIAIoAgQtAAA6AA8MAQsgAkEAOgAPCyACLQAPQf8BcQ8LPgECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBMBDbhoCAAEEBcSECIAFBEGokgICAgAAgAg8LRwEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgAToACyACKAIMQRRqIAItAAtBAXEQs4aAgAAgAkEQaiSAgICAAA8LOAEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBFGoQpYeAgAAgAUEQaiSAgICAAA8LPwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBgAMQ24aAgABBAXEhAiABQRBqJICAgIAAIAIPC44BAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABOgAHAkACQCACKAIIEOiGgIAAQf8BcSACLQAHQf8BcUZBAXFFDQAgAigCCCEDIAMgAygC0AFBAWo2AtABIAJBAUEBcToADwwBCyACQQBBAXE6AA8LIAItAA9BAXEhBCACQRBqJICAgIAAIAQPC2sBBn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMQcEEENuGgIAAIQJBASEDIAJBAXEhBCADIQUCQCAEDQAgASgCDCgCBEGQEHFBkBBGIQULIAVBAXEhBiABQRBqJICAgIAAIAYPCzIBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwoAgQgAigCCHFBAEdBAXEPC8wBAQl/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABOgAHAkACQCACKAIIKALQASACKAIIKAK4AU9BAXFFDQAgAkEAQQFxOgAPDAELIAIoAggQ1YaAgAAhA0EAIQQgA0EBcSEFIAQhBgJAIAVFDQAgAi0AByEHQQAhCCAHQQFxIQkgCCEGIAlFDQAgAigCCCgC0AEtAABB/wFxEPCKgIAAQX9zIQYLIAIgBkEBcToADwsgAi0AD0EBcSEKIAJBEGokgICAgAAgCg8LWAEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCADKAIIKAIEIAMoAggoAgggAygCBBC0hoCAACADQRBqJICAgIAADwuVAQEJfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgAToACyACKAIMQYgHENuGgIAAIQNBACEEIANBAXEhBSAEIQYCQCAFDQAgAi0ACyEHQQAhCCAHQQFxIQkgCCEGIAlFDQAgAigCDBDohoCAAEH/AXEQ8IqAgABBf3MhBgsgBkEBcSEKIAJBEGokgICAgAAgCg8LXwEFfyOAgICAAEEQayEBIAEgADYCDCABKAIMKALMASABKAIMKAK0AUYhAkEBIQMgAkEBcSEEIAMhBQJAIAQNACABKAIMKALMAUF/ai0AAEH/AXFBCkYhBQsgBUEBcQ8LUwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAgwoAtABIAIoAghqENSGgIAAQf8BcSEDIAJBEGokgICAgAAgAw8L2gYBC38jgICAgABBIGshASABJICAgIAAIAEgADYCGCABIAEoAhgoAtABIAEoAhgoArgBIAEoAhgoAtABaxCshoCAADYCFAJAAkAgASgCFEEARkEBcUUNACABKAIYKAK4ASECIAEoAhggAjYC0AEMAQsgASgCGEHMAmogASgCFBCji4CAABogASgCFEEBaiEDIAEoAhggAzYC0AELIAEoAhhBITYCyAEgASgCGBDLhoCAACABIAEoAhhBARDMhoCAADYCEAJAAkAgASgCEEEARkEBcUUNACABQQE2AhwMAQsCQANAIAEoAhgoAtABQQRqIAEoAhgoArgBTUEBcUUNASABKAIYKALQASEEIAEoAhggBDYCzAECQCABKAIYKALQASgAAEG9yrmjBkcNAAJAIAEoAhgoAtABQQRqIAEoAhgoArgBRkEBcQ0AIAEoAhgoAtABLQAEQf8BcRDwioCAAEEBcQ0AIAEoAhgoAtABLQAEQf8BcUUNACABKAIYKALQAS0ABEH/AXFBBEZBAXENACABKAIYKALQAS0ABEH/AXFBGkZBAXFFDQELIAEgASgCGCgC0AEgASgCGCgCuAEgASgCGCgC0AFrEKyGgIAANgIMAkACQCABKAIMQQBGQQFxRQ0AIAEoAhgoArgBIQUgASgCGCAFNgLQAQwBCyABKAIYQcwCaiABKAIMEKOLgIAAGiABKAIMQQFqIQYgASgCGCAGNgLQAQsgASgCGEEiNgLIASABKAIYEMuGgIAAIAEoAhgoAtABIQcgASgCECAHNgIIIAEoAhhB3AFqIAEoAhAQn4uAgAAgAUEiNgIcDAMLIAEgASgCGCgC0AEgASgCGCgCuAEgASgCGCgC0AFrEKyGgIAANgIIAkACQCABKAIIQQBGQQFxRQ0AIAEoAhgoArgBIQggASgCGCAINgLQAQwBCyABKAIYQcwCaiABKAIIEKOLgIAAGiABKAIIQQFqIQkgASgCGCAJNgLQAQsgASgCGEEjNgLIASABKAIYEMuGgIAADAALCyABKAIYQcUAEO2GgIAAIAEoAhgoAtABIQogASgCECAKNgIIIAEoAhhB3AFqIAEoAhAQn4uAgAAgAUEBNgIcCyABKAIcIQsgAUEgaiSAgICAACALDws+AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEEOENuGgIAAQQFxIQIgAUEQaiSAgICAACACDwu3AgEFfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIYIAMgATYCFCADIAI2AhACQAJAIAMoAhBBAExBAXFFDQAgA0EANgIcDAELAkAgAygCGC0AgwNBAXFFDQAgAygCGCgCoAIoAgghBCADKAIUIAMoAhAgBBGAgICAAICAgIAAIQUgAyAFNgIMAkAgBUUNACADIAMoAgw2AhwMAgsCQCADKAIULQAAQf8BcUHfAEZBAXFFDQAgA0EBNgIcDAILAkAgAygCFC0AAEH/AXFBgAFOQQFxRQ0AIAMoAhgoAqACKAIAIQYgAyADKAIUIAMoAhAgBhGAgICAAICAgIAANgIcDAILIANBADYCHAwBCyADIAMoAhQgAygCEBCmh4CAADYCHAsgAygCHCEHIANBIGokgICAgAAgBw8LsAMBD38jgICAgABBEGshAiACJICAgIAAIAIgADYCCCABIAIoAggoAhw2AiAgAigCCCEDIAMgAygCsAFBAWo2ArABAkACQAJAIAIoAggoArABQQNLQQFxRQ0AQSQQmIyAgAAhBCACKAIIIAQ2AhwCQCACKAIIKAIcQQBGQQFxRQ0AIAJBAEEBcToADwwDCyACKAIIKAIcIQUgBSABKQIANwIAQSAhBiAFIAZqIAEgBmooAgA2AgBBGCEHIAUgB2ogASAHaikCADcCAEEQIQggBSAIaiABIAhqKQIANwIAQQghCSAFIAlqIAEgCWopAgA3AgAMAQsgAigCCEEcakEEaiACKAIIKAKwAUEkbGohCiAKIAEpAgA3AgBBICELIAogC2ogASALaigCADYCAEEYIQwgCiAMaiABIAxqKQIANwIAQRAhDSAKIA1qIAEgDWopAgA3AgBBCCEOIAogDmogASAOaikCADcCACACKAIIQRxqQQRqIAIoAggoArABQSRsaiEPIAIoAgggDzYCHAsgAkEBQQFxOgAPCyACLQAPQQFxIRAgAkEQaiSAgICAACAQDwuBAQEFfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHEGIAmohBCADKAIYIQUgAygCGCADKAIUaiEGIAMoAhQhByADIAMoAhg2AgQgAyAHNgIAIAQgBSAGQYUBIAMQzoSAgAAaIANBIGokgICAgAAPC6kEAwJ/AX4RfyOAgICAAEHgAGshBSAFJICAgIAAIAUgADYCXCAFIAE6AFsgBSACOgBaIAUgAzoAWSAFIAQ6AFggBUHQAGpBADYCACAFQcgAaiEGQgAhByAGIAc3AwAgBUHAAGogBzcDACAFQThqIAc3AwAgBSAHNwMwIAVBBjYCMCAFIAUtAFtBAXE6ADggBSAFLQBaQQFxOgA5IAUgBS0AWToAOiAFIAUtAFg6ADsgBSAFQTBqQQRqQQhqNgIsIAUoAiwhCCAIQQNqIQlBACEKIAkgCigAz+KIgAA2AAAgCCAKKADM4oiAADYAACAFQQM2AigCQCAFLQBYQf8BcUUNACAFLQBYIQsgBSgCLCEMIAUoAighDSAFIA1BAWo2AiggDCANaiALOgAACwJAIAUtAFtBAXFFDQAgBSgCLCEOIAUoAighDyAFIA9BAWo2AiggDiAPakEjOgAACwJAIAUtAFlB/wFxRQ0AIAUtAFkhECAFKAIsIREgBSgCKCESIAUgEkEBajYCKCARIBJqIBA6AAALIAUoAlxBADYC8AIgBSgCXCETQSAhFCAFIBRqIBQgBUEwamooAgA2AgBBGCEVIAUgFWogFSAFQTBqaikDADcDAEEQIRYgBSAWaiAWIAVBMGpqKQMANwMAQQghFyAFIBdqIBcgBUEwamopAwA3AwAgBSAFKQMwNwMAIBMgBRDkhoCAAEEBcSEYIAVB4ABqJICAgIAAIBgPC7QFAQZ/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhgCQAJAIAEoAhgQ4oaAgABBAXFFDQAgASgCGEEBENOGgIAAIAFBiwE2AhwMAQsCQCABKAIYKALQASABKAIYKAK4AU9BAXFFDQAgASgCGEGGARDthoCAACABKAIYQeACaiABKAIYKALMAUEBaiABKAIYKALQARCni4CAACABQRc2AhwMAQsCQCABKAIYKALQAS0AAEH/AXEQ8IqAgABBAXFFDQAgASgCGEEBENOGgIAAIAFBiwE2AhwMAQsgASgCGEEBENOGgIAAAkAgASgCGEHcAEH/AXEQ2YaAgABBAXFFDQAgASgCGEECENOGgIAAIAFBDGpBAxDdioCAABogASgCGCABQQxqQQBBBEH/AXEQgIeAgAAgASgCGEHgAmogASgCFCABKAIMEKiLgIAAIAFBFzYCHAwBCyABKAIYKAKgAigCACECIAEgASgCGCgC0AEgASgCGCgCuAEgASgCGCgC0AFrIAIRgICAgACAgICAADYCCCABKAIYKAKgAigCCCEDAkACQAJAIAEoAhgoAtABIAEoAhgoArgBIAEoAhgoAtABayADEYCAgIAAgICAgAANACABKAIYEOiGgIAAQf8BcUHfAEZBAXFFDQELIAEoAhgoAtABIAEoAghqIAEoAhgoArgBT0EBcQ0AIAEoAhggASgCGCgC0AEgASgCCGogASgCGCgCuAEgASgCGCgC0AEgASgCCGprEOOGgIAADQELIAEoAhhBAhDThoCAACABKAIIIQQgASgCGCEFIAUgBCAFKALQAWo2AtABIAEoAhhB4AJqIAEoAhgoAswBQQFqIAEoAhgoAtABEKeLgIAAIAFBFzYCHAwBCyABQYsBNgIcCyABKAIcIQYgAUEgaiSAgICAACAGDwtGAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCABKAIMKALQARDUhoCAAEH/AXEhAiABQRBqJICAgIAAIAIPC8MEAQN/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwgAUE6NgIYIAEoAhxBCDsB3AICQCABKAIcKALQASABKAIcKAK4AUlBAXFFDQAgAUEAOgAXIAEgASgCHCABQRdqEKeHgIAANgIYIAEgASgCHCgC0AE2AhAgASABKAIYNgIMAkACQCABKAIYQTpGQQFxRQ0AAkACQCABKAIcQfIAQf8BcRDZhoCAAEEBcUUNACABQTw2AgwCQCABKAIcQekAQf8BcRDZhoCAAEEBcUUNACABQT02AgwLDAELAkAgASgCHEHpAEH/AXEQ2YaAgABBAXFFDQAgAUE7NgIMCwsMAQsCQAJAIAEtABdBAXENACABKAIcQfIAQf8BcRDZhoCAAEEBcUUNACABQS42AgwCQCABKAIcQekAQf8BcRDZhoCAAEEBcUUNACABQS82AgwLDAELAkAgASgCHEHpAEH/AXEQ2YaAgABBAXFFDQAgAUEtNgIMCwsLIAEgASgCHBDohoCAADoACwJAAkAgAS0AC0H/AXFFDQACQCABLQALQf8BcUGAAU5BAXENAAJAIAEtAAtB/wFxQeEATkEBcUUNACABLQALQf8BcUH6AExBAXENAQsCQCABLQALQf8BcUHBAE5BAXFFDQAgAS0AC0H/AXFB2gBMQQFxDQELIAEtAAtB/wFxQd8ARkEBcUUNAQsgASgCECECIAEoAhwgAjYC0AEMAQsgASABKAIMNgIYCwsgASgCGCEDIAFBIGokgICAgAAgAw8LhwEBAX8jgICAgABBEGshAiACIAA2AgggAiABNgIEIAIgAigCCCgCmAI2AgACQAJAA0AgAigCAEEAR0EBcUUNAQJAIAIoAgAoAgAgAigCBEZBAXFFDQAgAkEBQQFxOgAPDAMLIAIgAigCACgCBDYCAAwACwsgAkEAQQFxOgAPCyACLQAPQQFxDwvzAQEKfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAEgASgCCCgC0AE2AgQCQANAIAEoAgQgASgCCCgCuAFJIQJBACEDIAJBAXEhBCADIQUCQCAERQ0AIAEoAgQtAABB/wFxQQpHIQZBACEHIAZBAXEhCCAHIQUgCEUNACABKAIELQAAQf8BcUEjRyEFCwJAIAVBAXFFDQAgASgCBCEJIAEgCUEBajYCBAJAIAktAABB/wFxEPKKgIAAQQFxDQAgAUEAQQFxOgAPDAMLDAELCyABQQFBAXE6AA8LIAEtAA9BAXEhCiABQRBqJICAgIAAIAoPC9EDAwJ/AX4PfyOAgICAAEHgAGshAyADJICAgIAAIAMgADYCXCADIAE6AFsgAyACOgBaIANB0ABqQQA2AgAgA0HIAGohBEIAIQUgBCAFNwMAIANBwABqIAU3AwAgA0E4aiAFNwMAIAMgBTcDMCADQQU2AjAgAyADLQBbOgA4IAMgAy0AWjoAOSADIANBMGpBBGpBBmo2AiwgAygCLCEGIAZBA2ohB0EAIQggByAIKADW4oiAADYAACAGIAgoANPiiIAANgAAIANBBDYCKAJAIAMtAFpB/wFxRQ0AIAMtAFohCSADKAIsIQogAygCKCELIAMgC0EBajYCKCAKIAtqIAk6AAALAkAgAy0AW0H/AXFFDQAgAy0AWyEMIAMoAiwhDSADKAIoIQ4gAyAOQQFqNgIoIA0gDmogDDoAAAsgAygCXEEANgLwAiADKAJcIQ9BICEQIAMgEGogECADQTBqaigCADYCAEEYIREgAyARaiARIANBMGpqKQMANwMAQRAhEiADIBJqIBIgA0EwamopAwA3AwBBCCETIAMgE2ogEyADQTBqaikDADcDACADIAMpAzA3AwAgDyADEOSGgIAAQQFxIRQgA0HgAGokgICAgAAgFA8LUwEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAgwoAswBIAIoAgwoAtABIAIoAggQsIaAgAAgAkEQaiSAgICAAA8LnAIBBn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABIAEoAggQ+YaAgAA2AgQCQAJAIAEoAgRFDQACQAJAIAEoAggoAtgBQQBHQQFxRQ0AIAEoAggQ0IaAgAAMAQsgASgCCEHMAmogASgCCCgC0AEgASgCBGpBf2oQo4uAgAAaCyABIAEoAggoAtABLQAAOgADAkAgASgCBEECRkEBcUUNACABIAEoAggoAtABLQABOgADCyABKAIEIQIgASgCCCEDIAMgAiADKALQAWo2AtABIAEgAS0AAzoADwwBCyABKAIIIQQgBCgC0AEhBSAEIAVBAWo2AtABIAEgBS0AADoADwsgAS0AD0H/AXEhBiABQRBqJICAgIAAIAYPC2EBAn8jgICAgABBEGshASABIAA6AA4gAS0ADiECAkACQAJAIAJBKEYNACACQTxGDQAgAkHbAEYNACACQfsARw0BCyABIAEtAA46AA8MAQsgAUEAOgAPCyABLQAPQf8BcQ8LiQEBAn8jgICAgABBEGshASABIAA6AA4gAS0ADiECAkACQAJAAkACQAJAIAJBKEYNACACQTxGDQMgAkHbAEYNASACQfsARg0CDAQLIAFBKToADwwECyABQd0AOgAPDAMLIAFB/QA6AA8MAgsgAUE+OgAP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ASCoASCnASCpAUHTACCpARCph4CAACGqASACIKoBNgIMAkAgqgFBAUdBAXFFDQAgAiACKAIMNgIsDAULIAIoAighqwEgAigCGCGsASACKAIgIa0BIKsBIKwBQbSQhYAAIK0BQcAAQdkAQdoAEKmHgIAAIa4BIAIgrgE2AgwCQCCuAUEBR0EBcUUNACACIAIoAgw2AiwMBQsgAigCKCGvASACKAIYIbABIAIoAiAhsQEgrwEgsAFB59yEgAAgsQFBwABB3ABBARCph4CAACGyASACILIBNgIMAkAgsgFBAUdBAXFFDQAgAiACKAIMNgIsDAULIAIoAighswEgAigCGCG0ASACKAIgIbUBILMBILQBQbOwhIAAILUBQQFB4gBB4wAQqYeAgAAhtgEgAiC2ATYCDAJAILYBQQFHQQFxRQ0AIAIgAigCDDYCLAwFCwwCCyACKAIoIbcBIAIoAhghuAEgAigCICG5ASC3ASC4AUGG5YWAACC5AUECQewAQQEQqYeAgAAhugEgAiC6ATYCDAJAILoBQQFHQQFxRQ0AIAIgAigCDDYCLAwECyACKAIoIbsBIAIoAhghvAEgAigCICG9ASC7ASC8AUHP5YWAACC9AUECQesAQQEQqYeAgAAhvgEgAiC+ATYCDAJAIL4BQQFHQQFxRQ0AIAIgAigCDDYCLAwECwwBCyACKAIoIb8BIAIoAhghwAEgAigCICHBASC/ASDAAUHA5IWAACDBAUECQeoAQQEQqYeAgAAhwgEgAiDCATYCDAJAIMIBQQFHQQFxRQ0AIAIgAigCDDYCLAwDCwsLAkAgAi0AE0EBcUUNACACKAIoKAKgAigCDCHDASACKAIYIAIoAhwgAigCGGsgwwERgICAgACAgICAACHEASACQR1BNyDEAUEBcRs2AiwMAQsgAigCGCACKAIcIAIoAhhrENWEgIAAIcUBIAJBHUE3IMUBQQFxGzYCLAsgAigCLCHGASACQTBqJICAgIAAIMYBDwtCAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCABKAIMKALQARDPhoCAACECIAFBEGokgICAgAAgAg8LUAECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAgwgAigCCBCrh4CAABCsh4CAACEDIAJBEGokgICAgAAgAw8LwAEBDH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCCCACKAIMa0ECRiEDQQAhBCADQQFxIQUgBCEGAkAgBUUNACACKAIMLQAAQf8BcUHfAEYhB0EAIQggB0EBcSEJIAghBiAJRQ0AIAIoAgwtAAFB/wFxQTBHIQpBACELIApBAXEhDCALIQYgDEUNACACKAIMLQABQf8BcRD+ioCAACEGCyAGQQFxIQ0gAkEQaiSAgICAACANDwugAQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAAkAgAigCCCgCDEEARkEBcUUNACACKAIMQeACaiACKAIMKALMASACKAIMKALQARCni4CAAAwBCyACKAIIIAIoAggoAgwgAigCDCgC0AEgAigCCCgCDGsQ5YqAgAAgAigCDCACKAIIEP+GgIAACyACQRBqJICAgIAADwvgAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAAkAgAigCCCgCDEEARkEBcUUNACACKAIIQRAQ3YqAgAAaIAIgAigCDCgCzAE2AgQMAQsgAiACKAIIKAIMNgIECyACIAIoAgwoAtABQX9qNgIAAkAgAigCACACKAIET0EBcQ0AQaePhIAAQbPQhYAAQZzSAEHnqYWAABCOgICAAAALIAIoAgggAigCBCACKAIAIAIoAgRrEOWKgIAAIAIoAgAhAyACKAIIIAM2AgwgAkEQaiSAgICAAA8LRQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgAToACyACKAIMIAItAAtB/wFxEOaKgIAAIAJBEGokgICAgAAPC1YBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDEHgAmogAigCCBDeioCAACACKAIIEN+KgIAAEKiLgIAAIAJBEGokgICAgAAPC9w/AYsCfyOAgICAAEGgAWshBCAEJICAgIAAIAQgADYCnAEgBCABNgKYASAEIAI2ApQBIAQgAzoAkwEgBCAEKAKcARDohoCAADoAkgEgBC0AkgFBc2ohBSAFQesASxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAUObBESEhISEhISEhISEhISEhIS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AswBIAIoAgwoAtABEKeLgIAAIAIoAgwoAswBIAIoAgwoAtABIAIoAgwoAswBaxC3h4CAACEDIAIoAgwgA0EBcToAhwMMAQsgAigCCCACKAIIKAIMIAIoAgwoAtABIAIoAggoAgxrEOWKgIAAIAIoAghBEGogAigCCCgCDCACKAIMKALQASACKAIIKAIMaxDlioCAACACKAIMIAIoAggQhoeAgAALIAJBEGokgICAgAAPC98BAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIIKAIMQQBGQQFxRQ0AIAIoAghBEBDdioCAABogAigCCEEQakEQEN2KgIAAGiACIAIoAgwoAswBNgIEDAELIAIgAigCCCgCDDYCBAsgAiACKAIMKALQAUF/ajYCACACKAIIIAIoAgQgAigCACACKAIEaxDlioCAACACKAIIQRBqIAIoAgQgAigCACACKAIEaxDlioCAACACKAIAIQMgAigCCCADNgIMIAJBEGokgICAgAAPC0gBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE6AAsgAigCDEEQaiACLQALQf8BcRDmioCAACACQRBqJICAgIAADwuWAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQeACaiACKAIIEN6KgIAAIAIoAggQ34qAgAAQqIuAgAAgAigCCEEQahDeioCAACACKAIIQRBqEN+KgIAAELeHgIAAIQMgAigCDCADQQFxOgCHAyACKAIIQRBqEOuKgIAAIAJBEGokgICAgAAPC5MBAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIgAigCCBC1h4CAADYCBCACKAIMIAIoAggoAtABIAIoAgQQ5YqAgAAgAigCDEEQaiACKAIIKALQASACKAIEEOWKgIAAIAIoAgQhAyACKAIIIQQgBCADIAQoAtABajYC0AEgAkEQaiSAgICAAA8LyQIBCn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIANBADYCACADKAIEIQQgBEECSxoCQAJAAkACQCAEDgMAAQIDCwwCCyADKAIIKAIAIAMoAgwoArgBIAMoAggoAgBrEO6KgIAAIQUgAygC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IAMgADYCPCADIAE2AjggAyACNgI0IAMgAygCPEEoEKCHgIAANgIwIAMoAjAhBCADQcAAOwEIIANBADsBCiADKAI8IQUgBSgCAEEBaiEGIAUgBjYCACADIAY2AgwgAyADKAI8KAK0ATYCECADIAMoAjwoArQBNgIUIAMgAygCODYCGCADIAMoAjwoArQBNgIcIAMgAygCPCgCtAE2AiAgAyADKAI0NgIkIAMgAygCPCgCtAE2AiggAyADKAI8KAK0ATYCLCAEIAMpAgg3AgBBICEHIAQgB2ogByADQQhqaikCADcCAEEYIQggBCAIaiAIIANBCGpqKQIANwIAQRAhCSAEIAlqIAkgA0EIamopAgA3AgBBCCEKIAQgCmogCiADQQhqaikCADcCACADKAIwIQsgA0HAAGokgICAgAAgCw8LZgEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAggQyIeAgAAgAigCDEEQaiACKAIIEJ6GgIAAIAIoAghBAUH//wNxEJ6HgIAAIAJBEGokgICAgAAPC+wBAQh/I4CAgIAAQTBrIQEgASSAgICAACABIAA2AiwgASABKAIsQRwQoIeAgAA2AiggASgCKCECIAFB2gA7AQwgAUEEOwEOIAEoAiwhAyADKAIAQQFqIQQgAyAENgIAIAEgBDYCECABQQA2AhQgAUEANgIYIAFBADYCHCABQQA2AiAgAUEANgIkIAIgASkCDDcCAEEYIQUgAiAFaiAFIAFBDGpqKAIANgIAQRAhBiACIAZqIAYgAUEMamopAgA3AgBBCCEHIAIgB2ogByABQQxqaikCADcCACABKAIoIQggAUEwaiSAgICAACAIDwuEAwELfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCPCACIAE2AjggAiACKAI8QTQQoIeAgAA2AjQgAigCNCEDIAJBjwE7AQAgAkESOwECIAIoAjwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCBCACIAIoAjwoArQBNgIIIAIgAigCPCgCtAE2AgwgAkEQakIANwIAIAIgAigCPCgCtAE2AhggAiACKAI8KAK0ATYCHCACQSBqQgA3AgAgAkEANgIoIAJBADYCLCACQQA2AjAgAyACKQIANwIAQTAhBiADIAZqIAIgBmooAgA2AgBBKCEHIAMgB2ogAiAHaikCADcCAEEgIQggAyAIaiACIAhqKQIANwIAQRghCSADIAlqIAIgCWopAgA3AgBBECEKIAMgCmogAiAKaikCADcCAEEIIQsgAyALaiACIAtqKQIANwIAIAIoAjRBKGogAigCOCACKAI4EOyLgIAAEKmLgIAAIAIoAjQhDCACQcAAaiSAgICAACAMDwu3AQEGfyOAgICAAEEgayEBIAEkgICAgAAgASAANgIcIAEgASgCHEEQEKCHgIAANgIYIAEoAhghAiABQZABOwEIIAFBAjsBCiABKAIcIQMgAygCAEEBaiEEIAMgBDYCACABIAQ2AgwgASABKAIcKAK0ATYCECABIAEoAhwoArgBNgIUIAIgASkCCDcCAEEIIQUgAiAFaiAFIAFBCGpqKQIANwIAIAEoAhghBiABQSBqJICAgIAAIAYPC7UFAQp/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIAQgBCgCPEEgEKCHgIAANgIsAkACQCAEKAIwQQBHQQFxRQ0AIAQoAjAoAgwgBCgCOCgCDEtBAXFFDQAgBCAEKAIwKAIMNgIoDAELAkACQCAEKAI0KAIAQQNHQQFxRQ0AIAQgBCgCNCgCCDYCKAwBCyAEIAQoAjgoAgw2AigLCwJAIAQoAjgvAQBB//8DcUGNAUZBAXFFDQAgBCgCOCEFIAUgBS8BAkH//wNxQRJyOwECCyAEQQA7ASYCQCAEKAI4LwEAQf//A3FBBkZBAXENACAEKAI4LwEAQf//A3FBwQBGQQFxDQAgBCgCOC8BAEH//wNxQfoARkEBcQ0AIAQoAjBBAEdBAXFFDQAgBCgCMC8BAEH//wNxQQZGQQFxDQAgBCgCMC8BAEH//wNxQcEARkEBcQ0AIAQoAjAvAQBB//8DcUH6AEZBAXENACAEIAQoAjgvAQJB//8DcSAEKAIwLwECQf//A3FxQQJxOwEmCyAEKAIsIQYgBEEIOwEEIAQgBC8BJjsBBiAEKAI8IQcgBygCAEEBaiEIIAcgCDYCACAEIAg2AgggBCAEKAI4KAIINgIMIAQgBCgCKDYCECAEIAQoAjg2AhQgBCAEKAIwNgIYIARBBGpBGGohCQJAAkAgBCgCNCgCAEEDRkEBcUUNACAJQQA2AgAgCUEANgIEDAELIAkgBCgCNCgCBDYCACAJIAQoAjQoAgg2AgQLIAYgBCkCBDcCAEEYIQogBiAKaiAKIARBBGpqKQIANwIAQRAhCyAGIAtqIAsgBEEEamopAgA3AgBBCCEMIAYgDGogDCAEQQRqaikCADcCACAEKAIsIQ0gBEHAAGokgICAgAAgDQ8LxwEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQAJAIAIoAggvAQBB//8DcUEIRkEBcUUNACACKAIIKAIQLwEAQf//A3FBjwFGQQFxDQELIAIoAgxBBEH//wNxEPaHgIAACyACKAIMQRBqIAIoAggQnIaAgAACQCACKAIMKAIIQQBGQQFxRQ0AIAIoAggoAgghAyACKAIMIAM2AggLIAIoAggoAgwhBCACKAIMIAQ2AgwgAkEQaiSAgICAAA8LQwEDfyOAgICAAEEQayECIAIgADYCDCACIAE7AQogAi8BCkH//wNxIQMgAigCDCEEIAQgAyAELwECQf//A3FyOwECDwv8AgEKfyOAgICAAEHAAGshAyADJICAgIAAIAMgADYCPCADIAE2AjggAyACNgI0IAMgAygCPEEwEKCHgIAANgIwIAMoAjAhBCADQZUBOwEAIANBADsBAiADKAI8IQUgBSgCAEEBaiEGIAUgBjYCACADIAY2AgQgAyADKAI8KAK0ATYCCCADIAMoAjwoArQBNgIMIAMgAygCPCgCtAE2AhAgAyADKAI8KAK0ATYCFCADIAMoAjwoArQBNgIYIAMgAygCPCgCtAE2AhwgAyADKAI8KAK0ATYCICADIAMoAjwoArQBNgIkIAMgAygCODYCKCADIAMoAjQ2AiwgBCADKQIANwIAQSghByAEIAdqIAMgB2opAgA3AgBBICEIIAQgCGogAyAIaikCADcCAEEYIQkgBCAJaiADIAlqKQIANwIAQRAhCiAEIApqIAMgCmopAgA3AgBBCCELIAQgC2ogAyALaikCADcCACADKAIwIQwgA0HAAGokgICAgAAgDA8LjgEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCCCEDIAJBASADEKGMgIAANgIEAkAgAigCBEEARkEBcUUNAEEAKALA8IiAACEEIAIgAigCCDYCACAEQaG3hoAAIAIQx4uAgAAaEL6L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AigCCGsgAkEEahD4ioCAADYCACACKAIMIAIoAgggAigCACACKAIEEL2HgIAAIAIoAgAhAyACQRBqJICAgIAAIAMPC38BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIEIAIgAigCCCACKAIMKAK4ASACKAIIayACQQRqEPOKgIAANgIAIAIoAgwgAigCCCACKAIAIAIoAgQQvYeAgAAgAigCACEDIAJBEGokgICAgAAgAw8LfwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACQQA2AgQgAiACKAIIIAIoAgwoArgBIAIoAghrIAJBBGoQ9YqAgAA2AgAgAigCDCACKAIIIAIoAgAgAigCBBC9h4CAACACKAIAIQMgAkEQaiSAgICAACADDwt/AQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBADYCBCACIAIoAgggAigCDCgCuAEgAigCCGsgAkEEahD6ioCAADYCACACKAIMIAIoAgggAigCACACKAIEEL2HgIAAIAIoAgAhAyACQRBqJICAgIAAIAMPC+UEAQx/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAJBOjYCAAJAAkAgAigCCBDohoCAAEH/AXFBLkZBAXFFDQACQAJAIAIoAghBARDghoCAAEH/AXEQ/oqAgABBAXFFDQAgAigCCCEDIAMgAygC0AFBAmo2AtABIAIoAgggAigCCCgC0AEQuIeAgAAhBCACKAIIIQUgBSAEIAUoAtABajYC0AEgAkEsNgIADAELIAIgAigCADYCDAwCCwsCQAJAIAIoAggQ6IaAgABB/wFxQeUARkEBcQ0AIAIoAggQ6IaAgABB/wFxQcUARkEBcUUNAQsCQAJAAkAgAigCCEEBEOCGgIAAQf8BcUErRkEBcQ0AIAIoAghBARDghoCAAEH/AXFBLUZBAXFFDQELIAIoAgghBiAGIAYoAtABQQJqNgLQAQJAAkAgAigCCBDohoCAAEH/AXEQ/oqAgABBAXFFDQAgAigCCCEHIAcgBygC0AFBAWo2AtABIAIoAgggAigCCCgC0AEQuIeAgAAhCCACKAIIIQkgCSAIIAkoAtABajYC0AEMAQsgAigCCEGRARDthoCAAAsMAQsC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BiAMaiAMIAVBBGpqKQIANwIAIAUoAighDSAFQcAAaiSAgICAACANDwuCAwEMfyOAgICAAEHQAGshASABJICAgIAAIAEgADYCTCABIAEoAkxBPBCgh4CAADYCSCABKAJIIQIgAUHpADsBDCABQQA7AQ4gASgCTCEDIAMoAgBBAWohBCADIAQ2AgAgASAENgIQIAFBADYCFCABQQA2AhggAUEANgIcIAFBADYCICABQQA2AiQgAUEANgIoIAFBADYCLCABQQA2AjAgAUEANgI0IAFBADYCOCABQQA2AjwgAUEANgJAIAFBADYCRCACIAEpAgw3AgBBOCEFIAIgBWogBSABQQxqaigCADYCAEEwIQYgAiAGaiAGIAFBDGpqKQIANwIAQSghByACIAdqIAcgAUEMamopAgA3AgBBICEIIAIgCGogCCABQQxqaikCADcCAEEYIQkgAiAJaiAJIAFBDGpqKQIANwIAQRAhCiACIApqIAogAUEMamopAgA3AgBBCCELIAIgC2ogCyABQQxqaikCADcCACABKAJIIQwgAUHQAGokgICAgAAgDA8LoQQBCX8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUAkACQCADKAIULwEAQf//A3FBiwFGQQFxRQ0AAkACQCADKAIYKAIcQQBGQQFxRQ0AIAMoAhQhBCADKAIYIAQ2AhwMAQsgAygCHCADKAIUQboBEN6HgIAAIAMoAhhBIGogAygCFBCchoCAAAsMAQsCQAJAIAMoAhQvAQBB//8DcUHGAEZBAXFFDQACQAJAIAMoAhgoAhxBAEZBAXFFDQAgAygCFCEFIAMoAhggBTYCHAwBCyADKAIcQYgCaiEGIAMoAhwoAswBIQcgAygCHCgC0AEhCCADKAIcKALQASADKAIcKALMAWshCSADIAMoAhwoAswBNgIEIAMgCTYCACAGIAcgCEG7ASADEM6EgIAAGiADKAIYQSBqIAMoAhQQnIaAgAALDAELAkACQCADKAIYKAIcQQBGQQFxRQ0AIAMoAhhBEGogAygCFBCchoCAAAwBCyADKAIYQSBqIAMoAhQQnIaAgAALCwsCQAJAIAMoAhgoAghBAEZBAXENACADKAIYKAIIIAMoAhQoAghLQQFxRQ0BCyADKAIUKAIIIQogAygCGCAKNgIICwJA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IAA2AjwgAiABNgI4IAIgAigCPEEwEKCHgIAANgI0IAIoAjQhAyACQZQBOwEEIAJBADsBBiACKAI8IQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgggAiACKAI4KAIENgIMIAJBADYCECACIAIoAjgoAgQ2AhQgAiACKAI4KAIINgIYIAJBADYCHCACQQA2AiAgAkEANgIkIAJBADYCKCACQQA2AiwgAkEANgIwIAMgAikCBDcCAEEoIQYgAyAGaiAGIAJBBGpqKQIANwIAQSAhByADIAdqIAcgAkEEamopAgA3AgBBGCEIIAMgCGogCCACQQRqaikCADcCAEEQIQkgAyAJaiAJIAJBBGpqKQIANwIAQQghCiADIApqIAogAkEEamopAgA3AgAgAigCNCELIAJBwABqJICAgIAAIAsPC1gBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCCCgCDCEDIAIoAgwgAzYCDCACKAIMQRhqIAIoAggQnIaAgAAgAkEQaiSAgICAAA8LoQIBDH8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkIAMoAixBzAJqIAMoAiwoAuwCIAMoAiggAygCJEEAQQFxEMiKgIAAIQQgAyAENgIgAkAgBEEAR0EBcUUNACADKAIsQfwBaiEFIAMoAiQoAgghBiADKAIkKAIMIQcgAygCLEHMAmohCCADKAIkKAIIIQkgAygCLCgC7AIhCiADQRhqIAggCSAKEKWLgIAAIAMoAhghCyADKAIsQcwCaiEMIAMoAiAoAgghDSADKAIsKALsAiEOIANBEGogDCANIA4QpYuAgAAgAyADKAIQNgIEIAMgCzYCACAFIAYgB0GuAiADEM6EgIAAGgsgA0EwaiSAgICAAA8LYAEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCgCCCEDIAIoAgwgAzYCDCACKAIMQSRqIQQgAiACKAIIKAIENgIAIAIgAigCCCgCCDYCBCAEIAIpAgA3AgAPC10BA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIAkAgAigCCCgCDCACKAIMKAIMS0EBcUUNACACKAIIKAIMIQMgAigCDCADNgIMCyACKAIIIQQgAigCDCAENgIsDwuNAQECfyOAgICA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gICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQCQCADKAIoKAIAQdQARkEBcQ0AQerphYAAQbPQhYAAQb8vQZyUhYAAEI6AgIAAAAsgAyADKAIsQRwQoIeAgAA2AiAgAygCICEEIANBBGohBSADQesAOwEEIANBADsBBiADKAIsIQYgBigCAEEBaiEHIAYgBzYCACADIAc2AgggBUEIaiEIIAMgAygCKCgCBDYCDCAIQQRqIQkCQAJAIAMoAiRBAEZBAXFFDQAgAygCKCgCCCEKDAELIAMoAiQoAgwhCgsgCSAKNgIAIAMgAygCJDYCFCADIAMoAigoAgQ2AhggAyADKAIoKAIINgIcIAQgAykCBDcCAEEYIQsgBCALaiALIANBBGpqKAIANgIAQRAhDCAEIAxqIAwgA0EEamopAgA3AgBBCCENIAQgDWogDSADQQRqaikCADcCACADKAIgIQ4gA0EwaiSAgICAACAODwvOAgEMfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQgAyADKAIsQRwQoIeAgAA2AiAgAygCICEEIANBBGohBSADQYQBOwEEIANBADsBBiADKAIsIQYgBigCAEEBaiEHIAYgBzYCACADIAc2AgggBUEIaiEIIAMgAygCKCgCBDYCDCAIQQRqIQkCQAJAIAMoAiRBAEZBAXFFDQAgAygCKCgCCCEKDAELIAMoAiQoAgwhCgsgCSAKNgIAIAMgAygCKCgCBDYCFCADIAMoAigoAgg2AhggAyADKAIkNgIcIAQgAykCBDcCAEEYIQsgBCALaiALIANBBGpqKAIANgIAQRAhDCAEIAxqIAwgA0EEamopAgA3AgBBCCENIAQgDWogDSADQQRqaikCADcCACADKAIgIQ4gA0EwaiSAgICAACAODwupAgECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACQQA6AAcgAiACKAIMKAKYAjYCAAJAAkADQCACKAIAQQBHQQFxRQ0BIAIoAgAoAgAhAyADQTVLGgJAAkACQAJAAkACQAJAIAMONgQAAAAAAwMDAwMAAAICAgIDAwMDAwAAAAAAAAAAAwMDAwMAAAICAgIAAAAAAAABAQEBAAAAAAULDAULIAJBAToABwwECyACKAIMIAIoAghB/QEQ3oeAgAAMBgsMBQtB4raGgABBs9CFgABBrPoAQZbchIAAEI6AgIAAAAsLIAIgAigCACgCBDYCAAwACwsgAi0AB0EBcUUNACACKAIMIAIoAghB/QEQ3oeAgAALIAJBEGokgICAgAAPC7sDAQt/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJAJAIAMoAiQoAhRBAEZBAXENACADKAIkKAIULwEAQf//A3FBDkZBAXENAEHwq4aAAEGz0IWAAEGZIkG6loWAABCOgICAAAALAkAgAygCKCgCAEHeAEZBAXENAEHP8IWAAEGz0IWAAEGaIkG6loWAABCOgICAAAALIAMgAygCLEEUEKCHgIAANgIgIANBADYCHAJAIAMoAiQoAhRBAEdBAXFFDQAgAyADKAIkKAIUNgIcCyADKAIgIQQgA0EIaiEFIANBOjsBCCADQQA7AQogAygCLCEGIAYoAgBBAWohByAGIAc2AgAgAyAHNgIMIAVBCGohCCADIAMoAigoAgQ2AhAgCEEEaiEJAkACQCADKAIcQQBHQQFxRQ0AIAMoAhwoAgwhCgwBCyADKAIoKAIIIQoLIAkgCjYCACADIAMoAhw2AhggBCADKQIINwIAQRAhCyAEIAtqIAsgA0EIamooAgA2AgBBCCEMIAQgDGogDCADQQhqaikCADcCACADKAIgIQ0gA0EwaiSAgICAACANDwvoAwEKfyOAgICAAEHQAGshAyADJICAgIAAIAMgADYCTCADIAE2AkggAyACNgJEAkAgAygCSCgCAEHeAEZBAXENAEH18IWAAEGz0IWAAEHDN0GlloWAABCOgICAAAALIAMgAygCTEEwEKCHgIAANgJAIAMgAygCRBCtiYCAADYCPAJAIAMoAjxBAEZBAXFFDQBB4raGgABBs9CFgABByDdBpZaFgAAQjoCAgAAACyADKAJAIQQgA0GOATsBDCADQQA7AQ4gAygCTCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIQIAMgAygCSCgCBDYCFCADIAMoAjw2AhggAyADKAJIKAIENgIcIAMgAygCSCgCCDYCICADQQxqQRhqIAMoAkQpAgA3AgAgAyADKAJEKAIINgIsIANBDGpBJGogAygCREEMaikCADcCACADIAMoAkQoAhQ2AjggBCADKQIMNwIAQSghByAEIAdqIAcgA0EMamopAgA3AgBBICEIIAQgCGogCCADQQxqaikCADcCAEEYIQkgBCAJaiAJIANBDGpqKQIANwIAQRAhCiAEIApqIAogA0EMamopAgA3AgBBCCELIAQgC2ogCyADQQxqaikCADcCACADKAJAIQwgA0HQAGokgICAgAAgDA8L8gMBCn8jgICAgABB0ABrIQUgBSSAgICAACAFIAA2AkwgBSABNgJIIAUgAjYCRCAFIAM2AkAgBSAENgI8IAUgBSgCTEEsEKCHgIAANgI4AkACQCAFKAI8KAIAQQBHQQFxRQ0AIAUgBSgCPCgCBDYCNAwBCwJAAkAgBSgCQEEAR0EBcUUNACAFIAUoAkAoAgw2AjQMAQsCQAJAIAUoAkQoAgBBAEdBAXFFDQAgBSAFKAJEKAIENgI0DAELIAUgBSgCSCgCCDYCNAsLCyAFKAI4IQYgBUGXATsBCCAFQQA7AQogBSgCTCEHIAcoAgBBAWohCCAHIAg2AgAgBSAINgIMIAUgBSgCSCgCBDYCECAFIAUoAjQ2AhQgBSAFKAJIKAIENgIYIAUgBSgCSCgCCDYCHCAFQQhqQRhqIAUoAkQpAgA3AgAgBSAFKAJANgIoIAVBCGpBJGogBSgCPCkCADcCACAGIAUpAgg3AgBBKCEJIAYgCWogCSAFQQhqaigCADYCAEEgIQogBiAKaiAKIAVBCGpqKQIANwIAQRghCyAGIAtqIAsgBUEIamopAgA3AgBBECEMIAYgDGogDCAFQQhqaikCADcCAEEIIQ0gBiANaiANIAVBCGpqKQIANwIAIAUoAjghDiAFQdAAaiSAgICAACAODwvwAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAgwoApgCNgIEAkADQCACKAIEQQBHQQFxRQ0BIAIoAgQoAgAhAyADQTVLGgJAAkACQAJAAkAgAw42AgMDAwMDAwMDAwMDAQEBAQAAAAAAAAMDAwMDAwMDAwMDAwMBAQEBAQMDAwMDAwEBAQEDAwMDBAsMBQsgAigCDCACKAIIQacBEN6HgIAADAQLQeK2hoAAQbPQhYAAQaiMAUHdwYWAABCOgICAAAALCyACIAIoAgQoAgQ2AgQMAAsLIAJBEGokgICAgAAPC9UBAQZ/I4CAgIAAQTBrIQcgBySAgICAACAHIAA2AiwgByABNgIoIAcgAjYCJCAHIAM2AiAgByAENgIcIAcgBTYCGCAHIAY7ARYgBygCLCEIIAdBCGogCBDUh4CAACAHKAIsIQkgBygCHCEKIAcgCSAHQQhqIAoQpIiAgAA2AgQgBygCLCAHKAIoIAcoAiQgBygCBCAHKAIYIAcvARZB//8DcUEBakH//wNxEKWIgIAAIAcoAiAhCyAHKAIEIAs2AgggBygCBCEMIAdBMGokgICAgAAgDA8L/AMBD38jgICAgABB4ABrIQcgBySAgICAACAHIAA2AlwgByABNgJYIAcgAjYCVCAHIAM2AlAgByAENgJMIAcgBTYCSCAHIAY2AkQgByAHKAJcQTwQoIeAgAA2AkAgBygCQCEIIAdBhwE7AQQgB0EAOwEGIAcoAlwhCSAJKAIAQQFqIQogCSAKNgIAIAcgCjYCCCAHIAcoAlQoAgQ2AgwgByAHKAJEKAIINgIQIAdBBGpBEGohCyAHKAJYIQwgCyAMKQIANwIAQQghDSALIA1qIAwgDWooAgA2AgAgByAHKAJUKAIENgIgIAcgBygCVCgCCDYCJCAHIAcoAlAoAgQ2AiggByAHKAJQKAIINgIsIAcgBygCTDYCMCAHIAcoAkg2AjQgByAHKAJEKAIENgI4IAcgBygCRCgCCDYCPCAIIAcpAgQ3AgBBOCEOIAggDmogDiAHQQRqaigCADYCAEEwIQ8gCCAPaiAPIAdBBGpqKQIANwIAQSghECAIIBBqIBAgB0EEamopAgA3AgBBICERIAggEWogESAHQQRqaikCADcCAEEYIRIgCCASaiASIAdBBGpqKQIANwIAQRAhEyAIIBNqIBMgB0EEamopAgA3AgBBCCEUIAggFGogFCAHQQRqaikCADcCACAHKAJAIRUgB0HgAGokgICAgAAgFQ8LpwEBAn8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAE2AhggBCACNgIUIAQgAzYCEAJAAkAgBCgCHCAEKAIYIAQoAhQQiYeAgABBAXFFDQAMAQsgBCAEKAIcKALEATYCDCAEKAIcIAQoAgwgBCgCDCAEKAIQELCGgIAAIAQoAgwhBSAEKAIcIAU2AsABIAQoAhxBAjYCvAELIARBIGokgICAgAAPC7wBAQJ/I4CAgIAAQRBrIQEgASAANgIIIAEgASgCCCgCmAI2AgQCQAJAA0AgASgCBEEAR0EBcUUNASABKAIEKAIAQXRqIQIgAkElSxoCQAJAAkAgAg4mAQEBAQAAAAAAAgICAgICAgICAgICAgICAQEBAQICAgICAgEBAQECCyABQQFBAXE6AA8MBAsgAUEAQQFxOgAPDAMLIAEgASgCBCgCBDYCBAwACwsgAUEAQQFxOgAPCyABLQAPQQFxDwvJAwEKfyOAgICAAEHwAGshCSAJJICAgIAAIAkgADYCbCAJIAE2AmggCSACNgJkIAkgAzYCYCAJIAQ2AlwgCSAFNgJYIAkgBjYCVCAJIAc2AlAgCSAINgJMIAkgCSgCbEHEABCgh4CAADYCSCAJKAJIIQogCUEaOwEEIAlBADsBBiAJKAJsIQsgCygCAEEBaiEMIAsgDDYCACAJIAw2AgggCSAJKAJkKAIENgIMIAkgCSgCTCgCCDYCECAJQQRqQRBqIQ0gCSgCaCEOIA0gDikCADcCAEEIIQ8gDSAPaiAOIA9qKAIANgIAIAkgCSgCZCgCBDYCICAJIAkoAmQoAgg2AiQgCSAJKAJgNgIoIAlBBGpBKGohEAJAAkAgCSgCWCgCAEEDRkEBcUUNACAQQQA2AgAgEEEANgIEDAELIBAgCSgCWCgCBDYCACAQIAkoAlgoAgg2AgQLIAkgCSgCVDYCNCAJIAkoAlA2AjggCSAJKAJMKAIENgI8IAkgCSgCTCgCCDYCQCAJIAkoAmwgCSgCXBCrh4CAADYCREHEACERAkAgEUUNACAKIAlBBGogEfwKAAALIAkoAkghEiAJQfAAaiSAgICAACASDwuoBAELfyOAgICAAEEQayECIAIkgICAgAAgAiABNgIMIAIoAgwoAsgBQXxqIQMgA0GeAUsaAkACQAJAAkACQCADDp8BAgMDAwMCAwICAgMDAwMCAgMCAwMDAwMDAwADAwMDAwMDAwMDAgIDAgMDAwMDAgICAwMDAQMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAADAAAAAAAAAAADAAMAAAMAAAAAAwMDAgICAgMAAgMDAwMDAwMCAwMDAwMDAgMDAwIDAwMDAwIDAgMCAwMDAwMCAgMDAwICAgICAwsgAigCDBC+hoCAACACKAIMQbwBaiEEIAAgBCkCADcCAEEIIQUgACAFaiAEIAVqKAIANgIADAMLIAIoAgwgAigCDCgCzAEgAigCDCgC0AEQuIiAgAAgAigCDBC+hoCAACACKAIMQbwBaiEGIAAgBikCADcCAEEIIQcgACAHaiAGIAdqKAIANgIADAILIAIoAgxBCBDThoCAACACKAIMEL6GgIAAIAIoAgxBvAFqIQggACAIKQIANwIAQQghCSAAIAlqIAggCWooAgA2AgAMAQsgAigCDEGIAmohCiACKAIMKALMASELIAIoAgwoAtABIQwgAiACKAIMKALIARDcioCAADYCACAKIAsgDEE+IAIQzoSAgAAaIABBAjYCACAAIAIoAgwoAswBNgIEIAAgAigCDCgC0AE2AggLIAJBEGokgICAgAAPC4YBAQR/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBAJAIAMoAgggAygCBBD7hoCAAEEBcUUNACADKAIMQYgCaiEEIAMoAgghBSADKAIEIQYgAyADKAIINgIAIAQgBSAGQdABIAMQzoSAgAAaCyADQRBqJICAgIAADwvsAQEGfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAIAIoAhgoAgBB1QBGQQFxDQBB5PaFgABBs9CFgABB1y9BoZeFgAAQjoCAgAAACyACIAIoAhxBEBCgh4CAADYCFCACKAIUIQMgAkHsADsBBCACQQI7AQYgAigCHCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCGCgCBDYCDCACIAIoAhgoAgg2AhAgAyACKQIENwIAQQghBiADIAZqIAYgAkEEamopAgA3AgAgAigCFCEHIAJBIGokgICAgAAgBw8L7AEBBn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIYKAIAQd0ARkEBcQ0AQY79hYAAQbPQhYAAQZo1QfyXhYAAEI6AgIAAAAsgAiACKAIcQRAQoIeAgAA2AhQgAigCFCEDIAJBhQE7AQQgAkEAOwEGIAIoAhwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCCCACIAIoAhgoAgQ2AgwgAiACKAIYKAIINgIQIAMgAikCBDcCAEEIIQYgAyAGaiAGIAJBBGpqKQIANwIAIAIoAhQhByACQSBqJICAgIAAIAcPC+wBAQZ/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYAkAgAigCGCgCAEHgAEZBAXENAEHc/YWAAEGz0IWAAEH7OkGlmIWAABCOgICAAAALIAIgAigCHEEQEKCHgIAANgIUIAIoAhQhAyACQZABOwEEIAJBAjsBBiACKAIcIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgggAiACKAIYKAIENgIMIAIgAigCGCgCCDYCECADIAIpAgQ3AgBBCCEGIAMgBmogBiACQQRqaikCADcCACACKAIUIQcgAkEgaiSAgICAACAHDwvrAQEGfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAIAIoAhgoAgBBzgBGQQFxDQBBwv6FgABBs9CFgABBwx9BzJ2FgAAQjoCAgAAACyACIAIoAhxBEBCgh4CAADYCFCACKAIUIQMgAkEzOwEEIAJBAjsBBiACKAIcIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgggAiACKAIYKAIENgIMIAIgAigCGCgCCDYCECADIAIpAgQ3AgBBCCEGIAMgBmogBiACQQRqaikCADcCACACKAIUIQcgAkEgaiSAgICAACAHDwuGJwFMfyOAgICAAEHwAmshCCAIJICAgIAAIAggADYC6AIgCCABNgLkAiAIIAI6AOMCIAggAzoA4gIgCCAEOgDhAiAIIAU6AOACIAggBjoA3wIgCCAHOwHcAiAIKALoAkEAQQFxENaGgIAAIAggCCgC6AIQzomAgAA2AtgCIAhBCDYC1AIDQCAIQQE6ANMCIAgoAugCKALIASEJAkACQAJAAkACQAJAAkACQCAJQQRGDQAgCUEYRg0CIAlBHUYNAiAJQTBGDQIgCUE3Rg0CIAlBOUYNAiAJQe0ARg0DIAlB9QBGDQICQCAJQfsARg0AIAlBkQFGDQUgCUGTAUYNBiAJQZoBRg0BIAlBnQFGDQIgCUGhAUYNBSAJQaIBRg0GDAcLIAgoAugCIAgoAugCQcgBaiAIQdQCahDPiYCAABogCCAIKALoAhDQiYCAADYCzAICQAJAIAgoAtQCQQVLQQFxRQ0AIAgoAtgCIAgoAswCENGJgIAADAELIAgoAtgCIAgoAswCENKJgIAACwwHCyAIKALoAiAIKALoAkHIAWogCEHUAmoQz4mAgAAaIAgoAugCEL6GgIAAIAgoAugCQbwBaiEKQQghCyAKIAtqKAIAIQwgCyAIQcACamogDDYCACAIIAopAgA3A8ACIAhBADoArwICQAJAIAgoAugCQTcQy4eAgABBAXFFDQAgCCgC6AJBvAFqIQ1BCCEOIA0gDmooAgAhDyAOIAhBsAJqaiAPNgIAIAggDSkCADcDsAIgCCAIKALoAiAIQbACahDTiYCAAEEBcToArwIgCCgC6AIgCEGwAmpBARDUiYCAABoMAQsgCCgC6AIhECAIQaACaiAQENSHgIAAQQghESARIAhBsAJqaiARIAhBoAJqaigCADYCACAIIAgpAqACNwOwAiAIKALoAigClAIhEiASIBItABxB/wFxQQRyOgAcCyAIIAgoAugCIAhBsAJqIAhBwAJqENWJgIAANgKcAgJAIAgtAK8CQQFxRQ0AIAgoApwCENaJgIAACwJAAkAgCCgC2AIoAkhBAEZBAXFFDQAgCCgC2AIgCCgCnAIQ14mAgAAMAQsgCCgC6AIgCCgCnAJByQEQ3oeAgAAgCCgC2AIgCCgCnAIQ0omAgAALDAYLAkAgCC0A4QJBAXENACAIKALoAkEREO2GgIAACyAIIAgoAugCIAgoAugCQcgBaiAIQdQCahDPiYCAAEEBcToAmwIgCCgC6AIQvoaAgAAgCCgC6AIoApQCIRMgEyATLQAcQf8BcUEIcjoAHCAIIAgoAugCIAgoAugCQbwBahDYiYCAADYClAICQCAIKALYAigCREEAR0EBcUUNACAIIAgoAtgCKAJENgKQAiAIKALYAiAIKAKQAhDSiYCAAAJAIAgtAJsCQQFxRQ0AIAgoAugCQdQBEMyHgIAACyAIKALYAkEANgJECyAIKALYAiAIKAKUAhDZiYCAAAwFCyAIKALoAhC+hoCAACAIKALoAigCvAEhFAJAAkACQAJAIBRBGEYNAAJAAkACQCAUQR1GDQAgFEEwRg0CIBRBOUYNASAUQfUARg0EDAULIAgoAugCQQwQzIeAgAAMBQsgCCgC6AJBDhDMh4CAAAwECyAIKALoAkENEMyHgIAADAMLIAgoAugCQQsQzIeAgAAMAgsgCCgC6AJBzAEQzIeAgAAMAQsLAkACQCAIKALoAigCyAFBJ0ZBAXFFDQAgCCgC6AIgCCgC6AJByAFqIAhB1AJqEM+JgIAAGgwBCyAIKALoAiAIKALoAkG8AWogCEHUAmoQz4mAgAAaCyAIKALoAkG8AWohFUEIIRYgFSAWaigCACEXIBYgCEGAAmpqIBc2AgAgCCAVKQIANwOAAiAIIAgoAugCIAhBgAJqENOJgIAAQQFxOgD/ASAIKALoAiAIQYACakEBENSJgIAAGgJAAkAgCCgC6AJBJxCOh4CAAEEBcUUNACAIKALoAkHIAWohGEEIIRkgGCAZaigCACEaIBkgCEHwAWpqIBo2AgAgCCAYKQIANwPwASAIKALoAkEWEIuHgIAAGiAIKALoAhC+hoCAACAIIAgoAugCIAhBgAJqEKuHgIAANgLsAQJAAkAgCCgC6AIoAvgCQQFGQQFxRQ0AIAgoAugCKAKUAkEEaiAIKALsARDaiYCAACEbDAELQQAhGwsgCCAbNgLoAQJAIAgtAOACQQFxRQ0AIAgoAugCQQFBAXEQq4aAgAALIAgoAugCIRwgCCgC5AIhHSAILwHcAkH//wNxQQFqIR5BACEfQc4BISAgCCAcIB0gH0EBcSAfQQFxICAgHkH//wNxEM+HgIAANgLkAQJAIAgtAOACQQFxRQ0AIAgoAugCENeHgIAACyAIKALoAiEhIAgoAuQBISIgCCAhIAhBgAJqIAhB8AFqICIQ24mAgAA2AuABAkAgCC0A/wFBAXFFDQAgCCgC4AEQ1omAgAALIAgoAtgCIAgoAuABENyJgIAAAkAgCCgC6AIoAvgCQQFGQQFxRQ0AIAgoAugCKAKUAkEEaiAIKALsARDaiYCAACAIKALoAUdBAXFFDQAgCCgC6AJBiAJqISMgCCgChAIhJCAIKAKIAiElIAgoAogCIAgoAoQCayEmIAggCCgChAI2AgQgCCAmNgIAICMgJCAlQcoBIAgQzoSAgAAaCyAIKALoAhCPh4CAAAJAIAgoAugCLQCBA0EBcUUNACAIQQA6ANMCDAcLDAELAkACQCAIKALUAkEFS0EBcUUNACAIIAgoAugCIAhBgAJqEN2JgIAANgLcAQJAIAgtAP8BQQFxRQ0AIAgoAtwBENaJgIAACyAIKALYAiAIKALcARDRiYCAAAwBCyAIIAgoAugCIAhBgAJqEN2JgIAANgLYAQJAIAgtAP8BQQFxRQ0AIAgoAtgBENaJgIAACyAIKALYAiAIKALYARDSiYCAAAsLDAQLAkAgCC0A4wJBAXENACAILQDfAkEBcQ0AIAgoAugCQQE6AIUDCyAIKALoAiAIKALoAkHIAWogCEHUAmoQz4mAgAAaIAgoAugCQRYQi4eAgAAaIAgoAugCEL6GgIAAIAgoAugCQbwBaiEnQQghKCAnIChqKAIAISkgKCAIQcgBamogKTYCACAIICcpAgA3A8gBQQghKiAqIAhBuAFqaiAqIAhByAFqaigCADYCACAIIAgpAsgBNwO4ASAIIAgoAsABQX9qNgLAAQJAAkACQAJAIAgoAugCLQCDA0EBcUUNACAIKALoAigCoAIoAgwhKyAIKAK8ASAIKALAASAIKAK8AWsgKxGAgICAAICAgIAAQQFxDQEMAgsgCCgCvAEgCCgCwAEgCCgCvAFrENWEgIAAQQFxRQ0BCyAIKALoAiAIKAK8ASAIKALAAUEMELCGgIAADAELAkACQCAIKALAAUF/ai0AAEH/AXFBIUZBAXENACAIKALAAUF/ai0AAEH/AXFBP0ZBAXFFDQELIAgoAugCQYgCaiEsIAgoArwBIS0gCCgCwAEhLiAIKALAASAIKAK8AWshLyAIIAgoArwBNgIkIAggLzYCICAsIC0gLkGTASAIQSBqEM6EgIAAGgsLIAggCCgC6AIgCEG4AWoQ04mAgAA6ALcBIAgoAugCITBBASExIDAgCEG4AWogMRDUiYCAABogCCgC6AIoAsgBITICQAJAAkACQCAyQRtGDQAgMkH5AEYNASAyQf0ARg0AIDJBhQFGDQAgMkGOAUYNAQwCCyAIKALoAhCPh4CAACAIIAgoAugCIAhByAFqEN6JgIAANgKwAQJAIAgtALcBQQFxRQ0AIAgoArABENaJgIAACyAIKALYAiAIKAKwARDfiYCAAAwCCyAIKALoAhCPh4CAAAJAIAgtAOMCQQFxRQ0AIAhBADoA0wIMAgsgCCAIKALoAiAIQcgBahDeiYCAADYCrAECQCAILQC3AUEBcUUNACAIKAKsARDWiYCAAAsgCCgC2AIgCCgCrAEQ34mAgAAMAQsCQAJAIAgoAugCKALIARDnh4CAAEEBcUUNACAIIAgoAugCIAhBuAFqEKuHgIAANgKkAQJAAkAgCCgC6AIoAvgCQQFGQQFxRQ0AIAgoAugCKAKUAkEEaiAIKAKkARDaiYCAACEzDAELQQAhMwsgCCAzNgKgAQJAIAgtAOACQQFxRQ0AIAgoAugCQQFBAXEQq4aAgAALIAgoAugCITQgCCgC5AIhNSAILwHcAkH//wNxQQFqITZBACE3Qc8BITggCCA0IDUgN0EBcSA3QQFxIDggNkH//wNxEM+HgIAANgKcAQJAIAgtAOACQQFxRQ0AIAgoAugCENeHgIAACwJAIAgoAugCKAL4AkEBRkEBcUUNACAIKALoAigClAJBBGogCCgCpAEQ2omAgAAgCCgCoAFHQQFxRQ0AIAgoAugCQYgCaiE5IAgoArwBITogCCgCwAEhOyAIKALAASAIKAK8AWshPCAIIAgoArwBNgIUIAggPDYCECA5IDogO0HKASAIQRBqEM6EgIAAGgsgCCgC6AIhPSAIKAKcASE+IAggPSAIQcgBaiA+EOCJgIAANgKoAQwBCyAIIAgoAugCIAhByAFqEN6JgIAANgKoAQsCQCAILQC3AUEBcUUNACAIKAKoARDWiYCAAAsgCCgC6AIQj4eAgAAgCCgC2AIgCCgCqAEQ34mAgAACQCAIKALoAi0AgQNBAXFFDQAgCEEAOgDTAgwBCwsgCCgC6AJBADoAhQMMAwsgCCgC6AIgCCgC6AJByAFqIAhB1AJqEM+JgIAAGiAIKALoAhC+hoCAACAIKALoAkG8AWohP0EIIUAgPyBAaigCACFBIEAgCEGQAWpqIEE2AgAgCCA/KQIANwOQASAIQQA6AH8CQAJAIAgoAugCQTcQy4eAgABBAXFFDQAgCCgC6AJBvAFqIUJBCCFDIEIgQ2ooAgAhRCBDIAhBgAFqaiBENgIAIAggQikCADcDgAEgCCAIKALoAiAIQYABahDTiYCAAEEBcToAfyAIKALoAiAIQYABakEBENSJgIAAGgwBCyAIKALoAiFFIAhB8ABqIEUQ1IeAgABBCCFGIEYgCEGAAWpqIEYgCEHwAGpqKAIANgIAIAggCCkCcDcDgAEgCCgC6AIoApQCIUcgRyBHLQAcQf8BcUEBcjoAHAsgCCAIKALoAiAIQZABaiAIQYABahDhiYCAADYCbAJAIAgtAH9BAXFFDQAgCCgCbBDWiYCAAAsCQAJAIAgoAtgCKAIoQQBGQQFxRQ0AIAgoAtgCIAgoAmwQ4omAgAAMAQsgCCgC6AIgCCgCbEHSARDeh4CAACAIKALYAiAIKAJsENKJgIAACwwCCyAIIAgoAtQCNgJoIAgoAugCIAgoAugCQcgBaiAIQdQCahDPiYCAABogCCgC6AIQvoaAgAAgCCgC6AJBvAFqIUhBCCFJIEggSWooAgAhSiBJIAhB2ABqaiBKNgIAIAggSCkCADcDWAJAAkAgCCgC6AJB1QAQy4eAgABBAXFFDQACQCAIKAJoQQNNQQFxRQ0AIAgoAugCQdUBEMyHgIAACyAIKALoAiFLIAgoAugCQbwBaiFMIAggSyAIQdgAaiBMEOOJgIAANgJUDAELIAhBADoARwJAAkAgCCgC6AJBNxDLh4CAAEEBcUUNACAIKALoAkG8AWohTUEIIU4gTSBOaigCACFPIE4gCEHIAGpqIE82AgAgCCBNKQIANwNIIAggCCgC6AIgCEHIAGoQ04mAgABBAXE6AEcgCCgC6AIgCEHIAGpBARDUiYCAABoMAQsgCCgC6AIhUCAIQThqIFAQ1IeAgABBCCFRIFEgCEHIAGpqIFEgCEE4amooAgA2AgAgCCAIKQI4NwNIIAgoAugCKAKUAiFSIFIgUi0AHEH/AXFBAnI6ABwLIAggCCgC6AIgCEHYAGogCEHIAGoQ5ImAgAA2AlQCQCAILQBHQQFxRQ0AIAgoAlQQ1omAgAALCwJAAkAgCCgC2AIoAkRBAEZBAXFFDQAgCCgC2AIgCCgCVBDZiYCAAAwBCyAIKALoAiAIKAJUQcgBEN6HgIAAIAgoAtgCIAgoAlQQ0omAgAALDAELAkAgCCgC6AIoArwBQRtGQQFxRQ0AAkACQCAILQDiAkEBcUUNACAIKALUAkEHT0EBcUUNACAIIAgoAugCIAgoAugCQbwBahCmiYCAADYCNAJAAkAgCCgC2AIoAihBAEZBAXFFDQAgCCgC2AIgCCgCNBDiiYCAAAwBCyAIKALoAiAIKAI0QdIBEN6HgIAAIAgoAtgCIAgoAjQQ0omAgAALDAELIAgoAugCQdYBEMyHgIAACwsgCEEAOgDTAgsCQAJAIAgtANMCQQFxDQAMAQsgCEEAOgAzAkAgCC0A4wJBAXFFDQAgCCAIKALoAkH5ABDLh4CAAEEBcToAMwsCQAJAIAgoAugCQRsQy4eAgABBAXFFDQACQCAILQAzQQFxRQ0AIAgoAugCQY4BEMyHgIAACwwBCwwBCwwBCwsgCCgC6AIQ14aAgAACQAJAIAgoAtgCKAIIIAgoAtgCKAIMRkEBcUUNACAIKALoAiAIKALYAhChhoCAACAIQQA2AuwCDAELIAggCCgC2AI2AuwCCyAIKALsAiFTIAhB8AJqJICAgIAAIFMPC6gBAQx/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoAgBBE0YhAkEBIQMgAkEBcSEEIAMhBQJAIAQNACABKAIMKAIAQTdGIQZBACEHIAZBAXEhCCAHIQkCQCAIRQ0AIAEoAgwoAgggASgCDCgCBGtBAk4hCkEAIQsgCkEBcSEMIAshCSAMRQ0AIAEoAgwoAghBf2otAABB/wFxQT1GIQkLIAkhBQsgBUEBcQ8LqAIBCH8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8QSAQoIeAgAA2AiwgBCgCLCEFIARBgAE7AQwgBEEAOwEOIAQoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCECAEIAQoAjgoAgg2AhQgBCAEKAIwKAIMNgIYIAQgBCgCODYCHCAEIAQoAjQoAgQ2AiAgBCAEKAI0KAIINgIkIAQgBCgCMDYCKCAFIAQpAgw3AgBBGCEIIAUgCGogCCAEQQxqaikCADcCAEEQIQkgBSAJaiAJIARBDGpqKQIANwIAQQghCiAFIApqIAogBEEMamopAgA3AgAgBCgCLCELIARBwABqJICAgIAAIAsPC3wBAn8jgICAgABBEGshASABIAA2AgggASgCCCgCACECAkACQAJAIAJBC0YNACACQZkBRw0BCwJAIAEoAggoAghBf2otAABB/wFxQcAARkEBcUUNACABIAEoAggoAghBf2o2AgwMAgsLIAEgASgCCCgCCDYCDAsgASgCDA8L9gYBDn8jgICAgABBoAFrIQ0gDSSAgICAACANIAA2ApwBIA0gATYCmAEgDSACNgKUASANIAM2ApABIA0gBDYCjAEgDSAFNgKIASANIAY2AoQBIA0gBzYCgAEgDSAINgJ8IA0gCTYCeCANIAo2AnQgDSALNgJwIA0gDDYCbCANIA0oApwBQeQAEKCHgIAANgJoAkACQCANKAJsKAIAQQNGQQFxRQ0AIA0gDSgCiAEoAgw2AmQMAQsgDSANKAJsKAIINgJkCwJAIA0oApABQQBHQQFxRQ0AIA0oApABLwEAQf//A3FB9ABGQQFxRQ0AIA0oApwBIA0oApABEOWJgIAACyANKAJoIQ4gDUEtOwEAIA1BADsBAiANKAKcASEPIA8oAgBBAWohECAPIBA2AgAgDSAQNgIEIA0gDSgCgAEoAgQ2AgggDSANKAJkNgIMIA0gDSgCmAE2AhAgDSANKAKUASgCBDYCFCANIA0oApQBKAIINgIYIA0gDSgCkAE2AhwgDSANKAKMATYCICANIA0oAogBNgIkIA1BKGohESANKAKEASESIBEgEikCADcCAEEIIRMgESATaiASIBNqKAIANgIAIA0gDSgCgAEoAgQ2AjQgDSANKAKAASgCCDYCOCANQTxqIRQCQAJAIA0oAnwoAgBBA0ZBAXFFDQAgFEEANgIAIBRBADYCBAwBCyAUIA0oAnwoAgQ2AgAgFCANKAJ8KAIINgIECyANQcQAaiEVAkACQCANKAJ4KAIAQQNGQQFxRQ0AIBVBADYCACAVQQA2AgQMAQsgFSANKAJ4KAIENgIAIBUgDSgCeCgCCDYCBAsgDUHMAGohFgJAAkAgDSgCdCgCAEEDRkEBcUUNACAWQQA2AgAgFkEANgIEDAELIBYgDSgCdCgCBDYCACAWIA0oAnQoAgg2AgQLIA1B1ABqIRcCQAJAIA0oAnAoAgBBA0ZBAXFFDQAgF0EANgIAIBdBADYCBAwBCyAXIA0oAnAoAgQ2AgAgFyANKAJwKAIINgIECyANQdwAaiEYAkACQCANKAJsKAIAQQNGQQFxRQ0AIBhBADYCACAYQQA2AgQMAQsgGCANKAJsKAIENgIAIBggDSgCbCgCCDYCBAtB5AAhGQJAIBlFDQAgDiANIBn8CgAACyANKAJoIRogDUGgAWokgICAgAAgGg8LnQQBEH8jgICAgABB0ABrIQUgBSSAgICAACAFIAA2AkwgBSABNgJIIAUgAjYCRCAFIAM2AkAgBSAENgI8IAUgBSgCTEEsEKCHgIAANgI4IAUoAjghBiAFQQxqIQcgBUEuOwEMIAVBADsBDiAFKAJMIQggCCgCAEEBaiEJIAggCTYCACAFIAk2AhAgB0EIaiEKIAUgBSgCPCgCADYCFCAKQQRqIQsCQAJAIAUoAkAoAgBBA0ZBAXFFDQAgBSgCRCgCDCEMDAELIAUoAkAoAgghDAsgCyAMNgIAIAVBDGpBEGohDQJAAkAgBSgCSCgCAEEDRkEBcUUNACANQQA2AgAgDUEANgIEDAELIA0gBSgCSCgCBDYCACANIAUoAkgoAgg2AgQLIAUgBSgCRDYCJCAFQQxqQRxqIQ4CQAJAIAUoAkAoAgBBA0ZBAXFFDQAgDkEANgIAIA5BADYCBAwBCyAOIAUoAkAoAgQ2AgAgDiAFKAJAKAIINgIECyAFQQxqQSRqIAUoAjwpAgA3AgAgBiAFKQIMNwIAQSghDyAGIA9qIA8gBUEMamooAgA2AgBBICEQIAYgEGogECAFQQxqaikCADcCAEEYIREgBiARaiARIAVBDGpqKQIANwIAQRAhEiAGIBJqIBIgBUEMamopAgA3AgBBCCETIAYgE2ogEyAFQQxqaikCADcCACAFKAI4IRQgBUHQAGokgICAgAAgFA8LhwMBCn8jgICAgABB0ABrIQUgBSSAgICAACAFIAA2AkwgBSABNgJIIAUgAjYCRCAFIAM2AkAgBSAENgI8IAUgBSgCTEEsEKCHgIAANgI4IAUoAjghBiAFQfcAOwEMIAVBADsBDiAFKAJMIQcgBygCAEEBaiEIIAcgCDYCACAFIAg2AhAgBSAFKAJIKAIENgIUIAUgBSgCPCgCCDYCGCAFIAUoAkA2AhwgBSAFKAJIKAIENgIgIAUgBSgCSCgCCDYCJCAFIAUoAkQoAgQ2AiggBSAFKAJEKAIINgIsIAUgBSgCPCgCBDYCMCAFIAUoAjwoAgg2AjQgBiAFKQIMNwIAQSghCSAGIAlqIAkgBUEMamooAgA2AgBBICEKIAYgCmogCiAFQQxqaikCADcCAEEYIQsgBiALaiALIAVBDGpqKQIANwIAQRAhDCAGIAxqIAwgBUEMamopAgA3AgBBCCENIAYgDWogDSAFQQxqaikCADcCACAFKAI4IQ4gBUHQAGokgICAgAAgDg8LoAwBE38jgICAgABB0ABrIQQgBCSAgICAACAEIAA2AkggBCABNgJEQQEhBSAEIAIgBXE6AEMgBCADIAVxOgBCIAQoAkQvAQBBdmohBiAGQYYBSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBg6HAQUNDQ0NDQ0NDQwNDQ0NDQ0NDQ0NAg0NDQ0NDQMNDQ0NBA0NDQ0NDQ0NAQ0NDQ0NDQ0NDQ0GDQ0NDQ0NDQ0NDQ0NDQ0NDQkNDQ0NDQ0NDQgNDQ0NDQ0NBw0NDQ0NDQANCg0NAQ0NBQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQENDQEBAQsNDQ0NAQ0LIAQgBCgCRDYCTAwNCyAEIAQoAkggBCgCRBDmiYCAADYCTAwMCyAEKAJEQR87AQAgBCAEKAJENgJMDAsLAkAgBCgCSBC1iICAAEEBcUUNACAEKAJIIAQoAkRBnQIQ3oeAgAALIAQoAkRBKDsBACAEIAQoAkQ2AkwMCgsCQCAEKAJIELWIgIAAQQFxRQ0AIAQoAkggBCgCREGdAhDeh4CAAAsgBCgCREErOwEAIAQgBCgCRDYCTAwJCyAEKAJIQYgCaiEHIAQoAkQoAgghCCAEKAJEKAIMIQkgBCgCRCgCDCAEKAJEKAIIayEKIAQgBCgCRCgCCDYCBCAEIAo2AgAgByAIIAlBngIgBBDOhICAABogBCAEKAJENgJMDAgLIAQoAkRBPzsBACAEIAQoAkQ2AkwMBwsCQCAEKAJEKAIIIAQoAkQoAgwQ+4aAgABBAXFFDQAgBCgCSEGIAmohCyAEKAJEKAIIIQwgBCgCRCgCDCENIAQgBCgCRCgCCDYCECALIAwgDUHQASAEQRBqEM6EgIAAGiAEKAJIIAQoAkQQ94eAgAALIAQgBCgCRDYCPCAEIAQoAjwoAhA2AjggBCAEKAI8KAIUNgI0IAQoAkggBCgCNBD4h4CAAEEEaiAEKAI4EPmHgIAAIAQoAkRB4QA7AQAgBCAEKAJENgJMDAYLIAQgBCgCSEGspoSAAEECEPmIgIAANgIwIAQgBCgCSCAEKAJEQQhqIAQoAjBBABDniYCAADYCLCAEKAJIIAQoAkQQ94eAgAAgBCgCSCAEKAJEEKGGgIAAIAQgBCgCLDYCTAwFCyAEKAJEQdAAOwEAIAQgBCgCRDYCTAwECwJAIAQtAEJBAXFFDQAgBCgCSCAEKAJEQZ8CEN6HgIAACyAEIAQoAkQ2AkwMAwsgBCAEKAJENgIoAkAgBCgCKCgCGEEAR0EBcUUNACAEKAJIIQ4gBCgCKCgCGCEPIAQtAEMhEEEBIREgDiAPIBBBAXEgEUEBcRDEiICAACESIAQoAiggEjYCGAsgBCAEKAIoNgJMDAILIAQgBCgCRDYCJAJAIAQoAiQoAiBBAEdBAXFFDQAgBCgCJCgCJEF/ai0AAEH/AXFBIUdBAXFFDQAgBCgCJCgCJEF/ai0AAEH/AXFBP0dBAXFFDQAgBCgCJCgCKEEARkEBcUUNACAEKAIkKAIwQQBGQQFxRQ0AIAQoAiQoAjxBAEZBAXFFDQACQCAEKAIkKAIQQQBGQQFxRQ0AIAQgBCgCJEEgaikCADcDGCAEIAQoAkggBCgCGCAEKAIcQQAQ7oiAgAA2AhQgBCgCSCAEKAJEEKGGgIAAIAQoAkghEyAEKAIUIRQgBCATIARBGGogFEEAEOeJgIAANgJMDAMLAkACQCAEKAIkKAIgLQAAQf8BcUHfAEZBAXENACAEKAJIKAKgAigCCCEVIAQoAiQoAiAgBCgCJCgCJCAEKAIkKAIgayAVEYCAgIAAgICAgABFDQELAkAgBC0AQ0EBcUUNACAEKAIkLwECQf//A3FBBHFFDQAgBCgCSCAEKAIkQZcCEN6HgIAACyAEKAJIIAQoAiRBHGoQ/YiAgAAgBCAEKAJIIAQoAiQQ6ImAgAA2AkwMAwsLAkAgBCgCJC8BAkH//wNxQYACcUUNACAEIAQoAkggBCgCJBDpiYCAADYCTAwCCwsgBCgCSCAEKAJEQZ8CEN6HgIAAIAQgBCgCRDYCTAsgBCgCTCEWIARB0ABqJICAgIAAIBYPC5AEAQ1/I4CAgIAAQeAAayEIIAgkgICAgAAgCCAANgJcIAggATYCWCAIIAI2AlQgCCADNgJQIAggBDYCTCAIIAU2AkggCCAGNgJEIAggBzYCQCAIIAgoAlxBPBCgh4CAADYCPCAIKAI8IQkgCEE3OwEAIAhBADsBAiAIKAJcIQogCigCAEEBaiELIAogCzYCACAIIAs2AgQgCCAIKAJMKAIENgIIIAggCCgCQCgCCDYCDCAIIAgoAlg2AhAgCCAIKAJUNgIUIAggCCgCUDYCGCAIIAgoAkwoAgQ2AhwgCCAIKAJMKAIINgIgIAggCCgCSCgCBDYCJCAIIAgoAkgoAgg2AiggCEEsaiEMAkACQCAIKAJEKAIAQQNGQQFxRQ0AIAxBADYCACAMQQA2AgQMAQsgDCAIKAJEKAIENgIAIAwgCCgCRCgCCDYCBAsgCCAIKAJAKAIENgI0IAggCCgCQCgCCDYCOCAJIAgpAgA3AgBBOCENIAkgDWogCCANaigCADYCAEEwIQ4gCSAOaiAIIA5qKQIANwIAQSghDyAJIA9qIAggD2opAgA3AgBBICEQIAkgEGogCCAQaikCADcCAEEYIREgCSARaiAIIBFqKQIANwIAQRAhEiAJIBJqIAggEmopAgA3AgBBCCETIAkgE2ogCCATaikCADcCACAIKAI8IRQgCEHgAGokgICAgAAgFA8L9w4BPn8jgICAgABBoAFrIQUgBSSAgICAACAFIAA2ApwBIAUgATYCmAEgBSACNgKUASAFIAM6AJMBIAUgBDsBkAEgBUGIAWpBADYCACAFQgA3A4ABIAUgBSgCnAEgBUGAAWoQvYaAgAA2AnwgBSgCnAFBvAFqIQZBCCEHIAYgB2ooAgAhCCAHIAVB8ABqaiAINgIAIAUgBikCADcDcCAFKAKcASEJIAVB5ABqIAkQ1IeAgAAgBSgCnAEhCiAFKAKYASELIAUvAZABQf//A3FBAWohDCAFIApBBiALIAVB5ABqIAxB//8DcRDqiYCAADYCYCAFQQA2AlwCQCAFKAKcAUHKAEHJAEHLABDNh4CAAEEBcQ0AIAUoApwBQQFBAXEQq4aAgAAgBSAFKAKcASAFKAKYASAFLwGQAUH//wNxQQFqQf//A3EQv4aAgAA2AlwgBSgCnAEQ14eAgAAgBSgCnAFB+QBBjgEQiYeAgAAaCyAFKAKcASENIAVB0ABqIA0Q1IeAgAAgBUEANgJMIAUoApgBIQ4CQAJAAkACQCAOQRxGDQAgDkEzRg0BDAILIAUoApwBIQ8gBSgCYCEQIAUoAlwhESAFIA8gBUHwAGogECAFQeQAaiARQQAgBUHQAGoQ64mAgAA2AkwMAgsgBSgCnAEhEiAFKAJgIRMgBSgCXCEUIAUgEiAFQfAAaiATIAVB5ABqIBQQ7ImAgAA2AkwMAQtB4raGgABBs9CFgABB/fsAQbn6hIAAEI6AgIAAAAsgBSAFKAJMNgJIAkAgBSgCmAFBHEZBAXFFDQACQANAIAUoApwBQcoAEI6HgIAAQQFxRQ0BAkAgBSgCnAEQ64aAgABBAXFFDQAgBSgCnAFB/AFqIRUgBSgCnAEoAswBIRYgBSgCnAEoAtABIRcgBSgCnAEoAtABIAUoApwBKALMAWshGCAFIAUoApwBKALMATYCBCAFIBg2AgAgFSAWIBdBtgIgBRDOhICAABoLIAUoApwBIRkgBSgClAEhGiAFQfAAaiEbQQAhHCAZIBogGyAcQQFxIBxBAXEQkYiAgAAgBSgCnAFByAFqIR1BCCEeIB0gHmooAgAhHyAeIAVBOGpqIB82AgAgBSAdKQIANwM4IAUoApwBEL6GgIAAIAUoApwBISAgBS8BkAFB//8DcUEBaiEhIAUgIEEGQRggBUHkAGogIUH//wNxEOqJgIAANgI0IAUoApwBQQFBAXEQq4aAgAAgBSgCnAEhIiAFLwGQAUH//wNxQQFqISMgBSAiQRggI0H//wNxEL+GgIAANgIwIAUoApwBENeHgIAAIAUoApwBQfkAQY4BEImHgIAAGiAFKAKcASEkIAUoAjQhJSAFKAIwISYgBSAkIAVBOGogJSAFQeQAaiAmQQAgBUHQAGoQ64mAgAA2AiwgBSgCLCEnIAUoAkggJzYCKCAFIAUoAiw2AkgMAAsLCwJAAkAgBSgCnAFByQAQjoeAgABBAXFFDQAgBSgCnAEhKCAFKAKUASEpQQAhKiAoICkgBUHwAGogKiAqEJGIgIAAIAUgBSgCnAEQkIiAgAA2ApQBIAUoApwBEL6GgIAAIAUoApwBISsgK0HEAWooAgAhLCAFQShqICw2AgAgBSArKQK8ATcDICAFKAKcASEtQQEhLiAtIC4Qq4aAgAAgBSgCnAEhLyAuIAUvAZABakH//wNxITAgBSAvQRcgMBC/hoCAADYCHCAFKAKcARDXh4CAACAFKAKcASExQY4BITIgMUH5ACAyEImHgIAAGiAFKAKcASAFKAKUASAFQSBqICogKhCRiICAACAFKAKcASEzQTchNCAzQcsAIDQQ2IeAgAAgBSgCnAEhNSAFKAIcITYgNUG8AWohNyAFIDUgBUEgaiA2IDcQn4iAgAA2AhggBSgCmAEhOAJAAkACQAJAIDhBHEYNACA4QTNGDQEMAgsgBSgCGCE5IAUoAkggOTYCKAwCCyAFKAIYITogBSgCTCA6NgIoDAELQeK2hoAAQbPQhYAAQbX8AEG5+oSAABCOgICAAAALDAELIAUoApwBITsgBSgClAEhPCAFLQCTASE9IAVB8ABqIT5BACE/IDsgPCA+ID1BAXEgP0EBcRCRiICAACAFKAKcAUHLAEE2ENiHgIAACyAFKAKYASFAAkACQAJAAkAgQEEcRg0AIEBBM0YNAQwCCyAFIAUoAkw2AhQgBUEBOgATAkADQCAFLQATQQFxRQ0BIAUoAhQvAQAhQQJAAkACQCBBQS9GDQAgQUHDAEcNASAFKAIUIAUoApwBQbwBahDtiYCAACAFIAUoAhQoAig2AhQgBSAFKAIUQQBHQQFxOgATDAILIAUoAhQgBSgCnAFBvAFqEO6JgIAAIAVBADoAEwwBCyAFQQA6ABMLDAALCwwCCyAFKAJMIAUoApwBQbwBahDviYCAAAwBC0HitoaAAEGz0IWAAEHa/ABBufqEgAAQjoCAgAAACyAFKAKcASAFKAJ8ENmHgIAAIAVBgAFqEKCGgIAAIAUoAkwhQiAFQaABaiSAgICAACBCDwvUAgEJfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKAJAIAIoAigoAgBB4QBGQQFxDQBBs/2FgABBs9CFgABBnjtBkJiFgAAQjoCAgAAACyACIAIoAixBJBCgh4CAADYCJCACKAIkIQMgAkGRATsBACACQQA7AQIgAigCLCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIEIAIgAigCKCgCBDYCCCACIAIoAigoAgg2AgwgAkEANgIQIAJBADYCFCACQQA2AhggAiACKAIoKAIENgIcIAIgAigCKCgCCDYCICADIAIpAgA3AgBBICEGIAMgBmogAiAGaigCADYCAEEYIQcgAyAHaiACIAdqKQIANwIAQRAhCCADIAhqIAIgCGopAgA3AgBBCCEJIAMgCWogAiAJaikCADcCACACKAIkIQogAkEwaiSAgICAACAKDwvpBQcLfwF+AX8BfgF/AX4DfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCWCACIAE7AVYgAigCWCgCyAFBfGohAyADQZ4BSxoCQAJAAkACQAJAIAMOnwEAAwMDAwADAAAAAwMDAwAAAwADAwMDAwMDAQMDAwMDAwMDAwMAAAMAAwMDAwMAAAADAwMBAwMDAwMDAQEBAQEBAQEBAQEBAQEBAQEBAQMBAQEBAQEBAQMBAQEBAQEBAQMBAwEBAwEBAQEDAwMAAAAAAwEAAwMDAwMDAwADAwMDAwMAAwMDAAMDAwMDAAMAAwADAwMDAgAAAwMDAAAAAAADCyACKAJYIQQgAkHIAGogBBDUh4CAACACIAIoAlggAkHIAGpBABCziYCAADYCXAwDCyACKAJYEL6GgIAAIAIoAlghBSACQTxqIAUQ1IeAgAAgAigCWCEGIAJBMGogBhDUh4CAACACKAJYIQcgAigCWEG8AWohCCACIAcgAkE8aiAIIAJBMGoQqYmAgAA2AiwgAigCLEEoaiACKAJYKALAASACKAJYKALEARCni4CAACACKAIsIAIoAlggAigCWEG8AWogAigCLEEoakEAQQFxEKqJgIAAQf//A3EQnoeAgAAgAiACKAIsNgJcDAILIAIoAlgoAhwhCUEgIQogCSAKaigCACELIAogAkEIamogCzYCAEEYIQwgCSAMaikCACENIAwgAkEIamogDTcDAEEQIQ4gCSAOaikCACEPIA4gAkEIamogDzcDAEEIIRAgCSAQaikCACERIBAgAkEIamogETcDACACIAkpAgA3AwggAigCWBC+hoCAACACKAJYIRIgAi8BVkH//wNxQQFqIRMgAiASIAJBCGpBACATQf//A3EQ64iAgAA2AlwMAQsgAigCWEGQAhDthoCAACACIAIoAlggAigCWCgCzAEgAigCWCgC0AEQwoeAgAA2AlwLIAIoAlwhFCACQeAAaiSAgICAACAUDwtYAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAggoAgwhAyACKAIMIAM2AgwgAigCDEEQaiACKAIIEJyGgIAAIAJBEGokgICAgAAPC48EAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiAgBCgCLCAEKAIoEJ6JgIAAAkAgBCgCKEEAR0EBcUUNACAEKAIsIAQoAihBAhDiiICAAAsgBCgCLCEFAkACQCAEKAIoQQBGQQFxRQ0AQQAhBgwBCyAEKAIoEPCJgIAAQf//A3EhBgsgBCAFIAZB//8DcRCsiYCAADYCHCAEKAIkKAIEIQcgBCgCHCAHNgIIAkACQCAEKAIgKAIMQQBHQQFxRQ0AIAQoAiAoAhAhCCAEKAIcIAg2AgwMAQsCQCAEKAIoQQBHQQFxDQBBpvaFgABBs9CFgABBhxZBlZOFgAAQjoCAgAAACyAEKAIoKAIMIQkgBCgCHCAJNgIMCyAEKAIoIQogBCgCHCAKNgIQIAQoAhxBIGohCwJAAkAgBCgCJCgCAEEDRkEBcUUNACAEQQA2AhQgBEEANgIYIAsgBCkCFDcCAAwBCyAEIAQoAiQoAgQ2AgwgBCAEKAIkKAIINgIQIAsgBCkCDDcCAAsgBCgCHEEoaiAEKAIgKQIANwIAIAQoAiAoAgghDCAEKAIcIAw2AjAgBCgCHEE0aiAEKAIgQQxqKQIANwIAIAQoAixB/LaGgABBARCSh4CAACENIAQoAhwgDTYCHCAEKAIcIQ4gBEEwaiSAgICAACAODwuLBAEOfyOAgICAAEHgAGshByAHJICAgIAAIAcgADYCXCAHIAE2AlggByACNgJUIAcgAzYCUCAHIAQ2AkwgByAFNgJIIAcgBjYCRCAHIAcoAlxBOBCgh4CAADYCQCAHKAJAIQggB0HoADsBCCAHQQA7AQogBygCXCEJIAkoAgBBAWohCiAJIAo2AgAgByAKNgIMIAcgBygCVCgCBDYCECAHIAcoAkQoAgg2AhQgB0EIakEQaiELAkACQCAHKAJYQQBGQQFxRQ0AIAtBADYCACALQQA2AgQgC0EANgIIDAELIAcoAlghDCALIAwpAgA3AgBBCCENIAsgDWogDCANaigCADYCAAsgByAHKAJUKAIENgIkIAcgBygCVCgCCDYCKCAHIAcoAlA2AiwgByAHKAJINgIwIAcgBygCRCgCBDYCNCAHIAcoAkQoAgg2AjggByAHKAJcIAcoAkwQq4eAgAA2AjwgCCAHKQIINwIAQTAhDiAIIA5qIA4gB0EIamopAgA3AgBBKCEPIAggD2ogDyAHQQhqaikCADcCAEEgIRAgCCAQaiAQIAdBCGpqKQIANwIAQRghESAIIBFqIBEgB0EIamopAgA3AgBBECESIAggEmogEiAHQQhqaikCADcCAEEIIRMgCCATaiATIAdBCGpqKQIANwIAIAcoAkAhFCAHQeAAaiSAgICAACAUDwvsAQEGfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAIAIoAhgoAgBB2ABGQQFxDQBBy/OFgABBs9CFgABBtzNB8ZaFgAAQjoCAgAAACyACIAIoAhxBEBCgh4CAADYCFCACKAIUIQMgAkH8ADsBBCACQQA7AQYgAigCHCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCGCgCBDYCDCACIAIoAhgoAgg2AhAgAyACKQIENwIAQQghBiADIAZqIAYgAkEEamopAgA3AgAgAigCFCEHIAJBIGokgICAgAAgBw8L7AEBBn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIYKAIAQdsARkEBcQ0AQbXmhYAAQbPQhYAAQfI0QYeUhYAAEI6AgIAAAAsgAiACKAIcQRAQoIeAgAA2AhQgAigCFCEDIAJBgwE7AQQgAkEAOwEGIAIoAhwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCCCACIAIoAhgoAgQ2AgwgAiACKAIYKAIINgIQIAMgAikCBDcCAEEIIQYgAyAGaiAGIAJBBGpqKQIANwIAIAIoAhQhByACQSBqJICAgIAAIAcPC+sCAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIgAigCDCgCmAI2AgQgAkEANgIAAkADQCACKAIEQQBHQQFxRQ0BIAIoAgQoAgAhAyADQTVLGgJAAkACQAJAAkACQAJAIAMONgQFAwIABQUDAgAFBQEDAgABAwIAAQAFBQUFBQUFBQUDAgAFAQEDAgAFBQUFAQABAwIABQUFBQYLDAcLAkACQCACKAIADQAgAigCDCACKAIIQaMBEN6HgIAADAELAkACQCACKAIAQQFGQQFxRQ0AIAIoAgwgAigCCEGiARDeh4CAAAwBCwJAIAIoAgBBAkZBAXFFDQAgAigCDCACKAIIQaEBEN6HgIAACwsLDAYLIAJBAjYCAAwDCyACQQE2AgAMAgtB4raGgABBs9CFgABB3YsBQe+AhIAAEI6AgIAAAAsLIAIgAigCBCgCBDYCBAwACwsgAkEQaiSAgICAAA8LgQQBDH8jgICAgABB0ABrIQcgBySAgICAACAHIAA2AkwgByABNgJIIAcgAjYCRCAHIAM2AkAgByAENgI8IAcgBTYCOCAHIAY7ATYgByAHKAJMQTAQoIeAgAA2AjAgBygCTCAHKAI8QQAQ4oiAgAAgBygCMCEIIAdBkwE7AQAgByAHLwE2OwECIAcoAkwhCSAJKAIAQQFqIQogCSAKNgIAIAcgCjYCBCAHIAcoAkgoAgQ2AgggByAHKAJAKAIINgIMIAcgBygCSCgCBDYCECAHIAcoAkgoAgg2AhQgB0EYaiELAkACQCAHKAJEKAIAQQNGQQFxRQ0AIAtBADYCACALQQA2AgQMAQsgCyAHKAJEKAIENgIAIAsgBygCRCgCCDYCBAsgB0EgaiEMAkACQCAHKAJAKAIAQQNGQQFxRQ0AIAxBADYCACAMQQA2AgQMAQsgDCAHKAJAKAIENgIAIAwgBygCQCgCCDYCBAsgByAHKAI8NgIoIAcgBygCODYCLCAIIAcpAgA3AgBBKCENIAggDWogByANaikCADcCAEEgIQ4gCCAOaiAHIA5qKQIANwIAQRghDyAIIA9qIAcgD2opAgA3AgBBECEQIAggEGogByAQaikCADcCAEEIIREgCCARaiAHIBFqKQIANwIAIAcoAjAhEiAHQdAAaiSAgICAACASDwuBBAEMfyOAgICAAEHQAGshByAHJICAgIAAIAcgADYCTCAHIAE2AkggByACNgJEIAcgAzYCQCAHIAQ2AjwgByAFNgI4IAcgBjsBNiAHIAcoAkxBMBCgh4CAADYCMCAHKAJMIAcoAjxBABDiiICAACAHKAIwIQggB0GVATsBACAHIAcvATY7AQIgBygCTCEJIAkoAgBBAWohCiAJIAo2AgAgByAKNgIEIAcgBygCSCgCBDYCCCAHIAcoAkAoAgg2AgwgByAHKAJIKAIENgIQIAcgBygCSCgCCDYCFCAHQRhqIQsCQAJAIAcoAkQoAgBBA0ZBAXFFDQAgC0EANgIAIAtBADYCBAwBCyALIAcoAkQoAgQ2AgAgCyAHKAJEKAIINgIECyAHQSBqIQwCQAJAIAcoAkAoAgBBA0ZBAXFFDQAgDEEANgIAIAxBADYCBAwBCyAMIAcoAkAoAgQ2AgAgDCAHKAJAKAIINgIECyAHIAcoAjw2AiggByAHKAI4NgIsIAggBykCADcCAEEoIQ0gCCANaiAHIA1qKQIANwIAQSAhDiAIIA5qIAcgDmopAgA3AgBBGCEPIAggD2ogByAPaikCADcCAEEQIRAgCCAQaiAHIBBqKQIANwIAQQghESAIIBFqIAcgEWopAgA3AgAgBygCMCESIAdB0ABqJICAgIAAIBIPC9EBAQR/I4CAgIAAQSBrIQQgBCSAgICAACAEIAA2AhwgBCABNgIYIAQgAjYCFCAEIAM2AhAgBCAEKAIcIAQoAhggBCgCFCAEKAIQIAQoAhxB4AJqIAQoAhwgBCgCFCAEKAIcQeACakEAQQFxEKqJgIAAQf//A3EQq4mAgAA2AgwgBCgCHEHgAmohBSAEQQA2AgAgBEEANgIEIARBADYCCCAFIAQpAgA3AgBBCCEGIAUgBmogBCAGaigCADYCACAEKAIMIQcgBEEgaiSAgICAACAHDwu8AQEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAgwoAhgNACACKAIMKAIQQQBGQQFxRQ0AIAIoAggoAgghAyACKAIMIAM2AggLIAIoAgwgAigCDEEYaiACKAIIEPGJgIAAAkACQCACKAIMKAIMIAIoAggoAgxLQQFxRQ0AIAIoAgwoAgwhBAwBCyACKAIIKAIMIQQLIAQhBSACKAIMIAU2AgwgAkEQaiSAgICAAA8L4wQBEX8jgICAgABB0ABrIQQgBCSAgICAACAEIAA2AkwgBCABNgJIIAQgAjYCRCAEIAM2AkAgBCAEKAJMQSwQoIeAgAA2AjwgBCgCPCEFIARB1gA7ARAgBEECOwESIAQoAkwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCFCAEIAQoAkgoAgQ2AhggBCAEKAJAKAIINgIcIARBEGpBEGohCAJAAkAgBCgCSCgCAEEDRkEBcUUNACAIQQA2AgAgCEEANgIEDAELIAggBCgCSCgCBDYCACAIIAQoAkgoAgg2AgQLIARBADYCKCAEQQA2AiwgBEEANgIwIARBEGpBJGohCQJAAkAgBCgCQCgCAEEDRkEBcUUNACAJQQA2AgAgCUEANgIEDAELIAkgBCgCQCgCBDYCACAJIAQoAkAoAgg2AgQLIAUgBCkCEDcCAEEoIQogBSAKaiAKIARBEGpqKAIANgIAQSAhCyAFIAtqIAsgBEEQamopAgA3AgBBGCEMIAUgDGogDCAEQRBqaikCADcCAEEQIQ0gBSANaiANIARBEGpqKQIANwIAQQghDiAFIA5qIA4gBEEQamopAgA3AgACQCAEKAJEQQBHQQFxRQ0AIARBADYCCANAIAQoAgggBCgCRCgCAEkhD0EAIRAgD0EBcSERIBAhEgJAIBFFDQAgBCgCRCgCCCAEKAIIQQJ0aigCACETIAQgEzYCDCATQQBHIRILAkAgEkEBcUUNACAEKAI8IAQoAgwQ0oiAgAAgBCAEKAIIQQFqNgIIDAELCwsgBCgCPCEUIARB0ABqJICAgIAAIBQPC+8DARB/I4CAgIAAQdAAayECIAIkgICAgAAgAiAANgJMIAIgATYCSCACIAIoAkxBNBCgh4CAADYCRCACQQA7AUIgAigCTCwA/QJBAWohAyADQQJLGgJAAkACQCADDgMAAgECCyACQSA7AUIMAQsgAkESOwFCCyACKAJEIQQgAkEMaiEFIAJBjQE7AQwgAiACLwFCOwEOIAIoAkwhBiAGKAIAQQFqIQcgBiAHNgIAIAIgBzYCECAFQQhqIAIoAkhBCGopAgA3AgAgAkEMakEQaiACKAJIQRBqKQIANwIAIAJBDGpBGGogAigCSEEYaikCADcCACACQQxqQSBqIAIoAkhBIGopAgA3AgAgAkEMakEoaiEIIAIoAkhBKGohCSAIIAkpAgA3AgBBCCEKIAggCmogCSAKaigCADYCACAEIAIpAgw3AgBBMCELIAQgC2ogCyACQQxqaigCADYCAEEoIQwgBCAMaiAMIAJBDGpqKQIANwIAQSAhDSAEIA1qIA0gAkEMamopAgA3AgBBGCEOIAQgDmogDiACQQxqaikCADcCAEEQIQ8gBCAPaiAPIAJBDGpqKQIANwIAQQghECAEIBBqIBAgAkEMamopAgA3AgAgAigCSBCajICAACACKAJEIREgAkHQAGokgICAgAAgEQ8LugYBD38jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIMKAIYDQAgAigCDCgCEEEARkEBcUUNACACKAIIKAIIIQMgAigCDCADNgIICwJAAkAgAigCDCgCDCACKAIIKAIMS0EBcUUNACACKAIMKAIMIQQMAQsgAigCCCgCDCEECyAEIQUgAigCDCAFNgIMIAIoAggvAQAhBgJAAkACQAJAAkAgBkEwRg0AIAZBMUYNAQJAIAZB1QBGDQAgBkHXAEYNAwJAIAZBjQFGDQAgBkGWAUYNBAwFCyACKAIILwECQf//A3FBAnJBEHJBX3EhByACKAIIIAc7AQIMBQsCQAJAIAIoAggvAQJB//8DcUECcUUNAAwBCyACKAIMLwECQf//A3FBcXEhCCACKAIMIAg7AQILDAQLIAIgAigCCDYCBAJAAkAgAigCBCgCGEEAR0EBcUUNACACKAIEKAIYKAIQQQFGQQFxRQ0AIAIoAgQoAhgoAhgoAgAhCQwBC0EAIQkLIAIgCTYCAAJAAkAgAigCAEEARkEBcUUNACACKAIMLwECQf//A3FBcXEhCiACKAIMIAo7AQIMAQsCQAJAIAIoAgAvAQBB//8DcUGNAUZBAXFFDQAgAigCAC8BAkH//wNxQQJyQRByQV9xIQsgAigCACALOwECAkAgAigCDC8BAkH//wNxQQJxRQ0AIAIoAgwvAQJB//8DcUEIckF7cSEMIAIoAgwgDDsBAgsMAQsCQAJAIAIoAgAvAQBB//8DcUHVAEZBAXFFDQAgAigCAC8BAkH//wNxQQJxRQ0AAkAgAigCDC8BAkH//wNxQQJxRQ0AIAIoAgwvAQJB//8DcUEIckF7cSENIAIoAgwgDTsBAgsMAQsgAigCDC8BAkH//wNxQXFxIQ4gAigCDCAOOwECCwsLDAMLIAIoAgwvAQJB//8DcUFxcSEPIAIoAgwgDzsBAgwCCyACKAIMLwECQf//A3FBcXEhECACKAIMIBA7AQIMAQtBwraGgABBs9CFgABB2ilB7b6FgAAQjoCAgAAACyACKAIMQRhqIAIoAggQnIaAgAAgAkEQaiSAgICAAA8LhwEBBn8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAE2AhggBCACNgIUIAQgAzYCECAEKAIcIQUgBCgCGCEGIAQoAhQhByAEKAIQIQggBEEANgIEIARBADYCCCAEQQA2AgwgBSAGIAcgCCAEQQRqENeIgIAAIQkgBEEgaiSAgICAACAJDwvIBAETfyOAgICAAEHQAGshBSAFJICAgIAAIAUgADYCTCAFIAE2AkggBSACNgJEIAUgAzYCQCAFIAQ2AjwgBSAFKAJMQTQQoIeAgAA2AjggBSgCOCEGIAVBBGohByAFQf0AOwEEIAUgBSgCTCAFKAJAEPKJgIAAQf//A3FBAnI7AQYgBSgCTCEIIAgoAgBBAWohCSAIIAk2AgAgBSAJNgIIIAdBCGohCgJAAkAgBSgCSCgCBCAFKAJAKAIESUEBcUUNACAFKAJIKAIEIQsMAQsgBSgCQCgCBCELCyAKIAs2AgAgCkEEaiEMAkACQCAFKAJIKAIIIAUoAkAoAghLQQFxRQ0AIAUoAkgoAgghDQwBCyAFKAJAKAIIIQ0LIAwgDTYCACAFIAUoAkgoAgQ2AhQgBSAFKAJIKAIINgIYIAUgBSgCRCgCBDYCHCAFIAUoAkQoAgg2AiAgBSAFKAJAKAIENgIkIAUgBSgCQCgCCDYCKCAFQQRqQShqIQ4gBSgCPCEPIA4gDykCADcCAEEIIRAgDiAQaiAPIBBqKAIANgIAIAYgBSkCBDcCAEEwIREgBiARaiARIAVBBGpqKAIANgIAQSghEiAGIBJqIBIgBUEEamopAgA3AgBBICETIAYgE2ogEyAFQQRqaikCADcCAEEYIRQgBiAUaiAUIAVBBGpqKQIANwIAQRAhFSAGIBVqIBUgBUEEamopAgA3AgBBCCEWIAYgFmogFiAFQQRqaikCADcCACAFKAI4IRcgBUHQAGokgICAgAAgFw8L9gEBCn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIYQShqNgIUIAIgAigCHDYCBCACIAIoAhgoAgg2AgggAiACKAIYKAIMNgIMIAIgAigCFCgCCEEBRkEBcToAECACQQRqQQ1qIQNBACEEIAMgBDsAACADQQJqIAQ6AAAgAigCHCEFIAIoAhQQrIuAgAAhBiACKAIUEKuLgIAAIQcgAigCGC8BAkH//wNxQQhxQQBHIQhBACEJQd+BgIAAIQogAkEEaiELIAUgBiAHIAhBAXEgCSAJIAogCxC0ioCAACACQSBqJICAgIAADwukBwEtfyOAgICAAEEwayEEIAQkgICAgAAgBCAANgIoIAQgATYCJCAEIAI6ACMgBCADOwEgIARBAToAHwJAAkAgBCgCKCgC8AJBwNyHgABGQQFxRQ0AIAQtAB9BAXENACAEKAIoQYgCaiEFIAQoAigoAswBIQYgBCgCKCgC0AEhByAEKAIkEKuLgIAAIQggBCAEKAIkEKyLgIAANgIUIAQgCDYCECAFIAYgB0HzASAEQRBqEM6EgIAAGiAEIAQvASA7AS4MAQsCQCAEKAIoKAKgAkHA3IeAAEEYakZBAXFFDQAgBCgCKCgC8AJBAEZBAXFFDQAgBC0AI0EBcQ0AIAQoAihBiAJqIQkgBCgCKCgCzAEhCiAEKAIoKALQASELIAQgBCgCKCgCoAIoAhA2AgAgCSAKIAtBlAEgBBDOhICAABoLAkAgBC8BIEH//wNxQYABcUUNACAEKAIoIQwgBCgCJCENIAQtACMhDiAELwEgIQ9B7gAhEEHA3IeAAEEwaiERIA5BAXEhEiAPQf//A3EhE0EYIRQgBCAMIA0gEiATIBAgFHQgFHUgERD0iYCAADsBLgwBCwJAIAQvASBB//8DcUGABHFFDQAgBCgCKCEVIAQoAiQhFiAELQAjIRcgBC8BICEYQfUAIRlBwNyHgAAhGiAXQQFxIRsgGEH//wNxIRxBGCEdIAQgFSAWIBsgHCAZIB10IB11IBoQ9ImAgAA7AS4MAQsCQCAELwEgQf//A3FBwABxRQ0AIAQoAighHiAEKAIkIR8gBC0AIyEgIAQvASAhIUHlACEiQcDch4AAQcgAaiEjICBBAXEhJCAhQf//A3EhJUEYISYgBCAeIB8gJCAlICIgJnQgJnUgIxD0iYCAADsBLgwBCwJAIAQvASBB//8DcUGAAnFFDQAgBCgCKCEnIAQoAiQhKCAELQAjISkgBC8BICEqQfMAIStBwNyHgABB4ABqISwgKUEBcSEtICpB//8DcSEuQRghLyAEICcgKCAtIC4gKyAvdCAvdSAsEPSJgIAAOwEuDAELAkAgBC0AI0EBcUUNACAEQYAgOwEuDAELAkAgBCgCKCgC8AJBAEdBAXFFDQACQCAEKAIoKALwAkHA3IeAAEZBAXFFDQAgBEGACDsBLgwCCwJAIAQoAigoAqACQcDch4AAQRhqRkEBcUUNACAEQYAQOwEuDAILCyAEQQA7AS4LIAQvAS5B//8DcSEwIARBMGokgICAgAAgMA8L3QIBCn8jgICAgABBwABrIQIgAiSAgICAACACIAA2AjwgAiABNgI4IAIgAigCPEEsEKCHgIAANgI0IAIoAjQhAyACQdQAOwEIIAJBAjsBCiACKAI8IQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgwgAiACKAI4KAIENgIQIAJBADYCFCACIAIoAjgoAgQ2AhggAiACKAI4KAIINgIcIAJBADYCICACQQA2AiQgAkEANgIoIAIgAigCOCgCBDYCLCACIAIoAjgoAgg2AjAgAyACKQIINwIAQSghBiADIAZqIAYgAkEIamooAgA2AgBBICEHIAMgB2ogByACQQhqaikCADcCAEEYIQggAyAIaiAIIAJBCGpqKQIANwIAQRAhCSADIAlqIAkgAkEIamopAgA3AgBBCCEKIAMgCmogCiACQQhqaikCADcCACACKAI0IQsgAkHAAGokgICAgAAgCw8LpQEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIMKAIIIAIoAggoAghLQQFxRQ0AIAIoAggoAgghAyACKAIMIAM2AggLAkAgAigCDCgCDCACKAIIKAIMSUEBcUUNACACKAIIKAIMIQQgAigCDCAENgIMCyACKAIMIAIoAgxBGGogAigCCBDxiYCAACACQRBqJICAgIAADwuaAQEDfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGEEkaiEEIAMgAygCFCgCBDYCDCADIAMoAhQoAgg2AhAgBCADKQIMNwIAIAMoAhQoAgghBSADKAIYIAU2AgwgAygCGCADKAIcIAMoAhQQ8omAgABB//8DcRCeh4CAACADQSBqJICAgIAADwuHAQEGfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgATYCGCAEIAI2AhQgBCADNgIQIAQoAhwhBSAEKAIYIQYgBCgCFCEHIAQoAhAhCCAEQQA2AgQgBEEANgIIIARBADYCDCAFIAYgByAIIARBBGoQ/IeAgAAhCSAEQSBqJICAgIAAIAkPC10BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCACKAIMQRhqIAIoAggQ8YmAgAAgAigCCCgCDCEDIAIoAgwgAzYCDCACQRBqJICAgIAADwucBAEUfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCPCACIAE2AjggAigCOCEDAkACQAJAIANB1gBGDQACQAJAIANB3QBGDQACQCADQYABRg0AIANBgwFGDQEgA0GOAkYNAyADQY8CRg0CDAQLIAIoAjxBiAJqIQQgAigCPCgCwAEhBSACKAI8KALEASEGIAIoAjghByACIAIoAjwoArwBENyKgIAANgIAIAQgBSAGIAcgAhDOhICAABoMBAsgAigCPEGIAmohCCACKAI8KALMASEJIAIoAjwoAtABIQogAigCOCELIAIgAigCPCgCyAEQ3IqAgAA2AhAgCCAJIAogCyACQRBqEM6EgIAAGgwDCwJAAkAgAigCPCgCyAFBAUZBAXFFDQBBqouEgAAhDAwBCyACKAI8KALIARDcioCAACEMCyACIAw2AjQgAigCPEGIAmohDSACKAI8KALAASEOIAIoAjwoAsQBIQ8gAigCOCEQIAIoAjQhESACIAIoAjwoAsABLQAAQf8BcTYCJCACIBE2AiAgDSAOIA8gECACQSBqEM6EgIAAGgwCCyACKAI8QYgCaiESIAIoAjwoAswBIRMgAigCPCgC0AEhFCACKAI4IRUgAiACKAI8KALIARDcioCAADYCMCASIBMgFCAVIAJBMGoQzoSAgAAaDAELIAIoAjwgAigCOBDMh4CAAAsgAkHAAGokgICAgAAPC+0BAQZ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjoAByADKAIMIQQgAygCCCEFIAMtAAchBkEAIQcgAyAEIAUgBkEBcSAHQQFxEMSIgIAANgIAAkAgAygCDEEnEI6HgIAAQQFxDQACQCADKAIMQRsQ6oaAgABBAXFFDQAgAygCDEHSABCOh4CAAEEBcQ0BCwJAIAMoAgxBKRDqhoCAAEEBcUUNACADKAIMQf0AEI6HgIAAQQFxDQELIAMoAgwgAygCAEGfAhDeh4CAAAsgAygCACEIIANBEGokgICAgAAgCA8LtwIBB38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCICAEKAIsIAQoAiQQnomAgAAgBCAEKAIsIAQoAiQQ8ImAgABB//8DcRCsiYCAADYCHCAEKAIoKAIEIQUgBCgCHCAFNgIIIAQoAiQoAgwhBiAEKAIcIAY2AgwgBCgCJCEHIAQoAhwgBzYCECAEKAIcQSBqIQgCQAJAIAQoAigoAgBBA0ZBAXFFDQAgBEEANgIUIARBADYCGCAIIAQpAhQ3AgAMAQsgBCAEKAIoKAIENgIMIAQgBCgCKCgCCDYCECAIIAQpAgw3AgALIAQoAiwgBCgCICAEKAIgEOyLgIAAEJKHgIAAIQkgBCgCHCAJNgIcIAQoAhwhCiAEQTBqJICAgIAAIAoPC/kIAQJ/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADKAIoLwEAQXxqIQQgBEGLAUsaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBA6MAQAREREREREDERERERERERERERERERERERERERELEREREREREREREREMERERERERERERChEREREREREREQ0REREKERERERERERERERERDgcRBggJEREREREREREREREPERERERERERARERERERERARECEREREREEChEFEREREREREREREQoIChERCBEJEQsgAyADKAIoNgIgIAMoAiwgAygCICgCEEEAEOKIgIAAIAMoAiwgAygCICgCFEEAEOKIgIAADBELIAMgAygCKDYCHCADKAIsIAMoAhwoAhBBABDiiICAACADKAIsIAMoAhwoAhRBABDiiICAAAwQCyADIAMoAig2AhgCQCADKAIYKAIQQQBHQQFxRQ0AIAMoAhgoAhAvAQBB//8DcUGMAUZBAXFFDQAgAyADKAIYKAIQNgIUAkAgAygCFCgCEEEBRkEBcUUNACADKAIsIAMoAhQoAhgoAgAgAygCJBDiiICAAAsLDA8LIAMgAygCKDYCEAJAIAMoAhAoAhhBAEdBAXFFDQAgAyADKAIQKAIYNgIMAkAgAygCDCgCEEEBRkEBcUUNACADKAIsIAMoAgwoAhgoAgAgAygCJBDiiICAAAsLDA4LIAMgAygCKDYCCAJAIAMoAggoAhBBAEdBAXFFDQAgAygCLCADKAIIKAIQQQEQ4oiAgAALAkAgAygCCCgCFEEAR0EBcUUNACADKAIsIAMoAggoAhRBARDiiICAAAsgAygCKEE1OwEADA0LIAMoAihB4wA7AQACQCADKAIsLQD8AkH/AXFBAnENACADKAIsIAMoAiggAygCJEG3AkH+toaAABD1iYCAAAsMDAsgAygCKEHTADsBAAJAIAMoAiwtAPwCQf8BcUECcQ0AIAMoAiwgAygCKCADKAIkQbgCQf62hoAAEPWJgIAACwwLCwJAAkAgAygCJEEBRkEBcUUNAAJAIAMoAiwtAPwCQf8BcUECcQ0AIAMoAiwgAygCKEGyAhDJh4CAAAsMAQsgAygCLCADKAIoIAMoAiRBuAJB4bqGgAAQ9YmAgAALDAoLIAMoAiwgAygCKCADKAIkQbcCQY23hoAAEPWJgIAADAkLIAMoAiwgAygCKCADKAIkQbgCQYW3hoAAEPWJgIAADAgLIAMoAiwgAygCKCADKAIkQbgCQeG6hoAAEPWJgIAADAcLIAMoAiwgAygCKCgCHBD2iYCAAAwGCyADKAIsIAMoAigoAhwQ9omAgAAMBQsgAygCLCADKAIoKAIcEPaJgIAADAQLIAMoAiwgAygCKCgCHBD2iYCAAAwDCyADKAIsIAMoAigoAiAQ9omAgAAMAgsgAygCLCADKAIoKAJEEPaJgIAADAELCyADQTBqJICAgIAADwveAwEKfyOAgICAAEEwayEFIAUkgICAgAAgBSAANgIsIAUgATYCKCAFIAI2AiQgBSADNgIgIAUgBDsBHiAFKAIsIAUoAigQnomAgAAgBSgCLCAFKAIgEJ6JgIAAIAUgBSgCLCAFKAIoEPCJgIAAQf//A3EgBS8BHkH//wNxckH//wNxEKyJgIAANgIYAkACQCAFKAIoKAIIIAUoAiAoAghJQQFxRQ0AIAUoAigoAgghBgwBCyAFKAIgKAIIIQYLIAYhByAFKAIYIAc2AggCQAJAIAUoAigoAgwgBSgCICgCDEtBAXFFDQAgBSgCKCgCDCEIDAELIAUoAiAoAgwhCAsgCCEJIAUoAhggCTYCDCAFKAIoIQogBSgCGCAKNgIQIAUoAhhBIGohCwJAAkAgBSgCJCgCAEEDRkEBcUUNACAFQQA2AhAgBUEANgIUIAsgBSkCEDcCAAwBCyAFIAUoAiQoAgQ2AgggBSAFKAIkKAIINgIMIAsgBSkCCDcCAAsgBSAFKAIsEJGHgIAANgIEIAUoAgQgBSgCIBCUh4CAACAFKAIEIQwgBSgCGCAMNgIwIAUoAiwgBSgCJBCrh4CAACENIAUoAhggDTYCHCAFKAIYIQ4gBUEwaiSAgICAACAODwu1AgMEfwF8An8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMLwEAIQICQAJAAkACQAJAIAJBNkYNACACQcQARg0CAkAgAkHSAEYNACACQfsARg0CDAQLIAEgASgCDDYCCCABKAIIIQMgAyADKAIIQX9qNgIIIAEoAghBAToAHAwECyABIAEoAgw2AgQgASgCBCEEIAQgBCgCCEF/ajYCCCABKAIEKwMQmiEFIAEoAgQgBTkDEAwDCyABIAEoAgw2AgAgASgCACEGIAYgBigCCEF/ajYCCCABKAIAQQE6ABwMAgsgASgCDCEHIAcgBygCCEF/ajYCCCABKAIMKAIQEOSIgIAADAELQeK2hoAAQbPQhYAAQfWKAUHly4WAABCOgICAAAALIAFBEGokgICAgAAPC7IEAQt/I4CAgIAAQdAAayEDIAMkgICAgAAgAyAANgJMIAMgATYCSCADIAI2AkQgAyADKAJMQTAQoIeAgAA2AkACQAJAIAMoAkQoAgBBA0dBAXFFDQAgAyADKAJEKAIENgI8DAELAkACQCADKAJIQQBHQQFxRQ0AIAMgAygCSCgCCDYCPAwBCyADQQA2AjwLCwJAAkAgAygCSEEAR0EBcUUNACADIAMoAkgoAgw2AjgMAQsCQAJAIAMoAkQoAgBBA0dBAXFFDQAgAyADKAJEKAIINgI4DAELIANBADYCOAsLIAMoAkAhBCADQRA7AQggA0EAOwEKIAMoAkwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCDCADIAMoAjw2AhAgAyADKAI4NgIUIAMgAygCSDYCGCADQQA2AhwgA0EANgIgIANBADYCJCADQQhqQSBqIQcCQAJAIAMoAkQoAgBBA0ZBAXFFDQAgB0EANgIAIAdBADYCBAwBCyAHIAMoAkQoAgQ2AgAgByADKAJEKAIINgIECyADQQA2AjAgA0EANgI0IAQgAykCCDcCAEEoIQggBCAIaiAIIANBCGpqKQIANwIAQSAhCSAEIAlqIAkgA0EIamopAgA3AgBBGCEKIAQgCmogCiADQQhqaikCADcCAEEQIQsgBCALaiALIANBCGpqKQIANwIAQQghDCAEIAxqIAwgA0EIamopAgA3AgAgAygCQCENIANB0ABqJICAgIAAIA0PC4MFAQt/I4CAgIAAQSBrIQYgBiSAgICAACAGIAA2AhwgBiABOgAbIAYgAjYCFCAGIAM6ABMgBiAEOgASIAYgBTsBECAGQQA2AgwCQCAGKAIcQY4BEI6HgIAAQQFxDQAgBigCHCEHIAYtABMhCEEOQTAgCEEBcRshCSAGLQAbIQogBi0AEiELIAYvARBB//8DcUEBaiEMQQAhDUEBIQ4gBiAHIAkgDUEBcSAKQQFxIA1BAXEgC0EBcSAOQQFxIAxB//8DcRC9iICAADYCDAsgBiAGKAIcIAYoAgwgBigCFBDliICAADYCCAJAIAYoAhQoAgBBA0dBAXFFDQAgBigCHEH5ABDLh4CAABoCQCAGKAIcQY4BEMuHgIAAQQFxRQ0AA0AgBigCHCgCyAFBaGohDyAPQSFLGgJAAkACQAJAAkACQCAPDiIDBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQCBAQEBAQEBAQBBAsgBigCHEEMEO2GgIAAIAYoAhwQvoaAgAAMBAsgBigCHEEOEO2GgIAAIAYoAhwQvoaAgAAMAwsgBigCHEENEO2GgIAAIAYoAhwQvoaAgAAMAgsgBigCHEELEO2GgIAAIAYoAhwQvoaAgAAMAQsgBigCHEE3QSIQ2IeAgAALIAYgBigCHCAGKAIcQbwBahDTiYCAAEEBcToAByAGKAIcIAYoAhxBvAFqQQEQ1ImAgAAaIAYgBigCHCAGKAIcQbwBahD3iYCAADYCAAJAIAYtAAdBAXFFDQAgBigCABDWiYCAAAsgBigCCCAGKAIAEPiJgIAAIAYoAhxBGxDLh4CAAEEBcQ0ACwsLIAYoAgghECAGQSBqJICAgIAAIBAPC8QBAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkAgAigCCCgCAEGFAUZBAXENACACKAIIKAIAQf0ARkEBcQ0AIAIoAggoAgBBAkZBAXENAEGV+oWAAEGz0IWAAEGCFEHwpoSAABCOgICAAAALIAIoAggoAgghAyACKAIMIAM2AgwgAigCDEEoaiEEIAIgAigCCCgCBDYCACACIAIoAggoAgg2AgQgBCACKQIANwIAIAJBEGokgICAgAAPC74BAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASABKAIIKAKUAjYCBAJAA0ACQCABKAIEKAIAQQBGQQFxRQ0AIAFBAUEBcToADwwCCwJAIAEoAgQtAB5BAXFFDQAgAUEAQQFxOgAPDAILIAEoAgQoAgAhAiABIAI2AgQgAkEAR0EBcQ0AC0HitoaAAEGz0IWAAEHUBEG124SAABCOgICAAAALIAEtAA9BAXEhAyABQRBqJICAgIAAIAMPC5IIAQp/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI4IAQgATYCNCAEIAI2AjAgBCADNgIsIAQgBCgCOCgClAJBEGo2AigCQAJAIAQoAjRBAEdBAXFFDQACQCAEKAIoKAIAQQBLQQFxRQ0AIAQgBCgCKCgCCCgCADYCJAJAAkAgBCgCJC8BAEH//wNxQeAARkEBcUUNACAEKAI4IAQoAiRBwwEQ3oeAgAAMAQsCQAJAIAQoAiQvAQBB//8DcUHYAEZBAXFFDQAgBCgCOCAEKAIkQakBEN6HgIAADAELQeK2hoAAQbPQhYAAQZH4AEHJsoSAABCOgICAAAALCwsgBCAEKAI0NgI8DAELAkAgBCgCKCgCAA0AIARBADYCPAwBCyAEQQA6ACMgBEEAOgAiIARBADYCHAJAA0AgBCgCHCAEKAIoKAIASUEBcUUNASAEIAQoAigoAgggBCgCHEECdGooAgA2AhgCQAJAIAQoAhgvAQBB//8DcUHgAEZBAXFFDQACQAJAIAQtACJBAXFFDQAgBCgCOCAEKAIYQcIBEN6HgIAADAELAkACQCAEKAI4EPmJgIAAQQFxRQ0AIAQoAjggBCgCGEHEARDeh4CAAAwBCwJAAkAgBCgCOCgClAItABxB/wFxQSBxRQ0AIAQoAjggBCgCGEHBARDeh4CAAAwBCwJAAkAgBCgCGCgCCCAEKAIYKAIMEPuGgIAAQQFxRQ0AAkACQCAELQAjQf8BcSAEKAIYKAIILQABQf8BcUEwa0H/AXFKQQFxRQ0AIAQtACNB/wFxIQUMAQsgBCgCGCgCCC0AAUH/AXFBMGtB/wFxIQULIAQgBToAIwwBC0HitoaAAEGz0IWAAEGx+ABBybKEgAAQjoCAgAAACwsLCwwBCwJAIAQoAhgvAQBB//8DcUHYAEZBAXFFDQACQAJAIAQtACNB/wFxQQBKQQFxRQ0AIAQoAjggBCgCGEGoARDeh4CAAAwBCyAEQQE6ACILCwsgBCAEKAIcQQFqNgIcDAALCwJAIAQtACNB/wFxQQBKQQFxRQ0AIAQgBCgCOCgClAIoAgA2AhQDQCAEKAIUQQBHIQZBACEHIAZBAXEhCCAHIQkCQCAIRQ0AIAQoAhQtAB5Bf3MhCQsCQCAJQQFxRQ0AIAQoAhQhCiAKIAotABxB/wFxQSByOgAcIAQgBCgCFCgCADYCFAwBCwsgBCAEKAIwKAIENgIMIAQgBCgCLCgCCDYCECAEKAI4IQsgBC0AIyEMIAQgCyAEQQxqIAxB/wFxEPqJgIAANgI8DAELAkAgBC0AIkEBcUUNACAEIAQoAjggBCgCMCAEKAIsEPuJgIAANgI8DAELIARBADYCPAsgBCgCPCENIARBwABqJICAgIAAIA0PC/wDAQ9/I4CAgIAAQeAAayEHIAckgICAgAAgByAANgJcIAcgATYCWCAHIAI2AlQgByADNgJQIAcgBDYCTCAHIAU2AkggByAGNgJEIAcgBygCXEE8EKCHgIAANgJAIAcoAkAhCCAHQdwAOwEEIAdBADsBBiAHKAJcIQkgCSgCAEEBaiEKIAkgCjYCACAHIAo2AgggByAHKAJUKAIENgIMIAcgBygCTCgCCDYCECAHQQRqQRBqIQsgBygCWCEMIAsgDCkCADcCAEEIIQ0gCyANaiAMIA1qKAIANgIAIAcgBygCVCgCBDYCICAHIAcoAlQoAgg2AiQgByAHKAJQKAIENgIoIAcgBygCUCgCCDYCLCAHIAcoAkwoAgQ2AjAgByAHKAJMKAIINgI0IAcgBygCSDYCOCAHIAcoAkQ2AjwgCCAHKQIENwIAQTghDiAIIA5qIA4gB0EEamooAgA2AgBBMCEPIAggD2ogDyAHQQRqaikCADcCAEEoIRAgCCAQaiAQIAdBBGpqKQIANwIAQSAhESAIIBFqIBEgB0EEamopAgA3AgBBGCESIAggEmogEiAHQQRqaikCADcCAEEQIRMgCCATaiATIAdBBGpqKQIANwIAQQghFCAIIBRqIBQgB0EEamopAgA3AgAgBygCQCEVIAdB4ABqJICAgIAAIBUPC5kQASt/I4CAgIAAQZABayEEIAQkgICAgAAgBCAANgKIASAEIAE2AoQBIAQgAjYCgAEgBCADOwF+IAQoAogBQbwBaiEFQQghBiAFIAZqKAIAIQcgBiAEQfAAamogBzYCACAEIAUpAgA3A3ACQAJAIAQoAoQBKAIAQQZHQQFxRQ0AAkAgBCgCgAFFDQAgBCgCiAEgBCgCgAEQ04aAgAALIAQoAogBKALIAUF8aiEIIAhBngFLGgJAAkACQAJAIAgOnwEAAgICAgABAAAAAgICAgAAAgACAgECAgICAQICAgICAgICAgIAAAIAAgICAgEAAAACAgIBAgECAgICAQEBAQEBAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQIBAQEBAQEBAQIBAgEBAgEBAQECAgIAAAAAAgEAAgICAQICAgACAgICAgIAAgICAAICAgICAAIAAgACAgICAgAAAgICAAAAAAACCyAEKAKIASEJAkACQCAEKAKAAQ0AQQghCgwBCyAEKAKAASEKCyAKIQsgBCAJIARB8ABqIAsQs4mAgAA2AowBDAQLIAQoAogBEL6GgIAADAELIAQoAogBQTdB9QBBiAIQtIiAgAALIAQoAogBIQwgBEHkAGogDBDUh4CAACAEKAKIASENIAQoAogBQbwBaiEOIAQgDSAEQfAAaiAOIARB5ABqEKmJgIAANgJgIAQoAmBBKGogBCgCiAEoAsABIAQoAogBKALEARCni4CAACAEKAJgIAQoAogBIAQoAogBQbwBaiAEKAJgQShqQQBBAXEQqomAgABB//8DcRCeh4CAACAEIAQoAmA2AowBDAELAkAgBCgChAEtAAhBAXFFDQACQCAEKAKIAUGXARCOh4CAAEEBcUUNAAJAIAQoAoABRQ0AIAQoAogBIAQoAoABENOGgIAACyAEKAKIARC+hoCAACAEKAKIASEPIARB1ABqIA8Q1IeAgAAgBCgCiAFBvAFqIRBBCCERIBAgEWooAgAhEiARIARByABqaiASNgIAIAQgECkCADcDSCAEIAQoAogBIARB8ABqIARB1ABqIARByABqEKmJgIAANgKMAQwCCyAEIAQoAogBIAQvAX5B//8DcUEBakH//wNxEP6HgIAANgJEAkAgBCgCREEAR0EBcUUNACAEKAJELwEAQf//A3FBjQFGQQFxRQ0AIAQoAogBQZcBQQEQwYeAgABBAXFFDQACQCAEKAKAAUUNACAEKAKIASAEKAKAARDThoCAAAsgBCgCiAFBlwFBigIQ2IeAgAAgBCgCiAEhEyAEKAJEIRQgBCgCiAFBvAFqIRUgBCATIBQgBEHwAGogFRD8iYCAADYCjAEMAgsgBCgCiAEhFiAEQfAAaiEXIAQgFiAXQQAgFxDTiICAADYCQAJAIAQoAkRBAEdBAXFFDQAgBCgCQCAEKAJEENKIgIAACwJAA0AgBCgCiAFBlwFBARDBh4CAAEF/c0EBcUUNASAEKAKIASAELwF+Qf//A3FBAWpB//8DcRD+h4CAACEYIAQgGDYCRAJAIBhBAEdBAXFFDQAgBCgCQCAEKAJEENKIgIAACwwACwsCQCAEKAKAAUUNACAEKAKIASAEKAKAARDThoCAAAsCQAJAIAQoAogBQQEQjoeAgABBAXFFDQAgBCgCiAEgBEHwAGpBigIQqIeAgAAMAQsgBCgCiAFBlwFBigIQ2IeAgAALIAQoAkAgBCgCiAFBvAFqEP2JgIAAIAQgBCgCQDYCjAEMAQsCQAJAIAQoAogBQZYBEI6HgIAAQQFxRQ0AIAQoAogBQcgBaiEZQQghGiAZIBpqKAIAIRsgGiAEQTBqaiAbNgIAIAQgGSkCADcDMCAEKAKIAUHgAmohHEEIIR0gHCAdaigCACEeIB0gBEEgamogHjYCACAEIBwpAgA3AyAgBCgCiAEQvoaAgAACQCAEKAKIAUGWARCOh4CAAEEBcUUNACAEKAKIASEfIARB8ABqISAgBCAfICBBACAgENOIgIAANgIcIAQoAogBISEgBEEQaiAhENSHgIAAIAQoAogBISIgBEEQaiEjIAQgIiAjIARBMGogIyAEQSBqEP2HgIAANgIMIAQoAhwgBCgCDBDSiICAACAEKAKIASEkIAQoAogBQcgBaiElIAQoAogBQeACaiEmIARBEGohJyAEICQgJyAlICcgJhD9h4CAADYCDCAEKAIcIAQoAgwQ0oiAgAACQCAEKAKAAUUNACAEKAKIASAEKAKAARDThoCAAAsgBCgCiAEQvoaAgAAgBCgCiAFBlwFBiQIQ2IeAgAAgBCgCHCAEKAKIAUG8AWoQ/YmAgAAgBCAEKAIcNgKMAQwDCwwBCyAEQZYBNgIAIAQgBCgCiAEoAsQBNgIEIAQgBCgCiAEoAsQBNgIIQQghKCAoIARBMGpqIAQgKGooAgA2AgAgBCAEKQIANwMwIAQoAjQhKSAEKAI4ISogBEEgaiApICoQp4uAgAALAkAgBCgCgAFFDQAgBCgCiAEgBCgCgAEQ04aAgAALAkACQCAEKAKIAUEBEI6HgIAAQQFxRQ0AIAQoAogBIARB8ABqQYkCEKiHgIAADAELIAQoAogBQZcBQYkCENiHgIAACyAEKAKIASErIAQoAogBQbwBaiEsIAQoAogBIARBMGogBEEgakEAQQFxEKqJgIAAIS0gBCArIARB8ABqIARBMGogLCAEQSBqIC1B//8DcRCriYCAADYCjAELIAQoAowBIS4gBEGQAWokgICAgAAgLg8LoAEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAiACKAIIKAKYAjYCAAJAAkADQCACKAIAQQBHQQFxRQ0BAkAgAigCACgCACACKAIEEIqHgIAAQQFxRQ0AIAIgAigCACgCADYCDAwDCyACIAIoAgAoAgQ2AgAMAAsLIAJBADYCDAsgAigCDCEDIAJBEGokgICAgAAgAw8LzgUBA38jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIIQIgAkE1SxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg42AAEOCxwCAw4LHAQFBg4LHAcOCxwICgkLDA0PEBESEw4LHBQVFg4LHBcYGRobHB0OCxweHyAhIgtB4raGgABBs9CFgABBt8QAQdPuhIAAEI6AgIAAAAsgAUGKmISAADYCDAwhCyABQYaBhYAANgIMDCALIAFBlYGFgAA2AgwMHwsgAUGDpYWAADYCDAweCyABQfekhYAANgIMDB0LIAFB7OGEgAA2AgwMHAsgAUHD44SAADYCDAwbCyABQY21hIAANgIMDBoLIAFBjY+FgAA2AgwMGQsgAUGk6oSAADYCDAwYCyABQbClhYAANgIMDBcLIAFBkaWFgAA2AgwMFgsgAUHY6YSAADYCDAwVCyABQb6lhYAANgIMDBQLIAFBjtqEgAA2AgwMEwsgAUGQiISAADYCDAwSCyABQd2YhIAANgIMDBELIAFBqYCFgAA2AgwMEAsgAUG/gIWAADYCDAwPCyABQZ6ihYAANgIMDA4LIAFBzYqEgAA2AgwMDQsgAUH94YSAADYCDAwMCyABQYiwhIAANgIMDAsLIAFBm7yEgAA2AgwMCgsgAUG1gYWAADYCDAwJCyABQaOihYAANgIMDAgLIAFBp4GFgAA2AgwMBwsgAUGgpYWAADYCDAwGCyABQeLhhIAANgIMDAULIAFByuaEgAA2AgwMBAsgAUH5l4SAADYCDAwDCyABQZqYhIAANgIMDAILIAFBqpmEgAA2AgwMAQtB4raGgABBs9CFgABB8MQAQdPuhIAAEI6AgIAAAAsgASgCDCEDIAFBEGokgICAgAAgAw8LjAEBAn8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAE2AhggBCACNgIUIAQgAzYCECAEIAQoAhwgBCgCGCAEKAIUEMCHgIAANgIMAkAgBCgCDEUNACAEKAIcIAQoAgwgBCgCGCAEKAIUIAQoAhAQsoaAgAALIAQoAgwhBSAEQSBqJICAgIAAIAUPC8AHARp/I4CAgIAAQeAAayEGIAYkgICAgAAgBiAANgJYIAYgATYCVCAGIAI2AlAgBiADOgBPIAYgBDYCSCAGIAU7AUYgBkEBOgBFAkAgBigCVEECR0EBcUUNACAGKAJYQaEBEI6HgIAAQQFxRQ0AIAZBADoARQsgBigCWCEHIAYoAlAhCAJAAkAgBigCVEESRkEBcUUNACAGLQBPQQFxIQkMAQsgBigCVEEMSUEBcSEJCyAJQQBHIQogBigCSCELIAYvAUZB//8DcUEBaiEMIAYgByAIIApBAXEgCyAMQf//A3EQwYmAgAA2AkACQCAGLQBFQQFxDQAgBigCWCAGKAJAQZUCEN6HgIAACyAGKAJYIAYoAkAQoYqAgAAgBkEBOgA/AkAgBigCVEECRkEBcUUNAAJAIAYoAkAvAQBB//8DcUGLAUZBAXENACAGKAJYQRsQjoeAgABBAXFFDQELIAZBADoAPyAGKAJYIQ0gBkEwaiANENSHgIAAIAYgBigCWCAGQTBqEMqHgIAANgIsIAYoAiwgBigCQBDVh4CAACAGIAYoAiw2AkACQANAIAYoAlhBGxDLh4CAAEEBcUUNASAGKAJYIQ4gBigCUCEPIAYvAUZB//8DcUEBaiEQQQAhEUEYIRIgBiAOIA8gEUEBcSASIBBB//8DcRDBiYCAADYCKCAGKAIsIAYoAigQ1YeAgAACQCAGKAIoLwEAQf//A3FB5wBGQQFxRQ0ADAILIAYoAlggBigCKBChioCAAAwACwsLAkACQAJAIAYtAD9BAXENACAGKAJQQRFGQQFxRQ0BCyAGKAJYQdoAEI6HgIAAQQFxRQ0AIAYoAlhBLRCLh4CAABogBigCWEHIAWohE0EIIRQgEyAUaigCACEVIBQgBkEYamogFTYCACAGIBMpAgA3AxggBigCWBC+hoCAACAGQQA6ABcCQCAGKAJALwEAQf//A3FBE0ZBAXFFDQAgBiAGKAJANgIQAkAgBigCECgCMEEAR0EBcUUNACAGKAIQKAIoQQBGQQFxRQ0AIAZBAToAFwsLIAYoAlghFkEAKAL8komAACEXIAYtABchGCAGLwFGQf//A3FBAWohGUEAIRpB+gEhGyAGIBYgFyAYQQFxIBpBAXEgGyAZQf//A3EQjIeAgAA2AgwgBigCWBCPh4CAACAGKAJYIRwgBigCQCEdIAYoAgwhHiAGIBwgHSAGQRhqIB4Qv4iAgAA2AlwMAQsgBiAGKAJANgJcCyAGKAJcIR8gBkHgAGokgICAgAAgHw8L5REBIH8jgICAgABBkAFrIQQgBCSAgICAACAEIAA2AogBIAQgATYChAEgBCACNgKAASAEIAM2AnwgBCgChAEvAQBBdmohBSAFQYEBSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAUOggEEDAwMDAwMDAwLDAwMDAwMDAwMDAEMDAwMDAwCDAwMDAMMDAwMDAwMDAwMDAwMDAwMDAwMBQwMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwHDAwMDAwMDAYMDAwMDAwADAkMDAwMDAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwKDAsgBCgCiAEgBCgCfBChhoCAACAEIAQoAoQBNgKMAQwMCyAEIAQoAogBIAQoAoQBIAQoAoABIAQoAnwQooqAgAA2AnggBCgCiAEgBCgChAEQoYaAgAAgBCAEKAJ4NgKMAQwLCyAEIAQoAogBIAQoAoQBIAQoAoABIAQoAnwQo4qAgAA2AnQCQCAEKAKIARC1iICAAEEBcUUNACAEKAKIASAEKAJ0QZ0CEN6HgIAACyAEIAQoAogBIAQoAnQQ9oiAgAA2AowBDAoLIAQgBCgCiAEgBCgChAEgBCgCgAEgBCgCfBCkioCAADYCcAJAIAQoAogBELWIgIAAQQFxRQ0AIAQoAogBIAQoAnBBnQIQ3oeAgAALIAQoAogBIAQoAoQBEKGGgIAAIAQgBCgCiAEgBCgCcBD2iICAADYCjAEMCQsgBCgCiAFBiAJqIQYgBCgChAEoAgghByAEKAKEASgCDCEIIAQoAoQBKAIMIAQoAoQBKAIIayEJIAQgBCgChAEoAgg2AgQgBCAJNgIAIAYgByAIQZ4CIAQQzoSAgAAaCyAEIAQoAogBIAQoAoQBIAQoAoABIAQoAnwQpYqAgAA2AmwgBCgCiAEgBCgChAEQoYaAgAAgBCAEKAJsNgKMAQwHCyAEIAQoAoQBNgJoIAQgBCgCaCgCEDYCZCAEIAQoAoQBQQhqKQIANwNYIAQgBCgCaCgCFDYCVCAEIAQoAogBIAQoAlQQ+IeAgAA2AlACQCAEKAKEASgCCCAEKAKEASgCDBD7hoCAAEEBcUUNACAEKAJQLQAcQf8BcUHAAHEhCiAEQfYAQdABIAobNgJMIAQoAogBQYgCaiELIAQoAoQBKAIIIQwgBCgChAEoAgwhDSAEKAJMIQ4gBCAEKAKEASgCCDYCECALIAwgDSAOIARBEGoQzoSAgAAaIAQoAogBIAQoAoQBEPeHgIAACyAEKAJQQQRqIAQoAmQQ+YeAgAAgBCgCiAEgBCgChAEQoYaAgAAgBCgCiAEhDyAEKAJkIRAgBCgCVCERIAQoAnwhEiAEKAKAASETIAQgDyAQIBEgEiAEQdgAaiATEKaKgIAANgKMAQwGCyAEIAQoAogBQaymhIAAQQIQ+YiAgAA2AkggBCgCiAEhFCAEKAJIIRUgBCgCfCEWIAQoAoQBQQhqIRcgBCgCgAEhGCAEIBQgFUEAIBYgFyAYEKaKgIAANgJEIAQoAogBIAQoAoQBEPeHgIAAIAQoAogBIAQoAoQBEKGGgIAAIAQgBCgCRDYCjAEMBQsgBCAEKAKIASAEKAKEASAEKAKAASAEKAJ8EKeKgIAANgJAIAQoAogBIAQoAoQBEKGGgIAAIAQgBCgCQDYCjAEMBAsgBCAEKAKIASAEKAKEASAEKAKAASAEKAJ8EN+HgIAANgKMAQwDCyAEIAQoAoQBNgI8AkAgBCgCPCgCGEEAR0EBcUUNACAEKAKIASAEKAI8KAIYIAQoAoABIAQoAnwQ8IiAgAAhGSAEKAI8IBk2AhgLIAQgBCgCiAEQ24eAgAA2AjggBCgCiAEgBCgCOCAEKAI8ENyHgIAAIAQgBCgCiAEgBCgCOCAEKAKAASAEKAJ8EN+HgIAANgKMAQwCCyAEIAQoAoQBNgI0AkAgBCgCNCgCIEEAR0EBcUUNACAEKAI0KAIkQX9qLQAAQf8BcUEhR0EBcUUNACAEKAI0KAIkQX9qLQAAQf8BcUE/R0EBcUUNACAEKAI0KAIoQQBGQQFxRQ0AIAQoAjQoAjBBAEZBAXFFDQAgBCgCNCgCPEEARkEBcUUNAAJAIAQoAjQoAhBBAEZBAXFFDQAgBCAEKAI0QSBqKQIANwMoIAQoAogBIAQoAiggBCgCLEEAEO6IgIAAGiAEKAKIASAEKAKEARChhoCAACAEIAQoAogBIAQoAiggBCgCLBDAh4CAADYCJCAEKAKIASEaIAQoAiQhGyAEKAJ8IRwgBCgCgAEhHSAEIBogG0EAIBwgBEEoaiAdEKaKgIAANgKEASAEKAKIASAEKAIoIAQoAiwQuIiAgAAgBCAEKAKEATYCjAEMAwsCQCAEKAKIASAEKAI0KAIgIAQoAogBKAK4ASAEKAI0KAIgaxD2hoCAAEUNACAEIAQoAogBEJGHgIAANgIgIAQoAiAhHiAEKAI0IB42AjAgBCgCICAEKAJ8EJSHgIAAIAQoAiAoAgwhHyAEKAI0IB82AgwgBCgCiAEgBCgCNEEcahD9iICAACAEKAI0IAQoAnxBwABB//8DcRCniYCAAEH//wNxQRByQf//A3EQnoeAgAAgBCAEKAI0NgKMAQwDCwsCQCAEKAI0LwECQf//A3FBgAJxRQ0AAkAgBCgCNCgCMEEARkEBcUUNACAEKAKIARCRh4CAACEgIAQoAjQgIDYCMAsgBCgCNCgCMCAEKAJ8EJSHgIAAIAQoAnwoAgwhISAEKAKEASAhNgIMIAQoAogBQbeUhoAAQQMQkoeAgAAhIiAEKAI0ICI2AhwgBCgCiAEgBCgCNCgCMCAEKAI0KAI8EJ+KgIAAIAQoAjQgBCgCfEHAAEH//wNxEKeJgIAAQf//A3FBEHJB//8DcRCeh4CAACAEIAQoAoQBNgKMAQwCCyAEKAKIASAEKAJ8EKGGgIAACyAEKAKIASAEKAKAAUGfAhCoh4CAACAEIAQoAoQBNgKMAQsgBCgCjAEhIyAEQZABaiSAgICAACAjDwuoAwEIfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgATYCGCAEIAI2AhQgBCADNgIQIAQoAhgvAQAhBQJAAkACQAJAAkACQAJAAkAgBUEzRg0AIAVB7ABGDQMgBUGFAUYNBAJAIAVBiAFGDQAgBUGJAUYNAiAFQYoBRg0DIAVBkAFGDQYMBwsgBCgCHCAEKAIUQfEAEKiHgIAADAcLIAQoAhwgBCgCFEHyABCoh4CAAAwGCyAEKAIcIAQoAhRB8wAQqIeAgAAMBQsgBCgCHCAEKAIUQfQAEKiHgIAADAQLIAQoAhwgBCgCFEH1ABCoh4CAAAwDCyAEKAIcIAQoAhRB9wAQqIeAgAAMAgsgBCgCHCAEKAIUQfgAEKiHgIAADAELCyAEIAQoAhwgBCgCGCgCCCAEKAIYKAIMQQEQ7oiAgAA2AgwgBCgCHCEGIAQoAgwhByAEKAIQIQggBCgCGEEIaiEJIAQoAhQhCiAEIAYgB0EAIAggCSAKEKaKgIAANgIIIAQoAhwgBCgCGBChhoCAACAEKAIIIQsgBEEgaiSAgICAACALDwvHAwEUfyOAgICAAEHAAGshBiAGJICAgIAAIAYgADYCOCAGIAE2AjQgBiACNgIwIAYgAzoALyAGIAQ2AiggBiAFOwEmIAYoAjghByAGKAIwIQgCQAJAIAYoAjRBEkZBAXFFDQAgBi0AL0EBcSEJDAELIAYoAjRBDElBAXEhCQsgCUEARyEKIAYoAighCyAGLwEmQf//A3FBAWohDEEAIQ0gBiAHIAggCkEBcSANQQFxIAsgDEH//wNxEM+HgIAANgIgAkACQCAGKAI4QdoAEI6HgIAAQQFxRQ0AIAYoAjhBLRCLh4CAABogBigCOEHIAWohDkEIIQ8gDiAPaigCACEQIA8gBkEQamogEDYCACAGIA4pAgA3AxAgBigCOBC+hoCAACAGKAI4IRFBACgC/JKJgAAhEiAGLwEmQf//A3FBAWohE0EAIRRB+gEhFSAGIBEgEiAUQQFxIBRBAXEgFSATQf//A3EQjIeAgAA2AgwgBigCOBCPh4CAACAGKAI4IRYgBigCICEXIAYoAgwhGCAGIBYgFyAGQRBqIBgQv4iAgAA2AjwMAQsgBiAGKAIgNgI8CyAGKAI8IRkgBkHAAGokgICAgAAgGQ8LjgMBCX8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjACQCAEKAI0KAIAQQZGQQFxDQBB2feFgABBs9CFgABBlSNB+JyFgAAQjoCAgAAACyAEIAQoAjxBKBCgh4CAADYCLCAEKAIsIQUgBEE7OwEEIARBADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjwgBCgCOBCoioCAADYCFCAEQQRqQRRqIAQoAjhBCGopAgA3AgAgBCAEKAI0KAIENgIgIAQgBCgCNCgCCDYCJCAEIAQoAjA2AiggBSAEKQIENwIAQSAhCCAFIAhqIAggBEEEamopAgA3AgBBGCEJIAUgCWogCSAEQQRqaikCADcCAEEQIQogBSAKaiAKIARBBGpqKQIANwIAQQghCyAFIAtqIAsgBEEEamopAgA3AgAgBCgCLCEMIARBwABqJICAgIAAIAwPC4YDAQl/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwAkAgBCgCNCgCAEEGRkEBcQ0AQdn3hYAAQbPQhYAAQdkaQaichYAAEI6AgIAAAAsgBCAEKAI8QSgQoIeAgAA2AiwgBCgCLCEFIARBGzsBBCAEQQA7AQYgBCgCPCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIIIAQgBCgCOCgCCDYCDCAEIAQoAjAoAgw2AhAgBCAEKAI4KAIQNgIUIARBBGpBFGogBCgCOEEIaikCADcCACAEIAQoAjQoAgQ2AiAgBCAEKAI0KAIINgIkIAQgBCgCMDYCKCAFIAQpAgQ3AgBBICEIIAUgCGogCCAEQQRqaikCADcCAEEYIQkgBSAJaiAJIARBBGpqKQIANwIAQRAhCiAFIApqIAogBEEEamopAgA3AgBBCCELIAUgC2ogCyAEQQRqaikCADcCACAEKAIsIQwgBEHAAGokgICAgAAgDA8L1gIBCH8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjACQCAEKAI0KAIAQQZGQQFxDQBB2feFgABBs9CFgABB4xtBgZyFgAAQjoCAgAAACyAEIAQoAjxBIBCgh4CAADYCLCAEKAIsIQUgBEEkOwEMIARBADsBDiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAI4KAIINgIUIAQgBCgCMCgCDDYCGCAEIAQoAjg2AhwgBCAEKAI0KAIENgIgIAQgBCgCNCgCCDYCJCAEIAQoAjA2AiggBSAEKQIMNwIAQRghCCAFIAhqIAggBEEMamopAgA3AgBBECEJIAUgCWogCSAEQQxqaikCADcCAEEIIQogBSAKaiAKIARBDGpqKQIANwIAIAQoAiwhCyAEQcAAaiSAgICAACALDwuGAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACIAIoAggQqYqAgAA6AAMCQAJAIAItAANB/wFxRQ0AIAIgAigCCCACKAIEIAItAANB/wFxEKqKgIAANgIMDAELIAIgAigCBDYCDAsgAigCDCEDIAJBEGokgICAgAAgAw8LhgMBCX8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjACQCAEKAI0KAIAQQZGQQFxDQBB2feFgABBs9CFgABB5hxBwZuFgAAQjoCAgAAACyAEIAQoAjxBKBCgh4CAADYCLCAEKAIsIQUgBEEhOwEEIARBADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjgoAhA2AhQgBEEEakEUaiAEKAI4QQhqKQIANwIAIAQgBCgCNCgCBDYCICAEIAQoAjQoAgg2AiQgBCAEKAIwNgIoIAUgBCkCBDcCAEEgIQggBSAIaiAIIARBBGpqKQIANwIAQRghCSAFIAlqIAkgBEEEamopAgA3AgBBECEKIAUgCmogCiAEQQRqaikCADcCAEEIIQsgBSALaiALIARBBGpqKQIANwIAIAQoAiwhDCAEQcAAaiSAgICAACAMDwuHAwEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMAJAIAQoAjQoAgBBBkZBAXENAEHZ94WAAEGz0IWAAEGsJ0GhnYWAABCOgICAAAALIAQgBCgCPEEoEKCHgIAANgIsIAQoAiwhBSAEQcwAOwEEIARBADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjgoAhA2AhQgBEEEakEUaiAEKAI4QQhqKQIANwIAIAQgBCgCNCgCBDYCICAEIAQoAjQoAgg2AiQgBCAEKAIwNgIoIAUgBCkCBDcCAEEgIQggBSAIaiAIIARBBGpqKQIANwIAQRghCSAFIAlqIAkgBEEEamopAgA3AgBBECEKIAUgCmogCiAEQQRqaikCADcCAEEIIQsgBSALaiALIARBBGpqKQIANwIAIAQoAiwhDCAEQcAAaiSAgICAACAMDwuKAQECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAyADKAIMIAMoAgggAygCBBCSh4CAADYCAAJAIAMoAgBFDQAgAygCDCADKAIAIAMoAgwoArQBIAMoAgwoArQBQQEQsoaAgAALIAMoAgAhBCADQRBqJICAgIAAIAQPC5MEAQp/I4CAgIAAQdAAayEGIAYkgICAgAAgBiAANgJMIAYgATYCSCAGIAI2AkQgBiADNgJAIAYgBDYCPCAGIAU2AjgCQCAGKAJILwEAQf//A3FB4ABGQQFxDQAgBigCSC8BAEH//wNxQdgARkEBcQ0AIAYoAkgvAQBB//8DcUETRkEBcQ0AQdqqhoAAQbPQhYAAQacsQdCchYAAEI6AgIAAAAsCQCAGKAJEKAIAQQZGQQFxDQBB2feFgABBs9CFgABBqCxB0JyFgAAQjoCAgAAACyAGIAYoAkxBLBCgh4CAADYCNCAGKAI0IQcgBkHdADsBCCAGQQA7AQogBigCTCEIIAgoAgBBAWohCSAIIAk2AgAgBiAJNgIMIAYgBigCSCgCCDYCECAGIAYoAkAoAgw2AhQgBkEIakEQaiAGKAJIQQhqKQIANwIAIAYgBigCRCgCBDYCICAGIAYoAkQoAgg2AiQgBiAGKAJANgIoIAYgBigCPDYCLCAGIAYoAjg2AjAgByAGKQIINwIAQSghCiAHIApqIAogBkEIamooAgA2AgBBICELIAcgC2ogCyAGQQhqaikCADcCAEEYIQwgByAMaiAMIAZBCGpqKQIANwIAQRAhDSAHIA1qIA0gBkEIamopAgA3AgBBCCEOIAcgDmogDiAGQQhqaikCADcCACAGKAI0IQ8gBkHQAGokgICAgAAgDw8LhwUBDH8jgICAgABB4ABrIQQgBCSAgICAACAEIAA2AlwgBCABNgJYIAQgAjYCVCAEIAM2AlACQCAEKAJUKAIAQQZGQQFxDQBB2feFgABBs9CFgABBuRdBopuFgAAQjoCAgAAACyAEIAQoAlxBwAAQoIeAgAA2AkwgBCgCXCAEKAJYKAIwIAQoAlgoAjwQn4qAgAACQCAEKAJYKAI8QQBHQQFxRQ0AIAQoAlgoAjwvAQBB//8DcUEMRkEBcQ0AQf2nhoAAQbPQhYAAQb4XQaKbhYAAEI6AgIAAAAsgBCgCTCEFIARByAA7AQwgBCAEKAJYLwECOwEOIAQoAlwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCECAEIAQoAlgoAgg2AhQgBCAEKAJQKAIMNgIYIAQgBCgCWCgCEDYCHCAEQQxqQRRqIAQoAlhBFGopAgA3AgAgBEEMakEcaiAEKAJYQShqKQIANwIAIAQgBCgCWCgCMDYCMCAEQQxqQShqIAQoAlhBNGopAgA3AgAgBCAEKAJYKAI8NgI8IAQgBCgCVCgCBDYCQCAEIAQoAlQoAgg2AkQgBCAEKAJQNgJIIAUgBCkCDDcCAEE4IQggBSAIaiAIIARBDGpqKQIANwIAQTAhCSAFIAlqIAkgBEEMamopAgA3AgBBKCEKIAUgCmogCiAEQQxqaikCADcCAEEgIQsgBSALaiALIARBDGpqKQIANwIAQRghDCAFIAxqIAwgBEEMamopAgA3AgBBECENIAUgDWogDSAEQQxqaikCADcCAEEIIQ4gBSAOaiAOIARBDGpqKQIANwIAIAQoAlgQmoyAgAAgBCgCTCEPIARB4ABqJICAgIAAIA8PC7MCARN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAggoAiBBAEchA0EAIQQgA0EBcSEFIAQhBgJAIAVFDQAgAigCCCgCJEF/ai0AAEH/AXFBIUchB0EAIQggB0EBcSEJIAghBiAJRQ0AIAIoAggoAiRBf2otAABB/wFxQT9HIQpBACELIApBAXEhDCALIQYgDEUNACACKAIMIAIoAggoAiAgAigCDCgCuAEgAigCCCgCIGsQ9oaAgAAhDUEAIQYgDUUNACACKAIIKAIoQQBGIQ5BACEPIA5BAXEhECAPIQYgEEUNACACKAIIKAIwQQBGIRFBACESIBFBAXEhEyASIQYgE0UNACACKAIIKAI8QQBGIQYLIAZBAXEhFCACQRBqJICAgIAAIBQPC+cBAQV/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAIgAigCHEG8AmogAigCGCgCABCHi4CAADYCFCACIAIoAhQoAgQ2AhAgAiACKAIQQQFqQQEQoYyAgAA2AgwCQAJAIAIoAgxBAEZBAXFFDQAMAQsgAigCDCEDIAIoAhQoAgAhBCACKAIQIQUCQCAFRQ0AIAMgBCAF/AoAAAsgAigCDCACKAIQakE9OgAAIAIoAhxBvAJqIAIoAgwgAigCEEEBahCNi4CAACEGIAIoAhggBjYCAAsgAkEgaiSAgICAAA8LwAEBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEAkAgAygCCCgCMEEAR0EBcUUNACADKAIMIAMoAgRBxgEQqIeAgAAgAygCDCADKAIIKAIwEKGGgIAAIAMoAghBADYCMAsCQCADKAIIKAI8QQBHQQFxRQ0AIAMoAgwgAygCBEHHARCoh4CAACADKAIMIAMoAggoAjwQoYaAgAAgAygCCEEANgI8CyADQRBqJICAgIAADwu5BAELfyOAgICAAEHQAGshBCAEJICAgIAAIAQgADYCTCAEIAE2AkggBCACNgJEIAQgAzYCQAJAIAQoAkgoAjxBAEZBAXENAEGl9YWAAEGz0IWAAEH8FkHjm4WAABCOgICAAAALAkAgBCgCRCgCAEEGRkEBcQ0AQdn3hYAAQbPQhYAAQf0WQeObhYAAEI6AgIAAAAsgBCAEKAJMQTgQoIeAgAA2AjwgBCgCPCEFIARBEjsBBCAEIAQoAkgvAQI7AQYgBCgCTCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIIIAQgBCgCSCgCCDYCDCAEIAQoAkAoAgw2AhAgBCAEKAJIKAIQNgIUIARBBGpBFGogBCgCSEEUaikCADcCACAEQQRqQRxqIAQoAkhBIGopAgA3AgAgBEEANgIoIAQgBCgCSCgCHDYCLCAEIAQoAkQoAgQ2AjAgBCAEKAJEKAIINgI0IAQgBCgCQDYCOCAFIAQpAgQ3AgBBMCEIIAUgCGogCCAEQQRqaikCADcCAEEoIQkgBSAJaiAJIARBBGpqKQIANwIAQSAhCiAFIApqIAogBEEEamopAgA3AgBBGCELIAUgC2ogCyAEQQRqaikCADcCAEEQIQwgBSAMaiAMIARBBGpqKQIANwIAQQghDSAFIA1qIA0gBEEEamopAgA3AgAgBCgCTCAEKAI8QSRqIAQoAjxBKGoQq4qAgAAgBCgCSBCajICAACAEKAI8IQ4gBEHQAGokgICAgAAgDg8LjwMBCX8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjACQCAEKAI0KAIAQYgBRkEBcQ0AQa73hYAAQbPQhYAAQckjQdCahYAAEI6AgIAAAAsgBCAEKAI8QSgQoIeAgAA2AiwgBCgCLCEFIARBPTsBBCAEQQA7AQYgBCgCPCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIIIAQgBCgCOCgCCDYCDCAEIAQoAjAoAgw2AhAgBCAEKAI8IAQoAjgQqIqAgAA2AhQgBEEEakEUaiAEKAI4QQhqKQIANwIAIAQgBCgCNCgCBDYCICAEIAQoAjQoAgg2AiQgBCAEKAIwNgIoIAUgBCkCBDcCAEEgIQggBSAIaiAIIARBBGpqKQIANwIAQRghCSAFIAlqIAkgBEEEamopAgA3AgBBECEKIAUgCmogCiAEQQRqaikCADcCAEEIIQsgBSALaiALIARBBGpqKQIANwIAIAQoAiwhDCAEQcAAaiSAgICAACAMDwuHAwEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMAJAIAQoAjQoAgBBiAFGQQFxDQBBrveFgABBs9CFgABBjRtBgpqFgAAQjoCAgAAACyAEIAQoAjxBKBCgh4CAADYCLCAEKAIsIQUgBEEdOwEEIARBADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjgoAhA2AhQgBEEEakEUaiAEKAI4QQhqKQIANwIAIAQgBCgCNCgCBDYCICAEIAQoAjQoAgg2AiQgBCAEKAIwNgIoIAUgBCkCBDcCAEEgIQggBSAIaiAIIARBBGpqKQIANwIAQRghCSAFIAlqIAkgBEEEamopAgA3AgBBECEKIAUgCmogCiAEQQRqaikCADcCAEEIIQsgBSALaiALIARBBGpqKQIANwIAIAQoAiwhDCAEQcAAaiSAgICAACAMDwvXAgEIfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMAJAIAQoAjQoAgBBiAFGQQFxDQBBrveFgABBs9CFgABBlRxB3JmFgAAQjoCAgAAACyAEIAQoAjxBIBCgh4CAADYCLCAEKAIsIQUgBEEnOwEMIARBADsBDiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAI4KAIINgIUIAQgBCgCMCgCDDYCGCAEIAQoAjg2AhwgBCAEKAI0KAIENgIgIAQgBCgCNCgCCDYCJCAEIAQoAjA2AiggBSAEKQIMNwIAQRghCCAFIAhqIAggBEEMamopAgA3AgBBECEJIAUgCWogCSAEQQxqaikCADcCAEEIIQogBSAKaiAKIARBDGpqKQIANwIAIAQoAiwhCyAEQcAAaiSAgICAACALDwuHAwEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMAJAIAQoAjQoAgBBiAFGQQFxDQBBrveFgABBs9CFgABBmh1BnpmFgAAQjoCAgAAACyAEIAQoAjxBKBCgh4CAADYCLCAEKAIsIQUgBEEjOwEEIARBADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjgoAhA2AhQgBEEEakEUaiAEKAI4QQhqKQIANwIAIAQgBCgCNCgCBDYCICAEIAQoAjQoAgg2AiQgBCAEKAIwNgIoIAUgBCkCBDcCAEEgIQggBSAIaiAIIARBBGpqKQIANwIAQRghCSAFIAlqIAkgBEEEamopAgA3AgBBECEKIAUgCmogCiAEQQRqaikCADcCAEEIIQsgBSALaiALIARBBGpqKQIANwIAIAQoAiwhDCAEQcAAaiSAgICAACAMDwuIAwEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMAJAIAQoAjQoAgBBiAFGQQFxDQBBrveFgABBs9CFgABB4CdB+JqFgAAQjoCAgAAACyAEIAQoAjxBKBCgh4CAADYCLCAEKAIsIQUgBEHOADsBBCAEQQA7AQYgBCgCPCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIIIAQgBCgCOCgCCDYCDCAEIAQoAjAoAgw2AhAgBCAEKAI4KAIQNgIUIARBBGpBFGogBCgCOEEIaikCADcCACAEIAQoAjQoAgQ2AiAgBCAEKAI0KAIINgIkIAQgBCgCMDYCKCAFIAQpAgQ3AgBBICEIIAUgCGogCCAEQQRqaikCADcCAEEYIQkgBSAJaiAJIARBBGpqKQIANwIAQRAhCiAFIApqIAogBEEEamopAgA3AgBBCCELIAUgC2ogCyAEQQRqaikCADcCACAEKAIsIQwgBEHAAGokgICAgAAgDA8LlAQBCn8jgICAgABB0ABrIQYgBiSAgICAACAGIAA2AkwgBiABNgJIIAYgAjYCRCAGIAM2AkAgBiAENgI8IAYgBTYCOAJAIAYoAkgvAQBB//8DcUHgAEZBAXENACAGKAJILwEAQf//A3FB2ABGQQFxDQAgBigCSC8BAEH//wNxQRNGQQFxDQBB2qqGgABBs9CFgABB3ixBqZqFgAAQjoCAgAAACwJAIAYoAkQoAgBBiAFGQQFxDQBBrveFgABBs9CFgABB3yxBqZqFgAAQjoCAgAAACyAGIAYoAkxBLBCgh4CAADYCNCAGKAI0IQcgBkHfADsBCCAGQQA7AQogBigCTCEIIAgoAgBBAWohCSAIIAk2AgAgBiAJNgIMIAYgBigCSCgCCDYCECAGIAYoAkAoAgw2AhQgBkEIakEQaiAGKAJIQQhqKQIANwIAIAYgBigCRCgCBDYCICAGIAYoAkQoAgg2AiQgBiAGKAJANgIoIAYgBigCPDYCLCAGIAYoAjg2AjAgByAGKQIINwIAQSghCiAHIApqIAogBkEIamooAgA2AgBBICELIAcgC2ogCyAGQQhqaikCADcCAEEYIQwgByAMaiAMIAZBCGpqKQIANwIAQRAhDSAHIA1qIA0gBkEIamopAgA3AgBBCCEOIAcgDmogDiAGQQhqaikCADcCACAGKAI0IQ8gBkHQAGokgICAgAAgDw8LiAUBDH8jgICAgABB4ABrIQQgBCSAgICAACAEIAA2AlwgBCABNgJYIAQgAjYCVCAEIAM2AlACQCAEKAJUKAIAQYgBRkEBcQ0AQa73hYAAQbPQhYAAQdMYQYCZhYAAEI6AgIAAAAsgBCAEKAJcQcAAEKCHgIAANgJMIAQoAlwgBCgCWCgCMCAEKAJYKAI8EJ+KgIAAAkAgBCgCWCgCPEEAR0EBcUUNACAEKAJYKAI8LwEAQf//A3FBDEZBAXENAEH9p4aAAEGz0IWAAEHYGEGAmYWAABCOgICAAAALIAQoAkwhBSAEQcoAOwEMIAQgBCgCWC8BAjsBDiAEKAJcIQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAJYKAIINgIUIAQgBCgCUCgCDDYCGCAEIAQoAlgoAhA2AhwgBEEMakEUaiAEKAJYQRRqKQIANwIAIARBDGpBHGogBCgCWEEoaikCADcCACAEIAQoAlgoAjA2AjAgBEEMakEoaiAEKAJYQTRqKQIANwIAIAQgBCgCWCgCPDYCPCAEIAQoAlQoAgQ2AkAgBCAEKAJUKAIINgJEIAQgBCgCUDYCSCAFIAQpAgw3AgBBOCEIIAUgCGogCCAEQQxqaikCADcCAEEwIQkgBSAJaiAJIARBDGpqKQIANwIAQSghCiAFIApqIAogBEEMamopAgA3AgBBICELIAUgC2ogCyAEQQxqaikCADcCAEEYIQwgBSAMaiAMIARBDGpqKQIANwIAQRAhDSAFIA1qIA0gBEEMamopAgA3AgBBCCEOIAUgDmogDiAEQQxqaikCADcCACAEKAJYEJqMgIAAIAQoAkwhDyAEQeAAaiSAgICAACAPDwu6BAELfyOAgICAAEHQAGshBCAEJICAgIAAIAQgADYCTCAEIAE2AkggBCACNgJEIAQgAzYCQAJAIAQoAkgoAjxBAEZBAXENAEGl9YWAAEGz0IWAAEGtGEG/mYWAABCOgICAAAALAkAgBCgCRCgCAEGIAUZBAXENAEGu94WAAEGz0IWAAEGuGEG/mYWAABCOgICAAAALIAQgBCgCTEE4EKCHgIAANgI8IAQoAjwhBSAEQRU7AQQgBCAEKAJILwECOwEGIAQoAkwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCCCAEIAQoAkgoAgg2AgwgBCAEKAJAKAIMNgIQIAQgBCgCSCgCEDYCFCAEQQRqQRRqIAQoAkhBFGopAgA3AgAgBEEEakEcaiAEKAJIQSBqKQIANwIAIARBADYCKCAEIAQoAkgoAhw2AiwgBCAEKAJEKAIENgIwIAQgBCgCRCgCCDYCNCAEIAQoAkA2AjggBSAEKQIENwIAQTAhCCAFIAhqIAggBEEEamopAgA3AgBBKCEJIAUgCWogCSAEQQRqaikCADcCAEEgIQogBSAKaiAKIARBBGpqKQIANwIAQRghCyAFIAtqIAsgBEEEamopAgA3AgBBECEMIAUgDGogDCAEQQRqaikCADcCAEEIIQ0gBSANaiANIARBBGpqKQIANwIAIAQoAkwgBCgCPEEkaiAEKAI8QShqEKuKgIAAIAQoAkgQmoyAgAAgBCgCPCEOIARB0ABqJICAgIAAIA4PC4cDAQp/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIAQgBCgCPEEsEKCHgIAANgIsIAQoAiwhBSAEQTw7AQAgBEEAOwECIAQoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCBCAEIAQoAjgoAgg2AgggBCAEKAIwKAIMNgIMIAQgBCgCPCAEKAI4EKiKgIAANgIQIARBFGogBCgCOEEIaikCADcCACAEIAQoAjQoAgQ2AhwgBCAEKAI0KAIINgIgIAQgBCgCMDYCJCAEIAQoAjwgBCgCNCgCBCAEKAI0KAIIQX9qEMCHgIAANgIoIAUgBCkCADcCAEEoIQggBSAIaiAEIAhqKAIANgIAQSAhCSAFIAlqIAQgCWopAgA3AgBBGCEKIAUgCmogBCAKaikCADcCAEEQIQsgBSALaiAEIAtqKQIANwIAQQghDCAFIAxqIAQgDGopAgA3AgAgBCgCLCENIARBwABqJICAgIAAIA0PC/8CAQp/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIAQgBCgCPEEsEKCHgIAANgIsIAQoAiwhBSAEQRw7AQAgBEEAOwECIAQoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCBCAEIAQoAjgoAgg2AgggBCAEKAIwKAIMNgIMIAQgBCgCOCgCEDYCECAEQRRqIAQoAjhBCGopAgA3AgAgBCAEKAI0KAIENgIcIAQgBCgCNCgCCDYCICAEIAQoAjA2AiQgBCAEKAI8IAQoAjQoAgQgBCgCNCgCCEF/ahDAh4CAADYCKCAFIAQpAgA3AgBBKCEIIAUgCGogBCAIaigCADYCAEEgIQkgBSAJaiAEIAlqKQIANwIAQRghCiAFIApqIAQgCmopAgA3AgBBECELIAUgC2ogBCALaikCADcCAEEIIQwgBSAMaiAEIAxqKQIANwIAIAQoAiwhDSAEQcAAaiSAgICAACANDwvhAgEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjxBJBCgh4CAADYCLCAEKAIsIQUgBEEmOwEIIARBADsBCiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgwgBCAEKAI4KAIINgIQIAQgBCgCMCgCDDYCFCAEIAQoAjg2AhggBCAEKAI0KAIENgIcIAQgBCgCNCgCCDYCICAEIAQoAjA2AiQgBCAEKAI8IAQoAjQoAgQgBCgCNCgCCEF/ahDAh4CAADYCKCAFIAQpAgg3AgBBICEIIAUgCGogCCAEQQhqaigCADYCAEEYIQkgBSAJaiAJIARBCGpqKQIANwIAQRAhCiAFIApqIAogBEEIamopAgA3AgBBCCELIAUgC2ogCyAEQQhqaikCADcCACAEKAIsIQwgBEHAAGokgICAgAAgDA8L/wIBCn8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8QSwQoIeAgAA2AiwgBCgCLCEFIARBIjsBACAEQQA7AQIgBCgCPCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIEIAQgBCgCOCgCCDYCCCAEIAQoAjAoAgw2AgwgBCAEKAI4KAIQNgIQIARBFGogBCgCOEEIaikCADcCACAEIAQoAjQoAgQ2AhwgBCAEKAI0KAIINgIgIAQgBCgCMDYCJCAEIAQoAjwgBCgCNCgCBCAEKAI0KAIIQX9qEMCHgIAANgIoIAUgBCkCADcCAEEoIQggBSAIaiAEIAhqKAIANgIAQSAhCSAFIAlqIAQgCWopAgA3AgBBGCEKIAUgCmogBCAKaikCADcCAEEQIQsgBSALaiAEIAtqKQIANwIAQQghDCAFIAxqIAQgDGopAgA3AgAgBCgCLCENIARBwABqJICAgIAAIA0PC4ADAQp/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIAQgBCgCPEEsEKCHgIAANgIsIAQoAiwhBSAEQc0AOwEAIARBADsBAiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgQgBCAEKAI4KAIINgIIIAQgBCgCMCgCDDYCDCAEIAQoAjgoAhA2AhAgBEEUaiAEKAI4QQhqKQIANwIAIAQgBCgCNCgCBDYCHCAEIAQoAjQoAgg2AiAgBCAEKAIwNgIkIAQgBCgCPCAEKAI0KAIEIAQoAjQoAghBf2oQwIeAgAA2AiggBSAEKQIANwIAQSghCCAFIAhqIAQgCGooAgA2AgBBICEJIAUgCWogBCAJaikCADcCAEEYIQogBSAKaiAEIApqKQIANwIAQRAhCyAFIAtqIAQgC2opAgA3AgBBCCEMIAUgDGogBCAMaikCADcCACAEKAIsIQ0gBEHAAGokgICAgAAgDQ8LpwMBCn8jgICAgABB0ABrIQYgBiSAgICAACAGIAA2AkwgBiABNgJIIAYgAjYCRCAGIAM2AkAgBiAENgI8IAYgBTYCOCAGIAYoAkxBMBCgh4CAADYCNCAGKAI0IQcgBkHeADsBBCAGQQA7AQYgBigCTCEIIAgoAgBBAWohCSAIIAk2AgAgBiAJNgIIIAYgBigCSCgCCDYCDCAGIAYoAkAoAgw2AhAgBkEEakEQaiAGKAJIQQhqKQIANwIAIAYgBigCRCgCBDYCHCAGIAYoAkQoAgg2AiAgBiAGKAJANgIkIAYgBigCPDYCKCAGIAYoAkwgBigCRCgCBCAGKAJEKAIIQX9qEMCHgIAANgIsIAYgBigCODYCMCAHIAYpAgQ3AgBBKCEKIAcgCmogCiAGQQRqaikCADcCAEEgIQsgByALaiALIAZBBGpqKQIANwIAQRghDCAHIAxqIAwgBkEEamopAgA3AgBBECENIAcgDWogDSAGQQRqaikCADcCAEEIIQ4gByAOaiAOIAZBBGpqKQIANwIAIAYoAjQhDyAGQdAAaiSAgICAACAPDwvqAwEGfyOAgICAAEHgAGshBCAEJICAgIAAIAQgADYCXCAEIAE2AlggBCACNgJUIAQgAzYCUCAEIAQoAlxBxAAQoIeAgAA2AkwgBCgCXCAEKAJYKAIwIAQoAlgoAjwQn4qAgAACQCAEKAJYKAI8QQBHQQFxRQ0AIAQoAlgoAjwvAQBB//8DcUEMRkEBcQ0AQf2nhoAAQbPQhYAAQYoYQbmYhYAAEI6AgIAAAAsgBCgCTCEFIARByQA7AQggBCAEKAJYLwECOwEKIAQoAlwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCDCAEIAQoAlgoAgg2AhAgBCAEKAJQKAIMNgIUIAQgBCgCWCgCEDYCGCAEQQhqQRRqIAQoAlhBFGopAgA3AgAgBEEIakEcaiAEKAJYQShqKQIANwIAIAQgBCgCWCgCMDYCLCAEQQhqQShqIAQoAlhBNGopAgA3AgAgBCAEKAJYKAI8NgI4IAQgBCgCXCAEKAJUKAIEIAQoAlQoAghBf2oQwIeAgAA2AjwgBCAEKAJUKAIENgJAIAQgBCgCVCgCCDYCRCAEIAQoAlA2AkhBxAAhCAJAIAhFDQAgBSAEQQhqIAj8CgAACyAEKAJYEJqMgIAAIAQoAkwhCSAEQeAAaiSAgICAACAJDwupBAEMfyOAgICAAEHQAGshBCAEJICAgIAAIAQgADYCTCAEIAE2AkggBCACNgJEIAQgAzYCQAJAIAQoAkgoAjxBAEZBAXENAEGl9YWAAEGz0IWAAEHgF0HdmIWAABCOgICAAAALIAQgBCgCTEE8EKCHgIAANgI8IAQoAjwhBSAEQRQ7AQAgBCAEKAJILwECOwECIAQoAkwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCBCAEIAQoAkgoAgg2AgggBCAEKAJAKAIMNgIMIAQgBCgCSCgCEDYCECAEQRRqIAQoAkhBFGopAgA3AgAgBEEcaiAEKAJIQSBqKQIANwIAIARBADYCJCAEIAQoAkgoAhw2AiggBCAEKAJMIAQoAkQoAgQgBCgCRCgCCEF/ahDAh4CAADYCLCAEIAQoAkQoAgQ2AjAgBCAEKAJEKAIINgI0IAQgBCgCQDYCOCAFIAQpAgA3AgBBOCEIIAUgCGogBCAIaigCADYCAEEwIQkgBSAJaiAEIAlqKQIANwIAQSghCiAFIApqIAQgCmopAgA3AgBBICELIAUgC2ogBCALaikCADcCAEEYIQwgBSAMaiAEIAxqKQIANwIAQRAhDSAFIA1qIAQgDWopAgA3AgBBCCEOIAUgDmogBCAOaikCADcCACAEKAJMIAQoAjxBJGogBCgCPEEoahCrioCAACAEKAJIEJqMgIAAIAQoAjwhDyAEQdAAaiSAgICAACAPDwu3AgEIfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEKAI8IAQoAjgQnomAgAAgBCAEKAI8QSAQoIeAgAA2AiwgBCgCLCEFIARBBDsBDCAEQQA7AQ4gBCgCPCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIQIAQgBCgCOCgCCDYCFCAEIAQoAjAoAgw2AhggBCAEKAI4NgIcIAQgBCgCMDYCICAEIAQoAjQoAgQ2AiQgBCAEKAI0KAIINgIoIAUgBCkCDDcCAEEYIQggBSAIaiAIIARBDGpqKQIANwIAQRAhCSAFIAlqIAkgBEEMamopAgA3AgBBCCEKIAUgCmogCiAEQQxqaikCADcCACAEKAIsIQsgBEHAAGokgICAgAAgCw8LuAIBCH8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCgCPCAEKAI4EJ6JgIAAIAQgBCgCPEEgEKCHgIAANgIsIAQoAiwhBSAEQfIAOwEMIARBADsBDiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAI4KAIINgIUIAQgBCgCMCgCDDYCGCAEIAQoAjg2AhwgBCAEKAIwNgIgIAQgBCgCNCgCBDYCJCAEIAQoAjQoAgg2AiggBSAEKQIMNwIAQRghCCAFIAhqIAggBEEMamopAgA3AgBBECEJIAUgCWogCSAEQQxqaikCADcCAEEIIQogBSAKaiAKIARBDGpqKQIANwIAIAQoAiwhCyAEQcAAaiSAgICAACALDwuZAwEOfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCOCAEIAE2AjQgBCACNgIwIAQgAzoALyAEIAQoAjg2AhAgBCAEKAIwNgIUIARBADYCGCAEQQA2AhwgBEEANgIgIARBADYCJCAEIAQoAjQoAghBAUZBAXE6ACggBEEQakEZaiEFQQAhBiAFIAY7AAAgBUECaiAGOgAAIAQgBCgCODYCACAEIAQoAjAoAhAoAgg2AgQgBCAEKAIwKAIQKAIMNgIIIAQgBCgCNCgCCEEBRkEBcToADCAEQQ1qIQdBACEIIAcgCDsAACAHQQJqIAg6AAAgBCgCOCEJIAQoAjQQrIuAgAAhCiAEKAI0EKuLgIAAIQsgBC0ALyEMQeCBgIAAIQ0gBEEQaiEOQd+BgIAAIQ8gBCEQIAkgCiALIAxBAXEgDSAOIA8gEBC0ioCAACAEQRBqQQxqEISLgIAAAkACQCAEKAIYQQBHQQFxRQ0AIAQgBCgCGDYCPAwBCyAEIAQoAjA2AjwLIAQoAjwhESAEQcAAaiSAgICAACARDwupAwEJfyOAgICAAEEwayEEIAQkgICAgAAgBCAANgIsIAQgATYCKCAEIAI2AiQgBCADNgIgIAQoAiwgBCgCKBCeiYCAACAEIAQoAiwgBCgCKBDwiYCAAEH//wNxEKyJgIAANgIcIAQoAigoAgghBSAEKAIcIAU2AgggBCgCIBCtiYCAACEGIAQoAhwgBjYCDCAEKAIoIQcgBCgCHCAHNgIQIAQoAhxBFGohCAJAAkAgBCgCJCgCAEEDRkEBcUUNACAEQQA2AhQgBEEANgIYIAggBCkCFDcCAAwBCyAEIAQoAiQoAgQ2AgwgBCAEKAIkKAIINgIQIAggBCkCDDcCAAsgBCgCHEEoaiAEKAIgKQIANwIAIAQoAiAoAgghCSAEKAIcIAk2AjAgBCgCHEE0aiAEKAIgQQxqKQIANwIAIAQoAiAoAhQhCiAEKAIcIAo2AjwCQCAEKAIkKAIAQQdGQQFxRQ0AIAQoAhxBBEH//wNxEJ6HgIAACyAEKAIsQZP1hIAAQQQQkoeAgAAhCyAEKAIcIAs2AhwgBCgCHCEMIARBMGokgICAgAAgDA8LtgQBCn8jgICAgABBwABrIQUgBSSAgICAACAFIAA2AjwgBSABNgI4IAUgAjYCNCAFIAM2AjAgBSAENgIsIAUoAjwgBSgCOBCeiYCAACAFIAUoAjwgBSgCOBDwiYCAAEH//wNxEKyJgIAANgIoIAUoAjgoAgghBiAFKAIoIAY2AgggBSAFKAIsEK2JgIAANgIkAkAgBSgCJEEARkEBcUUNACAFIAUoAjAoAgg2AiQLIAUoAiQhByAFKAIoIAc2AgwgBSgCOCEIIAUoAiggCDYCECAFKAIoQRRqIQkCQAJAIAUoAjQoAgBBA0ZBAXFFDQAgBUEANgIcIAVBADYCICAJIAUpAhw3AgAMAQsgBSAFKAI0KAIENgIUIAUgBSgCNCgCCDYCGCAJIAUpAhQ3AgALIAUoAihBIGohCgJAAkAgBSgCMCgCAEEDRkEBcUUNACAFQQA2AgwgBUEANgIQIAogBSkCDDcCAAwBCyAFIAUoAjAoAgQ2AgQgBSAFKAIwKAIINgIIIAogBSkCBDcCAAsgBSgCKEEoaiAFKAIsKQIANwIAIAUoAiwoAgghCyAFKAIoIAs2AjAgBSgCKEE0aiAFKAIsQQxqKQIANwIAIAUoAiwoAhQhDCAFKAIoIAw2AjwCQCAFKAI0KAIAQQdGQQFxRQ0AIAUoAihBBEH//wNxEJ6HgIAACyAFKAI8IAUoAjAQq4eAgAAhDSAFKAIoIA02AhwgBSgCKCEOIAVBwABqJICAgIAAIA4PC54DAQp/I4CAgIAAQdAAayEFIAUkgICAgAAgBSAANgJMIAUgATYCSCAFIAI2AkQgBSADNgJAIAUgBDsBPiAFIAUoAkxBMBCgh4CAADYCOCAFKAJMIAUoAkRBABDiiICAACAFKAJMIAUoAkAQrYqAgAAgBSgCOCEGIAVBkwE7AQggBSAFLwE+OwEKIAUoAkwhByAHKAIAQQFqIQggByAINgIAIAUgCDYCDCAFIAUoAkAoAgg2AhAgBSAFKAJEKAIMNgIUIAUgBSgCSCgCBDYCGCAFIAUoAkgoAgg2AhwgBUEANgIgIAVBADYCJCAFQQA2AiggBUEANgIsIAUgBSgCRDYCMCAFIAUoAkA2AjQgBiAFKQIINwIAQSghCSAGIAlqIAkgBUEIamopAgA3AgBBICEKIAYgCmogCiAFQQhqaikCADcCAEEYIQsgBiALaiALIAVBCGpqKQIANwIAQRAhDCAGIAxqIAwgBUEIamopAgA3AgBBCCENIAYgDWogDSAFQQhqaikCADcCACAFKAI4IQ4gBUHQAGokgICAgAAgDg8LngMBCn8jgICAgABB0ABrIQUgBSSAgICAACAFIAA2AkwgBSABNgJIIAUgAjYCRCAFIAM2AkAgBSAEOwE+IAUgBSgCTEEwEKCHgIAANgI4IAUoAkwgBSgCREEAEOKIgIAAIAUoAkwgBSgCQBCtioCAACAFKAI4IQYgBUGVATsBCCAFIAUvAT47AQogBSgCTCEHIAcoAgBBAWohCCAHIAg2AgAgBSAINgIMIAUgBSgCQCgCCDYCECAFIAUoAkQoAgw2AhQgBSAFKAJIKAIENgIYIAUgBSgCSCgCCDYCHCAFQQA2AiAgBUEANgIkIAVBADYCKCAFQQA2AiwgBSAFKAJENgIwIAUgBSgCQDYCNCAGIAUpAgg3AgBBKCEJIAYgCWogCSAFQQhqaikCADcCAEEgIQogBiAKaiAKIAVBCGpqKQIANwIAQRghCyAGIAtqIAsgBUEIamopAgA3AgBBECEMIAYgDGogDCAFQQhqaikCADcCAEEIIQ0gBiANaiANIAVBCGpqKQIANwIAIAUoAjghDiAFQdAAaiSAgICAACAODwvMBAEMfyOAgICAAEHwAGshBiAGJICAgIAAIAYgADYCbCAGIAE2AmggBiACNgJkIAYgAzYCYCAGIAQ2AlwgBiAFNgJYIAYoAmwgBigCaBCeiYCAACAGKAJsIAYoAmhBABDiiICAACAGIAYoAmwQxIaAgAA2AlQgBigCbCAGKAJUIAYoAmBBAUEBcRCNh4CAACAGIAYoAmwQxIaAgAA2AlAgBigCbCAGKAJQIAYoAlhBAUEBcRCNh4CAACAGKAJsIQcgBkHEAGogBxDUh4CAACAGIAYoAmwgBigCXCAGKAJQIAZBxABqEJ+IgIAANgJAIAYgBigCbEE0EKCHgIAANgI8IAYoAjwhCCAGQcMAOwEIIAZBATsBCiAGKAJsIQkgCSgCAEEBaiEKIAkgCjYCACAGIAo2AgwgBiAGKAJoKAIINgIQIAYgBigCWCgCDDYCFCAGQQA2AhggBkEANgIcIAYgBigCaDYCICAGIAYoAmQoAgQ2AiQgBiAGKAJkKAIINgIoIAYgBigCVDYCLCAGIAYoAkA2AjAgBkEANgI0IAZBADYCOCAIIAYpAgg3AgBBMCELIAggC2ogCyAGQQhqaigCADYCAEEoIQwgCCAMaiAMIAZBCGpqKQIANwIAQSAhDSAIIA1qIA0gBkEIamopAgA3AgBBGCEOIAggDmogDiAGQQhqaikCADcCAEEQIQ8gCCAPaiAPIAZBCGpqKQIANwIAQQghECAIIBBqIBAgBkEIamopAgA3AgAgBigCPCERIAZB8ABqJICAgIAAIBEPC5EDAQp/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIAMoAhgQnomAgAAgAyADKAIYEPCJgIAAOwESAkACQCADKAIUKAIUQQBGQQFxDQAgAygCFCgCFC8BAEH//wNxQQxGQQFxRQ0BCyADIAMvARJB//8DcUGAAnI7ARILIAMgAygCHCADLwESQf//A3EQrImAgAA2AgwgAygCGCgCCCEEIAMoAgwgBDYCCCADKAIUEK2JgIAAIQUgAygCDCAFNgIMIAMoAhghBiADKAIMIAY2AhAgAygCFCgCACEHIAMoAgwgBzYCICADKAIUKAIQIQggAygCDCAINgIkIAMoAgxBKGogAygCFCkCADcCACADKAIUKAIIIQkgAygCDCAJNgIwIAMoAgxBNGogAygCFEEMaikCADcCACADKAIUKAIUIQogAygCDCAKNgI8IAMoAhxB4+WFgABBAhCSh4CAACELIAMoAgwgCzYCHCADKAIMIQwgA0EgaiSAgICAACAMDwuRCAEgfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCPCACIAE7ATogAigCPEG8AWohA0EIIQQgAyAEaigCACEFIAQgAkEoamogBTYCACACIAMpAgA3AyggAigCPEH5ABDLh4CAABogAigCPEEBQQFxEKuGgIAAIAIoAjxBAEEBcRCphoCAABogAkEANgIkAkAgAigCPEGFARDLh4CAAEEBcUUNACACKAI8QbwBaiEGQQghByAGIAdqKAIAIQggByACQRhqaiAINgIAIAIgBikCADcDGAJAAkAgAigCPEGFARCOh4CAAEEBcUUNACACIAIoAjxBACAC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DAELCyACKAJUIRMgAkHgAGokgICAgAAgEw8LnwMBDX8jgICAgABB0ABrIQIgAiSAgICAACACIAA2AkwgAiABNgJIIAIgAigCTEHAABCgh4CAADYCRCACKAJEIQMgAkEEaiEEIAJBBzsBBCACQQA7AQYgAigCTCEFIAUoAgBBAWohBiAFIAY2AgAgAiAGNgIIIARBCGogAigCSEEIaikCADcCACACQQA2AhQgAkEANgIYIAJBADYCHCACQQA2AiAgAiACKAJINgIkIAJBADYCKCACQQA2AiwgAkEANgIwIAJBADYCNCACQQA2AjggAkEANgI8IAJBADYCQCADIAIpAgQ3AgBBOCEHIAMgB2ogByACQQRqaikCADcCAEEwIQggAyAIaiAIIAJBBGpqKQIANwIAQSghCSADIAlqIAkgAkEEamopAgA3AgBBICEKIAMgCmogCiACQQRqaikCADcCAEEYIQsgAyALaiALIAJBBGpqKQIANwIAQRAhDCADIAxqIAwgAkEEamopAgA3AgBBCCENIAMgDWogDSACQQRqaikCADcCACACKAJEIQ4gAkHQAGokgICAgAAgDg8LqQMBDH8jgICAgABB0ABrIQIgAiSAgICAACACIAA2AkwgAiABNgJIIAIgAigCTEHAABCgh4CAADYCRCACKAJEIQMgAkGBATsBBCACQQA7AQYgAigCTCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCSCgCBDYCDCACIAIoAkgoAgg2AhAgAiACKAJIKAIENgIUIAIgAigCSCgCCDYCGCACQQA2AhwgAkEANgIgIAJBADYCJCACQQA2AiggAkEANgIsIAJBADYCMCACQQA2AjQgAkEANgI4IAJBADYCPCACQQA2AkAgAyACKQIENwIAQTghBiADIAZqIAYgAkEEamopAgA3AgBBMCEHIAMgB2ogByACQQRqaikCADcCAEEoIQggAyAIaiAIIAJBBGpqKQIANwIAQSAhCSADIAlqIAkgAkEEamopAgA3AgBBGCEKIAMgCmogCiACQQRqaikCADcCAEEQIQsgAyALaiALIAJBBGpqKQIANwIAQQghDCADIAxqIAwgAkEEamopAgA3AgAgAigCRCENIAJB0ABqJICAgIAAIA0PC30BAn8jgICAgABBIGshAiACIAA2AhwgAiABNgIY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AigCGBCrh4CAADYCECADIAIpAgA3AgBBECEGIAMgBmogAiAGaigCADYCAEEIIQcgAyAHaiACIAdqKQIANwIAIAIoAhQhCCACQSBqJICAgIAAIAgPC6cCAQh/I4CAgIAAQTBrIQIgAiSAgICAACACIAA2AiwgAiABNgIoIAIgAigCLEEcEKCHgIAANgIkIAIoAiQhAyACQf4AOwEIIAJBADsBCiACKAIsIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgwgAiACKAIoKAIENgIQIAIgAigCKCgCCDYCFCACIAIoAiwgAigCKCgCBCACKAIoKAIIQX9qEMCHgIAANgIYIAIgAigCKCgCBDYCHCACIAIoAigoAgg2AiAgAyACKQIINwIAQRghBiADIAZqIAYgAkEIamooAgA2AgBBECEHIAMgB2ogByACQQhqaikCADcCAEEIIQggAyAIaiAIIAJBCGpqKQIANwIAIAIoAiQhCSACQTBqJICAgIAAIAkPC1QBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCACKAIIEJ2KgIAAIAIoAgxBOGogAigCCBCchoCAACACQRBqJICAgIAADwuvAgEIfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQgAyADKAIsQSAQoIeAgAA2AiAgAygCICEEIANB8AA7AQAgA0EAOwECIAMoAiwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCBCADIAMoAigoAgQ2AgggAyADKAIkKAIMNgIMIAMgAygCLCADKAIoKAIEIAMoAigoAghBf2oQwIeAgAA2AhAgAyADKAIoKAIENgIUIAMgAygCKCgCCDYCGCADIAMoAiQ2AhwgBCADKQIANwIAQRghByAEIAdqIAMgB2opAgA3AgBBECEIIAQgCGogAyAIaikCADcCAEEIIQkgBCAJaiADIAlqKQIANwIAIAMoAiAhCiADQTBqJICAgIAAIAoPC8ADAQ5/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQgAyADKAI8QSQQoIeAgAA2AjAgAygCMCEEIANBDGohBSADQYIBOwEMIANBADsBDiADKAI8IQYgBigCAEEBaiEHIAYgBzYCACADIAc2AhAgBUEI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ACAJIAUoAkAoAgg2AgQLIAUgBSgCPDYCJCAFQQA2AiggBUEANgIsIAVBADYCMCAGIAUpAgA3AgBBMCEKIAYgCmogBSAKaigCADYCAEEoIQsgBiALaiAFIAtqKQIANwIAQSAhDCAGIAxqIAUgDGopAgA3AgBBGCENIAYgDWogBSANaikCADcCAEEQIQ4gBiAOaiAFIA5qKQIANwIAQQghDyAGIA9qIAUgD2opAgA3AgAgBSgCOCEQIAVB0ABqJICAgIAAIBAPC2ABA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAggoAgghAyACKAIMIAM2AgwgAigCDEEsaiEEIAIgAigCCCgCBDYCACACIAIoAggoAgg2AgQgBCACKQIANwIADwtgAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIKAIIIQMgAigCDCADNgIMIAIoAgxBHGohBCACIAIoAggoAgQ2AgAgAiACKAIIKAIINgIEIAQgAikCADcCAA8LYAEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCDEEsaiEDIAIgAigCCCgCBDYCACACIAIoAggoAgg2AgQgAyACKQIANwIAIAIoAggoAgghBCACKAIMIAQ2AgwPCzkBAn8jgICAgABBEGshASABIAA2AgwgASgCDC8BAEH//wNxQYUBRiECQSBBACACQQFxG0H//wNxDwupAwEDfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCFC8BACEEAkACQAJAAkAgBEEwRg0AIARBMUYNASAEQY0BRw0CIAMoAhRBEkH//wNxEJ6HgIAADAMLIAMgAygCFDYCEAJAAkAgAygCECgCGEEAR0EBcUUNACADKAIQKAIYKAIQQQFGQQFxRQ0AIAMoAhAoAhgoAhgoAgAhBQwBC0EAIQULIAMgBTYCDAJAAkAgAygCDEEARkEBcUUNACADKAIcQQJB//8DcRD2h4CAAAwBCwJAAkAgAygCDC8BAEH//wNxQY0BRkEBcUUNACADKAIMQRJB//8DcRCeh4CAAAwBCwJAAkAgAygCDC8BAEH//wNxQdUARkEBcUUNACADKAIMLwECQf//A3FBAnFFDQAMAQsgAygCHEECQf//A3EQ9oeAgAALCwsMAgsgAygCHEECQf//A3EQ9oeAgAAMAQtBwraGgABBs9CFgABByChBkL+FgAAQjoCAgAAACyADKAIYIAMoAhQQnIaAgAAgA0EgaiSAgICAAA8L+QQBCn8jgICAgABBMGshAiACJICAgIAAIAIgADYCLCACIAE2AiggAkEAOwEmAkAgAigCKCgCAEGNAUZBAXFFDQAgAkEgakEANgIAIAJCADcDGCACIAIoAigoAgRBAWo2AhQCQANAIAIoAhQgAigCKCgCCElBAXFFDQEgAigCFC0AAEGbf2ohAyADQRNLGgJAAkACQAJAAkACQAJAAkACQAJAIAMOFAQICAgACAgIAQUDCAgIBggHCAgCCAsgAiACLwEmQf//A3FBBHI7ASYMCAsgAiACLwEmQf//A3FBEHI7ASYMBwsgAiACLwEmQf//A3FBCHI7ASYMBgsgAiACLwEmQf//A3FBIHI7ASYMBQsgAiACLwEmQf//A3FBv3hxQf//A3FBwAByOwEmDAQLIAIgAi8BJkH//wNxQb94cUH//wNxQYABcjsBJgwDCyACIAIvASZB//8DcUG/eHFB//8DcUGAAnI7ASYMAgsgAiACLwEmQf//A3FBv3hxQf//A3FBgARyOwEmDAELIAIoAhQtAAAhBCACQRhqIARB/wFxEOaKgIAACyACIAIoAhRBAWo2AhQMAAsLIAIgAkEYahDfioCAADYCEAJAIAIoAhBFDQAgAigCEEECTyEFIAJB17WEgABBiuCEgAAgBUEBcRs2AgwgAigCLEGIAmohBiACKAIsKALAASEHIAIoAiwoAsQBIQggAigCDCEJIAIoAhAhCiACIAJBGGoQ3oqAgAA2AgggAiAKNgIEIAIgCTYCACAGIAcgCEH3ASACEM6EgIAAGgsgAkEYahDrioCAAAsgAi8BJkH//wNxIQsgAkEwaiSAgICAACALDwvbAQEEfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjA2AiwCQAJAIAQoAiwtAAxBAXFFDQAgBCAEKAI8NgIYIAQgBCgCODYCHCAEIAQpAhg3AyAMAQsgBCAEKAIsKAIENgIQIAQgBCgCLCgCCDYCFCAEIAQpAhA3AyALIAQoAiwoAgBBiAJqIQUgBCgCICEGIAQoAiQhByAEIAQoAjQ2AgAgBSAGIAdB9QEgBBDOhICAABogBEHAAGokgICAgAAPC4IKASx/I4CAgIAAQYABayEGIAYkgICAgAAgBiAANgJ4IAYgATYCdCAGIAI6AHMgBiADOwFwIAYgBDoAbyAGIAU2AmggBi0AbyEHQRghCAJAAkAgByAIdCAIdUHuAEZBAXFFDQAgBigCaEHA3IeAAEEwakZBAXENAQsgBi0AbyEJQRghCgJAIAkgCnQgCnVB9QBGQQFxRQ0AIAYoAmhBwNyHgABGQQFxDQELIAYtAG8hC0EYIQwCQCALIAx0IAx1QeUARkEBcUUNACAGKAJoQcDch4AAQcgAakZBAXENAQsgBi0AbyENQRghDgJAIA0gDnQgDnVB8wBGQQFxRQ0AIAYoAmhBwNyHgABB4ABqRkEBcQ0BC0HgpYaAAEGz0IWAAEG6OEGI1ISAABCOgICAAAALAkACQCAGKAJ4KALwAkEARkEBcUUNAAJAIAYtAHNBAXFFDQAgBi0AbyEPQRghEAJAAkAgDyAQdCAQdUHuAEZBAXFFDQBBgCAhEQwBCyAGLwFwQf//A3EhEQsgBiAROwF+DAILAkACQCAGKAJ4KAKgAkHA3IeAAEEYakZBAXFFDQACQCAGLQBzQQFxDQAgBigCeEGIAmohEiAGKAJ4KALMASETIAYoAngoAtABIRQgBiAGKAJ4KAKgAigCEDYCACASIBMgFEGUASAGEM6EgIAAGgsMAQsCQCAGKAJ4KAKgAiAGKAJoR0EBcUUNACAGKAJ4QYgCaiEVIAYoAngoAswBIRYgBigCeCgC0AEhFyAGLQBvIRhBGCEZIBggGXQgGXUhGiAGIAYoAngoAqACKAIQNgIkIAYgGjYCICAVIBYgF0HxASAGQSBqEM6EgIAAGiAGLQBvIRtBGCEcAkAgGyAcdCAcdUHuAEZBAXFFDQAgBi0Ac0EBcQ0AIAYoAnhBiAJqIR0gBigCeCgCzAEhHiAGKAJ4KALQASEfIAYoAnQQq4uAgAAhICAGIAYoAnQQrIuAgAA2AhQgBiAgNgIQIB0gHiAfQfQBIAZBEGoQzoSAgAAaCwsLIAYgBi8BcDsBfgwBCyAGQQA6AGcCQAJAIAYtAGdBAXFFDQAgBigCeEGIAmohISAGKAJ4KALMASEiIAYoAngoAtABISMgBigCdBCri4CAACEkIAYgBigCdBCsi4CAADYCNCAGICQ2AjAgISAiICNBlgEgBkEwahDOhICAABoMAQsgBi0AbyElQRghJgJAAkAgJSAmdCAmdUHuAEdBAXFFDQAgBigCeCgC8AJBwNyHgABBMGpGQQFxRQ0AIAZBAToAZgJAIAYtAGZBAXENACAGKAJ4QYgCaiEnIAYoAngoAswBISggBigCeCgC0AEhKSAGKAJ0EKuLgIAAISogBiAGKAJ0EKyLgIAANgJEIAYgKjYCQCAnICggKUGWASAGQcAAahDOhICAABoLDAELIAYtAG8hK0EYISwCQCArICx0ICx1QfUAR0EBcUUNACAGKAJ4KALwAkHA3IeAAEZBAXFFDQACQCAGKAJ4KAKgAkHA3IeAAEdBAXFFDQAgBigCeEGIAmohLSAGKAJ4KALMASEuIAYoAngoAtABIS8gBigCdBCri4CAACEwIAYgBigCdBCsi4CAADYCVCAGIDA2AlAgLSAuIC9B8gEgBkHQAGoQzoSAgAAaCwsLCyAGIAYvAXA7AX4LIAYvAX5B//8DcSExIAZBgAFqJICAgIAAIDEPC44CAQx/I4CAgIAAQTBrIQUgBSSAgICAACAFIAA2AiwgBSABNgIoIAUgAjYCJCAFIAM2AiAgBSAENgIcIAUoAiQhBiAGQQJLGgJAAkACQAJAIAYOAwABAgMLIAUoAixB/AFqIQcgBSgCKCgCCCEIIAUoAigoAgwhCSAFKAIgIQogBSgCHCELIAVB1eOEgAA2AgQgBSALNgIAIAcgCCAJIAogBRDOhICAABoMAgsgBSgCLEH8AWohDCAFKAIoKAIIIQ0gBSgCKCgCDCEOIAUoAiAhDyAFKAIcIRAgBUHp2oSAADYCFCAFIBA2AhAgDCANIA4gDyAFQRBqEM6EgIAAGgwBCwsgBUEwaiSAgICAAA8LdwEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAggQoIqAgABBAXFFDQAgAigCDCEDIAIoAgghBCACKAIMKAL4AkEBRiEFIAMgBEGrAkGqAiAFQQFxGxDJh4CAAAsgAkEQaiSAgICAAA8L4QEBB38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIcQRQQoIeAgAA2AhQgAigCFCEDIAJBDTsBACACQQA7AQIgAigCHCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIEIAIgAigCGCgCBDYCCCACIAIoAhgoAgg2AgwgAiACKAIcIAIoAhgQq4eAgAA2AhAgAyACKQIANwIAQRAhBiADIAZqIAIgBmooAgA2AgBBCCEHIAMgB2ogAiAHaikCADcCACACKAIUIQggAkEgaiSAgICAACAIDwuAAQEDfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQRRqIAIoAggQnIaAgAACQCACKAIMKAIIQQBGQQFxRQ0AIAIoAggoAgghAyACKAIMIAM2AggLIAIoAggoAgwhBCACKAIMIAQ2AgwgAkEQaiSAgICAAA8LqgEBBX8jgICAgABBEGshASABIAA2AgggASABKAIIKAKUAigCADYCBAJAA0AgASgCBEEARyECQQAhAyACQQFxIQQgAyEFAkAgBEUNACABKAIELQAeQX9zIQULAkAgBUEBcUUNAAJAIAEoAgQtABxB/wFxQcAAcUUNACABQQFBAXE6AA8MAwsgASABKAIEKAIANgIEDAELCyABQQBBAXE6AA8LIAEtAA9BAXEPC4ACAQp/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjoAJyADIAMoAixBFBCgh4CAADYCICADKAIgIQQgA0EMaiEFIANB7gA7AQwgA0EAOwEOIAMoAiwhBiAGKAIAQQFqIQcgBiAHNgIAIAMgBzYCECAFQQhqIAMoAigpAgA3AgAgAyADLQAnOgAcIANBDGpBEWohCEEAIQkgCCAJOwAAIAhBAmogCToAACAEIAMpAgw3AgBBECEKIAQgCmogCiADQQxqaigCADYCAEEIIQsgBCALaiALIANBDGpqKQIANwIAIAMoAiAhDCADQTBqJICAgIAAIAwPC8ABAQZ/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhxBEBCgh4CAADYCECADKAIQIQQgA0HZADsBACADQQA7AQIgAygCHCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIEIAMgAygCGCgCBDYCCCADIAMoAhQoAgg2AgwgBCADKQIANwIAQQghByAEIAdqIAMgB2opAgA3AgAgAygCECEIIANBIGokgICAgAAgCA8LggUBE38jgICAgABB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aikCADcCAEEIIQogBiAKaiAFIApqKQIANwIAIAUoAhghCyAFQTBqJICAgIAAIAsPC8wBAQF/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhQQrIuAgAA2AhAgAyADKAIQIAMoAhQQq4uAgABqNgIMAkADQCADKAIQIAMoAgxJQQFxRQ0BIAMgAygCECADKAIMIAMoAhBrENCEgIAANgIIAkAgAygCCA0AIAMoAhwgAygCGCgCBCADKAIYKAIIQaQBELCGgIAADAILIAMgAygCCCADKAIQajYCEAwACwsgA0EgaiSAgICAAA8L6wEBAn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMgAygCHCgCoAI2AhAgAyADKAIUEKyLgIAANgIMIAMgAygCDCADKAIUEKuLgIAAajYCCAJAA0AgAygCDCADKAIISUEBcUUNASADKAIQKAIAIQQgAyADKAIMIAMoAgggAygCDGsgBBGAgICAAICAgIAANgIEAkAgAygCBA0AIAMoAhwgAygCGCgCBCADKAIYKAIIQaQBELCGgIAADAILIAMgAygCBCADKAIMajYCDAwACwsgA0EgaiSAgICAAA8LuAEBAn8jgICAgABBIGshASABJICAgIAAIAEgADYCGCABIAEoAhgQq4uAgAA2AhQgASABKAIYEKyLgIAANgIQIAFBADYCDAJAAkADQCABKAIMIAEoAhRJQQFxRQ0BAkAgASgCECABKAIMai0AAEH/AXFBgAFxRQ0AIAFBAEEBcToAHwwDCyABIAEoAgxBAWo2AgwMAAsLIAFBAUEBcToAHwsgAS0AH0EBcSECIAFBIGokgICAgAAgAg8LrgMBDn8jgICAgABB0ABrIQYgBiSAgICAACAGIAA2AkwgBiABNgJIIAYgAjYCRCAGIAM2AkAgBiAENgI8IAYgBTYCOCAGIAYoAkxBNBCgh4CAADYCNCAGKAI0IQcgBkEOOwEAIAZBADsBAiAGKAJMIQggCCgCAEEBaiEJIAggCTYCACAGIAk2AgQgBiAGKAJEKAIENgIIIAYgBigCOCgCCDYCDCAGQRBqIQogBigCSCELIAogCykCADcCAEEIIQwgCiAMaiALIAxqKAIANgIAIAYgBigCQDYCHCAGIAYoAjw2AiAgBiAGKAJEKAIENgIkIAYgBigCRCgCCDYCKCAGIAYoAjgoAgQ2AiwgBiAGKAI4KAIINgIwIAcgBikCADcCAEEwIQ0gByANaiAGIA1qKAIANgIAQSghDiAHIA5qIAYgDmopAgA3AgBBICEPIAcgD2ogBiAPaikCADcCAEEYIRAgByAQaiAGIBBqKQIANwIAQRAhESAHIBFqIAYgEWopAgA3AgBBCCESIAcgEmogBiASaikCADcCACAGKAI0IRMgBkHQAGokgICAgAAgEw8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIQDwsmAQF/I4CAgIAAQRBrIQEgASAAOAIMIAEgASoCDDgCCCABKAIIDwsmAQF/I4CAgIAAQRBrIQEgASAAOQMIIAEgASsDCDkDACABKQMADwuCAQEIfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCACKAIMa0ECRiEDQQAhBCADQQFxIQUgBCEGAkAgBUUNACACKAIMLQAAQf8BcUHpAEYhB0EAIQggB0EBcSEJIAghBiAJRQ0AIAIoAgwtAAFB/wFxQfQARiEGCyAGQQFxDwu8AQEGfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACIAIoAhxBEBCgh4CAADYCFCACKAIUIQMgAkHYADsBBCACQQA7AQYgAigCHCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCGCgCBDYCDCACIAIoAhgoAgg2AhAgAyACKQIENwIAQQghBiADIAZqIAYgAkEEamopAgA3AgAgAigCFCEHIAJBIGokgICAgAAgBw8LfgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQCQCADKAIMQcwCaiADKAIMKALsAiADKAIIIAMoAgRBAUEBcRDIioCAAEEAR0EBcUUNACADKAIMIAMoAgRB5gEQ3oeAgAALIANBEGokgICAgAAPC5wEAQp/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADIAMoAiRBGGo2AiAgAyADKAIsIAMoAiAoAgAgAygCICgCBBDAh4CAADYCHCADQX82AhgCQAJAIAMoAiwgAygCICgCACADKAIgKAIEEJiKgIAAQQFxRQ0AIAMgAygCLCADKAIcEKyHgIAANgIYDAELIAMoAiwgAygCJCgCCCADKAIkKAIMQekBELCGgIAAAkAgAygCICgCBCADKAIgKAIAS0EBcUUNAAJAIAMoAiAoAgRBf2otAABB/wFxQSFGQQFxDQAgAygCICgCBEF/ai0AAEH/AXFBP0ZBAXFFDQELIAMoAixBiAJqIQQgAygCICgCACEFIAMoAiAoAgQhBiADKAIgKAIEIAMoAiAoAgBrIQcgAyADKAIgKAIANgIEIAMgBzYCACAEIAUgBkGTASADEM6EgIAAGgsLAkAgAygCGEF/RkEBcUUNACADKAIsIAMoAhwgAygCICgCACADKAIgKAIEQQAQsoaAgAALIAMoAiwgAygCKCADKAIcIAMoAiAQjoqAgAAgAygCLCEIIAMoAiAhCSADKAIcIQoCQAJAIAMoAhhBf0ZBAXFFDQBBACELDAELIAMoAhghCwsgAyAIIAkgCiALEOeJgIAANgIUIAMoAiwgAygCFBCkiYCAACEMIANBMGokgICAgAAgDA8L1wIBFX8jgICAgABBIGshCCAIJICAgIAAIAggADYCHCAIIAE2AhggCCACNgIUIAggAzYCECAIIAQ2AgwgCCAFNgIIIAggBjYCBCAIIAc2AgAgCCgCHCAIKAIYEI6HgIAAIQlBASEKIAlBAXEhCyAKIQwCQCALDQAgCCgCHCAIKAIUEI6HgIAAIQ1BASEOIA1BAXEhDyAOIQwgDw0AIAgoAhwgCCgCEBCOh4CAACEQQQEhESAQQQFxIRIgESEMIBINACAIKAIcIAgoAgwQjoeAgAAhE0EBIRQgE0EBcSEVIBQhDCAVDQAgCCgCHCAIKAIIEI6HgIAAIRZBASEXIBZBAXEhGCAXIQwgGA0AIAgoAhwgCCgCBBCOh4CAACEZQQEhGiAZQQFxIRsgGiEMIBsNACAIKAIcIAgoAgAQjoeAgAAhDAsgDEEBcSEcIAhBIGokgICAgAAgHA8LwAUBEH8jgICAgABB4ABrIQMgAySAgICAACADIAA2AlwgAyABNgJYIAMgAjYCVCADIAMoAlxBNBCgh4CAADYCUAJAAkAgAygCWCgCAEEAS0EBcUUNAAJAAkAgAygCVEEAR0EBcUUNACADIAMoAlgoAggoAgAoAgg2AkwgAyADKAJUKAIMNgJIDAELIAMgAygCWCgCCCgCACgCCDYCTCADIAMoAlgoAgggAygCWCgCAEEBa0ECdGooAgAoAgw2AkgLDAELAkAgAygCVEEAR0EBcQ0AQdH1hYAAQbPQhYAAQd8iQe+ShYAAEI6AgIAAAAsgAyADKAJUKAIINgJMIAMgAygCVCgCDDYCSAsgAygCUCEEIANBwgA7ARQgA0EAOwEWIAMoAlwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCGCADIAMoAkw2AhwgAyADKAJINgIgIANBADYCJCADQQA2AiggA0EANgIsIANBADYCMCADIAMoAlQ2AjQgA0EANgI4IANBADYCPCADQQA2AkAgA0EANgJEIAQgAykCFDcCAEEwIQcgBCAHaiAHIANBFGpqKAIANgIAQSghCCAEIAhqIAggA0EUamopAgA3AgBBICEJIAQgCWogCSADQRRqaikCADcCAEEYIQogBCAKaiAKIANBFGpqKQIANwIAQRAhCyAEIAtqIAsgA0EUamopAgA3AgBBCCEMIAQgDGogDCADQRRqaikCADcCACADQQA2AgwDQCADKAIMIAMoAlgoAgBJIQ1BACEOIA1BAXEhDyAOIRACQCAPRQ0AIAMoAlgoAgggAygCDEECdGooAgAhESADIBE2AhAgEUEARyEQCwJAIBBBAXFFDQAgAygCUEEUaiADKAIQEJyGgIAAIAMgAygCDEEBajYCDAwBCwsgAygCUCESIANB4ABqJICAgIAAIBIPC6oBAQF/I4CAgIAAQRBrIQQgBCSAgICAACAEIAA2AgwgBCABNgIIIAQgAjYCBCAEIAM2AgACQAJAIAQoAgAoAgAtAABB/wFxQd8ARkEBcUUNAAwBCwJAIAQoAgggBCgCBBCDi4CAAEEBcUUNACAEKAIMIAQoAgAoAgAgBCgCACgCBEHYARCwhoCAAAwBCyAEKAIIIAQoAgQQgYuAgAAaCyAEQRBqJICAgIAADwumAwEMfyOAgICAAEHQAGshAyADJICAgIAAIAMgADYCTCADIAE2AkggAyACNgJEIAMgAygCTEHAABCgh4CAADYCQCADKAJAIQQgA0EHOwEAIANBADsBAiADKAJMIQUgBSgCAEEBaiEGIAUgBjYCACADIAY2AgQgAyADKAJIKAIENgIIIAMgAygCRCgCCDYCDCADQQA2AhAgA0EANgIUIANBADYCGCADQQA2AhwgA0EANgIgIANBADYCJCADQQA2AiggA0EANgIsIAMgAygCSCgCBDYCMCADIAMoAkgoAgg2AjQgAyADKAJEKAIENgI4IAMgAygCRCgCCDYCPCAEIAMpAgA3AgBBOCEHIAQgB2ogAyAHaikCADcCAEEwIQggBCAIaiADIAhqKQIANwIAQSghCSAEIAlqIAMgCWopAgA3AgBBICEKIAQgCmogAyAKaikCADcCAEEYIQsgBCALaiADIAtqKQIANwIAQRAhDCAEIAxqIAMgDGopAgA3AgBBCCENIAQgDWogAyANaikCADcCACADKAJAIQ4gA0HQAGokgICAgAAgDg8LRAEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQRRqIAIoAggQnIaAgAAgAkEQaiSAgICAAA8LjwMBC38jgICAgABB0ABrIQMgAySAgICAACADIAA2AkwgAyABNgJIIAMgAjYCRCADIAMoAkxBNBCgh4CAADYCQCADKAJAIQQgA0HCADsBDCADQQA7AQ4gAygCTCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIQIAMgAygCSCgCBDYCFCADIAMoAkQoAgg2AhggA0EANgIcIANBADYCICADQQA2AiQgA0EANgIoIANBADYCLCADIAMoAkgoAgQ2AjAgAyADKAJIKAIINgI0IAMgAygCRCgCBDYCOCADIAMoAkQoAgg2AjwgBCADKQIMNwIAQTAhByAEIAdqIAcgA0EMamooAgA2AgBBKCEIIAQgCGogCCADQQxqaikCADcCAEEgIQkgBCAJaiAJIANBDGpqKQIANwIAQRghCiAEIApqIAogA0EMamopAgA3AgBBECELIAQgC2ogCyADQQxqaikCADcCAEEIIQwgBCAMaiAMIANBDGpqKQIANwIAIAMoAkAhDSADQdAAaiSAgICAACANDwtwAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADIAMoAgwgAygCCBCrh4CAADYCACADKAIMIAMoAgggAygCACADKAIEQQFBAXEQgIqAgAAhBCADQRBqJICAgIAAIAQPC5UCAQh/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADIAMoAixBHBCgh4CAADYCICADKAIgIQQgA0H2ADsBBCADQQA7AQYgAygCLCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIIIAMgAygCKCgCBDYCDCADIAMoAiQoAgw2AhAgAyADKAIkNgIUIAMgAygCKCgCBDYCGCADIAMoAigoAgg2AhwgBCADKQIENwIAQRghByAEIAdqIAcgA0EEamooAgA2AgBBECEIIAQgCGogCCADQQRqaikCADcCAEEIIQkgBCAJaiAJIANBBGpqKQIANwIAIAMoAiAhCiADQTBqJICAgIAAIAoPC4cDAQp/I4CAgIAAQdAAayEFIAUkgICAgAAgBSAANgJMIAUgATYCSCAFIAI2AkQgBSADNgJAIAUgBDYCPCAFIAUoAkxBLBCgh4CAADYCOCAFKAI4IQYgBUH1ADsBDCAFQQA7AQ4gBSgCTCEHIAcoAgBBAWohCCAHIAg2AgAgBSAINgIQIAUgBSgCRCgCBDYCFCAFIAUoAjwoAgg2AhggBSAFKAJINgIcIAUgBSgCRCgCBDYCICAFIAUoAkQoAgg2AiQgBSAFKAJAKAIENgIoIAUgBSgCQCgCCDYCLCAFIAUoAjwoAgQ2AjAgBSAFKAI8KAIINgI0IAYgBSkCDDcCAEEoIQkgBiAJaiAJIAVBDGpqKAIANgIAQSAhCiAGIApqIAogBUEMamopAgA3AgBBGCELIAYgC2ogCyAFQQxqaikCADcCAEEQIQwgBiAMaiAMIAVBDGpqKQIANwIAQQghDSAGIA1qIA0gBUEMamopAgA3AgAgBSgCOCEOIAVB0ABqJICAgIAAIA4PC5QMAS5/I4CAgIAAQZABayEEIAQkgICAgAAgBCAANgKIASAEIAE2AoQBIAQgAjYCgAEgBCADOwF+AkADQCAEKAKIAUEaEMuHgIAAQQFxRQ0BIAQoAogBQbwBaiEFQQghBiAFIAZqKAIAIQcgBiAEQfAAamogBzYCACAEIAUpAgA3A3AgBCgCiAFBHUE7ENiHgIAAIAQoAogBIQggBCgCgAEhCSAEKAKIAUG8AWohCiAEIAggCSAEQfAAaiAKEOyHgIAANgKAAQwACwsCQAJAIAQoAogBQRBB+wAQwYeAgABBAXENACAEIAQoAoABNgKMAQwBCyAEQQA2AkwCQAJAIAQoAogBQRAQy4eAgABBAXFFDQAgBCgCiAFBvAFqIQtBCCEMIAsgDGooAgAhDSAMIARB4ABqaiANNgIAIAQgCykCADcDYCAEKAKIAUH5ABDLh4CAABoCQCAEKAKIAUEUEMuHgIAAQQFxDQAgBCgCiAEhDiAEKAKEASEPIAQvAX5B//8DcUEBaiEQQQMhEUHZASESIAQgDiAPIBFB/wFxIBIgEEH//wNxEJqIgIAANgJMIAQoAogBQfkAEMuHgIAAGiAEKAKIAUEUQe4BENiHgIAACyAEKAKIAUG8AWohE0EIIRQgEyAUaigCACEVIBQgBEHQAGpqIBU2AgAgBCATKQIANwNQDAELIAQoAogBEL6GgIAAIAQoAogBQbwBaiEWQQghFyAWIBdqKAIAIRggFyAEQeAAamogGDYCACAEIBYpAgA3A2AgBCgCiAFB+QAQy4eAgAAaAkAgBCgCiAFB/QAQy4eAgABBAXENACAEKAKIASEZIAQoAoQBIRogBC8BfkH//wNxQQFqIRtBAyEcQd4BIR0gBCAZIBogHEH/AXEgHSAbQf//A3EQmoiAgAA2AkwgBCgCiAFB+QAQy4eAgAAaIAQoAogBQf0AQe8BENiHgIAACyAEKAKIAUG8AWohHkEIIR8gHiAfaigCACEgIB8gBEHQAGpqICA2AgAgBCAeKQIANwNQCwJAIAQoAkxBAEdBAXENACAEIAQoAogBIAQoAoABIARB4ABqIARB0ABqEJmKgIAANgKMAQwBCyAEKAJMLwEAISECQAJAAkACQAJAICFBB0YNACAhQTRGDQEgIUHCAEYNAgwDCyAEIAQoAkw2AkgCQCAEKAJIKAIQQQBGQQFxRQ0AIAQoAkgoAjBBAEZBAXFFDQAgBCgCgAEoAgghIiAEKAJIICI2AgggBCgCWCEjIAQoAkggIzYCDCAEKAKAASEkIAQoAkggJDYCECAEKAJIQTBqISUgBCAEKAJkNgJAIAQgBCgCaDYCRCAlIAQpAkA3AgAgBCgCSEE4aiEmIAQgBCgCVDYCOCAEIAQoAlg2AjwgJiAEKQI4NwIAIAQgBCgCSDYCjAEMBQsMAwsgBCAEKAJMNgI0AkAgBCgCNCgCEEEARkEBcUUNACAEKAI0KAIoQQBGQQFxRQ0AIAQoAoABKAIIIScgBCgCNCAnNgIIIAQoAlghKCAEKAI0ICg2AgwgBCgCgAEhKSAEKAI0ICk2AhAgBCgCNEEoaiEqIAQgBCgCZDYCLCAEIAQoAmg2AjAgKiAEKQIsNwIAIAQoAjRBMGohKyAEIAQoAlQ2AiQgBCAEKAJYNgIoICsgBCkCJDcCACAEIAQoAjQ2AowBDAQLDAILIAQgBCgCTDYCIAJAIAQoAiAoAhBBAEZBAXFFDQAgBCgCICgCJEEARkEBcUUNACAEKAKAASgCCCEsIAQoAiAgLDYCCCAEKAJYIS0gBCgCICAtNgIMIAQoAoABIS4gBCgCICAuNgIQIAQoAiBBJGohLyAEIAQoAmQ2AhggBCAEKAJoNgIcIC8gBCkCGDcCACAEKAIgQSxqITAgBCAEKAJUNgIQIAQgBCgCWDYCFCAwIAQpAhA3AgAgBCAEKAIgNgKMAQwDCwwBCwsgBCAEKAKIASAEKAKAASAEQeAAaiAEQdAAahCZioCAADYCDCAEKAIMIAQoAkwQkIqAgAAgBCAEKAIMNgKMAQsgBCgCjAEhMSAEQZABaiSAgICAACAxDwunAgEIfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjxBIBCgh4CAADYCLCAEKAIsIQUgBEEDOwEMIARBADsBDiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAI4KAIINgIUIAQgBCgCNCgCDDYCGCAEIAQoAjg2AhwgBCAEKAI0NgIgIAQgBCgCMCgCBDYCJCAEIAQoAjAoAgg2AiggBSAEKQIMNwIAQRghCCAFIAhqIAggBEEMamopAgA3AgBBECEJIAUgCWogCSAEQQxqaikCADcCAEEIIQogBSAKaiAKIARBDGpqKQIANwIAIAQoAiwhCyAEQcAAaiSAgICAACALDwunAgEIfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjxBIBCgh4CAADYCLCAEKAIsIQUgBEEXOwEMIARBADsBDiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAI4KAIINgIUIAQgBCgCNCgCDDYCGCAEIAQoAjg2AhwgBCAEKAI0NgIgIAQgBCgCMCgCBDYCJCAEIAQoAjAoAgg2AiggBSAEKQIMNwIAQRghCCAFIAhqIAggBEEMamopAgA3AgBBECEJIAUgCWogCSAEQQxqaikCADcCAEEIIQogBSAKaiAKIARBDGpqKQIANwIAIAQoAiwhCyAEQcAAaiSAgICAACALDwv9AgEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIYIAMgATYCFCADIAI2AhAgAyADKAIQIAMoAhRrNgIMAkACQCADKAIMDQAgA0EAQQFxOgAfDAELIAMgAygCGCADKAIUIAMoAhAgAygCFGsQ9oaAgAA2AggCQCADKAIIDQAgA0EAQQFxOgAfDAELAkACQCADKAIYLQCDA0EBcUUNACADKAIYKAKgAigCDCEEAkAgAygCFCADKAIMIAQRgICAgACAgICAAEEBcUUNACADQQBBAXE6AB8MAwsMAQsCQCADKAIUIAMoAgwQ1YSAgABBAXFFDQAgA0EAQQFxOgAfDAILCyADIAMoAhQgAygCCGo2AgQCQANAIAMoAhggAygCBCADKAIQIAMoAgRrEOOGgIAAIQUgAyAFNgIIIAVFDQEgAyADKAIIIAMoAgRqNgIEDAALCyADIAMoAgQgAygCEEZBAXE6AB8LIAMtAB9BAXEhBiADQSBqJICAgIAAIAYPC8UDAQx/I4CAgIAAQeAAayEEIAQkgICAgAAgBCAANgJcIAQgATYCWCAEIAI2AlQgBCADNgJQIAQgBCgCXEHAABCgh4CAADYCTCAEKAJMIQUgBEEHOwEMIARBADsBDiAEKAJcIQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AhAgBCAEKAJYKAIINgIUIAQgBCgCUCgCCDYCGCAEIAQoAlg2AhwgBEEANgIgIARBADYCJCAEQQA2AiggBEEANgIsIARBADYCMCAEQQA2AjQgBEEANgI4IAQgBCgCVCgCBDYCPCAEIAQoAlQoAgg2AkAgBCAEKAJQKAIENgJEIAQgBCgCUCgCCDYCSCAFIAQpAgw3AgBBOCEIIAUgCGogCCAEQQxqaikCADcCAEEwIQkgBSAJaiAJIARBDGpqKQIANwIAQSghCiAFIApqIAogBEEMamopAgA3AgBBICELIAUgC2ogCyAEQQxqaikCADcCAEEYIQwgBSAMaiAMIARBDGpqKQIANwIAQRAhDSAFIA1qIA0gBEEMamopAgA3AgBBCCEOIAUgDmogDiAEQQxqaikCADcCACAEKAJMIQ8gBEHgAGokgICAgAAgDw8LSgEFfyOAgICAAEEQayEBIAEgADYCDCABKAIMQQBHIQJBACEDIAJBAXEhBCADIQUCQCAERQ0AIAEoAgwoAhBBAEchBQsgBUEBcQ8LYAEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCgCBCEDIAIoAgwgAzYCCCACKAIMQSxqIQQgAiACKAIIKAIENgIAIAIgAigCCCgCCDYCBCAEIAIpAgA3AgAPC2ABA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAggoAgghAyACKAIMIAM2AgwgAigCDEE0aiEEIAIgAigCCCgCBDYCACACIAIoAggoAgg2AgQgBCACKQIANwIADwv6AQEHfyOAgICAAEEQayECIAIgADYCDCACIAE2AggCQAJAIAIoAgwoAghBAEZBAXFFDQAgAigCCCgCCCEDIAIoAgwgAzYCCAwBCwJAAkAgAigCDCgCCCACKAIIKAIISUEBcUUNACACKAIMKAIIIQQMAQsgAigCCCgCCCEECyAEIQUgAigCDCAFNgIICwJAAkAgAigCDCgCDEEARkEBcUUNACACKAIIKAIMIQYgAigCDCAGNgIMDAELAkACQCACKAIMKAIMIAIoAggoAgxLQQFxRQ0AIAIoAgwoAgwhBwwBCyACKAIIKAIMIQcLIAchCCACKAIMIAg2AgwLDwtmAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIIKAIAQQNGQQFxRQ0AQQAhAwwBCyACKAIMIAIoAggQq4eAgAAhAwsgAyEEIAJBEGokgICAgAAgBA8LswIBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUAkAgAygCHCgC+AJBAUdBAXFFDQACQCADKAIYQQBHQQFxRQ0AIAMoAhgvAQJB//8DcUEIcUUNACADQQA2AgwDQCADKAIMIAMoAhgoAhBJIQRBACEFIARBAXEhBiAFIQcCQCAGRQ0AIAMoAhgoAhggAygCDEECdGooAgAhCCADIAg2AhAgCEEARyEHCwJAIAdBAXFFDQACQCADKAIQLwEAQf//A3FB2gBGQQFxRQ0AIAMoAhwgAygCEEGTAhDeh4CAAAwBCyADIAMoAgxBAWo2AgwMAQsLCwJAIAMoAhRBAEdBAXFFDQAgAygCHCADKAIUQZICEN6HgIAACwsgA0EgaiSAgICAAA8L/gQBA38jgICAgABBIGshASABJICAgIAAIAEgADYCGCABKAIYLwEAQXpqIQIgAkGKAUsaAkACQAJAAkACQCACDosBAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMDAgMDAwMDAwMDAwMBAwMCAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAgMCAwMDAwMDAwMDAwICAgMDAgMCAgMLAkAgASgCGC8BAkH//wNxQQJxRQ0AIAFBAUEBcToAHwwECyABIAEoAhg2AhQgAUEANgIQAkADQCABKAIQIAEoAhQoAhBJQQFxRQ0BAkAgASgCFCgCGCABKAIQQQJ0aigCABCgioCAAEEBcQ0AIAFBAEEBcToAHwwGCyABIAEoAhBBAWo2AhAMAAsLIAFBAUEBcToAHwwDCwJAIAEoAhgvAQJB//8DcUECcUUNACABQQFBAXE6AB8MAwsgASABKAIYNgIMIAFBADYCCAJAA0AgASgCCCABKAIMKAIYSUEBcUUNASABIAEoAgwoAiAgASgCCEECdGooAgA2AgQCQCABKAIELwEAQf//A3FBCEZBAXENACABQQBBAXE6AB8MBQsgASABKAIENgIAAkACQCABKAIAKAIQEKCKgIAAQQFxRQ0AIAEoAgAoAhQQoIqAgABBAXENAQsgAUEAQQFxOgAfDAULIAEgASgCCEEBajYCCAwACwsgAUEBQQFxOgAfDAILIAFBAUEBcToAHwwBCyABQQBBAXE6AB8LIAEtAB9BAXEhAyABQSBqJICAgIAAIAMPC48DAQd/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAIoAhgvAQAhAwJAAkACQAJAAkACQCADQQtGDQAgA0HiAEYNASADQfQARg0CIANBjAFGDQMMBAsgAiACKAIYNgIUAkAgAigCFCgCGEEAR0EBcUUNACACKAIcIAIoAhQoAhgQoYqAgAALDAQLIAIgAigCGDYCECACKAIcIAIoAhAoAhQQ+IeAgABBBGogAigCECgCEBD/iYCAAAwDCyACIAIoAhg2AgwCQCACKAIMKAIQQQBHQQFxRQ0AIAIoAhwgAigCDCgCEBChioCAAAsMAgsgAiACKAIYNgIIIAJBADYCAANAIAIoAgAgAigCCCgCEEkhBEEAIQUgBEEBcSEGIAUhBwJAIAZFDQAgAigCCCgCGCACKAIAQQJ0aigCACEIIAIgCDYCBCAIQQBHIQcLAkAgB0EBcUUNACACKAIcIAIoAgQQoYqAgAAgAiACKAIAQQFqNgIADAELCwwBCwsgAkEgaiSAgICAAA8L6wIBCX8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8QSgQoIeAgAA2AiwgBCgCLCEFIARBIDsBBCAEIAQoAjBBBEH//wNxEKeJgIAAOwEGIAQoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCCCAEIAQoAjgoAgg2AgwgBCAEKAIwKAIMNgIQIAQgBCgCOCgCEDYCFCAEIAQoAjgoAgg2AhggBCAEKAI4KAIMNgIcIAQgBCgCMDYCICAEIAQoAjQoAgQ2AiQgBCAEKAI0KAIINgIoIAUgBCkCBDcCAEEgIQggBSAIaiAIIARBBGpqKQIANwIAQRghCSAFIAlqIAkgBEEEamopAgA3AgBBECEKIAUgCmogCiAEQQRqaikCADcCAEEIIQsgBSALaiALIARBBGpqKQIANwIAIAQoAiwhDCAEQcAAaiSAgICAACAMDwvoAgEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjxBIBCgh4CAADYCLCAEKAIsIQUgBEEpOwEMIAQgBCgCMEEEQf//A3EQp4mAgAA7AQ4gBCgCPCEGIAYoAgBBAWohByAGIAc2AgAgBCAHNgIQIAQgBCgCOCgCCDYCFCAEIAQoAjAoAgw2AhggBCAEKAI4NgIcIARBDGpBFGohCAJAAkAgBCgCNCgCAEEDRkEBcUUNACAIQQA2AgAgCEEANgIEDAELIAggBCgCNCgCBDYCACAIIAQoAjQoAgg2AgQLIAQgBCgCMDYCKCAFIAQpAgw3AgBBGCEJIAUgCWogCSAEQQxqaikCADcCAEEQIQogBSAKaiAKIARBDGpqKQIANwIAQQghCyAFIAtqIAsgBEEMamopAgA3AgAgBCgCLCEMIARBwABqJICAgIAAIAwPC5gDAQp/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIAQgBCgCPEEoEKCHgIAANgIsIAQoAiwhBSAEQSw7AQQgBCAEKAIwQQRB//8DcRCniYCAADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjgoAhA2AhQgBEEEakEUaiAEKAI4QQhqKQIANwIAIAQgBCgCMDYCICAEQQRqQSBqIQgCQAJAIAQoAjQoAgBBA0ZBAXFFDQAgCEEANgIAIAhBADYCBAwBCyAIIAQoAjQoAgQ2AgAgCCAEKAI0KAIINgIECyAFIAQpAgQ3AgBBICEJIAUgCWogCSAEQQRqaikCADcCAEEYIQogBSAKaiAKIARBBGpqKQIANwIAQRAhCyAFIAtqIAsgBEEEamopAgA3AgBBCCEMIAUgDGogDCAEQQRqaikCADcCACAEKAIsIQ0gBEHAAGokgICAgAAgDQ8LpQMBCn8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8QSgQoIeAgAA2AiwgBCgCLCEFIARBwAA7AQQgBCAEKAIwQQRB//8DcRCniYCAADsBBiAEKAI8IQYgBigCAEEBaiEHIAYgBzYCACAEIAc2AgggBCAEKAI4KAIINgIMIAQgBCgCMCgCDDYCECAEIAQoAjwgBCgCOBCoioCAADYCFCAEIAQoAjgoAgg2AhggBCAEKAI4KAIMNgIcIAQgBCgCMDYCICAEQQRqQSBqIQgCQAJAIAQoAjQoAgBBA0ZBAXFFDQAgCEEANgIAIAhBADYCBAwBCyAIIAQoAjQoAgQ2AgAgCCAEKAI0KAIINgIECyAFIAQpAgQ3AgBBICEJIAUgCWogCSAEQQRqaikCADcCAEEYIQogBSAKaiAKIARBBGpqKQIANwIAQRAhCyAFIAtqIAsgBEEEamopAgA3AgBBCCEMIAUgDGogDCAEQQRqaikCADcCACAEKAIsIQ0gBEHAAGokgICAgAAgDQ8LwgMBC38jgICAgABB0ABrIQYgBiSAgICAACAGIAA2AkwgBiABNgJIIAYgAjYCRCAGIAM2AkAgBiAENgI8IAYgBTYCOCAGIAYoAkxBLBCgh4CAADYCNCAGKAI0IQcgBkHiADsBCCAGIAYoAkBBBEH//wNxEKeJgIAAOwEKIAYoAkwhCCAIKAIAQQFqIQkgCCAJNgIAIAYgCTYCDCAGIAYoAjwoAgA2AhAgBiAGKAJAKAIMNgIUIAYgBigCSDYCGCAGIAYoAkQ2AhwgBkEIakEYaiAGKAI8KQIANwIAIAYgBigCQDYCKCAGQQhqQSRqIQoCQAJAIAYoAjgoAgBBA0ZBAXFFDQAgCkEANgIAIApBADYCBAwBCyAKIAYoAjgoAgQ2AgAgCiAGKAI4KAIINgIECyAHIAYpAgg3AgBBKCELIAcgC2ogCyAGQQhqaigCADYCAEEgIQwgByAMaiAMIAZBCGpqKQIANwIAQRghDSAHIA1qIA0gBkEIamopAgA3AgBBECEOIAcgDmogDiAGQQhqaikCADcCAEEIIQ8gByAPaiAPIAZBCGpqKQIANwIAIAYoAjQhECAGQdAAaiSAgICAACAQDwudAwEKfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjxBKBCgh4CAADYCLCAEKAIsIQUgBEHRADsBBCAEIAQoAjBBBEH//wNxEKeJgIAAOwEGIAQoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCCCAEIAQoAjgoAgg2AgwgBCAEKAIwKAIMNgIQIAQgBCgCOCgCEDYCFCAEIAQoAjgoAgg2AhggBCAEKAI4KAIMNgIcIAQgBCgCMDYCICAEQQRqQSBqIQgCQAJAIAQoAjQoAgBBA0ZBAXFFDQAgCEEANgIAIAhBADYCBAwBCyAIIAQoAjQoAgQ2AgAgCCAEKAI0KAIINgIECyAFIAQpAgQ3AgBBICEJIAUgCWogCSAEQQRqaikCADcCAEEYIQogBSAKaiAKIARBBGpqKQIANwIAQRAhCyAFIAtqIAsgBEEEamopAgA3AgBBCCEMIAUgDGogDCAEQQRqaikCADcCACAEKAIsIQ0gBEHAAGokgICAgAAgDQ8LxwEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAigCBC8BACEDAkACQAJAAkAgA0EKRg0AAkAgA0E+Rg0AIANB7wBGDQIMAwsgAiACKAIEKAIQNgIMDAMLIAIgAigCBCgCEDYCDAwCCyACIAIoAgggAigCBCgCCCACKAIEKAIMEMCHgIAANgIMDAELQeK2hoAAQbPQhYAAQYsjQaushYAAEI6AgIAAAAsgAigCDCEEIAJBEGokgICAgAAgBA8LJwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAKUAi0AHUH/AXEPC+sBAQd/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjoAJyADIAMoAixBFBCgh4CAADYCICADKAIgIQQgA0GGATsBDCADIAMtACdB/wFxOwEOIAMoAiwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCECADIAMoAigoAgg2AhQgAyADKAIoKAIMNgIYIAMgAygCKDYCHCAEIAMpAgw3AgBBECEHIAQgB2ogByADQQxqaigCADYCAEEIIQggBCAIaiAIIANBDGpqKQIANwIAIAMoAiAhCSADQTBqJICAgIAAIAkPC/sBAQZ/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhxBvAJqIAMoAhQoAgAQh4uAgAA2AhACQAJAIAMoAhAoAgRBAEtBAXFFDQAgAyADKAIQKAIEQQFrNgIMIAMgAygCDBCYjICAADYCCCADKAIIIQQgAygCECgCACEFIAMoAgwhBgJAIAZFDQAgBCAFIAb8CgAACyADKAIcQbwCaiADKAIIIAMoAgwQjYuAgAAhByADKAIYIAc2AgAMAQsgAygCHEHhuoaAAEEAEJKHgIAAIQggAygCGCAINgIACyADQSBqJICAgIAADwuGBwESfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCXCACIAE2AlggAiACKAJYNgJUIAIgAigCVCgCADYCUCACIAIoAlQoAgQ2AkwgAiACKAJUQQxqNgJIIAIgAigCXBCsi4CAADYCRCACIAIoAlwQq4uAgAA2AkAgAkE4akEANgIAIAJCADcDMCACKAJEIQMgAigCQCEEIAIoAlAtAIMDIQUgAigCUCgCoAIhBiACIANB3AAgBCAFQQFxIAYQoIuAgAA2AiwCQCACKAIsQQBHQX9zQX9zQQFxRQ0AIAIoAlAhByACKAJEIQggAigCQCEJIAIoAiwhCiAHIAJBMGogCCAJIAoQroqAgAAgAiACQTBqEN6KgIAANgJEIAIgAkEwahDfioCAADYCQAsCQAJAIAIoAlAgAigCRCACKAJEIAIoAkBqEJiKgIAAQQFxDQAgAkEwahDrioCAAAwBCwJAAkAgAigCVC0AGEEBcUUNACACIAIoAkQ2AhQgAiACKAJEIAIoAkBqNgIYIAIgAikCFDcDICACIAIoAlAgAigCICACKAIkEMCHgIAANgIcDAELIAIgAigCTCgCECgCCDYCDCACIAIoAkwoAhAoAgw2AhAgAiACKQIMNwMgIAIgAigCQBCYjICAADYCCAJAIAIoAghBAEZBAXFFDQAQvouAgAAACyACKAIIIQsgAigCRCEMIAIoAkAhDQJAIA1FDQAgCyAMIA38CgAACyACIAIoAlAgAigCCCACKAJAELGGgIAANgIcCwJAIAIoAhxFDQAgAigCSCACKAIcEIOLgIAAQQFxDQAgAigCSCACKAIcEIGLgIAAGiACKAJQIAIoAhwQrIeAgAAhDiACIA42AgQCQCAOQX9GQQFxRQ0AAkAgAigCRCACKAJAEK+KgIAAQQFxRQ0AIAJBMGoQ64qAgAAMAwsgAigCUCACKAIcIAIoAiAgAigCJEEAELKGgIAACwJAIAIoAlQoAghBAEZBAXFFDQAgAigCUCACKAJMELCKgIAAIQ8gAigCVCAPNgIICyACKAJQIRAgAigCHCERAkACQCACKAIEQX9GQQFxRQ0AQQAhEgwBCyACKAIEIRILIBIhEyACIBAgAkEgaiARIBMQ54mAgAA2AgAgAigCVCgCCEEUaiACKAIAEJyGgIAACyACQTBqEOuKgIAACyACQeAAaiSAgICAAA8L8wEBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIcKAL0AkEAR0EBcQ0AQd71hYAAQbPQhYAAQYg8QcCthIAAEI6AgIAAAAsgAiACKAIYKAIINgIUIAIgAigCHCgC9AIoAgA2AhACQANAIAIoAhBBAEtBAXFFDQEgAiACKAIcKAL0AigCCCACKAIQQQFrQQJ0aigCADYCDAJAIAIoAgwoAgggAigCFElBAXFFDQAMAgsgAigCHCgC9AIhAyADIAMoAgBBf2o2AgAgAiACKAIQQX9qNgIQDAALCyACQSBqJICAgIAADwukBAEHfyOAgICAAEEgayEFIAUkgICAgAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSADNgIQIAUgBDYCDCAFIAUoAhQgBSgCEGo2AgggBSgCGCAFKAIUIAUoAgwgBSgCFGsQ44qAgAACQANAIAUoAgxBAWohBiAFIAY2AgwCQCAGIAUoAghPQQFxRQ0AIAUoAhhB3ABB/wFxEOaKgIAADAILIAUoAgwtAABBUGohByAHQcgASxoCQAJAAkACQAJAIAcOSQEBAQEBAQEBAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIDAwADCyAFIAUoAhggBSgCDCAFKAIIELGKgIAANgIMDAMLIAUgBSgCGCAFKAIMIAUoAggQsoqAgAA2AgwMAgsgBSAFKAIcIAUoAhggBSgCDCAFKAIIELOKgIAANgIMDAELIAUoAhhB3ABB/wFxEOaKgIAACyAFKAIMIQggBSgCCCAFKAIMayEJIAUoAhwtAIMDIQogBSgCHCgCoAIhCyAFIAhB3AAgCSAKQQFxIAsQoIuAgAA2AgQCQAJAIAUoAgRBAEZBAXFFDQAMAQsgBSgCGCAFKAIMIAUoAgQgBSgCDGsQ44qAgAAgBSAFKAIENgIMDAELCyAFKAIYIAUoAgwgBSgCCCAFKAIMaxDjioCAAAsgBUEgaiSAgICAAA8L6BQBVH8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAigCBEF+aiEDIANBCksaAkACQAJAAkACQAJAAkACQAJAIAMOCwABAgMEBwUHBwcGBwsgAigCCCwAAEGcf2ohBCAEQQtLGgJAAkACQAJAIAQODAADAwMDAQMDAwMDAgMLIAIoAgghBSACKAIEIQYCQCAFQfvbhIAAIAYQ1IuAgAANACACQQFBAXE6AA8MCwsgAkEAQQFxOgAPDAoLIAIoAgghByACKAIEIQgCQCAHQc6MhYAAIAgQ1IuAgAANACACQQFBAXE6AA8MCgsgAigCCCEJIAIoAgQhCgJAIAlBsuuEgAAgChDUi4CAAA0AIAJBAUEBcToADwwKCyACQQBBAXE6AA8MCQsgAigCCCELIAIoAgQhDAJAIAtBvMuEgAAgDBDUi4CAAA0AIAJBAUEBcToADwwJCyACQQBBAXE6AA8MCAsgAkEAQQFxOgAPDAcLIAIoAggsAABBn39qIQ0gDUENSxoCQAJAAkACQAJAAkAgDQ4OAAUFAQIDBQUFBQUFBQQFCyACKAIIIQ4gAigCBCEPAkAgDkHZwYWAACAPENSLgIAADQAgAkEBQQFxOgAPDAwLIAJBAEEBcToADwwLCyACKAIIIRAgAigCBCERAkAgEEHdjIWAACARENSLgIAADQAgAkEBQQFxOgAPDAsLIAJBAEEBcToADwwKCyACKAIIIRIgAigCBCETAkAgEkH2wIWAACATENSLgIAADQAgAkEBQQFxOgAPDAoLIAJBAEEBcToADwwJCyACKAIIIRQgAigCBCEVAkAgFEG7y4SAACAVENSLgIAADQAgAkEBQQFxOgAPDAkLIAJBAEEBcToADwwICyACKAIIIRYgAigCBCEXAkAgFkH+9YSAACAXENSLgIAADQAgAkEBQQFxOgAPDAgLIAIoAgghGCACKAIEIRkCQCAYQfGPhIAAIBkQ1IuAgAANACACQQFBAXE6AA8MCAsgAkEAQQFxOgAPDAcLIAJBAEEBcToADwwGCyACKAIILAAAQZ1/aiEaIBpBFEsaAkACQAJAAkACQAJAAkACQCAaDhUABwEHBwcHBwcHBwIHBwcDBAUHBwYHCyACKAIIIRsgAigCBCEcAkAgG0HRp4WAACAcENSLgIAADQAgAkEBQQFxOgAPDA0LIAJBAEEBcToADwwMCyACKAIIIR0gAigCBCEeAkAgHUHdpoWAACAeENSLgIAADQAgAkEBQQFxOgAPDAwLIAJBAEEBcToADwwLCyACKAIIIR8gAigCBCEgAkAgH0GMi4SAACAgENSLgIAADQAgAkEBQQFxOgAPDAsLIAJBAEEBcToADwwKCyACKAIIISEgAigCBCEiAkAgIUH524SAACAiENSLgIAADQAgAkEBQQFxOgAPDAoLIAJBAEEBcToADwwJCyACKAIIISMgAigCBCEkAkAgI0HGjIWAACAkENSLgIAADQAgAkEBQQFxOgAPDAkLIAJBAEEBcToADwwICyACKAIIISUgAigCBCEmAkAgJUHB7oSAACAmENSLgIAADQAgAkEBQQFxOgAPDAgLIAIoAgghJyACKAIEISgCQCAnQZOOhYAAICgQ1IuAgAANACACQQFBAXE6AA8MCAsgAkEAQQFxOgAPDAcLIAIoAgghKSACKAIEISoCQCApQbzuhIAAICoQ1IuAgAANACACQQFBAXE6AA8MBwsgAkEAQQFxOgAPDAYLIAJBAEEBcToADwwFCyACKAIILAAAQZ9/aiErICtBGEsaAkACQAJAAkACQAJAAkACQAJAAkACQCArDhkAAQIKAwQKCgoKCgoKCgoKCgUGCgcKCAoJCgsgAigCCCEsIAIoAgQhLQJAICxBuL6EgAAgLRDUi4CAAA0AIAJBAUEBcToADwwPCyACQQBBAXE6AA8MDgsgAigCCCEuIAIoAgQhLwJAIC5BjOuEgAAgLxDUi4CAAA0AIAJBAUEBcToADwwOCyACKAIIITAgAigCBCExAkAgMEHggYWAACAxENSLgIAADQAgAkEBQQFxOgAPDA4LIAJBAEEBcToADwwNCyACKAIIITIgAigCBCEzAkAgMkG8soSAACAzENSLgIAADQAgAkEBQQFxOgAPDA0LIAJBAEEBcToADwwMCyACKAIIITQgAigCBCE1AkAgNEHLjIWAACA1ENSLgIAADQAgAkEBQQFxOgAPDAwLIAJBAEEBcToADwwLCyACKAIIITYgAigCBCE3AkAgNkGpp4WAACA3ENSLgIAADQAgAkEBQQFxOgAPDAsLIAJBAEEBcToADwwKCyACKAIIITggAigCBCE5AkAgOEH1gISAACA5ENSLgIAADQAgAkEBQQFxOgAPDAoLIAJBAEEBcToADwwJCyACKAIIITogAigCBCE7AkAgOkGO04SAACA7ENSLgIAADQAgAkEBQQFxOgAPDAkLIAJBAEEBcToADwwICyACKAIIITwgAigCBCE9AkAgPEHbjIWAACA9ENSLgIAADQAgAkEBQQFxOgAPDAgLIAIoAgghPiACKAIEIT8CQCA+QZj1hIAAID8Q1IuAgAANACACQQFBAXE6AA8MCAsgAkEAQQFxOgAPDAcLIAIoAgghQCACKAIEIUECQCBAQdmxhYAAIEEQ1IuAgAANACACQQFBAXE6AA8MBwsgAkEAQQFxOgAPDAYLIAIoAgghQiACKAIEIUMCQCBCQf/BhYAAIEMQ1IuAgAANACACQQFBAXE6AA8MBgsgAkEAQQFxOgAPDAULIAJBAEEBcToADwwECyACKAIILAAAQZt/aiFEIERBEEsaAkACQAJAAkACQCBEDhEABAQEBAQEBAEEBAQEAgQEAwQLIAIoAgghRSACKAIEIUYCQCBFQZ2ohYAAIEYQ1IuAgAANACACQQFBAXE6AA8MCAsgAkEAQQFxOgAPDAcLIAIoAgghRyACKAIEIUgCQCBHQcexhYAAIEgQ1IuAgAANACACQQFBAXE6AA8MBwsgAkEAQQFxOgAPDAYLIAIoAgghSSACKAIEIUoCQCBJQbSQhYAAIEoQ1IuAgAANACACQQFBAXE6AA8MBgsgAigCCCFLIAIoAgQhTAJAIEtB59yEgAAgTBDUi4CAAA0AIAJBAUEBcToADwwGCyACQQBBAXE6AA8MBQsgAigCCCFNIAIoAgQhTgJAIE1Bs7CEgAAgThDUi4CAAA0AIAJBAUEBcToADwwFCyACQQBBAXE6AA8MBAsgAkEAQQFxOgAPDAMLIAIoAgghTyACKAIEIVACQCBPQYblhYAAIFAQ1IuAgAANACACQQFBAXE6AA8MAwsgAigCCCFRIAIoAgQhUgJAIFFBz+WFgAAgUhDUi4CAAA0AIAJBAUEBcToADwwDCyACQQBBAXE6AA8MAgsgAigCCCFTIAIoAgQhVAJAIFNBwOSFgAAgVBDUi4CAAA0AIAJBAUEBcToADwwCCyACQQBBAXE6AA8MAQsgAkEAQQFxOgAPCyACLQAPQQFxIVUgAkEQaiSAgICAACBVDwuJAgEJfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKCACIAIoAixBIBCgh4CAADYCJCACKAIkIQMgAkEEaiEEIAJB5gA7AQQgAkEAOwEGIAIoAiwhBSAFKAIAQQFqIQYgBSAGNgIAIAIgBjYCCCAEQQhqIAIoAihBCGopAgA3AgAgAiACKAIoNgIUIAJBADYCGCACQQA2AhwgAkEANgIgIAMgAikCBDcCAEEYIQcgAyAHaiAHIAJBBGpqKQIANwIAQRAhCCADIAhqIAggAkEEamopAgA3AgBBCCEJIAMgCWogCSACQQRqaikCADcCACACKAIkIQogAkEwaiSAgICAACAKDwurAgECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAyADKAIIQQFqNgIIAkACQCADKAIIIAMoAgRJQQFxRQ0AIAMoAggtAABB/wFxEP+KgIAAQQFxRQ0AIAMgAygCCC0AAEH/AXEQr4eAgAA6AAMgAyADKAIIQQFqNgIIAkAgAygCCCADKAIESUEBcUUNACADKAIILQAAQf8BcRD/ioCAAEEBcUUNACADIAMtAANB/wFxQQR0IAMoAggtAABB/wFxEK+HgIAAQf8BcXI6AAMgAyADKAIIQQFqNgIICyADKAIMIAMtAANB/wFxEOaKgIAADAELIAMoAgxBv4iEgABBAhDjioCAAAsgAygCCCEEIANBEGokgICAgAAgBA8LugIBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMgAygCCC0AAEH/AXFBMGs6AAMgAyADKAIIQQFqNgIIAkAgAygCCCADKAIESUEBcUUNACADKAIILQAAQf8BcRD9ioCAAEEBcUUNACADIAMtAANB/wFxQQN0Qf8BcSADKAIILQAAQf8BcUEwa0H/AXFyOgADIAMgAygCCEEBajYCCAJAIAMoAgggAygCBElBAXFFDQAgAygCCC0AAEH/AXEQ/YqAgABBAXFFDQAgAyADLQADQf8BcUEDdEH/AXEgAygCCC0AAEH/AXFBMGtB/wFxcjoAAyADIAMoAghBAWo2AggLCyADKAIMIAMtAANB/wFxEOaKgIAAIAMoAgghBCADQRBqJICAgIAAIAQPC94EAQh/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiggBCABNgIkIAQgAjYCICAEIAM2AhwgBCAEKAIgQX9qNgIYIAQgBCgCIEEBajYCIAJAAkAgBCgCICAEKAIcT0EBcUUNACAEKAIkQZqJhIAAQQIQ44qAgAAgBCAEKAIgNgIsDAELAkAgBCgCIC0AAEH/AXFB+wBHQQFxRQ0AIAQoAiAhBQJAAkAgBCgCHCAEKAIga0EESEEBcUUNACAEKAIcIAQoAiBrIQYMAQtBBCEGCyAEIAUgBhD5ioCAADYCFCAEIAQoAiggBCgCICAEKAIUELGHgIAANgIQAkAgBCgCJCAEKAIQEOeKgIAAQQFxDQAgBCgCJCAEKAIYIAQoAiAgBCgCFGogBCgCGGsQ44qAgAALIAQgBCgCICAEKAIUajYCLAwBCyAEIAQoAiBBAWo2AiADQANAIAQoAiAgBCgCHEkhB0EAIQggB0EBcSEJIAghCgJAIAlFDQAgBCgCIC0AAEH/AXFBIEYhCgsCQCAKQQFxRQ0AIAQgBCgCIEEBajYCIAwBCwsCQAJAIAQoAiAgBCgCHE9BAXFFDQAMAQsCQCAEKAIgLQAAQf8BcUH9AEZBAXFFDQAgBCAEKAIgQQFqNgIgDAELIAQgBCgCICAEKAIcIAQoAiBrEPmKgIAANgIMIAQgBCgCKCAEKAIgIAQoAgwQsYeAgAA2AgggBCgCJCAEKAIIEOeKgIAAGiAEIAQoAgwgBCgCIGo2AiAMAQsLIAQgBCgCIDYCLAsgBCgCLCELIARBMGokgICAgAAgCw8L+AEBAX8jgICAgABB0ABrIQggCCSAgICAACAIIAA2AkwgCCABNgJIIAggAjYCRCAIIAM6AEMgCCAENgI8IAggBTYCOCAIIAY2AjQgCCAHNgIwIAggCCgCTDYCCCAIIAgoAkg2AgwgCCAIKAJINgIQIAggCCgCSCAIKAJEajYCFCAIIAgtAENBAXE6ABggCCAIKAJMLQCDA0EBcToAGSAIQQhqQRJqQQA7AQAgCCAIKAJMKAKgAjYCHCAIIAgoAjw2AiAgCCAIKAI4NgIkIAggCCgCNDYCKCAIIAgoAjA2AiwgCEEIahC1ioCAABogCEHQAGokgICAgAAPC6wBAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQANAAkAgASgCCBC2ioCAAEEBcUUNACABQQFBAXE6AA8MAgsCQCABKAIIQQBB//8DcRC3ioCAAEEBcQ0AIAFBAEEBcToADwwCCyABKAIIQfwAQf8BcRC4ioCAAEEBcQ0ACyABIAEoAggQtoqAgABBAXE6AA8LIAEtAA9BAXEhAiABQRBqJICAgIAAIAIPCysBAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCCCABKAIMKAIMT0EBcQ8L0AIBCX8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE7AQYCQAJAIAIvAQZB//8DcUGAIE5BAXFFDQAgAigCCCACKAIIKAIEIAIoAggoAgxBwsuEgAAQuYqAgAAgAkEAQQFxOgAPDAELAkAgAigCCCACLwEGQf//A3EQuoqAgABBAXENACACQQBBAXE6AA8MAQsDQCACKAIIELaKgIAAIQNBACEEIANBAXEhBSAEIQYCQCAFDQAgAigCCCgCCC0AAEH/AXFBKUchB0EAIQggB0EBcSEJIAghBiAJRQ0AIAIoAggoAggtAABB/wFxQfwARyEGCwJAIAZBAXFFDQACQCACKAIIIAIvAQZB//8DcRC6ioCAAEEBcQ0AIAJBAEEBcToADwwDCwwBCwsgAkEBQQFxOgAPCyACLQAPQQFxIQogAkEQaiSAgICAACAKDwucAQEDfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgAToABwJAAkAgAigCCBC2ioCAAEEBcQ0AIAIoAggoAggtAABB/wFxIAItAAdB/wFxRkEBcUUNACACKAIIIQMgAyADKAIIQQFqNgIIIAJBAUEBcToADwwBCyACQQBBAXE6AA8LIAItAA9BAXEhBCACQRBqJICAgIAAIAQPC20BAn8jgICAgABBEGshBCAEJICAgIAAIAQgADYCDCAEIAE2AgggBCACNgIEIAQgAzYCACAEKAIMKAIgIQUgBCgCCCAEKAIEIAQoAgAgBCgCDCgCJCAFEYWAgIAAgICAgAAgBEEQaiSAgICAAA8L5QYBFn8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE7AQYgAigCCCgCCC0AAEFdaiEDIANBO0saAkACQAJAAkACQAJAAkACQAJAIAMOPAYABwcHAgUEBAcHBwcHBwcHBwcHBwcHBwcHBwcEBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwEHAAcLIAIoAgghBCAEIAQoAghBAWo2AgggAiACKAIIELuKgIAAQQFxOgAPDAcLIAIoAgghBSAFIAUoAghBAWo2AggCQCACKAIIELaKgIAAQQFxDQAgAigCCCEGIAYgBigCCEEBajYCCAsgAiACKAIIELuKgIAAQQFxOgAPDAYLIAIoAgghByAHIAcoAghBAWo2AgggAigCCCACLwEGQf//A3EQvIqAgAAhCEEAIQkgCEEBcSEKIAkhCwJAIApFDQAgAigCCBC7ioCAACELCyACIAtBAXE6AA8MBQsgAigCCCEMIAwgDCgCCEEBajYCCCACKAIIIAIvAQZB//8DcRC9ioCAACENQQAhDiANQQFxIQ8gDiEQAkAgD0UNACACKAIIELuKgIAAIRALIAIgEEEBcToADwwECyACKAIIIREgESARKAIIQQFqNgIIIAIoAgggAigCCCgCCEF/aiACKAIIKAIIQcjKhYAAELmKgIAAIAJBAUEBcToADwwDCyACKAIIIRIgEiASKAIIQQFqNgIIIAIoAgggAigCCCgCCEF/aiACKAIIKAIIQfm5hIAAELmKgIAAIAJBAUEBcToADwwCCwJAIAIoAggtABBBAXFFDQACQCACKAIIQQpB/wFxEL6KgIAAQQFxDQAgAigCCCgCDCETIAIoAgggEzYCCAsgAkEBQQFxOgAPDAILCwJAAkAgAigCCC0AEUEBcQ0AIAIgAigCCCgCCCACKAIIKAIMIAIoAggoAghrENCEgIAANgIADAELIAIoAggoAhQoAgAhFCACIAIoAggoAgggAigCCCgCDCACKAIIKAIIayAUEYCAgIAAgICAgAA2AgALAkAgAigCAA0AIAJBAEEBcToADwwBCyACKAIAIRUgAigCCCEWIBYgFSAWKAIIajYCCCACIAIoAggQu4qAgABBAXE6AA8LIAItAA9BAXEhFyACQRBqJICAgIAAIBcPC+oBAQV/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAA0AgASgCCBC2ioCAAEF/c0EBcUUNASABKAIIKAIILQAAIQICQAJAAkACQCACQVZqQQJJDQAgAkE/Rg0AIAJB+wBGDQEMAgsgASgCCCEDIAMgAygCCEEBajYCCAwCCyABKAIIIQQgBCAEKAIIQQFqNgIIAkAgASgCCBC/ioCAAEEBcQ0AIAFBAEEBcToADwwFCwwBCyABQQFBAXE6AA8MAwsMAAsLIAFBAUEBcToADwsgAS0AD0EBcSEFIAFBEGokgICAgAAgBQ8L4xMBPn8jgICAgABBwABrIQIgAiSAgICAACACIAA2AjggAiABOwE2IAIgAigCOCgCCDYCMCACQRhqEMCKgIAAAkACQCACKAI4QT9B/wFxELiKgIAAQQFxRQ0AAkAgAigCOBC2ioCAAEEBcUUNACACKAI4IAIoAjAgAigCOCgCCEG52YSAABC5ioCAACACQQBBAXE6AD8MAgsgAigCOCgCCC0AAEFfaiEDIANB3QBLGgJAAkACQAJAAkACQAJAAkACQCADDl4BBwAHBwcDBAcHBwcGBwcHBwcHBwcHBwcHAQcCAQEHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBQcHBQcHBwcFBwcHBQcHBwcHBwcFBwcFBwcHBwcBBwsgAigCOCEEIAQgBCgCCEEBajYCCAJAIAIoAjgQtoqAgABBAXFFDQAgAigCOCACKAIwIAIoAjgoAghBudmEgAAQuYqAgAAgAkEAQQFxOgA/DAoLAkAgAigCOC0AEUEBcUUNACACKAI4KAIULQAUQQFxRQ0AIAJBADoAFwJAA0AgAigCOCgCCCACKAI4KAIMSUEBcUUNAQJAIAItABdBAXENACACKAI4KAIILQAAQf8BcUEpRkEBcUUNACACKAI4IQUgBSAFKAIIQQFqNgIIIAJBAUEBcToAPwwNCyACKAI4KAIUKAIAIQYgAiACKAI4KAIIIAIoAjgoAgwgAigCOCgCCGsgBhGAgICAAICAgIAANgIQAkAgAigCEA0AIAJBAEEBcToAPwwNCyACKAIQQQFGIQdBACEIIAdBAXEhCSAIIQoCQCAJRQ0AIAIoAjgoAggtAABB/wFxQdwARiEKCyACIApBAXE6ABcgAigCECELIAIoAjghDCAMIAsgDCgCCGo2AggMAAsLIAJBAEEBcToAPwwKCyACIAIoAjhBKUH/AXEQvoqAgABBAXE6AA8DQCACLQAPIQ1BACEOIA1BAXEhDyAOIRACQCAPRQ0AIAIoAjgoAgQgAigCOCgCCEF+ak0hEUEAIRIgEUEBcSETIBIhECATRQ0AIAIoAjgoAghBfmotAABB/wFxQdwARiEQCwJAIBBBAXFFDQAgAiACKAI4QSlB/wFxEL6KgIAAQQFxOgAPDAELCyACIAItAA9BAXE6AD8MCQsgAigCOCEUIBQgFCgCCEEBajYCCAwGCyACKAI4IRUgFSAVKAIIQQFqNgIIAkAgAigCOBC2ioCAAEEBcUUNACACKAI4IAIoAjAgAigCOCgCCEGVuoSAABC5ioCAACACQQBBAXE6AD8MCAsgAigCOCgCCC0AACEWAkACQAJAIBZBIUYNACAWQT1HDQELIAIoAjghFyAXIBcoAghBAWo2AggMAQsgAiACKAI4KAIINgIIAkAgAigCOEE+Qf8BcRC+ioCAAEEBcQ0AIAJBAEEBcToAPwwJCwJAIAIoAjgoAgggAigCCGtBAUZBAXFFDQAgAigCOCACKAIIIAIoAjgoAghBkYCEgAAQuYqAgAALAkAgAigCOCgCGEEAR0EBcUUNACACKAI4IAIoAgggAigCOCgCCEF/ahDBioCAAAsLDAULIAIoAjghGCAYKAIIQQFqIRkgGCAZNgIIIAIgGTYCBAJAIAIoAjhBJ0H/AXEQvoqAgABBAXENACACQQBBAXE6AD8MBwsCQCACKAI4KAIYQQBHQQFxRQ0AIAIoAjggAigCBCACKAI4KAIIQX9qEMGKgIAACwwECwJAIAIoAjhBKUH/AXEQvoqAgABBAXENACACQQBBAXE6AD8MBgsMAwsDQCACKAI4ELaKgIAAIRpBACEbIBpBAXEhHCAbIR0CQCAcDQAgAigCOCgCCC0AAEH/AXFBLUchHkEAIR8gHkEBcSEgIB8hHSAgRQ0AIAIoAjgoAggtAABB/wFxQTpHISFBACEiICFBAXEhIyAiIR0gI0UNACACKAI4KAIILQAAQf8BcUEpRyEdCwJAIB1BAXFFDQAgAigCOCgCCC0AACEkAkAgAkEYaiAkQf8BcRDCioCAAEEBcQ0AIAJBAEEBcToAPwwHCyACKAI4ISUgJSAlKAIIQQFqNgIIDAELCwJAIAIoAjgQtoqAgABBAXFFDQAgAkEAQQFxOgA/DAULAkAgAigCOCgCCC0AAEH/AXFBKUZBAXFFDQACQCACQRhqQfgAQf8BcRDDioCAAEH/AXFBA0ZBAXFFDQAgAigCOEEBOgAQCyACKAI4ISYgJiAmKAIIQQFqNgIIIAJBAUEBcToAPwwFCwJAIAIoAjgoAggtAABB/wFxQS1HQQFxRQ0ADAMLCyACKAI4IScgJyAnKAIIQQFqNgIIA0AgAigCOBC2ioCAACEoQQAhKSAoQQFxISogKSErAkAgKg0AIAIoAjgoAggtAABB/wFxQTpHISxBACEtICxBAXEhLiAtISsgLkUNACACKAI4KAIILQAAQf8BcUEpRyErCwJAICtBAXFFDQAgAigCOCgCCC0AACEvAkAgAkEYaiAvQf8BcRDEioCAAEEBcQ0AIAJBAEEBcToAPwwGCyACKAI4ITAgMCAwKAIIQQFqNgIIDAELCwJAIAIoAjgQtoqAgABBAXFFDQAgAkEAQQFxOgA/DAQLAkAgAigCOCgCCC0AAEH/AXFBKUZBAXFFDQBB+AAhMSACQRhqIDEQw4qAgABBfWohMiAyQQFLGgJAAkACQCAyDgIAAQILIAIoAjhBAToAEAwBCyACKAI4QQA6ABALIAIoAjghMyAzIDMoAghBAWo2AgggAkEBQQFxOgA/DAQLDAELIAIoAjghNCA0IDQoAghBAWo2AgggAigCOCACKAI4KAIIQX9qIAIoAjgoAghB+t+EgAAQuYqAgAALCyACKAI4LQAQITVBASE2IAIgNSA2cToAA0H4ACE3IAJBGGogNxDDioCAAEF9aiE4IDggNksaAkACQAJAIDgOAgABAgsgAigCOEEBOgAQDAELIAIoAjhBADoAEAsDQCACKAI4ELaKgIAAITlBACE6IDlBAXEhOyA6ITwCQCA7DQAgAigCOCgCCC0AAEH/AXFBKUchPAsCQCA8QQFxRQ0AAkAgAigCOCACLwE2Qf//A3FBAWpB//8DcRC3ioCAAEEBcQ0AIAItAAMhPSACKAI4ID1BAXE6ABAgAkEAQQFxOgA/DAMLIAIoAjhB/ABB/wFxELiKgIAAGgwBCwsgAi0AAyE+IAIoAjggPkEBcToAEAJAIAIoAjhBKUH/AXEQxYqAgABBAXFFDQAgAkEBQQFxOgA/DAELIAIoAjggAigCMCACKAI4KAIIQZW6hIAAELmKgIAAIAJBAEEBcToAPwsgAi0AP0EBcSE/IAJBwABqJICAgIAAID8PC7gDAQV/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABOwEGAkACQCACLwEGQf//A3FBgCBOQQFxRQ0AIAIoAgggAigCCCgCBCACKAIIKAIMQcLLhIAAELmKgIAAIAJBAEEBcToADwwBCwJAIAIoAggoAgggAigCCCgCDElBAXFFDQAgAigCCCgCCC0AAEH/AXFB3QBGQQFxRQ0AIAIoAgghAyADIAMoAghBAWo2AgggAigCCCACKAIIKAIIQX9qIAIoAggoAghB7LGEgAAQuYqAgAAgAkEBQQFxOgAPDAELIAIgAigCCCgCCDYCAAJAIAIoAggoAghBAmogAigCCCgCDElBAXFFDQAgAigCCCgCCC0AAEH/AXFB2wBGQQFxRQ0AIAIoAggoAggtAAFB/wFxQTpGQQFxRQ0AIAIoAgghBCAEIAQoAghBAWo2AggCQCACKAIIEMaKgIAAQQFxRQ0AIAJBAUEBcToADwwCCyACKAIAIQUgAigCCCAFNgIICyACIAIoAgggAi8BBkH//wNxEMeKgIAAQQFxOgAPCyACLQAPQQFxIQYgAkEQaiSAgICAACAGDwvvAQEIfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgAToABwJAAkAgAigCCBC2ioCAAEEBcUUNACACQQBBAXE6AA8MAQsgAigCCCgCCCEDIAItAAdB/wFxIQQgAigCCCgCDCACKAIIKAIIayEFIAIoAggtABEhBiACKAIIKAIUIQcgAiADIAQgBSAGQQFxIAcQoIuAgAA2AgACQCACKAIAQQBGQQFxRQ0AIAJBAEEBcToADwwBCyACKAIAQQFqIQggAigCCCAINgIIIAJBAUEBcToADwsgAi0AD0EBcSEJIAJBEGokgICAgAAgCQ8LsgYBEn8jgICAgABBEGshASABIAA2AgggASABKAIIKAIINgIEIAFBADYCAAJAA0ACQCABKAIIKAIIIAEoAggoAgxPQQFxRQ0AIAEoAgQhAiABKAIIIAI2AgggAUEBQQFxOgAPDAILIAEoAgAhAyADQQNLGgJAAkACQAJAAkAgAw4EAAEDAgQLIAEoAggoAggtAABBVGohBCAEQQ1LGgJAAkACQAJAIAQODgECAgIAAAAAAAAAAAAAAgsgASgCCCEFIAUgBSgCCEEBajYCCCABQQE2AgAMAgsgASgCCCEGIAYgBigCCEEBajYCCCABQQM2AgAMAQsgASgCBCEHIAEoAgggBzYCCCABQQFBAXE6AA8MBgsMAwsgASgCCCgCCC0AAEFUaiEIIAhB0QBLGgJAAkACQAJAAkAgCA5SAQMDAwAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMLIAEoAgghCSAJIAkoAghBAWo2AggMAwsgASgCCCEKIAogCigCCEEBajYCCCABQQI2AgAMAgsgASgCCCELIAsgCygCCEEBajYCCCABQQFBAXE6AA8MBgsgASgCBCEMIAEoAgggDDYCCCABQQFBAXE6AA8MBQsMAgsCQAJAIAEoAggoAggtAABBUGpBCUsNACABKAIIIQ0gDSANKAIIQQFqNgIIIAFBAjYCAAwBCyABKAIEIQ4gASgCCCAONgIIIAFBAUEBcToADwwECwwBCyABKAIIKAIILQAAQVBqIQ8gD0HNAEsaAkACQAJAAkAgDw5OAAAAAAAAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsgASgCCCEQIBAgECgCCEEBajYCCAwCCyABKAIIIREgESARKAIIQQFqNgIIIAFBAUEBcToADwwECyABKAIEIRIgASgCCCASNgIIIAFBAUEBcToADwwDCwsMAAsLIAEtAA9BAXEPC3sCAn8BfiOAgICAAEEQayEBIAEgADYCDCABKAIMIQJCACEDIAIgAzcAACACQRBqIAM3AAAgAkEIaiADNwAAIAEoAgxBAToACCABKAIMQQE6AAwgASgCDEEBOgAXIAEoAgxBAjoAAyABKAIMQQI6AAAgASgCDEECOgAUDwuIAQEFfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGCEEIAMoAhQhBSADQQhqIAQgBRCni4CAACADKAIcKAIYIQYgAygCHCgCHCEHIANBCGogByAGEYKAgIAAgICAgAAgA0EIahCui4CAACADQSBqJICAgIAADwvOAQECfyOAgICAAEEQayECIAIgADYCCCACIAE6AAcCQAJAIAItAAdB/wFxQeEATkEBcUUNACACLQAHQf8BcUH4AExBAXFFDQAgAiACLQAHQZ9/ajoAByACKAIIIAItAAdqLQAAIQMgA0EESxoCQAJAAkACQCADDgUAAQECAAMLIAJBAEEBcToADwwECyACKAIIIAItAAdB/wFxakEDOgAAIAJBAUEBcToADwwDCyACQQFBAXE6AA8MAgsLIAJBAEEBcToADwsgAi0AD0EBcQ8LhQEBAX8jgICAgABBEGshAiACIAA2AgggAiABOgAHAkACQCACLQAHQf8BcUHhAE5BAXFFDQAgAi0AB0H/AXFB+ABMQQFxRQ0AIAIgAi0AB0H/AXFB4QBrOgAHIAIgAigCCCACLQAHQf8BcWotAAA6AA8MAQsgAkEAOgAPCyACLQAPQf8BcQ8LzgEBAn8jgICAgABBEGshAiACIAA2AgggAiABOgAHAkACQCACLQAHQf8BcUHhAE5BAXFFDQAgAi0AB0H/AXFB+ABMQQFxRQ0AIAIgAi0AB0Gff2o6AAcgAigCCCACLQAHai0AACEDAkACQAJAIANFDQAgA0EBRg0BIANBAkYNACADQX1qQQJJDQEMAgsgAkEAQQFxOgAPDAMLIAIoAgggAi0AB0H/AXFqQQQ6AAAgAkEBQQFxOgAPDAILCyACQQBBAXE6AA8LIAItAA9BAXEPC5wBAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABOgAHAkACQCACKAIIELaKgIAAQQFxDQAgAigCCCgCCC0AAEH/AXEgAi0AB0H/AXFGQQFxRQ0AIAIoAgghAyADIAMoAghBAWo2AgggAkEBQQFxOgAPDAELIAJBAEEBcToADwsgAi0AD0EBcSEEIAJBEGokgICAgAAgBA8L4QEBCX8jgICAgABBEGshASABJICAgIAAIAEgADYCCAJAAkAgASgCCEE6Qf8BcRDFioCAAEEBcQ0AIAFBAEEBcToADwwBCyABKAIIQd4AQf8BcRC4ioCAABogASgCCEE6Qf8BcRC+ioCAACECQQAhAyACQQFxIQQgAyEFAkAgBEUNACABKAIIQd0AQf8BcRDFioCAACEGQQAhByAGQQFxIQggByEFIAhFDQAgASgCCEHdAEH/AXEQxYqAgAAhBQsgASAFQQFxOgAPCyABLQAPQQFxIQkgAUEQaiSAgICAACAJDwuuAgELfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATsBCiACKAIMQd4AQf8BcRC4ioCAABoDQCACKAIMELaKgIAAIQNBACEEIANBAXEhBSAEIQYCQCAFDQAgAigCDCgCCC0AAEH/AXFB3QBHIQYLAkAgBkEBcUUNACACKAIMIQcgBygCCCEIQQEhCSAHIAggCWo2AgggCC0AAEGlf2ohCiAKIAlLGgJAAkACQAJAIAoOAgABAgsgAigCDCACLwEKQf//A3FBAWpB//8DcRC9ioCAABoMAgsCQCACKAIMELaKgIAAQQFxDQAgAigCDCELIAsgCygCCEEBajYCCAsMAQsLDAELCyACKAIMQd0AQf8BcRDFioCAAEEBcSEMIAJBEGokgICAgAAgDA8LvQgBJX8jgICAgABB8ABrIQUgBSSAgICAACAFIAA2AmggBSABNgJkIAUgAjYCYCAFIAM2AlwgBSAEQQFxOgBbIAUoAlwvAQBBTWohBiAGQd0ASxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBg5eBwoKAQoKCgoKCgoKCgoKCgoCCgoKCgoKCgoKCgoKCgAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCAoKCgoKCgoKCgoKCgoKAgoECgoKCgoKCgoKCgkDAAoKAwoFBgoLIAUoAmAhByAFIAUoAmg2AkwgBSAFKAJkNgJQIAVBADYCVCAFKAJcIQggBS0AWyEJIAVBzABqIQpB4YGAgAAhCyAFIAcgCiAIIAlBAXEgCxDKioCAADYCbAwKCyAFKAJgQQxqIQwgBSAFKAJoNgJAIAUgBSgCZDYCRCAFQQA2AkggBSgCXCENIAUtAFshDiAFQcAAaiEPQeKBgIAAIRAgBSAMIA8gDSAOQQFxIBAQyoqAgAA2AmwMCQsgBSgCYEEYaiERIAUgBSgCaDYCNCAFIAUoAmQ2AjggBUEANgI8IAUoAlwhEiAFLQBbIRMgBUE0aiEUQeOBgIAAIRUgBSARIBQgEiATQQFxIBUQyoqAgAA2AmwMCAsgBSgCYEEkaiEWIAUgBSgCaDYCKCAFIAUoAmQ2AiwgBUEANgIwIAUoAlwhFyAFLQBbIRggBUEoaiEZQeSBgIAAIRogBSAWIBkgFyAYQQFxIBoQyoqAgAA2AmwMBwsgBSgCYEEwaiEbIAUgBSgCaDYCHCAFIAUoAmQ2AiAgBUEANgIkIAUoAlwhHCAFLQBbIR0gBUEcaiEeQeWBgIAAIR8gBSAbIB4gHCAdQQFxIB8QyoqAgAA2AmwMBgsgBSgCYEE8aiEgIAUgBSgCaDYCECAFIAUoAmQ2AhQgBUEANgIYIAUoAlwhISAFLQBbISIgBUEQaiEjQeSBgIAAISQgBSAgICMgISAiQQFxICQQyoqAgAA2AmwMBQsgBSAFKAJgKAJINgIMAkACQCAFKAIMQQBGQQFxDQAgBS0AW0EBcUUNAQsgBSgCXCElIAUoAmAgJTYCSAsgBSAFKAIMNgJsDAQLIAUgBSgCYCgCTDYCCAJAAkAgBSgCCEEARkEBcQ0AIAUtAFtBAXFFDQELIAUoAlwhJiAFKAJgICY2AkwLIAUgBSgCCDYCbAwDCyAFIAUoAmAoAlA2AgQCQAJAIAUoAgRBAEZBAXENACAFLQBbQQFxRQ0BCyAFKAJcIScgBSgCYCAnNgJQCyAFIAUoAgQ2AmwMAgsgBSAFKAJgKAJUNgIAAkACQCAFKAIAQQBGQQFxDQAgBS0AW0EBcUUNAQsgBSgCXCEoIAUoAmAgKDYCVAsgBSAFKAIANgJsDAELIAVBADYCbAsgBSgCbCEpIAVB8ABqJICAgIAAICkPC48CAQR/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiggAyABNgIkIAMgAjYCIAJAAkACQCADKAIkLwEAQf//A3FBigFGQQFxDQAgAygCIC8BAEH//wNxQYoBRkEBcUUNAQsgAyADKAIoIAMoAiQQ0IqAgAA3AxggAyADKAIoIAMoAiAQ0IqAgAA3AxACQAJAIAMpAxggAykDEFNBAXFFDQBBfyEEDAELIAMpAxggAykDEFUhBUEBQQAgBUEBcRshBAsgAyAENgIsDAELIAMgAygCJEEQajYCDCADIAMoAiBBEGo2AgggAyADKAIMIAMoAggQlYuAgAA2AiwLIAMoAiwhBiADQTBqJICAgIAAIAYPC8QFAQp/I4CAgIAAQcAAayEFIAUkgICAgAAgBSAANgI4IAUgATYCNCAFIAI2AjAgBSADOgAvIAUgBDYCKAJAAkAgBSgCOCgCBEEBdCAFKAI4KAIIT0EBcUUNAAJAAkAgBSgCOCgCCA0AQQQhBgwBCyAFKAI4KAIIQQF0IQYLIAUgBjYCJCAFIAUoAiRBBBChjICAADYCIAJAIAUoAiBBAEZBAXFFDQAgBUEANgI8DAILIAUgBSgCJEEBazYCHCAFQQA2AhgCQANAIAUoAhggBSgCOCgCCElBAXFFDQEgBSAFKAI4KAIAIAUoAhhBAnRqKAIANgIUAkAgBSgCFEEAR0EBcUUNACAFIAUoAjQgBSgCFBDPioCAACAFKAIccTYCECAFKAIUIQcgBSgCICAFKAIQQQJ0aiAHNgIACyAFIAUoAhhBAWo2AhgMAAsLIAUoAjgoAgAQmoyAgAAgBSgCICEIIAUoAjggCDYCACAFKAIkIQkgBSgCOCAJNgIICyAFIAUoAjgoAghBAWs2AgwgBSAFKAI0IAUoAjAQz4qAgAAgBSgCDHE2AggCQANAIAUoAjgoAgAgBSgCCEECdGooAgBBAEdBAXFFDQEgBSgCKCEKAkAgBSgCNCAFKAI4KAIAIAUoAghBAnRqKAIAIAUoAjAgChGGgICAAICAgIAADQAMAgsgBSAFKAIIQQFqIAUoAgxxNgIIDAALCyAFIAUoAjgoAgAgBSgCCEECdGooAgA2AgQCQAJAIAUoAgRBAEZBAXFFDQAgBSgCOCELIAsgCygCBEEBajYCBCAFKAIwIQwgBSgCOCgCACAFKAIIQQJ0aiAMNgIADAELAkAgBS0AL0EBcUUNACAFKAIwIQ0gBSgCOCgCACAFKAIIQQJ0aiANNgIACwsgBSAFKAIENgI8CyAFKAI8IQ4gBUHAAGokgICAgAAgDg8LdwEDfyOAgICAAEEgayEDIAMgADYCHCADIAE2AhggAyACNgIUIAMgAygCGCsDEDkDCCADIAMoAhQrAxA5AwACQAJAIAMrAwggAysDAGNBAXFFDQBBfyEEDAELIAMrAwggAysDAGQhBUEBQQAgBUEBcRshBAsgBA8L2gMBBX8jgICAgABBIGshAyADJICAgIAAIAMgADYCGCADIAE2AhQgAyACNgIQAkACQCADKAIULwEAQf//A3EgAygCEC8BAEH//wNxR0EBcUUNAAJAAkAgAygCFC8BAEH//wNxIAMoAhAvAQBB//8DcUlBAXFFDQBBfyEEDAELIAMoAhQvAQBB//8DcSADKAIQLwEAQf//A3FLIQVBAUEAIAVBAXEbIQQLIAMgBDYCHAwBCyADKAIULwEAIQYCQAJAIAZBNkYNAAJAAkACQCAGQcQARg0AIAZB0gBGDQIgBkH7AEYNAQwECyADIAMoAhggAygCFCgCECADKAIQKAIQEMyKgIAANgIcDAQLIAMgAygCFDYCDCADIAMoAhA2AgggAyADKAIMQSBqIAMoAghBIGoQlYuAgAA2AgQCQCADKAIERQ0AIAMgAygCBDYCHAwECyADIAMoAgxBEGogAygCCEEQahCVi4CAADYCHAwDCyADIAMoAhggAygCFCADKAIQEMmKgIAANgIcDAILIAMgAygCGCADKAIUIAMoAhAQy4qAgAA2AhwMAQtB4raGgABBt82FgABBrwJBoL2EgAAQjoCAgAAACyADKAIcIQcgA0EgaiSAgICAACAHDwtsAQJ/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhgQ0YqAgAA2AhAgAyADKAIUENGKgIAANgIMIAMoAhAgAygCDBCti4CAACEEIANBIGokgICAgAAgBA8L5wEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgAygCFDYCDCADIAMoAhA2AgggAyADKAIMQShqIAMoAghBKGoQrYuAgAA2AgQCQAJAIAMoAgRFDQAgAyADKAIENgIcDAELAkACQCADKAIMLwECQf//A3EgAygCCC8BAkH//wNxSEEBcUUNAEF/IQQMAQsgAygCDC8BAkH//wNxIAMoAggvAQJB//8DcUohBUEBQQAgBUEBcRshBAsgAyAENgIcCyADKAIcIQYgA0EgaiSAgICAACAGDwuXBgEGfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCOCACIAE2AjQgAigCNC8BAEFKaiEDIANB2QBLGgJAAkACQAJAAkACQAJAAkACQAJAAkAgAw5aAgkJCQkJCQkJCQkJCQkECQkJCQkJCQkJCQkJCQAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAwkHCQkJCQkJCQkJCQkGAQkJBQkICQsgAiACKAI0NgIwIAIgAigCMEEQahDZioCAADYCPAwJCyACKAI4KAIAIQQgAigCNCgCCCEFIAIoAjgoAgQhBiACQShqIAQgBSAGEKWLgIAAIAIgAkEoajYCJCACIAIoAiRBBBDaioCAADYCPAwICyACIAIoAjRBEGo2AiAgAiACKAIgQQgQ2oqAgAA2AjwMBwsgAiACKAI0NgIcIAIgAigCHEEQahDZioCAACACKAIcQSBqENmKgIAAcyACKAIcLwEAQf//A3EQ24qAgABzNgI8DAYLIAIgAigCNCgCEDYCGCACIAIoAjggAigCGBDPioCAACACKAI0LwEAQf//A3EQ24qAgABzNgI8DAULIAIgAigCNEEoajYCFCACIAIoAjQvAQI7ARIgAiACLwESQf//A3FBDHE7ARIgAiACKAIUEKyLgIAAIAIoAhQQq4uAgABBAHQQ2oqAgAAgAi8BEkH//wNxENuKgIAAczYCPAwECyACIAIoAjRBEGo2AgwgAiACKAIMEKyLgIAAIAIoAgwQq4uAgABBAHQQ2oqAgAA2AjwMAwsgAiACKAI0QShqNgIIIAIgAigCCBCsi4CAACACKAIIEKuLgIAAQQB0ENqKgIAAIAIoAjQvAQJB//8DcRDbioCAAHM2AjwMAgsgAiACKAI0QShqNgIEIAIgAigCBBCsi4CAACACKAIEEKuLgIAAQQB0ENqKgIAAIAIoAjQvAQJB//8DcRDbioCAAHM2AjwMAQtB4raGgABBt82FgABBkQFB9YSFgAAQjoCAgAAACyACKAI8IQcgAkHAAGokgICAgAAgBw8L0AIEA38CfgN/AX4jgICAgABBMGshAiACJICAgIAAIAIgADYCJCACIAE2AiAgAigCIC8BACEDAkACQAJAAkAgA0HSAEYNACADQYoBRg0BDAILIAIgAigCIEEQajYCHAJAIAIoAhwoAgRBAEdBAXFFDQAgAigCHC0ADCEEIAJCgICAgICAgICAf0L///////////8AIARBAXEbNwMoDAMLIAIgAigCHCgCCK03AxACQAJAIAIoAhwtAAxBAXFFDQAgAikDECEFQgAgBX0hBgwBCyACKQMQIQYLIAIgBjcDKAwCCyACKAIkKAIAIQcgAigCICgCCCEIIAIoAiQoAgQhCSACQQhqIAcgCCAJEKWLgIAAIAIgAigCCKw3AygMAQtB4raGgABBt82FgABB9QFB/o6FgAAQjoCAgAAACyACKQMoIQogAkEwaiSAgICAACAKDwurAQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAEoAggvAQBB935qIQIgAkEGSxoCQAJAAkACQAJAIAIOBwEDAwMAAwIDCyABIAEoAghBKGo2AgwMAwsgASABKAIIQRBqNgIMDAILIAEgASgCCEEoajYCDAwBC0HitoaAAEG3zYWAAEHBAkHujoWAABCOgICAAAALIAEoAgwhAyABQRBqJICAgIAAIAMPC3sBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMENOKgIAAIAEoAgxBDGoQ04qAgAAgASgCDEEYahDTioCAACABKAIMQSRqENOKgIAAIAEoAgxBMGoQ04qAgAAgASgCDEE8ahDTioCAACABQRBqJICAgIAADwtMAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIIQQBLQQFxRQ0AIAEoAgwoAgAQmoyAgAALIAFBEGokgICAgAAPC34BA38jgICAgABBIGshBSAFJICAgIAAIAUgADYCHCAFIAE2AhggBSACNgIUIAUgAzYCECAFIAQ2AgwgBSgCHCEGIAUgBSgCGDYCACAFIAUoAhQ2AgQgBSAFKAIQNgIIIAUoAgwhByAGIAUgBxDVioCAACAFQSBqJICAgIAADwuxDQQCfwF8AX4NfyOAgICAAEGAAWshAyADJICAgIAAIAMgADYCfCADIAE2AnggAyAC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NkYNACACQcQARg0DIAJB0gBGDQEgAkH7AEYNAgwECyABIAEoAggrAxBBALdkQQFxOgAPDAQLIAEgASgCCC0AHEF/c0EBcToADwwDCyABIAEoAggtABxBf3NBAXE6AA8MAgsgASABKAIIKAIQENiKgIAAQQFxOgAPDAELQeK2hoAAQbfNhYAAQecDQdDbhIAAEI6AgIAAAAsgAS0AD0EBcSEDIAFBEGokgICAgAAgAw8LowEBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDCgCBEEAR0EBcUUNACABIAEoAgwoAgQgASgCDCgCAEECdBDaioCAADYCCAwBCyABIAEoAgxBCGpBBBDaioCAADYCCAsCQCABKAIMLQAMQQFxRQ0AIAFBARDbioCAACABKAIIczYCCAsgASgCCCECIAFBEGokgICAgAAgAg8LqAMBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAkGM5Z66eTYCFCACIAIoAhhBAnY2AgwCQANAIAIoAgxFDQEgAiACKAIcKAAANgIQIAIgAigCHEEEajYCHCACIAIoAhAQ24qAgAAgAigCFHM2AhQgAiACKAIUQQ10IAIoAhRBE3ZyNgIUIAIgAigCFEEFbEHk1tGyfmo2AhQgAiACKAIMQX9qNgIMDAALCyACQQA2AhAgAiACKAIYQQNxNgIIAkADQCACKAIIRQ0BIAIgAigCEEEIdDYCECACIAIoAhwgAigCCEEBa2otAABB/wFxIAIoAhByNgIQIAIgAigCCEF/ajYCCAwACwsgAiACKAIQENuKgIAAIAIoAhRzNgIUIAIgAigCGCACKAIUczYCFCACIAIoAhRBEHYgAigCFHM2AhQgAiACKAIUQeuUr694bDYCFCACIAIoAhRBDXYgAigCFHM2AhQgAiACKAIUQbXcypV8bDYCFCACIAIoAhRBEHYgAigCFHM2AhQgAigCFCEDIAJBIGokgICAgAAgAw8LVAEBfyOAgICAAEEQayEBIAEgADYCDCABIAEoAgxB0dr45HxsNgIMIAEgASgCDEEPdCABKAIMQRF2cjYCDCABIAEoAgxBk+uc3AFsNgIMIAEoAgwPC7wXAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASgCCEF/aiECIAJBpAFLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg6lAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAQsgAUGqi4SAADYCDAylAQsgAUHj7YSAADYCDAykAQsgAUGC7oSAADYCDAyjAQsgAUHRtIaAADYCDAyiAQsgAUHVtIaAADYCDAyhAQsgAUH7s4aAADYCDAygAQsgAUGvtIaAADYCDAyfAQsgAUH2s4aAADYCDAyeAQsgAUGusoaAADYCDAydAQsgAUGzuoWAADYCDAycAQsgAUHitIaAADYCDAybAQsgAUGGtIaAADYCDAyaAQsgAUHBroaAADYCDAyZAQsgAUHTroaAADYCDAyYAQsgAUHGroaAADYCDAyXAQsgAUHusoaAADYCDAyWAQsgAUHusoaAADYCDAyVAQsgAUHlsoaAADYCDAyUAQsgAUG9s4aAADYCDAyTAQsgAUHqsoaAADYCDAySAQsgAUHhsoaAADYCDAyRAQsgAUG4s4aAADYCDAyQAQsgAUGV+ISAADYCDAyPAQsgAUGatIWAADYCDAyOAQsgAUGYtIaAADYCDAyNAQsgAUGTtIaAADYCDAyMAQsgAUG4tIaAADYCDAyLAQsgAUGxl4SAADYCDAyKAQsgAUG1ooSAADYCDAyJAQsgAUGrtIaAADYCDAyIAQsgAUG8o4aAADYCDAyHAQsgAUG7o4aAADYCDAyGAQsgAUGbsIaAADYCDAyFAQsgAUGTsoaAADYCDAyEAQsgAUHnq4WAADYCDAyDAQsgAUHXroaAADYCDAyCAQsgAUHGroaAADYCDAyBAQsgAUHetIaAADYCDAyAAQsgAUHys4aAADYCDAx/CyABQc6zhoAANgIMDH4LIAFByLOGgAA2AgwMfQsgAUGfs4aAADYCDAx8CyABQbiuhoAANgIMDHsLIAFB6amEgAA2AgwMegsgAUHPgYSAADYCDAx5CyABQcv6hIAANgIMDHgLIAFBz4GEgAA2AgwMdwsgAUHgtYWAADYCDAx2CyABQamzhoAANgIMDHULIAFBw7OGgAA2AgwMdAsgAUGblIaAADYCDAxzCyABQbuUhoAANgIMDHILIAFBg4uFgAA2AgwMcQsgAUHiiIWAADYCDAxwCyABQbm9hYAANgIMDG8LIAFBxaqFgAA2AgwMbgsgAUGmtoWAADYCDAxtCyABQf/UhIAANgIMDGwLIAFBz4GEgAA2AgwMawsgAUHL+oSAADYCDAxqCyABQc+BhIAANgIMDGkLIAFBjK+GgAA2AgwMaAsgAUGgsoaAADYCDAxnCyABQaSwhoAANgIMDGYLIAFB97KGgAA2AgwMZQsgAUGksYaAADYCDAxkCyABQfKxhoAANgIMDGMLIAFBhK+GgAA2AgwMYgsgAUHNsYaAADYCDAxhCyABQYqzhoAANgIMDGALIAFBjbCGgAA2AgwMXwsgAUGNsIaAADYCDAxeCyABQeOxhoAANgIMDF0LIAFBuLGGgAA2AgwMXAsgAUGasoaAADYCDAxbCyABQYSzhoAANgIMDFoLIAFB+bGGgAA2AgwMWQsgAUHqsYaAADYCDAxYCyABQfOvhoAANgIMDFcLIAFBwLGGgAA2AgwMVgsgAUHAsYaAADYCDAxVCyABQaywhoAANgIMDFQLIAFBgrKGgAA2AgwMUwsgAUHuroaAADYCDAxSCyABQZ6xhoAANgIMDFELIAFB9a6GgAA2AgwMUAsgAUH5r4aAADYCDAxPCyABQYawhoAANgIMDE4LIAFB2rGGgAA2AgwMTQsgAUHt1ISAADYCDAxMCyABQdyuhoAANgIMDEsLIAFBkrCGgAA2AgwMSgsgAUGxsYaAADYCDAxJCyABQf6vhoAANgIMDEgLIAFBuLCGgAA2AgwMRwsgAUHTsYaAADYCDAxGCyABQcWxhoAANgIMDEULIAFB+66GgAA2AgwMRAsgAUH7roaAADYCDAxDCyABQZaxhoAANgIMDEILIAFBlrGGgAA2AgwMQQsgAUGxsIaAADYCDAxACyABQYuyhoAANgIMDD8LIAFBi7KGgAA2AgwMPgsgAUGmsoaAADYCDAw9CyABQbKyhoAANgIMDDwLIAFBzLKGgAA2AgwMOwsgAUHBsoaAADYCDAw6CyABQZ/3hIAANgIMDDkLIAFB18qEgAA2AgwMOAsgAUHTroaAADYCDAw3CyABQYu0hoAANgIMDDYLIAFB07OGgAA2AgwMNQsgAUGZs4aAADYCDAw0CyABQa+VhoAANgIMDDMLIAFBopWGgAA2AgwMMgsgAUG1sYWAADYCDAwxCyABQbS0hoAANgIMDDALIAFB3bOGgAA2AgwMLwsgAUGks4aAADYCDAwuCyABQc2qhYAANgIMDC0LIAFBwrqFgAA2AgwMLAsgAUHNtIaAADYCDAwrCyABQc20hoAANgIMDCoLIAFBybSGgAA2AgwMKQsgAUHatIaAADYCDAwoCyABQYG0hoAANgIMDCcLIAFBrLGGgAA2AgwMJgsgAUHproaAADYCDAwlCyABQeSuhoAANgIMDCQLIAFB/7KGgAA2AgwMIwsgAUHysoaAADYCDAwiCyABQc+uhoAANgIMDCELIAFBs7OGgAA2AgwMIAsgAUHKroaAADYCDAwfCyABQa2zhoAANgIMDB4LIAFBvLSGgAA2AgwMHQsgAUHis4aAADYCDAwcCyABQZWzhoAANgIMDBsLIAFBxYiFgAA2AgwMGgsgAUHbioWAADYCDAwZCyABQY+0hoAANgIMDBgLIAFBnLSGgAA2AgwMFwsgAUHYs4aAADYCDAwWCyABQcW0hoAANgIMDBULIAFB7bOGgAA2AgwMFAsgAUHAtIaAADYCDAwTCyABQeezhoAANgIMDBILIAFB3PmEgAA2AgwMEQsgAUG8kISAADYCDAwQCyABQfWKhYAANgIMDA8LIAFBtviEgAA2AgwMDgsgAUG9roaAADYCDAwNCyABQdG0hoAANgIMDAwLIAFBk7SGgAA2AgwMCwsgAUGmtIaAADYCDAwKCyABQaC0hoAANgIMDAkLIAFBtLSGgAA2AgwMCAsgAUG0tIaAADYCDAwHCyABQby0hoAANgIMDAYLIAFB/KSGgAA2AgwMBQsgAUH7pIaAADYCDAwECyABQcbKhIAANgIMDAMLIAFB17KGgAA2AgwMAgtB4raGgABBotWFgABBtQVB4e6EgAAQjoCAgAAAC0HitoaAAEGi1YWAAEG7BUHh7oSAABCOgICAAAALIAEoAgwhAyABQRBqJICAgIAAIAMPC3UBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDEEANgIAIAIoAgghAyACKAIMIAM2AgQgAigCCBCYjICAACEEIAIoAgwgBDYCCCACKAIMKAIIQQBHQQFxIQUgAkEQaiSAgICAACAFDwsfAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoAggPCx8BAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCAA8LgwEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAiACKAIMKAIANgIEAkAgAigCDCACKAIIEOGKgIAAQQFxRQ0AIAIoAgwoAgggAigCBGohAyACKAIIIQRBACEFAkAgBEUNACADIAUgBPwLAAsLIAJBEGokgICAgAAPC44CAQV/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAIgAigCCCgCACACKAIEajYCAAJAAkAgAigCACACKAIIKAIES0EBcUUNAAJAIAIoAggoAgQNACACKAIIQQE2AgQLAkADQCACKAIAIAIoAggoAgRLQQFxRQ0BIAIoAgghAyADIAMoAgRBAXQ2AgQMAAsLIAIoAggoAgggAigCCCgCBBCbjICAACEEIAIoAgggBDYCCAJAIAIoAggoAghBAEZBAXFFDQAgAkEAQQFxOgAPDAILCyACKAIAIQUgAigCCCAFNgIAIAJBAUEBcToADwsgAi0AD0EBcSEGIAJBEGokgICAgAAgBg8L4gEBBX8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhghBCAD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ACADQRBqJICAgIAADwuSAQEBfyOAgICAAEEQayECIAIgADYCCCACIAE2AgQgAkEANgIAAkACQANAIAIoAgAgAigCCCgCAElBAXFFDQECQCACKAIIKAIIIAIoAgBBAnRqKAIAIAIoAgRGQQFxRQ0AIAJBAUEBcToADwwDCyACIAIoAgBBAWo2AgAMAAsLIAJBAEEBcToADwsgAi0AD0EBcQ8LTAEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCCEEAR0EBcUUNACABKAIMKAIIEJqMgIAACyABQRBqJICAgIAADwv+AQEFfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACQX82AhACQAJAIAIoAhRBgICAgHhPQQFxRQ0AIAJBAEEBcToAHwwBCyACIAIoAhQQhouAgAA2AhQgAkEQNgIMIAIgAigCFEEQEKGMgIAANgIIAkAgAigCCEEARkEBcUUNACACQQBBAXE6AB8MAQsgAigCCCEDIAIoAhggAzYCACACKAIIIAIoAhRBA3RqIQQgAigCGCAENgIEIAIoAhhBADYCCCACKAIUIQUgAigCGCAFNgIMIAJBAUEBcToAHwsgAi0AH0EBcSEGIAJBIGokgICAgAAgBg8LtQEBAX8jgICAgABBEGshASABIAA2AggCQAJAIAEoAggNACABQQE2AgwMAQsgASABKAIIQX9qNgIIIAEgASgCCEEBdiABKAIIcjYCCCABIAEoAghBAnYgASgCCHI2AgggASABKAIIQQR2IAEoAghyNgIIIAEgASgCCEEIdiABKAIIcjYCCCABIAEoAghBEHYgASgCCHI2AgggASABKAIIQQFqNgIIIAEgASgCCDYCDAsgASgCDA8LhgEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQAJAIAIoAghFDQAgAigCCCACKAIMKAIITUEBcQ0BC0GNjYWAAEGo0YWAAEHIAUGkoYSAABCOgICAAAALIAIoAgwoAgQgAigCCEEBa0EDdGohAyACQRBqJICAgIAAIAMPCysBAX8jgICAgABBEGshASABIAA2AgwgASgCDCABKAIMQQFrcUEARkEBcQ8LfgEBfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAkGFKjYCBCACQQA2AgACQANAIAIoAgAgAigCCElBAXFFDQEgAiACKAIEQQV0IAIoAgRqIAIoAgwgAigCAGotAABB/wFxajYCBCACIAIoAgBBAWo2AgAMAAsLIAIoAgQPC1MBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgwgAygCCCADKAIEQQAQi4uAgAAhBCADQRBqJICAgIAAIAQPC5YGAQx/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI4IAQgATYCNCAEIAI2AjAgBCADNgIsAkACQCAEKAI4KAIIIAQoAjgoAgxBAnZBA2xPQQFxRQ0AAkAgBCgCOBCMi4CAAEEBcQ0AIARBADYCPAwCCwsCQCAEKAI4KAIMEIiLgIAAQQFxDQBB/qSGgABBqNGFgABB7gFB1o6EgAAQjoCAgAAACyAEIAQoAjgoAgxBAWs2AiggBCAEKAI0IAQoAjAQiYuAgAA2AiQgBCAEKAIkIAQoAihxNgIgAkADQCAEIAQoAjgoAgAgBCgCIEEDdGo2AhwgBCgCHCgCAEH/////A3FFDQEgBCAEKAI4KAIEIAQoAhwoAgBB/////wNxQQFrQQN0ajYCGAJAIAQoAhgoAgQgBCgCMEZBAXFFDQAgBCgCGCgCACAEKAI0IAQoAjAQ1IuAgAANAAJAAkAgBCgCLEEBRkEBcUUNACAEKAI0EJqMgIAADAELAkAgBCgCHCgCAEEedkEBRkEBcUUNACAEKAIYKAIAEJqMgIAAIAQoAjQhBSAEKAIYIAU2AgAgBCgCHCEGIAYgBigCAEH/////A3FBAHI2AgALCyAEIAQoAhwoAgBB/////wNxNgI8DAMLIAQgBCgCIEEBaiAEKAIocTYCIAwACwsgBCgCOCEHIAcoAghBAWohCCAHIAg2AgggBCAINgIUAkAgBCgCOCgCCEGAgICABElBAXENAEG/rYaAAEGo0YWAAEGXAkHWjoSAABCOgICAAAALIAQoAhwhCSAEQQA2AgwgBCgCFEH/////A3EhCiAEKAIMIQsgBCAKQf////8DcSALQYCAgIB8cXI2AgwgBCgCLEEDcSEMIAQoAgwhDSAEIAxBA3FBHnQgDUH/////A3FyNgIMIAQgBCgCJDYCECAJIAQpAgw3AgAgBCgCOCgCBCAEKAIUQQFrQQN0aiEOIAQgBCgCNDYCBCAEIAQoAjA2AgggDiAEKQIENwIAIAQgBCgCFDYCPAsgBCgCPCEPIARBwABqJICAgIAAIA8PC7YEAQh/I4CAgIAAQTBrIQEgASSAgICAACABIAA2AigCQCABKAIoKAIMEIiLgIAAQQFxDQBB/qSGgABBqNGFgABB/gBB9YyFgAAQjoCAgAAACyABIAEoAigoAgxBAXQ2AiQCQAJAIAEoAiQgASgCKCgCDElBAXFFDQAgAUEAQQFxOgAvDAELIAEgASgCJEEBazYCICABQRA2AhwgASABKAIkQRAQoYyAgAA2AhgCQCABKAIYQQBGQQFxRQ0AIAFBAEEBcToALwwBCyABIAEoAhg2AhQgASABKAIYIAEoAiRBA3RqNgIQIAFBADYCDAJAA0AgASgCDCABKAIoKAIMSUEBcUUNASABIAEoAigoAgAgASgCDEEDdGo2AggCQCABKAIIKAIAQf////8DcUUNACABIAEoAggoAgQgASgCIHE2AgQCQANAIAEoAhQgASgCBEEDdGooAgBB/////wNxRQ0BIAEgASgCBEEBaiABKAIgcTYCBAwACwsgASgCFCABKAIEQQN0aiABKAIIKQIANwIACyABIAEoAgxBAWo2AgwMAAsLIAEoAhAhAiABKAIoKAIEIQMgASgCKCgCCEEDdCEEAkAgBEUNACACIAMgBPwKAAALIAEoAigoAgAQmoyAgAAgASgCECEFIAEoAiggBTYCBCABKAIUIQYgASgCKCAGNgIAIAEoAiQhByABKAIoIAc2AgwgAUEBQQFxOgAvCyABLQAvQQFxIQggAUEwaiSAgICAACAIDwtTAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIAMoAgggAygCBEEBEIuLgIAAIQQgA0EQaiSAgICAACAEDwtTAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIAMoAgggAygCBEECEIuLgIAAIQQgA0EQaiSAgICAACAEDwvYAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAFBADYCCAJAA0AgASgCCCABKAIMKAIMSUEBcUUNASABIAEoAgwoAgAgASgCCEEDdGo2AgQCQCABKAIEKAIAQf////8DcUUN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IAAgABDsi4CAAGoPCyAAIQQLA0AgBCIALQAAIgNFDQEgAEEBaiEEIAMgAUH/AXFHDQALCyAAC1kBAn8gAS0AACECAkAgAC0AACIDRQ0AIAMgAkH/AXFHDQADQCABLQABIQIgAC0AASIDRQ0BIAFBAWohASAAQQFqIQAgAyACQf8BcUYNAAsLIAMgAkH/AXFrCy0BAn8CQCAAEOyLgIAAQQFqIgEQmIyAgAAiAg0AQQAPCyACIAAgARDKi4CAAAuHAQEDfyAAIQECQAJAIABBA3FFDQACQCAALQAADQAgACAAaw8LIAAhAQNAIAFBAWoiAUEDcUUNASABLQAADQAMAgsLA0AgASICQQRqIQFBgIKECCACKAIAIgNrIANyQYCBgoR4cUGAgYKEeEYNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrC3UBAn8CQCACDQBBAA8LAkACQCAALQAAIgMNAEEAIQAMAQsCQANAIANB/wFxIAEtAAAiBEcNASAERQ0BIAJBf2oiAkUNASABQQFqIQEgAC0AASEDIABBAWohACADDQALQQAhAwsgA0H/AXEhAAsgACABLQAAawuEAgEBfwJAAkACQAJAIAEgAHNBA3ENACACQQBHIQMCQCABQQNxRQ0AIAJFDQADQCAAIAEtAAAiAzoAACADRQ0FIABBAWohACACQX9qIgJBAEchAyABQQFqIgFBA3FFDQEgAg0ACwsgA0UNAiABLQAARQ0DIAJBBEkNAANAQYCChAggASgCACIDayADckGAgYKEeHFBgIGChHhHDQIgACADNgIAIABBBGohACABQQRqIQEgAkF8aiICQQNLDQALCyACRQ0BCwNAIAAgAS0AACIDOgAAIANFDQIgAEEBaiEAIAFBAWohASACQX9qIgINAAsLQQAhAgsgAEEAIAIQw4uAgAAaIAALEQAgACABIAIQ7ouAgAAaIAALWAECfyOAgICAAEEQayIBJICAgIAAQX8hAgJAIAAQy4uAgAANACAAIAFBD2pBASAAKAIgEYaAgIAAgICAgABBAUcNACABLQAPIQILIAFBEGokgICAgAAgAgtHAQJ/IAAgATcDcCAAIAAoAiwgACgCBCICa6w3A3ggACgCCCEDAkAgAVANACABIAMgAmusWQ0AIAIgAadqIQMLIAAgAzYCaAviAQMCfwJ+AX8gACkDeCAAKAIEIgEgACgCLCICa6x8IQMCQAJAAkAgACkDcCIEUA0AIAMgBFkNAQsgABDwi4CAACICQX9KDQEgACgCBCEBIAAoAiwhAgsgAEJ/NwNwIAAgATYCaCAAIAMgAiABa6x8NwN4QX8PCyADQgF8IQMgACgCBCEBIAAoAgghBQJAIAApA3AiBEIAUQ0AIAQgA30iBCAFIAFrrFkNACABIASnaiEFCyAAIAU2AmggACADIAAoAiwiBSABa6x8NwN4AkAgASAFSw0AIAFBf2ogAjoAAAsgAguuAQACQAJAIAFBgAhIDQAgAEQAAAAAAADgf6IhAAJAIAFB/w9PDQAgAUGBeGohAQwCCyAARAAAAAAAAOB/oiEAIAFB/RcgAUH9F0kbQYJwaiEBDAELIAFBgXhKDQAgAEQAAAAAAABgA6IhAAJAIAFBuHBNDQAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEsbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCzwAIAAgATcDACAAIARCMIinQYCAAnEgAkKAgICAgIDA//8Ag0IwiKdyrUIwhiACQv///////z+DhDcDCAvmAgEBfyOAgICAAEHQAGsiBCSAgICAAAJAAkAgA0GAgAFIDQAgBEEgaiABIAJCAEKAgICAgICA//8AELCMgIAAIAQpAyghAiAEKQMgIQECQCADQf//AU8NACADQYGAf2ohAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQsIyAgAAgA0H9/wIgA0H9/wJJG0GCgH5qIQMgBCkDGCECIAQpAxAhAQwBCyADQYGAf0oNACAEQcAAaiABIAJCAEKAgICAgICAORCwjICAACAEKQNIIQIgBCkDQCEBAkAgA0H0gH5NDQAgA0GN/wBqIQMMAQsgBEEwaiABIAJCAEKAgICAgICAORCwjICAACADQeiBfSADQeiBfUsbQZr+AWohAyAEKQM4IQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQsIyAgAAgACAEKQMINwMIIAAgBCkDADcDACAEQdAAaiSAgICAAAvnBgQDfwJ+AX8BfiOAgICAAEGAAWsiBSSAgICAAAJAAkACQCADIARCAEIAEKaMgIAARQ0AIAMgBBC9i4CAAEUNACACQjCIpyIGQf//AXEiB0H//wFHDQELIAVBEGogASACIAMgBBCwjICAACAFIAUpAxAiBCAFKQMYIgMgBCADEKiMgIAAIAUpAwghAiAFKQMAIQQMAQsCQCABIAJC////////////AIMiCCADIARC////////////AIMiCRCmjICAAEEASg0AAkAgASAIIAMgCRCmjICAAEUNACABIQQMAgsgBUHwAGogASACQgBCABCwjICAACAFKQN4IQIgBSkDcCEEDAELIARCMIinQf//AXEhCgJAAkAgB0UNACABIQQMAQsgBUHgAGogASAIQgBCgICAgICAwLvAABCwjICAACAFKQNoIghCMIinQYh/aiEHIAUpA2AhBAsCQCAKDQAgBUHQAGogAyAJQgBCgICAgICAwLvAABCwjICAACAFKQNYIglCMIinQYh/aiEKIAUpA1AhAwsgCUL///////8/g0KAgICAgIDAAIQhCyAIQv///////z+DQoCAgICAgMAAhCEIAkAgByAKTA0AA0ACQAJAIAggC30gBCADVK19IglCAFMNAAJAIAkgBCADfSIEhEIAUg0AIAVBIGogASACQgBCABCwjICAACAFKQMoIQIgBSkDICEEDAULIAlCAYYgBEI/iIQhCAwBCyAIQgGGIARCP4iEIQgLIARCAYYhBCAHQX9qIgcgCkoNAAsgCiEHCwJAAkAgCCALfSAEIANUrX0iCUIAWQ0AIAghCQwBCyAJIAQgA30iBIRCAFINACAFQTBqIAEgAkIAQgAQsIyAgAAgBSkDOCECIAUpAzAhBAwBCwJAIAlC////////P1YNAANAIARCP4ghAyAHQX9qIQcgBEIBhiEEIAMgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAZBgIACcSEKAkAgB0EASg0AIAVBwABqIAQgCUL///////8/gyAHQfgAaiAKcq1CMIaEQgBCgICAgICAwMM/ELCMgIAAIAUpA0ghAiAFKQNAIQQMAQsgCUL///////8/gyAHIApyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiSAgICAAAscACAAIAJC////////////AIM3AwggACABNwMAC9kJBAF/AX4GfwF+I4CAgIAAQTBrIgQkgICAgABCACEFAkACQCACQQJLDQAgAkECdCICKAKM8YiAACEGIAIoAoDxiIAAIQcDQAJAAkAgASgCBCICIAEo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gIAAgICAgAALCz0BAX8CQCAAUA0AA0AgAUF/aiIBIACnQQ9xLQDw9IiAACACcjoAACAAQg9WIQMgAEIEiCEAIAMNAAsLIAELNgEBfwJAIABQDQADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIHViECIABCA4ghACACDQALCyABC4oBAgF+A38CQAJAIABCgICAgBBaDQAgACECDAELA0AgAUF/aiIBIAAgAEIKgCICQgp+fadBMHI6AAAgAEL/////nwFWIQMgAiEAIAMNAAsLAkAgAlANACACpyEDA0AgAUF/aiIBIAMgA0EKbiIEQQpsa0EwcjoAACADQQlLIQUgBCEDIAUNAAsLIAELhAEBAX8jgICAgABBgAJrIgUkgICAgAACQCACIANMDQAgBEGAwARxDQAgBSABIAIgA2siA0GAAiADQYACSSICGxDDi4CAABoCQCACDQADQCAAIAVBgAIQiIyAgAAgA0GAfmoiA0H/AUsNAAsLIAAgBSADEIiMgIAACyAFQYACaiSAgICAAAsaACAAIAEgAkHsgYCAAEHtgYCAABCGjICAAAvDGQYCfwF+DH8CfgR/AXwjgICAgABBsARrIgYkgICAgABBACEHIAZBADYCLAJAAkAgARCSjICAACIIQn9VDQBBASEJQcyIhIAAIQogAZoiARCSjICAACEIDAELAkAgBEGAEHFFDQBBASEJQc+IhIAAIQoMAQtB0oiEgABBzYiEgAAgBEEBcSIJGyEKIAlFIQcLAkACQCAIQoCAgICAgID4/wCDQoCAgICAgID4/wBSDQAgAEEgIAIgCUEDaiILIARB//97cRCOjICAACAAIAogCRCIjICAACAAQc/uhIAAQfj0hYAAIAVBIHEiDBtBi4yFgABBiv2FgAAgDBsgASABYhtBAxCIjICAACAAQSAgAiALIARBgMAAcxCOjICAACACIAsgAiALShshDQwBCyAGQRBqIQ4CQAJAAkACQCABIAZBLGoQhYyAgAAiASABoCIBRAAAAAAAAAAAYQ0AIAYgBigCLCILQX9qNgIsIAVBIHIiD0HhAEcNAQwDCyAFQSByIg9B4QBGDQJBBiADIANBAEgbIRAgBigCLCERDAELIAYgC0FjaiIRNgIsQQYgAyADQQBIGyEQIAFEAAAAAAAAsEGiIQELIAZBMGpBAEGgAiARQQBIG2oi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cjYCmKyJgAAgAyEBDAELIAMoAggiASAESQ0DCyADIAA2AgggASAANgIMIAAgAzYCDCAAIAE2AggPC0EfIQMCQCABQf///wdLDQAgAUEmIAFBCHZnIgNrdkEBcSADQQF0a0E+aiEDCyAAIAM2AhwgAEIANwIQIANBAnRByK6JgABqIQUCQAJAAkBBACgCnKyJgAAiBkEBIAN0IgJxDQBBACAGIAJyNgKcrImAACAFIAA2AgAgACAFNgIYDAELIAFBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhBgNAIAYiBSgCBEF4cSABRg0CIANBHXYhBiADQQF0IQMgBSAGQQRxaiICKAIQIgYNAAsgAkEQaiIBIARJDQMgASAANgIAIAAgBTYCGAsgACAANgIMIAAgADYCCA8LIAUgBEkNASAFKAIIIgEgBEkNASABIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACABNgIICw8LEL6LgIAAAAtrAgF/AX4CQAJAIAANAEEAIQIMAQsgAK0gAa1+IgOnIQIgASAAckGAgARJDQBBfyACIANCIIinQQBHGyECCwJAIAIQmIyAgAAiAEUNACAAQXxqLQAAQQNxRQ0AIABBACACEMOLgIAAGgsgAAsHAD8AQRB0C2EBAn9BACgCxKGJgAAiASAAQQdqQXhxIgJqIQACQAJAAkAgAkUNACAAIAFNDQELIAAQooyAgABNDQEgABCdgICAAA0BCxC8i4CAAEEwNgIAQX8PC0EAIAA2AsShiYAAIAELgAsHAX8BfgF/An4BfwF+AX8jgICAgABB8ABrIgUkgICAgAAgBEL///////////8AgyEGAkACQAJAIAFQIgcgAkL///////////8AgyIIQoCAgICAgMCAgH98QoCAgICAgMCAgH9UIAhQGw0AIANCAFIgBkKAgICAgIDAgIB/fCIJQoCAgICAgMCAgH9WIAlCgICAgICAwICAf1EbDQELAkAgByAIQoCAgICAgMD//wBUIAhCgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEEIAEhAwwCCwJAIANQIAZCgICAgICAwP//AFQgBkKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQQMAgsCQCABIAhCgICAgICAwP//AIWEQgBSDQBCgICAgICA4P//ACACIAMgAYUgBCAChUKAgICAgICAgIB/hYRQIgcbIQRCACABIAcbIQMMAgsgAyAGQoCAgICAgMD//wCFhFANAQJAIAEgCIRCAFINACADIAaEQgBSDQIgAyABgyEDIAQgAoMhBAwCCyADIAaEUEUNACABIQMgAiEEDAELIAMgASADIAFWIAYgCFYgBiAIURsiChshBiAEIAIgChsiCUL///////8/gyEIIAIgBCAKGyILQjCIp0H//wFxIQwCQCAJQjCIp0H//wFxIgcNACAFQeAAaiAGIAggBiAIIAhQIgcbeULAAEIAIAcbfKciB0FxahCljICAAEEQIAdrIQcgBSkDaCEIIAUpA2AhBgsgASADIAobIQMgC0L///////8/gyEBAkAgDA0AIAVB0ABqIAMgASADIAEgAVAiCht5QsAAQgAgCht8pyIKQXFqEKWMgIAAQRAgCmshDCAFKQNYIQEgBSkDUCEDCyABQgOGIANCPYiEQoCAgICAgIAEhCEBIAhCA4YgBkI9iIQhCyADQgOGIQggBCAChSEDAkAgByAMRg0AAkAgByAMayIKQf8ATQ0AQgAhAUIBIQgMAQsgBUHAAGogCCABQYABIAprEKWMgIAAIAVBMGogCCABIAoQr4yAgAAgBSkDMCAFKQNAIAUpA0iEQgBSrYQhCCAFKQM4IQELIAtCgICAgICAgASEIQsgBkIDhiEGAkACQCADQn9VDQBCACEDQgAhBCAGIAiFIAsgAYWEUA0CIAYgCH0hAiALIAF9IAYgCFStfSIEQv////////8DVg0BIAVBIGogAiAEIAIgBCAEUCIKG3lCwABCACAKG3ynQXRqIgoQpYyAgAAgByAKayEHIAUpAyghBCAFKQMgIQIMAQsgASALfCAIIAZ8IgIgCFStfCIEQoCAgICAgIAIg1ANACACQgGIIARCP4aEIAhCAYOEIQIgB0EBaiEHIARCAYghBAsgCUKAgICAgICAgIB/gyEIAkAgB0H//wFIDQAgCEKAgICAgIDA//8AhCEEQgAhAwwBC0EAIQoCQAJAIAdBAEwNACAHIQoMAQsgBUEQaiACIAQgB0H/AGoQpYyAgAAgBSACIARBASAHaxCvjICAACAFKQMAIAUpAxAgBSkDGIRCAFKthCECIAUpAwghBAsgAkIDiCAEQj2GhCEDIAqtQjCGIARCA4hC////////P4OEIAiEIQQgAqdBB3EhBwJAAkACQAJAAkAQrYyAgAAOAwABAgMLAkAgB0EERg0AIAQgAyAHQQRLrXwiCCADVK18IQQgCCEDDAMLIAQgAyADQgGDfCIIIANUrXwhBCAIIQMMAwsgBCADIAhCAFIgB0EAR3GtfCIIIANUrXwhBCAIIQMMAQsgBCADIAhQIAdBAEdxrXwiCCADVK18IQQgCCEDCyAHRQ0BCxCujICAABoLIAAgAzcDACAAIAQ3AwggBUHwAGokgICAgAALUwEBfgJAAkAgA0HAAHFFDQAgASADQUBqrYYhAkIAIQEMAQsgA0UNACABQcAAIANrrYggAiADrSIEhoQhAiABIASGIQELIAAgATcDACAAIAI3AwgL5gECAX8CfkEBIQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQACQCACIACEIAYgBYSEUEUNAEEADwsCQCADIAGDQgBTDQACQCAAIAJUIAEgA1MgASADURtFDQBBfw8LIAAgAoUgASADhYRCAFIPCwJAIAAgAlYgASADVSABIANRG0UNAEF/DwsgACAChSABIAOFhEIAUiEECyAEC9gBAgF/An5BfyEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPCyAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLnxEGAX8DfgN/AX4Bfwt+I4CAgIAAQdACayIFJICAgIAAIARC////////P4MhBiACQv///////z+DIQcgBCAChUKAgICAgICAgIB/gyEIIARCMIinQf//AXEhCQJAAkACQCACQjCIp0H//wFxIgpBgYB+akGCgH5JDQBBACELIAlBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyIMQoCAgICA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AiABQgGGIgRUrX0hASACIAR9IQILIAVBEGogAyAOQgNCABCxjICAACAFIAMgDkIFQgAQsYyAgAAgBiAHIAdCAYMiBCACfCICIANWIAEgAiAEVK18IgEgDlYgASAOURutfCIEIAdUrXwiAyAEIANCgICAgICAwP//AFQgAiAFKQMQViABIAUpAxgiA1YgASADURtxrXwiAyAEVK18IgQgAyAEQoCAgICAgMD//wBUIAIgBSkDAFYgASAFKQMIIgJWIAEgAlEbca18IgEgA1StfCAIhCEICyAAIAE3AwAgACAINwMIIAVB0AJqJICAgIAAC/QBAwF/BH4BfyOAgICAAEEQayICJICAgIAAIAG9IgNC/////////weDIQQCQAJAIANCNIhC/w+DIgVQDQACQCAFQv8PUQ0AIARCBIghBiAEQjyGIQQgBUKA+AB8IQUMAgsgBEIEiCEGIARCPIYhBEL//wEhBQwBCwJAIARQRQ0AQgAhBEIAIQZCACEFDAELIAIgBEIAIAR5pyIHQTFqEKWMgIAAIAIpAwhCgICAgICAwACFIQZBjPgAIAdrrSEFIAIpAwAhBAsgACAENwMAIAAgBUIwhiADQoCAgICAgICAgH+DhCAGhDcDCCACQRBqJICAgIAAC+oBAgV/An4jgICAgABBEGsiAiSAgICAACABvCIDQf///wNxIQQCQAJAIANBF3YiBUH/AXEiBkUNAAJAIAZB/wFGDQAgBK1CGYYhByAFQf8BcUGA/wBqIQRCACEIDAILIAStQhmGIQdCACEIQf//ASEEDAELAkAgBA0AQgAhCEEAIQRCACEHDAELIAIgBK1CACAEZyIEQdEAahCljICAAEGJ/wAgBGshBCACKQMIQoCAgICAgMAAhSEHIAIpAwAhCAsgACAINwMAIAAgBK1CMIYgA0Efdq1CP4aEIAeENwMIIAJBEGokgICAgAALoQEDAX8CfgF/I4CAgIAAQRBrIgIkgICAgAACQAJAIAENAEIAIQNCACEEDAELIAIgASABQR91IgVzIAVrIgWtQgAgBWciBUHRAGoQpYyAgAAgAikDCEKAgICAgIDAAIVBnoABIAVrrUIwhnxCgICAgICAgICAf0IAIAFBAEgbhCEEIAIpAwAhAwsgACADNwMAIAAgBDcDCCACQRBqJICAgIAAC4EBAgF/An4jgICAgABBEGsiAiSAgICAAAJAAkAgAQ0AQgAhA0IAIQQMAQsgAiABrUIAQfAAIAFnIgFBH3NrEKWMgIAAIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQQgAikDACEDCyAAIAM3AwAgACAENwMIIAJBEGokgICAgAALBABBAAsEAEEAC1MBAX4CQAJAIANBwABxRQ0AIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC7ULBgF/BH4DfwF+AX8EfiOAgICAAEHgAGsiBSSAgICAACAEQv///////z+DIQYgBCAChUKAgICAgICAgIB/gyEHIAJC////////P4MiCEIgiCEJIARCMIinQf//AXEhCgJAAkACQCACQjCIp0H//wFxIgtBgYB+akGCgH5JDQBBACEMIApBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEHDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEHIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAoRQRQ0AQoCAgICAgOD//wAhB0IAIQEMAwsgB0KAgICAgIDA//8AhCEHQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINACABIA2EIQJCACEBAkAgAlBFDQBCgICAgICA4P//ACEHDAMLIAdCgICAgICAwP//AIQhBwwCCwJAIAEgDYRCAFINAEIAIQEMAgsCQCADIAKEQgBSDQBCACEBDAILQQAhDAJAIA1C////////P1YNACAFQdAAaiABIAggASAIIAhQIgwbeULAAEIAIAwbfKciDEFxahCljICAAEEQIAxrIQwgBSkDWCIIQiCIIQkgBSkDUCEBCyACQv///////z9WDQAgBUHAAGogAyAGIAMgBiAGUCIOG3lCwABCACAOG3ynIg5BcWoQpYyAgAAgDCAOa0EQaiEMIAUpA0ghBiAFKQNAIQMLIAsgCmogDGpBgYB/aiEKAkACQCAGQg+GIg9CIIhCgICAgAiEIgIgAUIgiCIEfiIQIANCD4YiEUIgiCIGIAlCgIAEhCIJfnwiDSAQVK0gDSADQjGIIA+EQv////8PgyIDIAhC/////w+DIgh+fCIPIA1UrXwgAiAJfnwgDyARQoCA/v8PgyINIAh+IhEgBiAEfnwiECARVK0gECADIAFC/////w+DIgF+fCIRIBBUrXx8IhAgD1StfCADIAl+IhIgAiAIfnwiDyASVK1CIIYgD0IgiIR8IBAgD0IghnwiDyAQVK18IA8gDSAJfiIQIAYgCH58IgkgAiABfnwiAiADIAR+fCIDQiCIIAkgEFStIAIgCVStfCADIAJUrXxCIIaEfCICIA9UrXwgAiARIA0gBH4iCSAGIAF+fCIEQiCIIAQgCVStQiCGhHwiBiARVK0gBiADQiCGfCIDIAZUrXx8IgYgAlStfCAGIAMgBEIghiICIA0gAX58IgEgAlStfCICIANUrXwiBCAGVK18IgNCgICAgICAwACDUA0AIApBAWohCgwBCyABQj+IIQYgA0IBhiAEQj+IhCEDIARCAYYgAkI/iIQhBCABQgGGIQEgBiACQgGGhCECCwJAIApB//8BSA0AIAdCgICAgICAwP//AIQhB0IAIQEMAQsCQAJAIApBAEoNAAJAQQEgCmsiC0H/AEsNACAFQTBqIAEgAiAKQf8AaiIKEKWMgIAAIAVBIGogBCADIAoQpYyAgAAgBUEQaiABIAIgCxCvjICAACAFIAQgAyALEK+MgIAAIAUpAyAgBSkDEIQgBSkDMCAFKQM4hEIAUq2EIQEgBSkDKCAFKQMYhCECIAUpAwghAyAFKQMAIQQMAgtCACEBDAILIAqtQjCGIANC////////P4OEIQMLIAMgB4QhBwJAIAFQIAJCf1UgAkKAgICAgICAgIB/URsNACAHIARCAXwiAVCtfCEHDAELAkAgASACQoCAgICAgICAgH+FhEIAUQ0AIAQhAQwBCyAHIAQgBEIBg3wiASAEVK18IQcLIAAgATcDACAAIAc3AwggBUHgAGokgICAgAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCADQv////8PgyACIAF+fCIBQiCIfDcDCCAAIAFCIIYgBUL/////D4OENwMACyAAQYCAhIAAJIKAgIAAQYCAgIAAQQ9qQXBxJIGAgIAACw8AI4CAgIAAI4GAgIAAawsIACOCgICAAAsIACOBgICAAAtUAQF/I4CAgIAAQRBrIgUkgICAgAAgBSABIAIgAyAEQoCAgICAgICAgH+FEKSMgIAAIAUpAwAhBCAAIAUpAwg3AwggACAENwMAIAVBEGokgICAgAALqQQDAX8CfgR/I4CAgIAAQSBrIgIkgICAgAAgAUL///////8/gyEDAkACQCABQjCIQv//AYMiBKciBUH/h39qQf0PSw0AIABCPIggA0IEhoQhAyAFQYCIf2qtIQQCQAJAIABC//////////8PgyIAQoGAgICAgICACFQNACADQgF8IQMMAQsgAEKAgICAgICAgAhSDQAgA0IBgyADfCEDC0IAIAMgA0L/////////B1YiBRshACAFrSAEfCEDDAELAkAgACADhFANACAEQv//AVINACAAQjyIIANCBIaEQoCAgICAgIAEhCEAQv8PIQMMAQsCQCAFQf6HAU0NAEL/DyEDQgAhAAwBCwJAQYD4AEGB+AAgBFAiBhsiByAFayIIQfAATA0AQgAhAEIAIQMMAQsgAyADQoCAgICAgMAAhCAGGyEDQQAhBgJAIAcgBUYNACACQRBqIAAgA0GAASAIaxCljICAACACKQMQIAIpAxiEQgBSIQYLIAIgACADIAgQr4yAgAAgAikDACIDQjyIIAIpAwhCBIaEIQACQAJAIANC//////////8PgyAGrYQiA0KBgICAgICAgAhUDQAgAEIBfCEADAELIANCgICAgICAgIAIUg0AIABCAYMgAHwhAAsgAEKAgICAgICACIUgACAAQv////////8HViIFGyEAIAWtIQMLIAJBIGokgICAgAAgA0I0hiABQoCAgICAgICAgH+DhCAAhL8LHgBBACAAIABBmQFLG0EBdC8BgISJgABBgPWIgABqCwwAIAAgABC4jICAAAsRAEHZuIWAAEEAEJaNgIAAAAtUAQJ/I4CAgIAAQRBrIgIkgICAgABBACEDAkAgAEEDcQ0AIAEgAHANACACQQxqIAAgARCfjICAACEAQQAgAigCDCAAGyEDCyACQRBqJICAgIAAIAMLGQACQCAAEL2MgIAAIgANABC+jICAAAsgAAs+AQJ/IABBASAAQQFLGyEBAkADQCABEJiMgIAAIgINARCZjYCAACIARQ0BIAARgYCAgACAgICAAAwACwsgAgsJABC6jICAAAALCgAgABCajICAAAsKACAAEL+MgIAACxsAAkAgACABEMKMgIAAIgENABC+jICAAAsgAQtMAQJ/IAFBBCABQQRLGyECIABBASAAQQFLGyEAAkADQCACIAAQw4yAgAAiAw0BEJmNgIAAIgFFDQEgARGBgICAAICAgIAADAALCyADCyQBAX8gACABIAAgAWpBf2pBACAAa3EiAiABIAJLGxC7jICAAAsKACAAEMWMgIAACwoAIAAQmoyAgAALDAAgACACEMSMgIAACyEAAkAgABDPjICAAEUNACAAENCMgIAADwsgABDRjICAAAsMACAAIAEQ04yAgAALJQEBf0EKIQECQCAAEM+MgIAARQ0AIAAQ1IyAgABBf2ohAQsgAQshAAJAIAAQz4yAgABFDQAgABDVjICAAA8LIAAQ1oyAgAALBAAgAAsCAAuxAwEDfyOAgICAAEEgayIIJICAgIAAAkAgAiAAENqMgIAAIgkgAUF/c2pLDQAgABDKjICAACEKAkAgASAJQQF2QXhqTw0AIAggAUEBdDYCHCAIIAIgAWo2AhAgCEEQaiAIQRxqENuMgIAAKAIAENyMgIAAQQFqIQkLIAAQ3YyAgAAgCEEcaiAIQRhqIAAQ3oyAgAAoAgAQ34yAgAAgCEEQaiAAIAkQ4IyAgAAgCCgCECIJIAgoAhQQ4YyAgAACQCAERQ0AIAkQy4yAgAAgChDLjICAACAEEOKMgIAAGgsCQCAGRQ0AIAkQy4yAgAAgBGogByAGEOKMgIAAGgsgAyAFIARqIgdrIQICQCADIAdGDQAgCRDLjICAACAEaiAGaiAKEMuMgIAAIARqIAVqIAIQ4oyAgAAaCwJAIAFBAWoiAUELRg0AIAAgCiABEOOMgIAACyAAIAkQ5IyAgAAgACAIKAIUEOWMgIAAIAAgBiAEaiACaiIEEOaMgIAAIAhBADoADyAJIARqIAhBD2oQ2YyAgAAgCEEcahDnjICAABogCEEgaiSAgICAAA8LEOiMgIAAAAsPAEHrhoWAABDSjICAAAALCgAgAC0AC0EHdgsHACAAKAIECwsAIAAtAAtB/wBxCysBAX8jgICAgABBEGsiASSAgICAACABIAA2AgBBgLaGgAAgARCWjYCAAAALOAECfyOAgICAAEEQayICJICAgIAAIAJBD2ogASAAEIGNgIAAIQMgAkEQaiSAgICAACABIAAgAxsLDgAgACgCCEH/////B3ELBwAgACgCAAsKACAAEPKMgIAACxsAAkAgAkUNACACRQ0AIAAgASAC/AoAAAsgAAslAAJAIAAQz4yAgABFDQAgACABEOaMgIAADwsgACABEO2MgIAACwwAIAAgAS0AADoAAAscACAAEO+MgIAAIgAgABDwjICAAEEBdkt2QXhqCwwAIAAgARD7jICAAAswAQF/QQohAQJAIABBC0kNACAAQQFqEPSMgIAAIgAgAEF/aiIAIABBC0YbIQELIAELAgALCwAgACABNgIAIAALDQAgACABEPyMgIAAGgsOACAAIAEgAhDzjICAAAsCAAsRACAAIAEgAhDXjICAABogAAsOACAAIAEgAhD4jICAAAsJACAAIAE2AgALEAAgACABQYCAgIB4cjYCCAsJACAAIAE2AgQLDAAgABD9jICAACAACw8AQeuGhYAAEPGMgIAAAAsQACAAEOqMgIAAEOuMgIAACyEAAkAgABDPjICAAEUNACAAEIKNgIAADwsgABCDjYCAAAsEACAACwcAIABBC0kLDQAgACABQf8AcToACwsCAAsIABDwjICAAAsIABCFjYCAAAsrAQF/I4CAgIAAQRBrIgEkgICAgAAgASAANgIAQb61hoAAIAEQlo2AgAAACwQAIAALDgAgACABIAIQho2AgAALCgAgAEEHakF4cQsKACAAEPaMgIAACwoAIAAQ7IuAgAALMgAgABDdjICAAAJAIAAQz4yAgABFDQAgACAAENWMgIAAIAAQ1IyAgAAQ44yAgAALIAALDgAgASACQQEQjY2AgAAL3gEBAn8jgICAgABBEGsiAySAgICAAAJAIAIgABDajICAAEsNAAJAAkAgAhDsjICAAEUNACAAIAIQ7YyAgAAgABDWjICAACEEDAELIANBCGogACACENyMgIAAQQFqEOCMgIAAIAMoAggiBCADKAIMEOGMgIAAIAAgBBDkjICAACAAIAMoAgwQ5YyAgAAgACACEOaMgIAACyAEEMuMgIAAIAEgAhDijICAABogA0EAOgAHIAQgAmogA0EHahDZjICAACAAIAIQ7oyAgAAgA0EQaiSAgICAAA8LEOiMgIAAAAuzAQEDfyOAgICAAEEQayIDJICAgIAAAkACQCAAEMmMgIAAIgQgABDHjICAACIFayACSQ0AIAJFDQEgACACEMyMgIAAIAAQyoyAgAAQy4yAgAAiBCAFaiABIAIQ4oyAgAAaIAAgBSACaiICENiMgIAAIANBADoADyAEIAJqIANBD2oQ2YyAgAAMAQsgACAEIAIgBGsgBWogBSAFQQAgAiABEM2MgIAACyADQRBqJICAgIAAIAALOAECfyOAgICAAEEQayICJICAgIAAIAJBD2ogACABEIGNgIAAIQMgAkEQaiSAgICAACABIAAgAxsLCwAgACABNgIAIAALGQAgACgCACEAIAAgABDHjICAABDujICAAAu5AQEBfyOAgICAAEEQayIFJICAgIAAIAUgBDYCCCAFIAI2AgwCQCAAEMeMgIAAIgIgAUkNACAEQX9GDQAgBSACIAFrNgIAIAUgBUEMaiAFEMiMgIAAKAIANgIEAkAgABDpjICAACABaiADIAVBBGogBUEIahDIjICAACgCABD/jICAACIBDQBBfyEBIAUoAgQiBCAFKAIIIgBJDQAgBCAASyEBCyAFQRBqJICAgIAAIAEPCxDOjICAAAALDgAgACABIAIQ1IuAgAALFAAgACABIAEQ9YyAgAAQ+oyAgAALDQAgASgCACACKAIASQsHACAAKAIACwoAIAAQhI2AgAALBAAgAAsEAEF/CxwAIAEgAhCHjYCAACEBIAAgAjYCBCAAIAE2AgALIwACQCABIAAQ74yAgABNDQAQiI2AgAAACyABQQEQiY2AgAALEQBBobiFgABBABCWjYCAAAALIwACQCABEIqNgIAARQ0AIAAgARCLjYCAAA8LIAAQjI2AgAALBwAgAEEISwsMACAAIAEQwYyAgAALCgAgABC8jICAAAsnAAJAIAIQio2AgABFDQAgACABIAIQjo2AgAAPCyAAIAEQj42AgAALDgAgACABIAIQxoyAgAALDAAgACABEMCMgIAACwwAIAAgARCRjYCAAAt7AQJ/AkACQCABKAJMIgJBAEgNACACRQ0BIAJB/////wNxEOGLgIAAKAIYRw0BCwJAIABB/wFxIgIgASgCUEYNACABKAIUIgMgASgCEEYNACABIANBAWo2AhQgAyAAOgAAIAIPCyABIAIQ44uAgAAPCyAAIAEQko2AgAALhAEBA38CQCABQcwAaiICEJONgIAARQ0AIAEQwIuAgAAaCwJAAkAgAEH/AXEiAyABKAJQRg0AIAEoAhQiBCABKAIQRg0AIAEgBEEBajYCFCAEIAA6AAAMAQsgASADEOOLgIAAIQMLAkAgAhCUjYCAAEGAgICABHFFDQAgAhCVjYCAAAsgAwsbAQF/IAAgACgCACIBQf////8DIAEbNgIAIAELFAEBfyAAKAIAIQEgAEEANgIAIAELDQAgAEEBENWLgIAAGgtdAQF/I4CAgIAAQRBrIgIkgICAgAAgAiABNgIMQQAoAsDwiIAAIgIgACABEI+MgIAAGgJAIAAgABDsi4CAAGpBf2otAABBCkYNAEEKIAIQkI2AgAAaCxC+i4CAAAALVwECfyOAgICAAEEQayICJICAgIAAQZW3hoAAQQtBAUEAKALA8IiAACIDEM6LgIAAGiACIAE2AgwgAyAAIAEQj4yAgAAaQQogAxCQjYCAABoQvouAgAAACwcAIAAoAgALDgBBiLCJgAAQmI2AgAALCgAgABCyjYCAAAsCAAsCAAsSACAAEJqNgIAAQQgQwIyAgAALEgAgABCajYCAAEEIEMCMgIAACxIAIAAQmo2AgABBDBDAjICAAAsOACAAIAFBABChjYCAAAs5AAJAIAINACAAKAIEIAEoAgRGDwsCQCAAIAFHDQBBAQ8LIAAQoo2AgAAgARCijYCAABDqi4CAAEULBwAgACgCBAuRAgECfyOAgICAAEHQAGsiAySAgICAAEEBIQQCQAJAIAAgAUEAEKGNgIAADQBBACEEIAFFDQBBACEEIAFBtIaJgABB5IaJgABBABCkjYCAACIBRQ0AIAIoAgAiBEUNAQJAQThFDQAgA0EYakEAQTj8CwALIANBAToASyADQX82AiAgAyAANgIcIAMgATYCFCADQQE2AkQgASADQRRqIARBASABKAIAKAIcEYWAgIAAgICAgAACQCADKAIsIgRBAUcNACACIAMoAiQ2AgALIARBAUYhBAsgA0HQAGokgICAgAAgBA8LIANBsY6GgAA2AgggA0HnAzYCBCADQc7ZhIAANgIAQZjChIAAIAMQl42AgAAAC5UBAQR/I4CAgIAAQRBrIgQkgICAgAAgBEEEaiAAEKWNgIAAIAQoAggiBSACQQAQoY2AgAAhBiAEKAIEIQcCQAJAIAZFDQAgACAHIAEgAiAEKAIMIAMQpo2AgAAhBgwBCyAAIAcgAiAFIAMQp42AgAAiBg0AIAAgByABIAIgBSADEKiNgIAAIQYLIARBEGokgICAgAAgBgsvAQJ/IAAgASgCACICQXhqKAIAIgM2AgggACABIANqNgIAIAAgAkF8aigCADYCBAvXAQECfyOAgICAAEHAAGsiBiSAgICAAEEAIQcCQAJAIAVBAEgNACABQQAgBEEAIAVrRhshBwwBCyAFQX5GDQAgBkEcaiIHQgA3AgAgBkEkakIANwIAIAZBLGpCADcCACAGQgA3AhQgBiAFNgIQIAYgAjYCDCAGIAA2AgggBiADNgIEIAZBADYCPCAGQoGAgICAgICAATcCNCADIAZBBGogASABQQFBACADKAIAKAIUEYmAgIAAgICAgAAgAUEAIAcoAgBBAUYbIQcLIAZBwABqJICAgIAAIAcLxQEBAn8jgICAgABBwABrIgUkgICAgABBACEGAkAgBEEASA0AIAAgBGsiACABSA0AIAVBHGoiBkIANwIAIAVBJGpCADcCACAFQSxqQgA3AgAgBUIANwIUIAUgBDYCECAFIAI2AgwgBSADNgIEIAVBADYCPCAFQoGAgICAgICAATcCNCAFIAA2AgggAyAFQQRqIAEgAUEBQQAgAygCACgCFBGJgICAAICAgIAAIABBACAGKAIAGyEGCyAFQcAAaiSAgICAACAGC/IBAQF/I4CAgIAAQcAAayIGJICAgIAAIAYgBTYCECAGIAI2AgwgBiAANgIIIAYgAzYCBEEAIQUCQEEnRQ0AIAZBFGpBAEEn/AsACyAGQQA2AjwgBkEBOgA7IAQgBkEEaiABQQFBACAEKAIAKAIYEYqAgIAAgICAgAACQAJAAkAgBigCKA4CAAECCyAGKAIYQQAgBigCJEEBRhtBACAGKAIgQQFGG0EAIAYoAixBAUYbIQUMAQsCQCAGKAIcQQFGDQAgBigCLA0BIAYoAiBBAUcNASAGKAIkQQFHDQELIAYoAhQhBQsgBkHAAGokgICAgAAgBQt3AQF/AkAgASgCJCIEDQAgASADNgIYIAEgAjYCECABQQE2AiQgASABKAI4NgIUDwsCQAJAIAEoAhQgASgCOEcNACABKAIQIAJHDQAgASgCGEECRw0BIAEgAzYCGA8LIAFBAToANiABQQI2AhggASAEQQFqNgIkCwslAAJAIAAgASgCCEEAEKGNgIAARQ0AIAEgASACIAMQqY2AgAALC0YAAkAgACABKAIIQQAQoY2AgABFDQAgASABIAIgAxCpjYCAAA8LIAAoAggiACABIAIgAyAAKAIAKAIcEYWAgIAAgICAgAALnwEAIAFBAToANQJAIAMgASgCBEcNACABQQE6ADQCQAJAIAEoAhAiAw0AIAFBATYCJCABIAQ2AhggASACNgIQIARBAUcNAiABKAIwQQFGDQEMAgsCQCADIAJHDQACQCABKAIYIgNBAkcNACABIAQ2AhggBCEDCyABKAIwQQFHDQIgA0EBRg0BDAILIAEgASgCJEEBajYCJAsgAUEBOgA2CwsgAAJAIAIgASgCBEcNACABKAIcQQFGDQAgASADNgIcCwudAgACQCAAIAEoAgggBBChjYCAAEUNACABIAEgAiADEK2NgIAADwsCQAJAIAAgASgCACAEEKGNgIAARQ0AAkACQCACIAEoAhBGDQAgAiABKAIURw0BCyADQQFHDQIgAUEBNgIgDwsgASADNgIgAkAgASgCLEEERg0AIAFBADsBNCAAKAIIIgAgASACIAJBASAEIAAoAgAoAhQRiYCAgACAgICAAAJAIAEtADVBAUcNACABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEYqAgIAAgICAgAALC6QBAAJAIAAgASgCCCAEEKGNgIAARQ0AIAEgASACIAMQrY2AgAAPCwJAIAAgASgCACAEEKGNgIAARQ0AAkACQCACIAEoAhBGDQAgAiABKAIURw0BCyADQQFHDQEgAUEBNgIgDwsgASACNgIUIAEgAzYCICABIAEoAihBAWo2AigCQCABKAIkQQFHDQAgASgCGEECRw0AIAFBAToANgsgAUEENgIsCwtMAAJAIAAgASgCCCAFEKGNgIAARQ0AIAEgASACIAMgBBCsjYCAAA8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBGJgICAAICAgIAACycAAkAgACABKAIIIAUQoY2AgABFDQAgASABIAIgAyAEEKyNgIAACwsEACAACwoAIAAkgICAgAALGgECfyOAgICAACAAa0FwcSIBJICAgIAAIAELCAAjgICAgAALC8uhBQIAQYCABAuxigV+AGhhc093blByb3BlcnR5AGdyb3VwIG5hbWUgaXMgZW1wdHkAaW5maW5pdHkASW5maW5pdHkAaW5kZXggPCBsaXN0LT5jYXBhY2l0eQBuZXh0X2NhcGFjaXR5ID4gbG9jYWxzLT5jYXBhY2l0eQBwYXJzZV9yZXRyeQBmYWlsZWQgdG8gYWxsb2NhdGUgbWVtb3J5AFtwbV9mbG9hdF9ub2RlX3JhdGlvbmFsX2NyZWF0ZV0gRmFpbGVkIHRvIGFsbG9jYXRlIG1lbW9yeQBpbWFnaW5hcnkAbnVtYmVyZWRfcGFyYW1ldGVyX29yZGluYXJ5AGl0X25vdF9hbGxvd2VkX29yZGluYXJ5AGludmFsaWRfbnVtYmVyX2JpbmFyeQBleHBlcmltZW50YWxfY29weQBwbV9ub2RlX2Rlc3Ryb3kAa2FyYXRzdWJhX211bHRpcGx5AHdyaXRlX3RhcmdldF9yZWFkb25seQBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfa2V5AHBhdHRlcm5faGFzaF9rZXkAZHVwbGljYXRlZF9oYXNoX2tleQBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUga2V5AEludmFsaWQgcmV0dXJuIGluIGNsYXNzL21vZHVsZSBib2R5AGNvdWxkIG5vdCBwYXJzZSB0aGUgZW5kbGVzcyBtZXRob2QgYm9keQB1bmV4cGVjdGVkIGNsYXNzIGRlZmluaXRpb24gaW4gbWV0aG9kIGJvZHkAdW5leHBlY3RlZCBtb2R1bGUgZGVmaW5pdGlvbiBpbiBtZXRob2QgYm9keQBhbmFseXplZF9ydWJ5AGV4dHJhY3RSdWJ5AGV4cGVjdGVkIGFuIGVsZW1lbnQgZm9yIHRoZSBhcnJheQBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAqYCBpbiB0aGUgYXJyYXkAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBgXWAgdG8gY2xvc2UgdGhlIGFycmF5AEFycmF5AHBhcnNlX2V4cHJlc3Npb25faW5maXgAcGFyc2VfZXhwcmVzc2lvbl9wcmVmaXgAYW1iaWd1b3VzIGAqYCBoYXMgYmVlbiBpbnRlcnByZXRlZCBhcyBhbiBhcmd1bWVudCBwcmVmaXgAYW1iaWd1b3VzIGAqKmAgaGFzIGJlZW4gaW50ZXJwcmV0ZWQgYXMgYW4gYXJndW1lbnQgcHJlZml4AGFtYmlndW91cyBgJmAgaGFzIGJlZW4gaW50ZXJwcmV0ZWQgYXMgYW4gYXJndW1lbnQgcHJlZml4AHBhcnNlcl9sZXgAZm9yX2luZGV4AGZvciBsb29wIGluZGV4AEludmFsaWQgZXNjYXBlIGNoYXJhY3RlciBzeW50YXgAXHgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABwYXJhbWV0ZXJfbm9fZGVmYXVsdF9rdwBwYXJhbWV0ZXJfdW5leHBlY3RlZF9ub19rdwBcdgAlbGx1AFx1ACV1AHVuZXhwZWN0ZWRfdG9rZW5fY2xvc2VfY29udGV4dAB1bmV4cGVjdGVkIG11bHRpcGxlIGFzc2lnbm1lbnQ7IG11bHRpcGxlIGFzc2lnbm1lbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBjb250ZXh0AHVuZXhwZWN0ZWQgJXM7IHVuYXJ5IGNhbGxzIGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAdG9wIGxldmVsIGNvbnRleHQAcG9zc2libHkgdXNlbGVzcyB1c2Ugb2YgJS4qcyBpbiB2b2lkIGNvbnRleHQAbmV4dAB1bmV4cGVjdGVkICVzLCBleHBlY3RpbmcgZW5kLW9mLWlucHV0AG5vIFJ1Ynkgc2NyaXB0IGZvdW5kIGluIGlucHV0AGVzY2FwZV9pbnZhbGlkX3VuaWNvZGVfbGlzdABleHBlY3RlZCBhIHN0cmluZyBpbiBhIGAld2AgbGlzdABleHBlY3RlZCBhIHN5bWJvbCBpbiBhIGAlaWAgbGlzdABleHBlY3RlZCBhIHN0cmluZyBpbiBhIGAlV2AgbGlzdABleHBlY3RlZCBhIHN5bWJvbCBpbiBhIGAlSWAgbGlzdABwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfcmVzdABwYXJhbWV0ZXJfZm9yd2FyZGluZ19hZnRlcl9yZXN0AHBhcnNlX3BhdHRlcm5fcmVzdABwYXJzZV9wYXR0ZXJuX2tleXdvcmRfcmVzdABtdWx0aV9hc3NpZ25fdW5leHBlY3RlZF9yZXN0AGVzY2FwZV9pbnZhbGlkX3VuaWNvZGVfc2hvcnQAdW5zaWduZWQgc2hvcnQAcG1fY29uc3RhbnRfaWRfbGlzdF9pbnNlcnQAcG1fYnVmZmVyX2luc2VydABwbV9jb25zdGFudF9wb29sX2luc2VydABjb21tZW50X3N0YXJ0AGN1cnNvciA+PSBsaXN0LT5zdGFydABVbmV4cGVjdGVkIEVSQiBzdGFydABlbmQgPj0gc3RhcnQAY2Fubm90X3BhcnNlX3N0cmluZ19wYXJ0AGNhbm5vdCBwYXJzZSB0aGUgc3RyaW5nIHBhcnQAc2NyaXB0AG5vdABwcmludABwbV91dGZfOF9jb2RlcG9pbnQAdW5zaWduZWQgaW50AHN1YnNlcXVlbnQAZXhwZWN0X3N0cmluZ19jb250ZW50AHN0cmluZyBjb250ZW50AGludmFsaWRfZmxvYXRfZXhwb25lbnQAaW52YWxpZCBleHBvbmVudABleHBlY3RfYXJndW1lbnQAYWxpYXNfYXJndW1lbnQAdW5leHBlY3RlZF9ibG9ja19hcmd1bWVudAB1bmRlZl9hcmd1bWVudAAuLi4gYWZ0ZXIgcmVzdCBhcmd1bWVudAB1bmV4cGVjdGVkIGAqYCBzcGxhdCBhcmd1bWVudCBhZnRlciBhIGAqKmAga2V5d29yZCBzcGxhdCBhcmd1bWVudAB1bmV4cGVjdGVkIGAqYCBzcGxhdCBhcmd1bWVudCBhZnRlciBhIGAqYCBzcGxhdCBhcmd1bWVudABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAqYCBzcGxhdCBpbiBhbiBhcmd1bWVudAB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhbiBhcmd1bWVudABpbnZhbGlkIGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBgdW5kZWZgOyBleHBlY3RlZCBhIGJhcmUgd29yZCwgY29uc3RhbnQsIG9yIHN5bWJvbCBhcmd1bWVudAB1bmV4cGVjdGVkIGFyZ3VtZW50IGFmdGVyIGEgYmxvY2sgYXJndW1lbnQAdW5leHBlY3RlZCBiYXJlIGhhc2ggYXJndW1lbnQAaGVyZSBkb2N1bWVudABkeW5hbWljIGNvbnN0YW50IGFzc2lnbm1lbnQAZXhwZWN0ZWQgYSBgKWAgYWZ0ZXIgbXVsdGlwbGUgYXNzaWdubWVudAB1bmV4cGVjdGVkICclLipzJyByZXN1bHRpbmcgaW4gbXVsdGlwbGUgc3BsYXRzIGluIG11bHRpcGxlIGFzc2lnbm1lbnQAdW5leHBlY3RlZCBvcGVyYXRvciBmb3IgYSBtdWx0aXBsZSBhc3NpZ25tZW50AHVuZXhwZWN0ZWQgYHx8PWAgaW4gYSBtdWx0aXBsZSBhc3NpZ25tZW50AHVuZXhwZWN0ZWQgYCYmPWAgaW4gYSBtdWx0aXBsZSBhc3NpZ25tZW50AGludmFsaWRfZW5jb2RpbmdfbWFnaWNfY29tbWVudAB1bmtub3duIG9yIGludmFsaWQgZW5jb2RpbmcgaW4gdGhlIG1hZ2ljIGNvbW1lbnQAZXhwZWN0X2VvbF9hZnRlcl9zdGF0ZW1lbnQAdW5yZWFjaGFibGVfc3RhdGVtZW50AHZvaWRfc3RhdGVtZW50AHVubGVzcyBzdGF0ZW1lbnQAYmVnaW4gc3RhdGVtZW50AHVudGlsIHN0YXRlbWVudABleHBlY3RlZCBhIHByZWRpY2F0ZSBmb3IgYSBjYXNlIG1hdGNoaW5nIHN0YXRlbWVudABpZiBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gZXhjZXB0aW9uIHZhcmlhYmxlIGFmdGVyIGA9PmAgaW4gYSByZXNjdWUgc3RhdGVtZW50AHdoaWxlIHN0YXRlbWVudABleHBlY3RlZCBhIHByZWRpY2F0ZSBleHByZXNzaW9uIGZvciB0aGUgYHVubGVzc2Agc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgY2xhc3NgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgaW5gIGFmdGVyIHRoZSBpbmRleCBpbiBhIGBmb3JgIHN0YXRlbWVudABleHBlY3RlZCBhIGNvbGxlY3Rpb24gYWZ0ZXIgdGhlIGBpbmAgaW4gYSBgZm9yYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGBiZWdpbmAgc3RhdGVtZW50AGV4cGVjdGVkIGEgcHJlZGljYXRlIGV4cHJlc3Npb24gZm9yIHRoZSBgdW50aWxgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYHVudGlsYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmb3IgdGhlIGBlbHNpZmAgc3RhdGVtZW50AGV4cGVjdGVkIGEgcHJlZGljYXRlIGV4cHJlc3Npb24gZm9yIHRoZSBgaWZgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYGRlZmAgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgY2FzZWAgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgbW9kdWxlYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmb3IgdGhlIGB3aGlsZWAgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgd2hpbGVgIHN0YXRlbWVudABleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgYEJFR0lOYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBgfWAgdG8gY2xvc2UgdGhlIGBFTkRgIHN0YXRlbWVudABhcnJheV9lbGVtZW50AGxpc3Rfd19sb3dlcl9lbGVtZW50AGxpc3RfaV9sb3dlcl9lbGVtZW50AGxpc3Rfd191cHBlcl9lbGVtZW50AGxpc3RfaV91cHBlcl9lbGVtZW50AGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gZm9yIHRoZSBhcnJheSBlbGVtZW50AHdhcm5faW5kZW50AGludmFsaWRfcGVyY2VudABwbV9jb25zdGFudF9wb29sX2lkX3RvX2NvbnN0YW50AGNvbnN0YW50X3BhdGhfY29sb25fY29sb25fY29uc3RhbnQAYXJndW1lbnRfZm9ybWFsX2NvbnN0YW50AGludmFsaWQgZm9ybWFsIGFyZ3VtZW50OyBmb3JtYWwgYXJndW1lbnQgY2Fubm90IGJlIGEgY29uc3RhbnQAcGFyYW1ldGVyX25vX2RlZmF1bHQAbGl0ZXJhbF9pbl9jb25kaXRpb25fZGVmYXVsdABFTkQgaW4gbWV0aG9kOyB1c2UgYXRfZXhpdABwYXJzZV9ibG9ja19leGl0AGludmFsaWRfYmxvY2tfZXhpdABwbV9wYXJzZXJfaW5pdABwbV9zdHJpbmdfc2hhcmVkX2luaXQAc3BsaXQAcG1faW50ZWdlcl9wYXJzZV9kaWdpdABwYXR0ZXJuX2hhc2hfaW1wbGljaXQAbnVtYmVyZWRfcGFyYW1ldGVyX2l0AHVuZXhwZWN0ZWQgJXMsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ30nLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICdpbicsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ3doZW4nLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICdlbHNpZicsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ3Jlc2N1ZScsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ2Vsc2UnLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICdlbnN1cmUnLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICdlbmQnLCBpZ25vcmluZyBpdABwbV9wYXJhbWV0ZXJzX25vZGVfa2V5d29yZF9yZXN0X3NldABwbV9wYXJhbWV0ZXJzX25vZGVfYmxvY2tfc2V0AHBtX2Jsb2NrX3BhcmFtZXRlcnNfbm9kZV9jbG9zaW5nX3NldABwbV9zdHJwYnJrX2V4cGxpY2l0X2VuY29kaW5nX3NldABwbV9hcnJheV9ub2RlX2Nsb3NlX3NldABwbV9iZWdpbl9ub2RlX2VuZF9rZXl3b3JkX3NldABpZGVudGlmaWVyICUuKnMgaXMgbm90IHZhbGlkIHRvIHNldABwYXR0ZXJuX2lkZW50X2FmdGVyX2hyb2NrZXQAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX2hyb2NrZXQAaGFzaF9yb2NrZXQAZXhwZWN0X3JicmFja2V0AHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9icmFja2V0AHBhdHRlcm5fdGVybV9icmFja2V0AHVuZXhwZWN0ZWQgd3JpdGUgdGFyZ2V0AGlkZW50aWZpZXIgJS4qcyBpcyBub3QgdmFsaWQgdG8gZ2V0AG9iamVjdABPYmplY3QAZmxvYXQAYXJndW1lbnRfc3BsYXRfYWZ0ZXJfc3BsYXQAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfc3BsYXQAYXJndW1lbnRfc3BsYXRfYWZ0ZXJfYXNzb2Nfc3BsYXQAZXNjYXBlX2ludmFsaWRfY29udHJvbF9yZXBlYXQAZXNjYXBlX2ludmFsaWRfbWV0YV9yZXBlYXQAVW5rbm93biBwbV9lcnJvcl9sZXZlbF90AFx0AGFtYmlndW91c19maXJzdF9hcmd1bWVudF9taW51cwBhbWJpZ3VvdXNfZmlyc3RfYXJndW1lbnRfcGx1cwBwYXR0ZXJuX2FycmF5X211bHRpcGxlX3Jlc3RzAG9wZXJhdG9yX3dyaXRlX2FyZ3VtZW50cwB1bmV4cGVjdGVkIG9wZXJhdG9yIGFmdGVyIGEgY2FsbCB3aXRoIGFyZ3VtZW50cwB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIGApYCB0byBjbG9zZSB0aGUgYXJndW1lbnRzAHN0YXRlbWVudHMAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBgLGAgc2VwYXJhdG9yIGZvciB0aGUgYXJyYXkgZWxlbWVudHMAcG1fbG9vcF9tb2RpZmllcl9ibG9ja19leGl0cwBmbHVzaF9ibG9ja19leGl0cwBpbnZhbGlkIGJpbmFyeSBudW1iZXI7IG51bWVyaWMgbGl0ZXJhbCB3aXRob3V0IGRpZ2l0cwBpbnZhbGlkIG9jdGFsIG51bWJlcjsgbnVtZXJpYyBsaXRlcmFsIHdpdGhvdXQgZGlnaXRzAGludmFsaWQgaGV4YWRlY2ltYWwgbnVtYmVyOyBudW1lcmljIGxpdGVyYWwgd2l0aG91dCBkaWdpdHMAaW52YWxpZCBkZWNpbWFsIG51bWJlcjsgbnVtZXJpYyBsaXRlcmFsIHdpdGhvdXQgZGlnaXRzAGludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2U7IG1heGltdW0gbGVuZ3RoIGlzIDYgZGlnaXRzAG11bHRpcGxlIHRhcmdldHMAbXVsdGlfYXNzaWduX211bHRpX3NwbGF0cwB1bmxlc3MAdW5leHBlY3RlZCBgZWxzZWAgaW4gYGJlZ2luYCBibG9jazsgZWxzZSB3aXRob3V0IHJlc2N1ZSBpcyB1c2VsZXNzAGRlZl9lbmRsZXNzAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX2xlc3NfbGVzcwBjbGFzc19zdXBlcmNsYXNzAGFyZ3VtZW50X2Zvcm1hbF9jbGFzcwBpbmNvbXBsZXRlX3ZhcmlhYmxlX2NsYXNzAGVtcHR5IGNoYXItY2xhc3MAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBuZXdsaW5lIG9yIGEgJzsnIGFmdGVyIHRoZSBzaW5nbGV0b24gY2xhc3MAZXJyb3JzAHBhcnNlX2Jsb2NrbGlrZV9wYXJhbWV0ZXJzAHVuZXhwZWN0ZWQgbXVsdGlwbGUgYCpgIHNwbGF0IHBhcmFtZXRlcnMAdW5leHBlY3RlZCBtdWx0aXBsZSBgKipgIHNwbGF0IHBhcmFtZXRlcnMAdW5leHBlY3RlZCBgLi4uYCBpbiBwYXJhbWV0ZXJzAHVuZXhwZWN0ZWQgYCxgIGluIHBhcmFtZXRlcnMAZXhwZWN0ZWQgYSBsb2NhbCB2YXJpYWJsZSBuYW1lIGluIHRoZSBibG9jayBwYXJhbWV0ZXJzAGV4cGVjdGVkIGEgZGVsaW1pdGVyIHRvIGNsb3NlIHRoZSBwYXJhbWV0ZXJzAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgYClgIHRvIGNsb3NlIHRoZSBwYXJhbWV0ZXJzAG1ldGhvZCBwYXJhbWV0ZXJzACUuMnMgaXMgcmVzZXJ2ZWQgZm9yIG51bWJlcmVkIHBhcmFtZXRlcnMAcmVnZXhwX3Vua25vd25fb3B0aW9ucwBjYXNlX21pc3NpbmdfY29uZGl0aW9ucwBMZXhlciBzdGFsbGVkIGFmdGVyIDUgaXRlcmF0aW9ucwB1bmV4cGVjdGVkIGJsb2NrIGFyZyBnaXZlbiBpbiBpbmRleCBhc3NpZ25tZW50OyBibG9ja3MgYXJlIG5vdCBhbGxvd2VkIGluIGluZGV4IGFzc2lnbm1lbnQgZXhwcmVzc2lvbnMAdW5leHBlY3RlZCBrZXl3b3JkIGFyZyBnaXZlbiBpbiBpbmRleCBhc3NpZ25tZW50OyBrZXl3b3JkcyBhcmUgbm90IGFsbG93ZWQgaW4gaW5kZXggYXNzaWdubWVudCBleHByZXNzaW9ucwAnZnJvemVuX3N0cmluZ19saXRlcmFsJyBpcyBpZ25vcmVkIGFmdGVyIGFueSB0b2tlbnMAc2hlYmFuZyBsaW5lIGVuZGluZyB3aXRoIFxyIG1heSBjYXVzZSBwcm9ibGVtcwBldWMtanAtbXMAZXVjSlAtbXMAZXF1YWxzAHNpbmdsZXRvbl9mb3JfbGl0ZXJhbHMAY2Fubm90IGRlZmluZSBzaW5nbGV0b24gbWV0aG9kIGZvciBsaXRlcmFscwBwYXR0ZXJuX2hhc2hfa2V5X2xvY2FscwB1bmV4cGVjdGVkICd7JyBhZnRlciBhIG1ldGhvZCBjYWxsIHdpdGhvdXQgcGFyZW50aGVzaXMAdW5tYXRjaGVkIGNsb3NlIHBhcmVudGhlc2lzAGVuZCBwYXR0ZXJuIHdpdGggdW5tYXRjaGVkIHBhcmVudGhlc2lzAHBhcnNlX3N0cmluZ3MAd2FybmluZ3MAZXNjYXBlX2ludmFsaWRfdW5pY29kZV9jbV9mbGFncwBpbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOyBVbmljb2RlIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGNvbnRyb2wgb3IgbWV0YSBmbGFncwBwYXJzZV9yZXNjdWVzAGFyZ3VtZW50X2FmdGVyX2ZvcndhcmRpbmdfZWxsaXBzZXMAYXJndW1lbnRfbm9fZm9yd2FyZGluZ19lbGxpcHNlcwBwYXJlbnRoZXNlcwBpbnZhbGlkIGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBgYWxpYXNgOyBjYW4ndCBtYWtlIGFsaWFzIGZvciB0aGUgbnVtYmVyIHZhcmlhYmxlcwBrZXkgbXVzdCBiZSB2YWxpZCBhcyBsb2NhbCB2YXJpYWJsZXMAcG1fY29tcGFyZV9udW1iZXJfbm9kZXMAdW5leHBlY3RlZF9pbmRleF9rZXl3b3JkcwB1bmV4cGVjdGVkICoqbmlsOyBubyBrZXl3b3JkcyBtYXJrZXIgZGlzYWxsb3dlZCBhZnRlciBrZXl3b3JkcwBwbV9sb2NhbHNfcmVhZHMAcGFyc2VfYXNzb2NzAHN0YXRlbWVudF9hbGlhcwBccwBDYW4ndCBhc3NpZ24gdG8gbnVtYmVyZWQgcGFyYW1ldGVyICUuMnMAQ2FuJ3Qgc2V0IHZhcmlhYmxlICUuKnMAaW52YWxpZCBVbmljb2RlIGxpc3Q6ICUuKnMAaW52YWxpZCB2YWx1ZSBmb3IgJS4qczogJS4qcwB0b28gc2hvcnQgZXNjYXBlIHNlcXVlbmNlOiAlLipzAHVua25vd24gcmVnZXhwICVzIC0gJS4qcwBhc3NpZ25lZCBidXQgdW51c2VkIHZhcmlhYmxlIC0gJS4qcwBjaXJjdWxhciBhcmd1bWVudCByZWZlcmVuY2UgLSAlLipzAGludmFsaWQgY2hhcmFjdGVyIHN5bnRheDsgdXNlICVzJXMlcwB1bmV4cGVjdGVkICVzLCBhc3N1bWluZyBpdCBpcyBjbG9zaW5nIHRoZSBwYXJlbnQgJXMAJXNsaXRlcmFsIGluICVzACclcycgYWZ0ZXIgbG9jYWwgdmFyaWFibGUgb3IgbGl0ZXJhbCBpcyBpbnRlcnByZXRlZCBhcyBiaW5hcnkgb3BlcmF0b3IgZXZlbiB0aG91Z2ggaXQgc2VlbXMgbGlrZSAlcwBJbnZhbGlkICVzACVzOiAlcwAlczolZDogJXMAKmJyZWFrcG9pbnQgPT0gbGV4X21vZGUtPmFzLmxpc3QuaW5jcmVtZW50b3IAYW1iaWd1b3VzX2JpbmFyeV9vcGVyYXRvcgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9vcGVyYXRvcgBub25fYXNzb2NpYXRpdmVfb3BlcmF0b3IAdW5leHBlY3RlZF9yYW5nZV9vcGVyYXRvcgB1bmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA/YCBpbiB0aGUgdGVybmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA6YCBpbiB0aGUgdGVybmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhIGA6YCBhZnRlciB0aGUgdHJ1ZSBleHByZXNzaW9uIG9mIGEgdGVybmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYF5gIHBpbiBvcGVyYXRvcgB1bmV4cGVjdGVkICVzOyAlcyBpcyBhIG5vbi1hc3NvY2lhdGl2ZSBvcGVyYXRvcgB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIHRoZSBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgcmFuZ2Ugb3BlcmF0b3IAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGB8YCBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYFtgIG9wZXJhdG9yAGV4cGVjdGVkIGFuIGlkZW50aWZpZXIgYWZ0ZXIgdGhlIGA9PmAgb3BlcmF0b3IAZXhwZWN0ZWQgYSBjb25zdGFudCBhZnRlciB0aGUgYDo6YCBvcGVyYXRvcgBhbWJpZ3VvdXMgYC9gOyB3cmFwIHJlZ2V4cCBpbiBwYXJlbnRoZXNlcyBvciBhZGQgYSBzcGFjZSBhZnRlciBgL2Agb3BlcmF0b3IAYW1iaWd1b3VzIGZpcnN0IGFyZ3VtZW50OyBwdXQgcGFyZW50aGVzZXMgb3IgYSBzcGFjZSBldmVuIGFmdGVyIGAtYCBvcGVyYXRvcgBhbWJpZ3VvdXMgZmlyc3QgYXJndW1lbnQ7IHB1dCBwYXJlbnRoZXNlcyBvciBhIHNwYWNlIGV2ZW4gYWZ0ZXIgYCtgIG9wZXJhdG9yAGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIHRoZSBgKGAgb3BlcmF0b3IAYXJyYXlfc2VwYXJhdG9yAHN0cmluZyBzZXBhcmF0b3IAbGFiZWwgdGVybWluYXRvcgB1bmV4cGVjdGVkICVzLCBleHBlY3RlZCBhIHN0cmluZyBsaXRlcmFsIHRlcm1pbmF0b3IAcmVnZXhwX3BhcnNlX2Vycm9yAFRva2VuIEVycm9yAGZvcgBocgBwYXJzZSBkZXB0aCBsaW1pdCBvdmVyAHVuYXJ5X3JlY2VpdmVyAGRlZl9yZWNlaXZlcgB1bmV4cGVjdGVkICVzOyBleHBlY3RpbmcgYSBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIHJlY2VpdmVyAGRlZl9lbmRsZXNzX3NldHRlcgBleHBlY3Rfc2luZ2xldG9uX2NsYXNzX2RlbGltaXRlcgBleHBlY3RfZm9yX2RlbGltaXRlcgBleHBlY3RfaW5fZGVsaW1pdGVyAGV4cGVjdF93aGVuX2RlbGltaXRlcgB1bnRlcm1pbmF0ZWQgcmVnZXhwIG1lZXRzIGVuZCBvZiBmaWxlOyBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyAGV4cGVjdGVkIHN0cmluZyBjb250ZW50IGFmdGVyIG9wZW5pbmcgc3RyaW5nIGRlbGltaXRlcgBleHBlY3RfaWRlbnRfcmVxX3BhcmFtZXRlcgBleHBlY3RfcnBhcmVuX3JlcV9wYXJhbWV0ZXIAZXhwZWN0X2xwYXJlbl9yZXFfcGFyYW1ldGVyAHBtX25vZGVfZmxhZ19zZXRfcmVwZWF0ZWRfcGFyYW1ldGVyAHVuZXhwZWN0ZWQgYCpgOyBubyBhbm9ueW1vdXMgcmVzdCBwYXJhbWV0ZXIAdW5leHBlY3RlZCBgKipgOyBubyBhbm9ueW1vdXMga2V5d29yZCByZXN0IHBhcmFtZXRlcgB1bmV4cGVjdGVkIGAmYDsgbm8gYW5vbnltb3VzIGJsb2NrIHBhcmFtZXRlcgBleHBlY3RlZCBhIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXIAZXhwZWN0ZWQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUga2V5d29yZCBwYXJhbWV0ZXIAZXhwZWN0ZWQgYW4gaWRlbnRpZmllciBmb3IgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcgBleHBlY3RlZCBhIGAoYCB0byBzdGFydCBhIHJlcXVpcmVkIHBhcmFtZXRlcgBleHBlY3RlZCBhIGApYCB0byBlbmQgYSByZXF1aXJlZCBwYXJhbWV0ZXIAdW5leHBlY3RlZCBuYW1lIGZvciBhIHBhcmFtZXRlcgBpbnZhbGlkX211bHRpYnl0ZV9jaGFyYWN0ZXIAaW52YWxpZF9lc2NhcGVfY2hhcmFjdGVyAGludmFsaWRfcHJpbnRhYmxlX2NoYXJhY3RlcgBpbnZhbGlkX2NoYXJhY3RlcgBzdXBlcgBwYXR0ZXJuX2ZpbmRfbWlzc2luZ19pbm5lcgBpbnZhbGlkX251bWJlcl91bmRlcnNjb3JlX2lubmVyAGhlcmVkb2NfaWRlbnRpZmllcgB1bnRlcm1pbmF0ZWQgaGVyZSBkb2N1bWVudCBpZGVudGlmaWVyAHBhcnNlX2FuZF92YWxpZGF0ZV9yZWd1bGFyX2V4cHJlc3Npb25fZW5jb2RpbmdfbW9kaWZpZXIAZXhwZWN0ZWQgYSB2YWx1ZSBhZnRlciB0aGUgYHJlc2N1ZWAgbW9kaWZpZXIAJ3Jlc2N1ZScgbW9kaWZpZXIAaW50ZWdlcgBwYXJhbWV0ZXJfb3JkZXIAdW5leHBlY3RlZCBwYXJhbWV0ZXIgb3JkZXIAcG1fbnVtYmVyZWRfcmVmZXJlbmNlX3JlYWRfbm9kZV9udW1iZXIAaW52YWxpZCB1bmRlcnNjb3JlIHBsYWNlbWVudCBpbiBudW1iZXIAdHJhaWxpbmcgJ18nIGluIG51bWJlcgB3YnIAYXJndW1lbnRfZm9ybWFsX2l2YXIAYW1iaWd1b3VzX3ByZWZpeF9zdGFyAGFyZ3VtZW50X2NvbmZsaWN0X3N0YXIAYXJyYXlfZXhwcmVzc2lvbl9hZnRlcl9zdGFyAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX3N0YXIAcGFyYW1ldGVyX3N0YXIAYW1iaWd1b3VzX3ByZWZpeF9zdGFyX3N0YXIAYXJndW1lbnRfY29uZmxpY3Rfc3Rhcl9zdGFyAGFyZ3VtZW50X25vX2ZvcndhcmRpbmdfc3Rhcl9zdGFyAGFyZ3VtZW50X25vX2ZvcndhcmRpbmdfc3RhcgBwYXJhbWV0ZXJfY2lyY3VsYXIAaW52YWxpZF9tdWx0aWJ5dGVfY2hhcgB1bnNpZ25lZCBjaGFyAFxyAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX2FtcGFtcGVxAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX3BpcGVwaXBlZXEAcmVnZXhwX3V0ZjhfY2hhcl9ub25fdXRmOF9yZWdleHAAZW5kIHBhdHRlcm4gaW4gZ3JvdXAAL2Vtc2RrL2Vtc2NyaXB0ZW4vc3lzdGVtL2xpYi9saWJjeHhhYmkvc3JjL3ByaXZhdGVfdHlwZWluZm8uY3BwAGZvciBsb29wAGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgZm9yYCBsb29wAGludGVnZXJfaW5fZmxpcF9mbG9wAGludGVnZXIgbGl0ZXJhbCBpbiBmbGlwLWZsb3AAY2hvbXAAbmVzdGluZ190b29fZGVlcABuZXN0aW5nIHRvbyBkZWVwAHRva2VuX2JlZ2luc19leHByZXNzaW9uX3AAcG1fcGFyc2VyX3Njb3BlX3RvcGxldmVsX3AAcG1fc3RhdGljX2xpdGVyYWxfcG9zaXRpdmVfcABtYWNDZW50RXVybwByZWRvAFNKSVMtRG9Db01vAFVURjgtRG9Db01vAHBhcnNlX3JldHVybgBzaGViYW5nX2NhcnJpYWdlX3JldHVybgB1bmV4cGVjdGVkX2NhcnJpYWdlX3JldHVybgBlc2NhcGVkIGNhcnJpYWdlIHJldHVybgB1bmV4cGVjdGVkIG11bHRpcGxlICcqJyByZXN0IHBhdHRlcm5zIGluIGFuIGFycmF5IHBhdHRlcm4AdW5leHBlY3RlZCByZXN0IHBhdHRlcm4AZmluZCBwYXR0ZXJucyBuZWVkIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBpbm5lciBwYXR0ZXJuAGV4cGVjdGVkIGEgbGFiZWwgYXMgdGhlIGtleSBpbiB0aGUgaGFzaCBwYXR0ZXJuAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEga2V5IGluIHRoZSBoYXNoIHBhdHRlcm4AZXhwZWN0ZWQgYSBsYWJlbCBhZnRlciB0aGUgYCxgIGluIHRoZSBoYXNoIHBhdHRlcm4AY29tcGFyaXNvbl9hZnRlcl9jb21wYXJpc29uAGNvbXBhcmlzb24gJyUuKnMnIGFmdGVyIGNvbXBhcmlzb24AdGVybmFyeV9jb2xvbgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9xdWVzdGlvbgB1bmRlZmluZWQgZ3JvdXAgb3B0aW9uAGRlc2NyaXB0aW9uAHVuZXhwZWN0ZWQgYW4gYGFsaWFzYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24AdW5leHBlY3RlZCBhbiBgdW5kZWZgIGF0IGEgbm9uLXN0YXRlbWVudCBwb3NpdGlvbgB1bmV4cGVjdGVkIGEgYEJFR0lOYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24AdW5leHBlY3RlZCBhbiBgRU5EYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24Ac2luZ2xldG9uIGNsYXNzIGRlZmluaXRpb24AbW9kdWxlIGRlZmluaXRpb24AaW52YWxpZCBtZXRob2QgbmFtZTsgYSBzZXR0ZXIgbWV0aG9kIGNhbm5vdCBiZSBkZWZpbmVkIGluIGFuIGVuZGxlc3MgbWV0aG9kIGRlZmluaXRpb24AZXhwZWN0ZWQgYSByZWNlaXZlciBmb3IgdGhlIG1ldGhvZCBkZWZpbml0aW9uAGV4cGVjdGVkIGEgYC5gIG9yIGA6OmAgYWZ0ZXIgdGhlIHJlY2VpdmVyIGluIGEgbWV0aG9kIGRlZmluaXRpb24AY29uZGl0aW9uAGZvcl9jb2xsZWN0aW9uAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgJ2RvJywgbmV3bGluZSwgb3IgJzsnIGFmdGVyIHRoZSAnZm9yJyBsb29wIGNvbGxlY3Rpb24AaW52YWxpZF9udW1iZXJfZnJhY3Rpb24AJi4gaW5zaWRlIG11bHRpcGxlIGFzc2lnbm1lbnQgZGVzdGluYXRpb24Ac3RyaW5nX2NvbmNhdGVuYXRpb24AZXhwZWN0ZWQgYSBzdHJpbmcgZm9yIGNvbmNhdGVuYXRpb24AdW5leHBlY3RlZF9zYWZlX25hdmlnYXRpb24AbG9jYXRpb24AYXJyYXlfZXhwcmVzc2lvbgBub3RfZXhwcmVzc2lvbgByZXNjdWVfZXhwcmVzc2lvbgBjYW5ub3RfcGFyc2VfZXhwcmVzc2lvbgB2b2lkX2V4cHJlc3Npb24AZGVmaW5lZF9leHByZXNzaW9uAHRlcm5hcnkgZXhwcmVzc2lvbgBleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgcGF0dGVybiBleHByZXNzaW9uAGV4cGVjdGVkIGEgYF1gIHRvIGNsb3NlIHRoZSBwYXR0ZXJuIGV4cHJlc3Npb24AZXhwZWN0ZWQgYSBgKWAgdG8gY2xvc2UgdGhlIHBhdHRlcm4gZXhwcmVzc2lvbgB1bmV4cGVjdGVkIGJhcmUgaGFzaCBpbiBleHByZXNzaW9uAEludmFsaWQgY2hhciAnXHglMDJYJyBpbiBleHByZXNzaW9uAGAlLipzYCBhdCB0aGUgZW5kIG9mIGxpbmUgd2l0aG91dCBhbiBleHByZXNzaW9uAHVuZXhwZWN0ZWQgdm9pZCB2YWx1ZSBleHByZXNzaW9uAGNhbm5vdCBwYXJzZSB0aGUgZXhwcmVzc2lvbgBleHBlY3RlZCBhIHJlc2N1ZWQgZXhwcmVzc2lvbgBleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgZW1iZWRkZWQgZXhwcmVzc2lvbgB1bmV4cGVjdGVkIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYCoqYCBleHByZXNzaW9uACdkZWZpbmVkPycgZXhwcmVzc2lvbgB2ZXJzaW9uAHBtX25ld2xpbmVfbGlzdF9saW5lX2NvbHVtbgBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfcGluAHN0YXRlbWVudF9wcmVleGVfYmVnaW4AZm9yX2luAHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9pbgBvcGVyYXRvcl9tdWx0aV9hc3NpZ24AYW1wYW1wZXFfbXVsdGlfYXNzaWduAHBpcGVwaXBlZXFfbXVsdGlfYXNzaWduAGJsb2NrIGFyZ3VtZW50IHNob3VsZCBub3QgYmUgZ2l2ZW4AdW5leHBlY3RlZCAnPSc7IHRhcmdldCBjYW5ub3QgYmUgd3JpdHRlbgBjaGlsZHJlbgBleHBlY3RfcnBhcmVuAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX2xwYXJlbgBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfcGFyZW4AYXJndW1lbnRfdGVybV9wYXJlbgBkZWZfcGFyYW1zX3Rlcm1fcGFyZW4AcGF0dGVybl90ZXJtX3BhcmVuAGxhbWJkYV9vcGVuAG1pc3NpbmcgdG9rZW4AVW5leHBlY3RlZCB0b2tlbgBub3QgcHJvdmlkZWQgdG9rZW4AVW5leHBlY3RlZCBUb2tlbgBjYXNlX2V4cHJlc3Npb25fYWZ0ZXJfd2hlbgB0aGVuAE1hY0phcGFuAG5hbgBjb250ZXh0X2h1bWFuAHBtX3Rva2VuX3R5cGVfaHVtYW4AcG1fZGlhZ25vc3RpY19pZF9odW1hbgBtYWNSb21hbgBtYWNDcm9hdGlhbgBcbgBhcnJheV90ZXJtAGNsYXNzX3Rlcm0AZGVmX3BhcmFtc190ZXJtAGZvcl90ZXJtAGxpc3Rfd19sb3dlcl90ZXJtAGxpc3RfaV9sb3dlcl90ZXJtAGRlZl9yZWNlaXZlcl90ZXJtAGxpc3Rfd191cHBlcl90ZXJtAGxpc3RfaV91cHBlcl90ZXJtAHJlZ2V4cF90ZXJtAGJlZ2luX3Rlcm0AdW50aWxfdGVybQBzdHJpbmdfbGl0ZXJhbF90ZXJtAGNvbmRpdGlvbmFsX3Rlcm0AaGFzaF90ZXJtAHhzdHJpbmdfdGVybQBkZWZfdGVybQByZXNjdWVfdGVybQBjb25kaXRpb25hbF9wcmVkaWNhdGVfdGVybQBiZWdpbl91cGNhc2VfdGVybQBlbmRfdXBjYXNlX3Rlcm0AYmxvY2tfcGFyYW1fcGlwZV90ZXJtAG1vZHVsZV90ZXJtAHdoaWxlX3Rlcm0AZXNjYXBlX2ludmFsaWRfdW5pY29kZV90ZXJtAHN0cmluZ19pbnRlcnBvbGF0ZWRfdGVybQBoZXJlZG9jX3Rlcm0AZW1iZG9jX3Rlcm0AcGFyc2VfcHJvZ3JhbQBwYXJhbQBlc2NhcGVfaW52YWxpZF9jb250cm9sAGJvb2wAZG90X2RvdF9kb3RfZW9sAGtleXdvcmRfZW9sAGNvbABpbnZhbGlkX3N5bWJvbABpbnZhbGlkIHN5bWJvbAB1bnRlcm1pbmF0ZWQgc3ltYm9sOyBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyIGZvciB0aGUgaW50ZXJwb2xhdGVkIHN5bWJvbAB1bnRlcm1pbmF0ZWQgcXVvdGVkIHN0cmluZzsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGR5bmFtaWMgc3ltYm9sADw/eG1sAHVuZXhwZWN0ZWQgYC4uLmAgaW4gYW4gbm9uLXBhcmVudGhlc2l6ZWQgY2FsbAB1bnRpbABleHByZXNzaW9uX25vdF93cml0YWJsZV9uaWwAJyUuKnMnIGlzIHRvbyBiaWcgZm9yIGEgbnVtYmVyIHZhcmlhYmxlLCBhbHdheXMgbmlsAENhbid0IGFzc2lnbiB0byBuaWwAYmVnaW5fdXBjYXNlX3RvcGxldmVsAEJFR0lOIGlzIHBlcm1pdHRlZCBvbmx5IGF0IHRvcGxldmVsAHBtX2RpYWdub3N0aWNfbGV2ZWwAcGF0dGVybl9oYXNoX2tleV9sYWJlbABoYXNoX2V4cHJlc3Npb25fYWZ0ZXJfbGFiZWwAdW5leHBlY3RlZF9sYWJlbAB1bmV4cGVjdGVkIGxhYmVsAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX2VxdWFsAGludmFsaWRfbnVtYmVyX29jdGFsAGlnbm9yZWRfZnJvemVuX3N0cmluZ19saXRlcmFsAGVzY2FwZV9pbnZhbGlkX3VuaWNvZGVfbGl0ZXJhbABjaGFyYWN0ZXIgbGl0ZXJhbAByZWdleHAgbGl0ZXJhbABzeW1ib2wgbGl0ZXJhbAB1bmV4cGVjdGVkICVzLCBleHBlY3RpbmcgJ30nIG9yIGEga2V5IGluIHRoZSBoYXNoIGxpdGVyYWwAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSB2YWx1ZSBpbiB0aGUgaGFzaCBsaXRlcmFsAGV4cGVjdGVkIGEgYH1gIHRvIGNsb3NlIHRoZSBoYXNoIGxpdGVyYWwAc3RyaW5nIGxpdGVyYWwAdW5leHBlY3RlZCBmcmFjdGlvbiBwYXJ0IGFmdGVyIG51bWVyaWMgbGl0ZXJhbABhIGxpdGVyYWwAZXF1YWxfaW5fY29uZGl0aW9uYWwAcGFyc2VfY29uZGl0aW9uYWwAcmF0aW9uYWwAaW52YWxpZF9udW1iZXJfaGV4YWRlY2ltYWwAZXNjYXBlX2ludmFsaWRfaGV4YWRlY2ltYWwAaW52YWxpZF9udW1iZXJfZGVjaW1hbABhcmd1bWVudF9mb3JtYWxfZ2xvYmFsAGludmFsaWRfdmFyaWFibGVfZ2xvYmFsAGluY29tcGxldGVfcXVlc3Rpb25fbWFyawBsaW5rAFNKSVMtU29mdEJhbmsAVVRGOC1Tb2Z0QmFuawBtYWNHcmVlawB1bmV4cGVjdGVkX2luZGV4X2Jsb2NrAG51bWJlcmVkX3BhcmFtZXRlcl9vdXRlcl9ibG9jawBhcmd1bWVudF9hZnRlcl9ibG9jawBudW1iZXJlZF9wYXJhbWV0ZXJfaW5uZXJfYmxvY2sAb3BlcmF0b3Jfd3JpdGVfYmxvY2sAcGFyc2VfYmxvY2sAYXJndW1lbnRfdW5leHBlY3RlZF9ibG9jawBudW1iZXJlZCBwYXJhbWV0ZXIgaXMgYWxyZWFkeSB1c2VkIGluIG91dGVyIGJsb2NrAG51bWJlcmVkIHBhcmFtZXRlciBpcyBhbHJlYWR5IHVzZWQgaW4gaW5uZXIgYmxvY2sAdW5leHBlY3RlZCBgKmA7IGFub255bW91cyByZXN0IHBhcmFtZXRlciBpcyBhbHNvIHVzZWQgd2l0aGluIGJsb2NrAHVuZXhwZWN0ZWQgYCoqYDsgYW5vbnltb3VzIGtleXdvcmQgcmVzdCBwYXJhbWV0ZXIgaXMgYWxzbyB1c2VkIHdpdGhpbiBibG9jawB1bmV4cGVjdGVkIGAmYDsgYW5vbnltb3VzIGJsb2NrIHBhcmFtZXRlciBpcyBhbHNvIHVzZWQgd2l0aGluIGJsb2NrAGV4cGVjdGVkIGEgYGRvYCBrZXl3b3JkIG9yIGEgYHtgIHRvIG9wZW4gdGhlIGxhbWJkYSBibG9jawAneycuLid9JyBsYW1iZGEgYmxvY2sAJ2RvJy4uJ2VuZCcgbGFtYmRhIGJsb2NrAHVuZXhwZWN0ZWQgb3BlcmF0b3IgYWZ0ZXIgYSBjYWxsIHdpdGggYSBibG9jawAneycuLid9JyBibG9jawAnZG8nLi4nZW5kJyBibG9jawAnQkVHSU4nIGJsb2NrACdFTkQnIGJsb2NrAHBtX3ZvaWRfc3RhdGVtZW50c19jaGVjawB0cmFjawBicmVhawBwYXJhbWV0ZXJfc3BsYXRfbXVsdGkAcGFyYW1ldGVyX2Fzc29jX3NwbGF0X211bHRpAGV4cGVjdF9ycGFyZW5fYWZ0ZXJfbXVsdGkAYXJndW1lbnRfYmxvY2tfbXVsdGkAcGFyYW1ldGVyX2Jsb2NrX211bHRpAG1hY1RoYWkAbWlzbWF0Y2hlZCBpbmRlbnRhdGlvbnMgYXQgJyUuKnMnIHdpdGggJyUuKnMnIGF0ICVpAGtleSAlLipzIGlzIGR1cGxpY2F0ZWQgYW5kIG92ZXJ3cml0dGVuIG9uIGxpbmUgJWkAaW5kZXggPD0gYnVmZmVyLT5sZW5ndGgAcG1fZW5jb2RpbmdfdXRmXzhfY2hhcl93aWR0aABwdXNoAG1hY1R1cmtpc2gAYmFja3NsYXNoAGFtYmlndW91c19zbGFzaABleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9zcGxhdF9oYXNoAGFyZ3VtZW50X2JhcmVfaGFzaABleHByZXNzaW9uX2JhcmVfaGFzaABub2RlX2hhc2gAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciB0aGUgbGFiZWwgaW4gYSBoYXNoAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCoqYCBpbiBhIGhhc2gAcmVnZXhwX2VuY29kaW5nX29wdGlvbl9taXNtYXRjaABpbmRlbnRhdGlvbl9taXNtYXRjaABzdmcAZXNjYXBlX2ludmFsaWRfdW5pY29kZV9sb25nAHVuc2lnbmVkIGxvbmcgbG9uZwB1bnNpZ25lZCBsb25nAHRhZ19jbG9zaW5nAHN0ZDo6d3N0cmluZwBiYXNpY19zdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAdW5rbm93biB0eXBlIG9mICVzdHJpbmcAZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGAleGAgb3IgYmFja3RpY2sgc3RyaW5nAHVudGVybWluYXRlZCBzdHJpbmc7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBpbnRlcnBvbGF0ZWQgc3RyaW5nAHJlZ3VsYXIgZXhwcmVzc2lvbiBiZWdpbm5pbmcAaGVyZWRvYyBiZWdpbm5pbmcAdGFnX29wZW5pbmcAaW52YWxpZF9udW1iZXJfdW5kZXJzY29yZV90cmFpbGluZwBleHBlcmltZW50YWxfZXZlcnl0aGluZwBhcmd1bWVudF9ibG9ja19mb3J3YXJkaW5nAHVuZXhwZWN0ZWQgLi4uIHdoZW4gdGhlIHBhcmVudCBtZXRob2QgaXMgbm90IGZvcndhcmRpbmcAcmVnZXhwX2luY29tcGF0X2NoYXJfZW5jb2RpbmcAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfZW5jb2RpbmcAbWl4ZWRfZW5jb2RpbmcAcmVndWxhciBleHByZXNzaW9uIGVuZGluZwBzdHJpbmcgZW5kaW5nAGhlcmVkb2MgZW5kaW5nAGltZwBvcGVuX3RhZwBjbG9zaW5nX3RhZwBvcGVuaW5nX3RhZwBjbG9zZV90YWcASFRNTE9wZW5UYWcgb3IgSFRNTFNlbGZDbG9zZVRhZwAlZwBpbnZhbGlkX3BlcmNlbnRfZW9mAHN0cmluZ19saXRlcmFsX2VvZgBpbmYAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfc2VsZgBDYW4ndCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHNlbGYAZWxzaWYAc3RhdGVtZW50X3VuZGVmAFxmAHBtX2xvY2Fsc19yZXNpemUAcG1fY29uc3RhbnRfcG9vbF9yZXNpemUAY29uc3RhbnRfaWQgIT0gUE1fQ09OU1RBTlRfSURfVU5TRVQgJiYgY29uc3RhbnRfaWQgPD0gcG9vbC0+c2l6ZQB0ZXJuYXJ5X2V4cHJlc3Npb25fdHJ1ZQBleHByZXNzaW9uX25vdF93cml0YWJsZV90cnVlAENhbid0IGFzc2lnbiB0byB0cnVlAGludmFsaWRfbWFnaWNfY29tbWVudF92YWx1ZQBzaGFyZWFibGVfY29uc3RhbnRfdmFsdWUAcmVzY3VlX21vZGlmaWVyX3ZhbHVlAGhhc2hfdmFsdWUAcG1fc3RyaW5nX3ZhbHVlAHBtX2ludDY0X3ZhbHVlAHBhcmFtZXRlciBkZWZhdWx0IHZhbHVlAFVuZXNjYXBlZCBxdW90ZSBjaGFyYWN0ZXIgaW4gYXR0cmlidXRlIHZhbHVlAGV4cGVjdGVkIGEgYD0+YCBiZXR3ZWVuIHRoZSBoYXNoIGtleSBhbmQgdmFsdWUAaW52YWxpZF9yZXRyeV93aXRob3V0X3Jlc2N1ZQBJbnZhbGlkIHJldHJ5IHdpdGhvdXQgcmVzY3VlAEludmFsaWQgcXVvdGUgY2hhcmFjdGVyIGZvciBIVE1MIGF0dHJpYnV0ZQBvcGVuX3F1b3RlAGNsb3NpbmdfcXVvdGUAb3BlbmluZ19xdW90ZQBjbG9zZV9xdW90ZQBwbV9sb2NhbHNfd3JpdGUAdW5leHBlY3RlZF9tdWx0aV93cml0ZQBpbnZhbGlkX2xvY2FsX3ZhcmlhYmxlX3dyaXRlAHBtX2Zsb2F0X25vZGVfcmF0aW9uYWxfaW1hZ2luYXJ5X2NyZWF0ZQBwbV9pbnRlZ2VyX25vZGVfcmF0aW9uYWxfaW1hZ2luYXJ5X2NyZWF0ZQBwbV9mbG9hdF9ub2RlX2ltYWdpbmFyeV9jcmVhdGUAcG1faW50ZWdlcl9ub2RlX2ltYWdpbmFyeV9jcmVhdGUAcG1faGFzaF9wYXR0ZXJuX25vZGVfbm9kZV9saXN0X2NyZWF0ZQBwbV9jYWxsX25vZGVfbm90X2NyZWF0ZQBwbV9zeW1ib2xfbm9kZV9sYWJlbF9jcmVhdGUAcG1fZmxvYXRfbm9kZV9yYXRpb25hbF9jcmVhdGUAcG1faW50ZWdlcl9ub2RlX3JhdGlvbmFsX2NyZWF0ZQBwbV9yZXRyeV9ub2RlX2NyZWF0ZQBwbV9uZXh0X25vZGVfY3JlYXRlAHBtX2ltcGxpY2l0X3Jlc3Rfbm9kZV9jcmVhdGUAcG1faW5kZXhfdGFyZ2V0X25vZGVfY3JlYXRlAHBtX2Zsb2F0X25vZGVfY3JlYXRlAHBtX2Fzc29jX3NwbGF0X25vZGVfY3JlYXRlAHBtX2ZvcndhcmRpbmdfYXJndW1lbnRzX25vZGVfY3JlYXRlAHBtX25vX2tleXdvcmRzX3BhcmFtZXRlcl9ub2RlX2NyZWF0ZQBwbV9ibG9ja19wYXJhbWV0ZXJfbm9kZV9jcmVhdGUAcG1fZm9yd2FyZGluZ19wYXJhbWV0ZXJfbm9kZV9jcmVhdGUAcG1fc3VwZXJfbm9kZV9jcmVhdGUAcG1fZm9yd2FyZGluZ19zdXBlcl9ub2RlX2NyZWF0ZQBwbV9pbnRlZ2VyX25vZGVfY3JlYXRlAHBtX3JlZG9fbm9kZV9jcmVhdGUAcG1fZmluZF9wYXR0ZXJuX25vZGVfY3JlYXRlAHBtX25pbF9ub2RlX2NyZWF0ZQBwbV9icmVha19ub2RlX2NyZWF0ZQBwbV9oYXNoX25vZGVfY3JlYXRlAHBtX3NvdXJjZV9lbmNvZGluZ19ub2RlX2NyZWF0ZQBwbV9zZWxmX25vZGVfY3JlYXRlAHBtX3VuZGVmX25vZGVfY3JlYXRlAHBtX3RydWVfbm9kZV9jcmVhdGUAcG1faW5kZXhfb3BlcmF0b3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY2FsbF9vcGVyYXRvcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9pbmRleF9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jb25zdGFudF9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jYWxsX29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NvbnN0YW50X3BhdGhfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY2xhc3NfdmFyaWFibGVfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fbG9jYWxfdmFyaWFibGVfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fZ2xvYmFsX3ZhcmlhYmxlX29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2luc3RhbmNlX3ZhcmlhYmxlX29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2luZGV4X2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jb25zdGFudF9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY2FsbF9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY29uc3RhbnRfcGF0aF9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY2xhc3NfdmFyaWFibGVfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2xvY2FsX3ZhcmlhYmxlX2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9nbG9iYWxfdmFyaWFibGVfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2luc3RhbmNlX3ZhcmlhYmxlX2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9mYWxzZV9ub2RlX2NyZWF0ZQBwbV9zb3VyY2VfbGluZV9ub2RlX2NyZWF0ZQBwbV9zb3VyY2VfZmlsZV9ub2RlX2NyZWF0ZQBwbV9hbGlhc19nbG9iYWxfdmFyaWFibGVfbm9kZV9jcmVhdGUAcG1fYWxpYXNfbWV0aG9kX25vZGVfY3JlYXRlAHBtX2NvbnN0YW50X3JlYWRfbm9kZV9jcmVhdGUAcG1fY2xhc3NfdmFyaWFibGVfcmVhZF9ub2RlX2NyZWF0ZQBwbV9pbnN0YW5jZV92YXJpYWJsZV9yZWFkX25vZGVfY3JlYXRlAHBtX2JhY2tfcmVmZXJlbmNlX3JlYWRfbm9kZV9jcmVhdGUAcG1fbnVtYmVyZWRfcmVmZXJlbmNlX3JlYWRfbm9kZV9jcmVhdGUAdW5leHBlY3RlZCBpbXBsaWNpdCBoYXNoIGluIHBhdHRlcm47IHVzZSAneycgdG8gZGVsaW5lYXRlAHBhdHRlcm5faGFzaF9rZXlfZHVwbGljYXRlAHBhdHRlcm5fY2FwdHVyZV9kdXBsaWNhdGUAY29uZGl0aW9uYWxfdW5sZXNzX3ByZWRpY2F0ZQBjb25kaXRpb25hbF91bnRpbF9wcmVkaWNhdGUAY2FzZV9tYXRjaF9taXNzaW5nX3ByZWRpY2F0ZQBjb25kaXRpb25hbF9lbHNpZl9wcmVkaWNhdGUAY29uZGl0aW9uYWxfaWZfcHJlZGljYXRlAGNvbmRpdGlvbmFsX3doaWxlX3ByZWRpY2F0ZQBsb29wIHByZWRpY2F0ZQBkdXBsaWNhdGVkX3doZW5fY2xhdXNlAHJlc2N1ZV9jbGF1c2UAZWxzZV9jbGF1c2UAZW5zdXJlX2NsYXVzZQBleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgY29uZGl0aW9uYWwgY2xhdXNlAGV4cGVjdGVkIGEgZGVsaW1pdGVyIGFmdGVyIHRoZSBwYXR0ZXJucyBvZiBhbiBgaW5gIGNsYXVzZQBleHBlY3RlZCBhIGRlbGltaXRlciBhZnRlciB0aGUgcHJlZGljYXRlcyBvZiBhIGB3aGVuYCBjbGF1c2UAZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGByZXNjdWVgIGNsYXVzZQBleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYGVsc2VgIGNsYXVzZQAnaW4nIGNsYXVzZQAnd2hlbicgY2xhdXNlACdlbHNpZicgY2xhdXNlACdyZXNjdWUnIGNsYXVzZQAnZWxzZScgY2xhdXNlACdlbnN1cmUnIGNsYXVzZQBmbG9hdF9wYXJzZQBwbV9pbnRlZ2VyX3BhcnNlAGxpdGVyYWxfaW5fY29uZGl0aW9uX3ZlcmJvc2UAYmVnaW5fbG9uZWx5X2Vsc2UAaW52YWxpZF9yZXRyeV9hZnRlcl9lbHNlAGNvbmRpdGlvbmFsX3Rlcm1fZWxzZQBJbnZhbGlkIHJldHJ5IGFmdGVyIGVsc2UAdGVybmFyeV9leHByZXNzaW9uX2ZhbHNlAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX2ZhbHNlAENhbid0IGFzc2lnbiB0byBmYWxzZQBNYWNKYXBhbmVzZQBjYXNlX2V4cHJlc3Npb25fYWZ0ZXJfY2FzZQBwbV9pbnRlZ2VyX2NvbnZlcnRfYmFzZQBpbnZhbGlkX3JldHJ5X2FmdGVyX2Vuc3VyZQBJbnZhbGlkIHJldHJ5IGFmdGVyIGVuc3VyZQB1bmV4cGVjdGVkX3Rva2VuX2lnbm9yZQBudW1iZXJfbGl0ZXJhbF91bmRlcnNjb3JlAGNsYXNzX3ZhcmlhYmxlX2JhcmUAZ2xvYmFsX3ZhcmlhYmxlX2JhcmUAaW5zdGFuY2VfdmFyaWFibGVfYmFyZQBwcm90b3R5cGUAZXhwZWN0ZWRfdHlwZQBVbmtub3duIEhUTUwgb3BlbiB0YWcgdHlwZQBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfcGlwZQBwbV90b2tlbl9idWZmZXJfZXNjYXBlAGludmFsaWRfbXVsdGlieXRlX2VzY2FwZQB1bnRlcm1pbmF0ZWQgVW5pY29kZSBlc2NhcGUAbm9uZQBuZXh0X25ld2xpbmUAaWdub3JlZCBuZXdsaW5lAHBtX25ld2xpbmVfbGlzdF9saW5lAHNoYXJlYWJsZV9jb25zdGFudF92YWx1ZV9saW5lAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX2xpbmUAJ3NoYXJlYWJsZV9jb25zdGFudF92YWx1ZScgaXMgaWdub3JlZCB1bmxlc3MgaW4gY29tbWVudC1vbmx5IGxpbmUAZW1iZWRkZWQgZG9jdW1lbnRhdGlvbiBsaW5lAG1hY1VrcmFpbmUAY2xhc3NfbmFtZQB0YWdfbmFtZQBkZWZfbmFtZQBwbV9nbG9iYWxfdmFyaWFibGVfd3JpdGVfbmFtZQBtb2R1bGVfbmFtZQBwYXJhbWV0ZXJfbWV0aG9kX25hbWUAZHVwbGljYXRlZCBrZXkgbmFtZQBkdXBsaWNhdGVkIGFyZ3VtZW50IG5hbWUAJ0BAJyB3aXRob3V0IGlkZW50aWZpZXJzIGlzIG5vdCBhbGxvd2VkIGFzIGEgY2xhc3MgdmFyaWFibGUgbmFtZQBgJS4qcycgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lACclLipzJyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWUAJyQnIHdpdGhvdXQgaWRlbnRpZmllcnMgaXMgbm90IGFsbG93ZWQgYXMgYSBnbG9iYWwgdmFyaWFibGUgbmFtZQBgJS4qcycgaXMgbm90IGFsbG93ZWQgYXMgYSBnbG9iYWwgdmFyaWFibGUgbmFtZQAnJS4qcycgaXMgbm90IGFsbG93ZWQgYXMgYSBnbG9iYWwgdmFyaWFibGUgbmFtZQAnQCcgd2l0aG91dCBpZGVudGlmaWVycyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lAGAlLipzJyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lACclLipzJyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lAGR1cGxpY2F0ZWQgdmFyaWFibGUgbmFtZQB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIG1ldGhvZCBuYW1lAHN0eWxlAG1vZHVsZQBFbWFjcy1NdWxlAHdoaWxlAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX2ZpbGUAZW1iZWRkZWQgZG9jdW1lbnQgbWVldHMgZW5kIG9mIGZpbGUAdW50ZXJtaW5hdGVkIHF1b3RlZCBzdHJpbmcgbWVldHMgZW5kIG9mIGZpbGUAdW50ZXJtaW5hdGVkIHN0cmluZyBtZWV0cyBlbmQgb2YgZmlsZQBkb3VibGUAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGUAbm9fbG9jYWxfdmFyaWFibGUAYmxvY2tfcGFyYW1fbG9jYWxfdmFyaWFibGUAdW51c2VkX2xvY2FsX3ZhcmlhYmxlAHJlc2N1ZV92YXJpYWJsZQBpbnZhbGlkIGZvcm1hbCBhcmd1bWVudDsgZm9ybWFsIGFyZ3VtZW50IGNhbm5vdCBiZSBhIGNsYXNzIHZhcmlhYmxlACUuKnM6IG5vIHN1Y2ggbG9jYWwgdmFyaWFibGUAaW52YWxpZCBhcmd1bWVudCBiZWluZyBwYXNzZWQgdG8gYGFsaWFzYDsgZXhwZWN0ZWQgYSBiYXJlIHdvcmQsIHN5bWJvbCwgY29uc3RhbnQsIG9yIGdsb2JhbCB2YXJpYWJsZQBpbnZhbGlkIGZvcm1hbCBhcmd1bWVudDsgZm9ybWFsIGFyZ3VtZW50IGNhbm5vdCBiZSBhIGdsb2JhbCB2YXJpYWJsZQBpbnZhbGlkIGZvcm1hbCBhcmd1bWVudDsgZm9ybWFsIGFyZ3VtZW50IGNhbm5vdCBiZSBhbiBpbnN0YW5jZSB2YXJpYWJsZQBpbnZhbGlkIGVtYmVkZGVkIHZhcmlhYmxlAGEgdmFyaWFibGUAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX3JhbmdlAGZsb2F0X291dF9vZl9yYW5nZQByZWdleHBfaW52YWxpZF91bmljb2RlX3JhbmdlAEZsb2F0ICUuKnMlcyBvdXQgb2YgcmFuZ2UAZXhwZWN0X21lc3NhZ2UAZXJyb3JfbWVzc2FnZQBwbV9kaWFnbm9zdGljX21lc3NhZ2UAcG1fc3RhdGljX2xpdGVyYWxfaW5zcGVjdF9ub2RlAGVuZF9ub2RlAGJhZF9hcnJheV9uZXdfbGVuZ3RoIHdhcyB0aHJvd24gaW4gLWZuby1leGNlcHRpb25zIG1vZGUAYmFkX2FsbG9jIHdhcyB0aHJvd24gaW4gLWZuby1leGNlcHRpb25zIG1vZGUAZXNjYXBlX2ludmFsaWRfdW5pY29kZQBVVEYtOCBtaXhlZCB3aXRoaW4gJXMgc291cmNlAGludmFsaWQgaGV4IGVzY2FwZSBzZXF1ZW5jZQBpbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlAGFsaWFzX2FyZ3VtZW50X251bWJlcmVkX3JlZmVyZW5jZQBpbnZhbGlkX251bWJlcmVkX3JlZmVyZW5jZQBiYWNrIHJlZmVyZW5jZQBudW1iZXJlZCByZWZlcmVuY2UAaW5jb21wbGV0ZV92YXJpYWJsZV9pbnN0YW5jZQBwYXR0ZXJuX3Rlcm1fYnJhY2UAYmxvY2tfdGVybV9icmFjZQBsYW1iZGFfdGVybV9icmFjZQBiZWdpbl91cGNhc2VfYnJhY2UAZW5kX3VwY2FzZV9icmFjZQB0cmFja193aGl0ZXNwYWNlAGVuY291bnRlcmVkIFxyIGluIG1pZGRsZSBvZiBsaW5lLCB0cmVhdGVkIGFzIGEgbWVyZSBzcGFjZQBlc2NhcGVkIHNwYWNlAHBhcmFtZXRlcl91bmV4cGVjdGVkX2Z3ZABleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYGluYCBrZXl3b3JkAHdyaXRlX3RhcmdldF9pbl9tZXRob2QAY2xhc3NfaW5fbWV0aG9kAG1vZHVsZV9pbl9tZXRob2QAZW5kX2luX21ldGhvZABsb2NhbCB2YXJpYWJsZSBvciBtZXRob2QAc2NyaXB0X25vdF9mb3VuZABhcmd1bWVudF9mb3J3YXJkaW5nX3VuYm91bmQAcG1fcGFyc2VyX3Njb3BlX2ZpbmQAcG1fbmV3bGluZV9saXN0X2FwcGVuZABwbV9jYXNlX21hdGNoX25vZGVfY29uZGl0aW9uX2FwcGVuZABwbV9jYXNlX25vZGVfY29uZGl0aW9uX2FwcGVuZABwbV9pbnRlcnBvbGF0ZWRfc3RyaW5nX25vZGVfYXBwZW5kAHBtX2ludGVycG9sYXRlZF9ub2RlX2FwcGVuZABjb21tZW50X2VuZABlbWJleHByX2VuZABibG9ja190ZXJtX2VuZABsYW1iZGFfdGVybV9lbmQAc3RhdGVtZW50X3Bvc3RleGVfZW5kAGNsYXNzX3VuZXhwZWN0ZWRfZW5kAHBhcnNlcl9mbHVzaF9oZXJlZG9jX2VuZABwYXJzZXItPmhlcmVkb2NfZW5kIDw9IHBhcnNlci0+ZW5kAHBhcnNlci0+Y3VycmVudC5lbmQgPD0gcGFyc2VyLT5lbmQAc3RhcnQgPD0gZW5kAGFtYmlndW91c19wcmVmaXhfYW1wZXJzYW5kAGFyZ3VtZW50X2NvbmZsaWN0X2FtcGVyc2FuZABhcmd1bWVudF9ub19mb3J3YXJkaW5nX2FtcGVyc2FuZABtYWNJY2VsYW5kAHBhcnNlX3lpZWxkAGludmFsaWRfeWllbGQASW52YWxpZCB5aWVsZABpc192b2lkAGVtYnZhcl9pbnZhbGlkAHJldHVybl9pbnZhbGlkAHN5bWJvbF9pbnZhbGlkAGRpYWdub3N0aWNfaWQAdW5hcnlfZGlzYWxsb3dlZABpbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOyBNdWx0aXBsZSBjb2RlcG9pbnRzIGF0IHNpbmdsZSBjaGFyYWN0ZXIgbGl0ZXJhbCBhcmUgZGlzYWxsb3dlZABzeW1ib2wgbGl0ZXJhbCB3aXRoIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQAbXVsdGlwbGUgYmxvY2sgcGFyYW1ldGVyczsgb25seSBvbmUgYmxvY2sgaXMgYWxsb3dlZABib3RoIGJsb2NrIGFyZyBhbmQgYWN0dWFsIGJsb2NrIGdpdmVuOyBvbmx5IG9uZSBibG9jayBpcyBhbGxvd2VkAHBhcmFtZXRlcl9udW1iZXJlZF9yZXNlcnZlZABxdW90ZWQAd3JpdGVfdGFyZ2V0X3VuZXhwZWN0ZWQAcGF0dGVybl9oYXNoX2tleV9pbnRlcnBvbGF0ZWQAc3ltYm9sX3Rlcm1faW50ZXJwb2xhdGVkAGludmFsaWQgY29udHJvbCBlc2NhcGUgc2VxdWVuY2U7IGNvbnRyb2wgY2Fubm90IGJlIHJlcGVhdGVkAGludmFsaWQgbWV0YSBlc2NhcGUgc2VxdWVuY2U7IG1ldGEgY2Fubm90IGJlIHJlcGVhdGVkAHBhcmFtZXRlcl9uYW1lX2R1cGxpY2F0ZWQAJ2l0JyBpcyBub3QgYWxsb3dlZCB3aGVuIGEgbnVtYmVyZWQgcGFyYW1ldGVyIGlzIGFscmVhZHkgdXNlZABudW1iZXJlZCBwYXJhbWV0ZXJzIGFyZSBub3QgYWxsb3dlZCB3aGVuICdpdCcgaXMgYWxyZWFkeSB1c2VkAHBhcnNlZAAnd2hlbicgY2xhdXNlIG9uIGxpbmUgJWkgZHVwbGljYXRlcyAnd2hlbicgY2xhdXNlIG9uIGxpbmUgJWkgYW5kIGlzIGlnbm9yZWQAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfbnVtYmVyZWQAaXRfbm90X2FsbG93ZWRfbnVtYmVyZWQAJ2l0JyBpcyBub3QgYWxsb3dlZCB3aGVuIGFuIG9yZGluYXJ5IHBhcmFtZXRlciBpcyBkZWZpbmVkAG51bWJlcmVkIHBhcmFtZXRlcnMgYXJlIG5vdCBhbGxvd2VkIHdoZW4gYW4gb3JkaW5hcnkgcGFyYW1ldGVyIGlzIGRlZmluZWQAdW5leHBlY3RlZCByYW5nZSBvcGVyYXRvcjsgLi4gYW5kIC4uLiBhcmUgbm9uLWFzc29jaWF0aXZlIGFuZCBjYW5ub3QgYmUgY2hhaW5lZABtYWxsb2NfZmFpbGVkAHRhcmdldCBvZiByZXBlYXQgb3BlcmF0b3IgaXMgbm90IHNwZWNpZmllZABzdGF0ZW1lbnQgbm90IHJlYWNoZWQAZXNjYXBlZCBmb3JtIGZlZWQAZW1iZWQAbG9hZABwbV9sb2NhbHNfdW5yZWFkAHBtX2xvY2Fsc19yZWFkAGludmFsaWRfbG9jYWxfdmFyaWFibGVfcmVhZAAlZABwYXJzZV9uZWdhdGl2ZV9udW1lcmljAHN5bWJvbF90ZXJtX2R5bmFtaWMAbWFjQ3lyaWxsaWMAcmVnZXhwX25vbl9lc2NhcGVkX21iYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjYuMS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI2NmY4M2RlNmEyYi9zcmMvdXRpbC9wbV9uZXdsaW5lX2xpc3QuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjYuMS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI2NmY4M2RlNmEyYi9zcmMvc3RhdGljX2xpdGVyYWxzLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC42LjEvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yNjZmODNkZTZhMmIvc3JjL3V0aWwvcG1faW50ZWdlci5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNi4xL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjY2ZjgzZGU2YTJiL3NyYy91dGlsL3BtX2J1ZmZlci5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNi4xL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjY2ZjgzZGU2YTJiL3NyYy9wcmlzbS5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNi4xL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjY2ZjgzZGU2YTJiL3NyYy91dGlsL3BtX2NvbnN0YW50X3Bvb2wuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjYuMS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI2NmY4M2RlNmEyYi9zcmMvdXRpbC9wbV9zdHJwYnJrLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC42LjEvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yNjZmODNkZTZhMmIvc3JjL3V0aWwvcG1fc3RyaW5nLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC42LjEvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yNjZmODNkZTZhMmIvc3JjL2VuY29kaW5nLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC42LjEvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yNjZmODNkZTZhMmIvc3JjL3Rva2VuX3R5cGUuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjYuMS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI2NmY4M2RlNmEyYi9zcmMvZGlhZ25vc3RpYy5jAHByaXNtL3RlbXBsYXRlcy9zcmMvbm9kZS5jLmVyYgBlc2NhcGVkIGhvcml6b250YWwgdGFiAGVzY2FwZWQgdmVydGljYWwgdGFiAFxiAGVzY2FwZV9pbnZhbGlkX21ldGEAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfY29tbWEAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX2NvbW1hAHBhdHRlcm5fbGFiZWxfYWZ0ZXJfY29tbWEAcGFyYW1ldGVyX3dpbGRfbG9vc2VfY29tbWEAaW52YWxpZF9jb21tYQBpbnZhbGlkIGNvbW1hAG1hY1JvbWFuaWEAYXJlYQBcYQBleHBlY3RlZCBhIGxhbWJkYSBibG9jayBiZWdpbm5pbmcgd2l0aCBge2AgdG8gZW5kIHdpdGggYH1gAGV4cGVjdGVkIGEgYmxvY2sgYmVnaW5uaW5nIHdpdGggYHtgIHRvIGVuZCB3aXRoIGB9YABleHBlY3RlZCB0aGUgYmxvY2sgcGFyYW1ldGVycyB0byBlbmQgd2l0aCBgfGAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJXdgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYG5vdGAAZXhwZWN0ZWQgYW4gaW5kZXggYWZ0ZXIgYGZvcmAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgd2hlbmAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJWlgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYGNhc2VgAGV4cGVjdGVkIGEgYHdoZW5gIG9yIGBpbmAgY2xhdXNlIGFmdGVyIGBjYXNlYABleHBlY3RlZCBhIGxhbWJkYSBibG9jayBiZWdpbm5pbmcgd2l0aCBgZG9gIHRvIGVuZCB3aXRoIGBlbmRgAGV4cGVjdGVkIGEgYmxvY2sgYmVnaW5uaW5nIHdpdGggYGRvYCB0byBlbmQgd2l0aCBgZW5kYAB1bmV4cGVjdGVkICVzLCBleHBlY3RlZCBhIHJlY2VpdmVyIGZvciB1bmFyeSBgJWNgAGludmFsaWQgY2hhcmFjdGVyIGAlY2AAbnVtYmVyIGxpdGVyYWwgZW5kaW5nIHdpdGggYSBgX2AAZXhwZWN0ZWQgYSBtYXRjaGluZyBgXWAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJVdgAGV4cGVjdGVkIGEgYHtgIGFmdGVyIGBCRUdJTmAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJUlgAGV4cGVjdGVkIGEgYHtgIGFmdGVyIGBFTkRgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYGRlZmluZWQ/YABpbmNvbXBsZXRlIGV4cHJlc3Npb24gYXQgYD9gAGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIGA9PmAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgfHw9YABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA9YABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAmJj1gAGV4cGVjdGVkIGEgc3VwZXJjbGFzcyBhZnRlciBgPGAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgPDxgAHVuZXhwZWN0ZWQgYXJndW1lbnQgYWZ0ZXIgYC4uLmAAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgYCxgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCxgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCpgAHVuZXhwZWN0ZWQgcGFyYW1ldGVyIGAqYABleHBlY3RlZCBhIG1hdGNoaW5nIGApYABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAoYAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX19fRU5DT0RJTkdfXwBDYW4ndCBhc3NpZ24gdG8gX19FTkNPRElOR19fAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfX19MSU5FX18AQ2FuJ3QgYXNzaWduIHRvIF9fTElORV9fAGZpbGVfa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX19fRklMRV9fAENhbid0IGFzc2lnbiB0byBfX0ZJTEVfXwBfX0VORF9fACRfAFtdAGxpc3QtPnNpemUgPT0gMCB8fCBuZXdsaW5lX29mZnNldCA+IGxpc3QtPm9mZnNldHNbbGlzdC0+c2l6ZSAtIDFdAFxcADwhW0NEQVRBWwB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1JFVFJZAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0ZMT0FUX0lNQUdJTkFSWQB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSX0lNQUdJTkFSWQB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9GTE9BVF9SQVRJT05BTF9JTUFHSU5BUlkAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fSU5URUdFUl9SQVRJT05BTF9JTUFHSU5BUlkAQklOQVJZAGRpYWdfaWQgPCBQTV9ESUFHTk9TVElDX0lEX01BWABpbmRleCAhPSBVSU5UMzJfTUFYAGxvY2FsLT5yZWFkcyA8IFVJTlQzMl9NQVgAXHUlMDRYAFx4JTAyWABpbnZhbGlkIG11bHRpYnl0ZSBjaGFyYWN0ZXIgMHglWABldWNUVwBFVUMtVFcAS09JOC1VAFVua25vd24gZXJyb3JfdHlwZV9UAFVua25vd24gdG9rZW5fdHlwZV9UAFVua25vd24gYXN0X25vZGVfdHlwZV9UAGtleXdvcmQtPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9ORVhUAFRPS0VOX0hUTUxfQ09NTUVOVF9TVEFSVABUT0tFTl9IVE1MX1RBR19TVEFSVABUT0tFTl9JREVOVElGSUVSLCBUT0tFTl9RVU9URSwgVE9LRU5fRVJCX1NUQVJUAFRPS0VOX0NEQVRBX1NUQVJUAHRva2VuLT50eXBlID09IFBNX1RPS0VOX1VET1RfRE9UX0RPVABUT0tFTl9FUkJfQ09OVEVOVABUT0tFTl9QRVJDRU5UAHVuZXhwZWN0ZWQgY29uc3RhbnQgcGF0aCBhZnRlciBgY2xhc3NgOyBjbGFzcy9tb2R1bGUgbmFtZSBtdXN0IGJlIENPTlNUQU5UAHVuZXhwZWN0ZWQgY29uc3RhbnQgcGF0aCBhZnRlciBgbW9kdWxlYDsgY2xhc3MvbW9kdWxlIG5hbWUgbXVzdCBiZSBDT05TVEFOVABUT0tFTl9MVABBU0NJSS04QklUAHBtX2JpbmRpbmdfcG93ZXJzW3R5cGVdLmxlZnQgPT0gUE1fQklORElOR19QT1dFUl9VTlNFVABsaXN0LT5pZHNbaW5kZXhdID09IFBNX0NPTlNUQU5UX0lEX1VOU0VUAFRPS0VOX0FUAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0ZMT0FUAFRPS0VOX0VRVUFMUwBTaGlmdF9KSVMAU0pJUwBVVEYtOC1IRlMAQmlnNS1IS1NDUwBrZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfQUxJQVMAVU5DTE9TRURfRUxFTUVOVF9FUlJPUgBVTkVYUEVDVEVEX1RPS0VOX0VSUk9SAG5vdCBUT0tFTl9FUlJPUgBRVU9URVNfTUlTTUFUQ0hfRVJST1IAVEFHX05BTUVTX01JU01BVENIX0VSUk9SAFZPSURfRUxFTUVOVF9DTE9TSU5HX1RBR19FUlJPUgBNSVNTSU5HX0NMT1NJTkdfVEFHX0VSUk9SAE1JU1NJTkdfT1BFTklOR19UQUdfRVJST1IAUlVCWV9QQVJTRV9FUlJPUgBVTkVYUEVDVEVEX0VSUk9SAGV1Y0tSAEVVQy1LUgBUT0tFTl9DSEFSQUNURVIAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9TVVBFUgBrZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfU1VQRVIAVE9LRU5fSURFTlRJRklFUgB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSAG9wZXJhdG9yLT50eXBlID09IFBNX1RPS0VOX1VTVEFSX1NUQVIgfHwgb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fU1RBUl9TVEFSAG9wZXJhdG9yLT50eXBlID09IFBNX1RPS0VOX1VTVEFSX1NUQVIAcGFyc2VyLT5jdXJyZW50LnR5cGUgPT0gUE1fVE9LRU5fVVNUQVJfU1RBUgBwYXJzZXItPnByZXZpb3VzLnR5cGUgPT0gUE1fVE9LRU5fVVNUQVIAS09JOC1SAFRPS0VOX05CU1AAZXVjSlAARVVDLUpQAHN0YXRlbGVzcy1JU08tMjAyMi1KUAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1JFRE8AQmlnNS1VQU8AVE9LRU5fQ09MT04AVE9LRU5fU0VNSUNPTE9OAFRPS0VOX1hNTF9ERUNMQVJBVElPTgBUT0tFTl9FWENMQU1BVElPTgBwYXJzZXItPmN1cnJlbnQudHlwZSA9PSBQTV9UT0tFTl9TVFJJTkdfQkVHSU4AZXVjQ04ARVVDLUNOAE5BTgBleHRyYWN0SFRNTABwYXJhbXMtPmtleXdvcmRfcmVzdCA9PSBOVUxMAHRhcmdldC0+YmxvY2sgPT0gTlVMTABwYXJhbXMtPmJsb2NrID09IE5VTEwAcmVzdCAhPSBOVUxMAHBhcnNlci0+Y3VycmVudF9ibG9ja19leGl0cyAhPSBOVUxMAHoyLnZhbHVlcyAhPSBOVUxMAHowLnZhbHVlcyAhPSBOVUxMAHJlY2VpdmVyICE9IE5VTEwAb3BlbmluZyAhPSBOVUxMAHNjb3BlICE9IE5VTEwAc291cmNlICE9IE5VTEwAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9OSUwAa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX05JTABvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9QSVBFX1BJUEVfRVFVQUwAb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fQU1QRVJTQU5EX0FNUEVSU0FORF9FUVVBTAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9GTE9BVF9SQVRJT05BTAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSX1JBVElPTkFMAFBDSwBUT0tFTl9CQUNLVElDSwBHQksAa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX0JSRUFLAGNzV2luZG93czMxSgBXaW5kb3dzLTMxSgBVUy1BU0NJSQBTSklTLUtEREkAc3RhdGVsZXNzLUlTTy0yMDIyLUpQLUtEREkAVVRGOC1LRERJAFRPS0VOX1NMQVNIAFRPS0VOX0JBQ0tTTEFTSABUT0tFTl9EQVNIAGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fUElQRSB8fCBjbG9zaW5nLT50eXBlID09IFBNX1RPS0VOX1BBUkVOVEhFU0lTX1JJR0hUIHx8IGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fTUlTU0lORwBuYW1lLT50eXBlID09IFBNX1RPS0VOX0NPTlNUQU5UIHx8IG5hbWUtPnR5cGUgPT0gUE1fVE9LRU5fTUlTU0lORwBlbmRfa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX0VORCB8fCBlbmRfa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9NSVNTSU5HAGxleF9tb2RlLT5tb2RlID09IFBNX0xFWF9TVFJJTkcAVE9LRU5fRU9GAHVudGVybWluYXRlZCBoZXJlZG9jOyBjYW4ndCBmaW5kIHN0cmluZyAiJS4qcyIgYW55d2hlcmUgYmVmb3JlIEVPRgBJTkYAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9TRUxGAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfVU5ERUYAJEYAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9UUlVFAFRPS0VOX1FVT1RFAFRPS0VOX0hUTUxfVEFHX1NUQVJUX0NMT1NFAFRPS0VOX0hUTUxfVEFHX1NFTEZfQ0xPU0UAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9GQUxTRQBUT0tFTl9VTkRFUlNDT1JFAFRPS0VOX0hUTUxfRE9DVFlQRQA8IURPQ1RZUEUAVE9LRU5fRVJCX1NUQVJULCBUT0tFTl9IVE1MX0RPQ1RZUEUsIFRPS0VOX0hUTUxfQ09NTUVOVF9TVEFSVCwgVE9LRU5fSURFTlRJRklFUiwgVE9LRU5fV0hJVEVTUEFDRSwgVE9LRU5fTkJTUCwgVE9LRU5fQVQsIG9yIFRPS0VOX05FV0xJTkUAVE9LRU5fSURFTlRJRklFUiwgVE9LRU5fQVQsIFRPS0VOX0VSQl9TVEFSVCxUT0tFTl9XSElURVNQQUNFLCBvciBUT0tFTl9ORVdMSU5FAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0NMQVNTX1ZBUklBQkxFAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0lOU1RBTkNFX1ZBUklBQkxFAEFTVF9IVE1MX1RFWFRfTk9ERQBBU1RfRVJCX0NPTlRFTlRfTk9ERQBBU1RfRE9DVU1FTlRfTk9ERQBBU1RfSFRNTF9DT01NRU5UX05PREUAQVNUX0hUTUxfRUxFTUVOVF9OT0RFAEFTVF9FUkJfVU5MRVNTX05PREUAQVNUX0VSQl9GT1JfTk9ERQBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fQkxPQ0tfTE9DQUxfVkFSSUFCTEVfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fQkxPQ0tfUEFSQU1FVEVSX05PREUgfHwgUE1fTk9ERV9UWVBFKG5vZGUpID09IFBNX0tFWVdPUkRfUkVTVF9QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fT1BUSU9OQUxfS0VZV09SRF9QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fT1BUSU9OQUxfUEFSQU1FVEVSX05PREUgfHwgUE1fTk9ERV9UWVBFKG5vZGUpID09IFBNX1JFUVVJUkVEX0tFWVdPUkRfUEFSQU1FVEVSX05PREUgfHwgUE1fTk9ERV9UWVBFKG5vZGUpID09IFBNX1JFUVVJUkVEX1BBUkFNRVRFUl9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9SRVNUX1BBUkFNRVRFUl9OT0RFAEFTVF9YTUxfREVDTEFSQVRJT05fTk9ERQBBU1RfRVJCX0lOX05PREUAQVNUX0VSQl9CRUdJTl9OT0RFAEFTVF9FUkJfV0hFTl9OT0RFAEFTVF9FUkJfVU5USUxfTk9ERQBBU1RfTElURVJBTF9OT0RFAEFTVF9FUkJfQkxPQ0tfTk9ERQBBU1RfRVJCX0NBU0VfTUFUQ0hfTk9ERQBBU1RfSFRNTF9PUEVOX1RBR19OT0RFAEFTVF9IVE1MX0NMT1NFX1RBR19OT0RFAEFTVF9FUkJfSUZfTk9ERQBBU1RfSFRNTF9BVFRSSUJVVEVfVkFMVUVfTk9ERQBBU1RfRVJCX1JFU0NVRV9OT0RFAEFTVF9IVE1MX0FUVFJJQlVURV9OT0RFAEFTVF9FUkJfRUxTRV9OT0RFAEFTVF9FUkJfQ0FTRV9OT0RFAEFTVF9FUkJfRU5TVVJFX05PREUAQVNUX0hUTUxfRE9DVFlQRV9OT0RFAEFTVF9IVE1MX0FUVFJJQlVURV9OQU1FX05PREUAQVNUX0VSQl9XSElMRV9OT0RFAEFTVF9XSElURVNQQUNFX05PREUAQVNUX0VSQl9FTkRfTk9ERQBBU1RfRVJCX1lJRUxEX05PREUAQVNUX0NEQVRBX05PREUAbmFtZS0+dHlwZSA9PSBQTV9UT0tFTl9CQUNLX1JFRkVSRU5DRQBuYW1lLT50eXBlID09IFBNX1RPS0VOX05VTUJFUkVEX1JFRkVSRU5DRQBUT0tFTl9XSElURVNQQUNFAFRPS0VOX0hUTUxfQ09NTUVOVF9FTkQAVE9LRU5fWE1MX0RFQ0xBUkFUSU9OX0VORABUT0tFTl9IVE1MX1RBR19FTkQAVE9LRU5fRVJCX0VORABUT0tFTl9DREFUQV9FTkQAb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fTk9UX1BST1ZJREVEIHx8IG9wZXJhdG9yLT50eXBlID09IFBNX1RPS0VOX1VBTVBFUlNBTkQgfHwgb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fQU1QRVJTQU5EAGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fQlJBQ0tFVF9SSUdIVCB8fCBjbG9zaW5nLT50eXBlID09IFBNX1RPS0VOX1NUUklOR19FTkQgfHwgY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9NSVNTSU5HIHx8IGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fTk9UX1BST1ZJREVEAHBhcnNlci0+bGV4X21vZGVzLmN1cnJlbnQtPm1vZGUgPT0gUE1fTEVYX0hFUkVET0MAVVRGOC1NQUMAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fQ09NTUEAbGlicHJpc21AACwgbGliaGVyYkAALUAAK0AAY2F0Y2hpbmcgYSBjbGFzcyB3aXRob3V0IGFuIG9iamVjdD8ALi4uIGF0IEVPTCwgc2hvdWxkIGJlIHBhcmVudGhlc2l6ZWQ/AGRlZmluZWQ/AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+ACM8RW5jb2Rpbmc6JXM+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AF1dPgA/PgA+PgA8PT4APC8+ADwgLz4ALS0+AC0lPgAlJT4AW109AD4+PQA8JT09AGZvdW5kIGA9IGxpdGVyYWwnIGluIGNvbmRpdGlvbmFsLCBzaG91bGQgYmUgPT0AZm91bmQgJz0gbGl0ZXJhbCcgaW4gY29uZGl0aW9uYWwsIHNob3VsZCBiZSA9PQA8PD0APCU9ADwlJT0APDwAJDsAOjoAXzkAQ1A4NjkASUJNODY5AENQOTQ5AElTTzg4NTktOQBJU08tODg1OS05AF84AEdCMTk4OABDUDg3OABBTlNJX1gzLjQtMTk2OABDUDEyNTgAV2luZG93cy0xMjU4AEJpZzUtSEtTQ1M6MjAwOABDRVNVLTgAVVRGLTgASVNPODg1OS04AElTTy04ODU5LTgAXzcAQ1A4NTcASUJNODU3AENQMTI1NwBXaW5kb3dzLTEyNTcAQ1A3MzcASUJNNzM3AENQNDM3AElCTTQzNwBJU084ODU5LTcASVNPLTg4NTktNwBfNgBDUDg2NgBJQk04NjYAQ1AxMjU2AFdpbmRvd3MtMTI1NgA2NDYAQ1A5MzYASVNPODg1OS0xNgBJU08tODg1OS0xNgBJU084ODU5LTYASVNPLTg4NTktNgBCaWc1AF81AENQNzc1AElCTTc3NQBDUDg2NQBJQk04NjUAQ1A4NTUASUJNODU1AENQMTI1NQBXaW5kb3dzLTEyNTUAR0IxMjM0NQBJU084ODU5LTE1AElTTy04ODU5LTE1AElTTzg4NTktNQBJU08tODg1OS01AF80AENQODc0AFdpbmRvd3MtODc0AENQODY0AElCTTg2NABDUDEyNTQAV2luZG93cy0xMjU0AElTTzg4NTktMTQASVNPLTg4NTktMTQARVVDLUpJUy0yMDA0AElTTzg4NTktNABJU08tODg1OS00AGluY29tcGxldGVfdmFyaWFibGVfY2xhc3NfM18zAGVxdWFsX2luX2NvbmRpdGlvbmFsXzNfMwBpbnZhbGlkX3ZhcmlhYmxlX2dsb2JhbF8zXzMAaW5jb21wbGV0ZV92YXJpYWJsZV9pbnN0YW5jZV8zXzMAQ1A4NjMASUJNODYzAENQMTI1MwBXaW5kb3dzLTEyNTMARVVDLUpJU1gwMjEzAElTTzg4NTktMTMASVNPLTg4NTktMTMASVNPODg1OS0zAElTTy04ODU5LTMAXzIAQ1A4NjIASUJNODYyAENQODUyAElCTTg1MgBDUDEyNTIAV2luZG93cy0xMjUyAENQOTMyAENQNTE5MzIAR0IyMzEyAElTTzg4NTktMgBJU08tODg1OS0yAF8xAENQODYxAElCTTg2MQBDUDk1MQBDUDEyNTEAV2luZG93cy0xMjUxAElTTzg4NTktMTEASVNPLTg4NTktMTEAQ1A2NTAwMQAwLjYuMQBJU084ODU5LTEASVNPLTg4NTktMQBDUDg2MABJQk04NjAAQ1A5NTAAQ1A4NTAASUJNODUwAENQMTI1MABXaW5kb3dzLTEyNTAAR0IxODAzMABDUDcyMABJQk03MjAAVElTLTYyMABJU084ODU5LTEwAElTTy04ODU5LTEwADEuNC4wADAuMAAoMABsb2NhbC0+cmVhZHMgPiAwAGJpZ2ludHNfbGVuZ3RoID4gMABkaWZmID4gMABzdGF0ZW1lbnRzLT5ib2R5LnNpemUgPiAwAG5vZGUtPmJvZHkuc2l6ZSA+IDAAbiA+PSAwAGxlbmd0aCA+PSAwAChsYWJlbC5lbmQgLSBsYWJlbC5zdGFydCkgPj0gMAAvLi4uL24gaGFzIGEgbm9uIGVzY2FwZWQgbm9uIEFTQ0lJIGNoYXJhY3RlciBpbiBub24gQVNDSUktOEJJVCBzY3JpcHQ6IC8lLipzLwBpbmNvbXBhdGlibGUgY2hhcmFjdGVyIGVuY29kaW5nOiAvJS4qcy8AaW52YWxpZCBtdWx0aWJ5dGUgZXNjYXBlOiAvJS4qcy8AaW52YWxpZCBVbmljb2RlIHJhbmdlOiAvJS4qcy8AVVRGLTggY2hhcmFjdGVyIGluIG5vbiBVVEYtOCByZWdleHA6IC8lcy8APC8AJC8AVGFnIGA8JXM+YCBvcGVuZWQgYXQgKCV6dTolenUpIHdhcyBuZXZlciBjbG9zZWQgYmVmb3JlIHRoZSBlbmQgb2YgZG9jdW1lbnQuAEZvdW5kIGNsb3NpbmcgdGFnIGA8LyVzPmAgYXQgKCV6dTolenUpIHdpdGhvdXQgYSBtYXRjaGluZyBvcGVuaW5nIHRhZy4AJXMuIEV4cGVjdGVkOiBgJXNgLCBmb3VuZDogYCVzYC4AT3BlbmluZyB0YWcgYDwlcz5gIGF0ICglenU6JXp1KSBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjbG9zaW5nIHRhZyBgPC8lcz5gLgBgJXNgIGlzIGEgdm9pZCBlbGVtZW50IGFuZCBzaG91bGQgbm90IGJlIHVzZWQgYXMgYSBjbG9zaW5nIHRhZy4gVXNlIGA8JXM+YCBvciBgPCVzIC8+YCBpbnN0ZWFkIG9mIGA8LyVzPmAuAC4uLgBTdHJpbmcgb3BlbmVkIHdpdGggJXMgYnV0IGNsb3NlZCB3aXRoICVzIGF0ICglenU6JXp1KS4ARm91bmQgYCVzYCB3aGVuIGV4cGVjdGluZyBgJXNgIGF0ICglenU6JXp1KS4AT3BlbmluZyB0YWcgYDwlcz5gIGF0ICglenU6JXp1KSBjbG9zZWQgd2l0aCBgPC8lcz5gIGF0ICglenU6JXp1KS4AXE0tAFxDLQA8IS0tADwlLQAgLQArACoqAGlzX3Bvd2VyX29mX3R3byhwb29sLT5jYXBhY2l0eSkAIChXZWJBc3NlbWJseSkAaW52YWxpZCBtdWx0aWJ5dGUgY2hhciAoJXMpAChudWxsKQBpKQBiYWNrdGljayAoYCkAKG1vZGlmaWVyID09ICduJyAmJiBtb2RpZmllcl9lbmNvZGluZyA9PSBQTV9FTkNPRElOR19BU0NJSV84QklUX0VOVFJZKSB8fCAobW9kaWZpZXIgPT0gJ3UnICYmIG1vZGlmaWVyX2VuY29kaW5nID09IFBNX0VOQ09ESU5HX1VURl84X0VOVFJZKSB8fCAobW9kaWZpZXIgPT0gJ2UnICYmIG1vZGlmaWVyX2VuY29kaW5nID09IFBNX0VOQ09ESU5HX0VVQ19KUF9FTlRSWSkgfHwgKG1vZGlmaWVyID09ICdzJyAmJiBtb2RpZmllcl9lbmNvZGluZyA9PSBQTV9FTkNPRElOR19XSU5ET1dTXzMxSl9FTlRSWSkAIXRhcmdldC0+YmxvY2sgfHwgUE1fTk9ERV9UWVBFX1AodGFyZ2V0LT5ibG9jaywgUE1fQkxPQ0tfQVJHVU1FTlRfTk9ERSkAUE1fTk9ERV9UWVBFX1AocmlnaHQsIFBNX1NQTEFUX05PREUpAFBNX05PREVfVFlQRV9QKGxlZnQsIFBNX1NQTEFUX05PREUpAGJvZHkgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChib2R5LCBQTV9TVEFURU1FTlRTX05PREUpAHN0YXRlbWVudHMgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChzdGF0ZW1lbnRzLCBQTV9TVEFURU1FTlRTX05PREUpAFBNX05PREVfVFlQRV9QKGNvbmRpdGlvbiwgUE1fSU5fTk9ERSkAUE1fTk9ERV9UWVBFX1AoY29uZGl0aW9uLCBQTV9XSEVOX05PREUpAFBNX05PREVfVFlQRV9QKHRhcmdldCwgUE1fTE9DQUxfVkFSSUFCTEVfUkVBRF9OT0RFKSB8fCBQTV9OT0RFX1RZUEVfUCh0YXJnZXQsIFBNX0lUX0xPQ0FMX1ZBUklBQkxFX1JFQURfTk9ERSkgfHwgUE1fTk9ERV9UWVBFX1AodGFyZ2V0LCBQTV9DQUxMX05PREUpAGFyZ3VtZW50cy0+YmxvY2sgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChhcmd1bWVudHMtPmJsb2NrLCBQTV9CTE9DS19OT0RFKQBQTV9OT0RFX1RZUEVfUChub2RlLCBQTV9IQVNIX05PREUpIHx8IFBNX05PREVfVFlQRV9QKG5vZGUsIFBNX0tFWVdPUkRfSEFTSF9OT0RFKQBQTV9OT0RFX1RZUEVfUChub2RlLCBQTV9MT0NBTF9WQVJJQUJMRV9SRUFEX05PREUpAHBvb2wtPnNpemUgPCAoKHVpbnQzMl90KSAoMSA8PCAzMCkpAHNpbmdsZSBxdW90ZSAoJykgb3IgZG91YmxlIHF1b3RlICgiKQBlc2NhcGVkIHF1b3RlIChcJykgb3IgZGlmZmVyZW50IHF1b3RlIHN0eWxlICgiKQAnPX4nACd+JwAnIX4nACd9JwAnfHwnACd8JwAneycAJyN7JwAncmV0cnknACcleCcAJyV3JwAnbmV4dCcAJ25vdCcAJ3VubGVzcycAJ2NsYXNzJwAnYWxpYXMnAGNvdWxkIG5vdCBwYXJzZSB0aGUgZmxvYXQgJyUuKnMnAHJlZ2V4cCBlbmNvZGluZyBvcHRpb24gJyVjJyBkaWZmZXJzIGZyb20gc291cmNlIGVuY29kaW5nICclcycAJ2ZvcicAJ29yJwAnc3VwZXInACdyZWRvJwAnZG8nACdyZXR1cm4nACc9YmVnaW4nACdiZWdpbicAJ2luJwAnd2hlbicAJ3RoZW4nAGV4cGVjdGVkIGB0aGVuYCBvciBgO2Agb3IgJ1xuJwB1bmV4cGVjdGVkIGBlbmRgLCBleHBlY3RpbmcgJzsnIG9yICdcbicAKmN1cnNvciA9PSAnXG4nACd1bnRpbCcAJ25pbCcAJ2JyZWFrJwAnJWknACdzZWxmJwAnZWxzaWYnACdpZicAJ3VuZGVmJwAnZGVmJwAndHJ1ZScAJ3Jlc2N1ZScAJ2Vsc2UnACdmYWxzZScAJ2Nhc2UnACdlbnN1cmUnACdtb2R1bGUnACd3aGlsZScAJz1lbmQnACdlbmQnACdhbmQnACd5aWVsZCcAJ2AnACdfX0VOQ09ESU5HX18nACdfX0xJTkVfXycAJ19fRklMRV9fJwAnX19FTkRfXycAJ14nACdbXScAJ10nACdbJwAnJVcnACdCRUdJTicAJyVJJwAnRU5EJwAnZGVmaW5lZD8nACc/JwAnPD0+JwAnPT4nACctPicAJz4nACd8fD0nACd8PScAJ149JwAnW109JwAnPj0nACc9PT0nACc9PScAJzw9JwAnLz0nACctPScAJys9JwAnKio9JwAnKj0nACc9JwAnJj0nACcmJj0nACclPScAJyE9JwAnPCcAJzsnACc6OicAJzonACcvJwAnLi4uJwAnLi4nACcuJwAnJi4nACctJwAnLCcAJysnACcqKicAJyonACcpJwAnKCcAJyYnACcmJicAJyUnACcjJwAnIScAJgA8JQA8JSUADQpcIwA8JSMAcG9pbnQgJiYgInNob3VsZCBoYXZlIGEgZGVjaW1hbCBwb2ludCIAdmFsdWUgIT0gLTEgJiYgImludmFsaWQgZGlnaXQiAGxlbmd0aF9lcnJvciB3YXMgdGhyb3duIGluIC1mbm8tZXhjZXB0aW9ucyBtb2RlIHdpdGggbWVzc2FnZSAiJXMiAG91dF9vZl9yYW5nZSB3YXMgdGhyb3duIGluIC1mbm8tZXhjZXB0aW9ucyBtb2RlIHdpdGggbWVzc2FnZSAiJXMiAGZhbHNlICYmICJ1bmV4cGVjdGVkIG5vZGUgdHlwZSIAZmFsc2UgJiYgInVucmVhY2hhYmxlIgBcIgAhAHJlZ2V4IABzeW1ib2wgAHN0cmluZyAAbGliYysrYWJpOiAARmFpbGVkIHRvIGFsbG9jYXRlICVkIGJ5dGVzCgBFcnJvcjogRmFpbGVkIHRvIHJlc2l6ZSBidWZmZXIgdG8gJXp1LgoARXJyb3I6IEZhaWxlZCB0byBpbml0aWFsaXplIGJ1ZmZlciB3aXRoIGNhcGFjaXR5IG9mICV6dS4KAEVycm9yOiBCdWZmZXIgY2FwYWNpdHkgd291bGQgb3ZlcmZsb3cgc3lzdGVtIGxpbWl0cy4KAEVycm9yOiBBcnJheSBhbGxvY2F0aW9uIHdvdWxkIGV4Y2VlZCBzeXN0ZW0gbGltaXRzLgoARXJyb3I6IEZhaWxlZCB0byBhbGxvY2F0ZSAlenUgYnl0ZXMuCgBXYXJuaW5nOiBBcHByb2FjaGluZyBhcnJheSBzaXplIGxpbWl0cywgdXNpbmcgY29uc2VydmF0aXZlIGdyb3d0aC4KAEVycm9yOiBNZW1vcnkgcmVhbGxvY2F0aW9uIGZhaWxlZCAoc2l6ZTogJXp1IGJ5dGVzKS4KAFtMZXhlcl0gRXJyb3I6ICVzIChjaGFyYWN0ZXIgJyVjJywgbGluZSAlenUsIGNvbCAlenUpCgAAAAAAAAAAAAAAAAAAAJFsAQDpUwEAGCsBAKQ5AQCbZQEAvyUBAJJFAQDPBQEA6T0BAPNrAQBmOQEAs1wBANpAAQAXKwEAAAAAAAAAAAA/igEAqooBAKaKAQB0mgEAcpIBAGuaAQBomgEAAAAAANSdAQCgRAIA3J0BAE4xMGVtc2NyaXB0ZW4zdmFsRQAA5EMCANSdAQAAAAAA1J0BAFxEAgAAAAAA5EMCAFxE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AAB6HgAAeh4AAHweAAB8HgAAfh4AAH4eAACAHgAAgB4AAIIeAACCHgAAhB4AAIQeAACGHgAAhh4AAIgeAACIHgAAih4AAIoeAACMHgAAjB4AAI4eAACOHgAAkB4AAJAeAACSHgAAkh4AAJQeAACUHgAAnh4AAJ4eAACgHgAAoB4AAKIeAACiHgAApB4AAKQeAACmHgAAph4AAKgeAACoHgAAqh4AAKoeAACsHgAArB4AAK4eAACuHgAAsB4AALAeAACyHgAAsh4AALQeAAC0HgAAth4AALYeAAC4HgAAuB4AALoeAAC6HgAAvB4AALweAAC+HgAAvh4AAMAeAADAHgAAwh4AAMIeAADEHgAAxB4AAMYeAADGHgAAyB4AAMgeAADKHgAAyh4AAMweAADMHgAAzh4AAM4eAADQHgAA0B4AANIeAADSHgAA1B4AANQeAADWHgAA1h4AANgeAADYHgAA2h4AANoeAADcHgAA3B4AAN4eAADeHgAA4B4AAOAeAADiHgAA4h4AAOQeAADkHgAA5h4AAOYeAADoHgAA6B4AAOoeAADqHgAA7B4AAOweAADuHgAA7h4AAPAeAADwHgAA8h4AAPIeAAD0HgAA9B4AAPYeAAD2HgAA+B4AAPgeAAD6HgAA+h4AAPweAAD8HgAA/h4AAP4eAAAIHwAADx8AABgfAAAdHwAAKB8AAC8fAAA4HwAAPx8AAEgfAABNHwAAWR8AAFkfAABbHwAAWx8AAF0fAABdHwAAXx8AAF8fAABoHwAAbx8AAIgfAACPHwAAmB8AAJ8fAACoHwAArx8AALgfAAC8HwAAyB8AAMwfAADYHwAA2x8AAOgfAADsHwAA+B8AAPwfAAACIQAAAiEAAAchAAAHIQAACyEAAA0hAAAQIQAAEiEAABUhAAAVIQAAGSEAAB0hAAAkIQAAJCEAACYhAAAmIQAAKCEAACghAAAqIQAALSEAADAhAAAzIQAAPiEAAD8hAABFIQAARSEAAGAhAABvIQAAgyEAAIMhAAC2JAAAzyQAAAAsAAAvLAAAYCwAAGAsAABiLAAAZCwAAGcsAABnLAAAaSwAAGksAABrLAAAaywAAG0sAABwLAAAciwAAHIsAAB1LAAAdSwAAH4sAACALAAAgiwAAIIsAACELAAAhCwAAIYsAACGLAAAiCwAAIgsAACKLAAAiiwAAIwsAACMLAAAjiwAAI4sAACQLAAAkCwAAJIsAACSLAAAlCwAAJQsAACWLAAAliwAAJgsAACYLAAAmiwAAJosAACcLAAAnCwAAJ4sAACeLAAAoCwAAKAsAACiLAAAoiwAAKQsAACkLAAApiwAAKYsAACoLAAAqCwAAKosAACqLAAArCwAAKwsAACuLAAAriwAALAsAACwLAAAsiwAALIsAAC0LAAAtCwAALYsAAC2LAAAuCwAALgsAAC6LAAAuiwAALwsAAC8LAAAviwAAL4sAADALAAAwCwAAMIsAADCLAAAxCwAAMQsAADGLAAAxiwAAMgsAADILAAAyiwAAMosAADMLAAAzCwAAM4sAADOLAAA0CwAANAsAADSLAAA0iwAANQsAADULAAA1iwAANYsAADYLAAA2CwAANosAADaLAAA3CwAANwsAADeLAAA3iwAAOAsAADgLAAA4iwAAOIsAADrLAAA6ywAAO0sAADtLAAA8iwAAPIsAABApgAAQKYAAEKmAABCpgAARKYAAESmAABGpgAARqYAAEimAABIpgAASqYAAEqmAABMpgAATKYAAE6mAABOpgAAUKYAAFCmAABSpgAAUqYAAFSmAABUpgAAVqYAAFamAABYpgAAWKYAAFqmAABapgAAXKYAAFymAABepgAAXqYAAGCmAABgpgAAYqYAAGKmAABkpgAAZKYAAGamAABmpgAAaKYAAGimAABqpgAAaqYAAGymAABspgAAgKYAAICmAACCpgAAgqYAAISmAACEpgAAhqYAAIamAACIpgAAiKYAAIqmAACKpgAAjKYAAIymAACOpgAAjqYAAJCmAACQpgAAkqYAAJKmAACUpgAAlKYAAJamAACWpgAAmKYAAJimAACapgAAmqYAACKnAAAipwAAJKcAACSnAAAmpwAAJqcAACinAAAopwAAKqcAACqnAAAspwAALKcAAC6nAAAupwAAMqcAADKnAAA0pwAANKcAADanAAA2pwAAOKcAADinAAA6pwAAOqcAADynAAA8pwAAPqcAAD6nAABApwAAQKcAAEKnAABCpwAARKcAAESnAABGpwAARqcAAEinAABIpwAASqcAAEqnAABMpwAATKcAAE6nAABOpwAAUKcAAFCnAABSpwAAUqcAAFSnAABUpwAAVqcAAFanAABYpwAAWKcAAFqnAABapwAAXKcAAFyn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AADHAAAAyAAAAMkAAADNjQEAAAAAAB8AAADKAAAAywAAAMwAAABjjQEAAAAAAB8AAADNAAAAzgAAAM8AAACVjAEAAAAAAB8AAADQAAAA0QAAANIAAAArjAEAAAAAAB8AAADTAAAA1AAAANUAAACyiwEAAAAAAB8AAADWAAAA1wAAANgAAABfiwEAAAAAAB8AAADZAAAA2gAAANsAAAAJiwEAAAAAAB8AAADcAAAA3QAAAN4AAAB1jAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAwAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcHAAAHBwcHAAcHAAMAAwADAwAAAwMDAwADAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAABwAABwcHBwAABwADAAAAAwMAAAMDAwMAAAMHBwcABwcHBwcHBwcHBwcHAAcHBwcHBwAHBwcHBwcHAwMDAwADAwMDAwMDAwMDAwMAAwMDAwMDAAMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAwcABwcAAAcHBwcABwAAAwADAAMDAAADAwMDBwMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHBwcHBwcHBwcHAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwMDAwMAAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcHBwAHAAcHAwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAwAAAAADAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwcHBwcABwcHBwcABwcAAwMDAwMDAAMDAwMDAAMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcAAAAABwAAAAAAAwAAAwADAAAAAAMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAwAHAwcABwAHAwcAAAcHAwcDBwMABwMDAwcDBwMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAMAAwAAAAAAAAAAAAcDAAADAAMABwMHAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcDBwAABwADAAcABwADBwAABwMHAAAAAwMDAAcDBwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwADAwAAAAAAAwAAAAAABwcABwcAAAAAAAcAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAcABwcHBwAAAAAAAAAAAAADAAMDAwMAAAAHAAcAAAAABwAAAAAHAAAAAwADAAAAAwMABwADAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAcHAAMAAAAAAAAHAAcHBwcDAAAAAAAAAAAAAwADAwMDAAcDBwAHAAAHAAcAAAAABwAABwMDAwAAAwADAAMHAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAABwAHAAcAAAAAAAAAAAAAAAMAAwADBwAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAwAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAADBwAHBwcABwAHBwMHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAHAAcAAAAAAAAAAAAAAAAAAwADAAAHAAAAAAAAAAAAAAMAAAAAAAAAAAAAAwAAAAADAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcAAAAABwAAAAAAAwAAAwADAAAAAAMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADW3AH8AQAAEAEAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANClwAAAAADQpcIwAAAFwgCQwNCwoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAASOAQCpjQEATI0BAGyMAQD6iwEAm4sBAEiLAQDjigEAuIoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBAwMDAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///z8/Pz8/PDwAAAAAAAAAMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKoAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg////////////////////////////////8A/woLDA0OD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6BEAgAoNQIATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAKBEAgBwNQIATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAACgRAIAvDUCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAoEQCAAg2AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAKBEAgAwNgIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAACgRAIAWDYCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAAoEQCAIA2AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAKBEAgCoNgIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAACgRAIA0DYCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAoEQCAPg2AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAKBEAgAgNwIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAACgRAIASDcCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAoEQCAHA3AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAKBEAgCYNwIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAACgRAIAwDcCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAAoEQCAOg3AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAGOSAQBhnQEAYZ0BAGGdAQBhnQEAYZ0BAGGdAQBhnQEAYZ0BAGGdAQB/f39/f39/f39/f39/fwAAmE8CAAAAAAAAAAAAAAAAANF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAAGQALABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZAAoKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRkAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAGQALDRkZGQANAAACAAkOAAAACQAOAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAABMAAAAAEwAAAAAJDAAAAAAADAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAPAAAABA8AAAAACRAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAAAAaGhoAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAXAAAAABcAAAAACRQAAAAAABQAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgAAAAAAAAAAAAAAFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGTm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgAAABIAAAABAAAAHAAAAB0AAAABAQAAHAAAAB0AAAABAQAADAAAAA0AAAABAQAAHAAAAB0AAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAB8AAAABAAAAHgAAAB8AAAABAAAAJAAAACUAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAkAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAADAAAAA0AAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAkAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAB8AAAABAAAAHgAAAB8AAAABAAAAHAAAAB0AAAABAQAAJAAAACUAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAJgAAACcAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACEAAAABAAAALgAAABIAAAABAAAAGAAAABkAAAABAAAALgAAABIAAAABAAAAJgAAACcAAAABAAAALgAAABIAAAABAAAAFAAAABQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAALAAAACwAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAABgAAAAAAAAAGAAAABgAAAAAAAAAKgAAACoAAAAAAAAAKgAAADQAAAAAAAAALgAAAC4AAAAAAAAAKAAAACgAAAAAAAAALgAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAgAAAFAAAAAAAAAAAAAADnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoAAAA6QAAAAhSAgAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACYTwIAAAAAAAUAAAAAAAAAAAAAAOoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOgAAADrAAAAGFICAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAD/////CgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBQAgAQWAIAAJQBD3RhcmdldF9mZWF0dXJlcwgrC2J1bGstbWVtb3J5Kw9idWxrLW1lbW9yeS1vcHQrFmNhbGwtaW5kaXJlY3Qtb3ZlcmxvbmcrCm11bHRpdmFsdWUrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsPcmVmZXJlbmNlLXR5cGVzKwhzaWduLWV4dA==');
}

function getBinarySync(file) {
  if (ArrayBuffer.isView(file)) {
    return file;
  }
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'both async and sync fetching of the wasm failed';
}

async function getWasmBinary(binaryFile) {

  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    // Warn on some common problems.
    if (isFileURI(wasmBinaryFile)) {
      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
    }
    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    

    wasmMemory = wasmExports['memory'];
    
    assert(wasmMemory, 'memory not found in wasm exports');
    updateMemoryViews();

    wasmTable = wasmExports['__indirect_function_table'];
    
    assert(wasmTable, 'table not found in wasm exports');

    assignWasmExports(wasmExports);
    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    return receiveInstance(result['instance']);
  }

  var info = getWasmImports();

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    return new Promise((resolve, reject) => {
      try {
        Module['instantiateWasm'](info, (mod, inst) => {
          resolve(receiveInstance(mod, inst));
        });
      } catch(e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        reject(e);
      }
    });
  }

  wasmBinaryFile ??= findWasmBinary();
  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
  var exports = receiveInstantiationResult(result);
  return exports;
}

// end include: preamble.js

// Begin JS library code


  class ExitStatus {
      name = 'ExitStatus';
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.push(cb);

  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.push(cb);

  /** @noinline */
  var base64Decode = (b64) => {
      {
        var buf = Buffer.from(b64, 'base64');
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
    };

  var noExitRuntime = true;

  var ptrToString = (ptr) => {
      assert(typeof ptr === 'number');
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      ptr >>>= 0;
      return '0x' + ptr.toString(16).padStart(8, '0');
    };

  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        text = 'warning: ' + text;
        err(text);
      }
    };

  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;
  
  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {
      var maxIdx = idx + maxBytesToRead;
      if (ignoreNul) return maxIdx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.
      // As a tiny code save trick, compare idx against maxIdx using a negation,
      // so that maxBytesToRead=undefined/NaN means Infinity.
      while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;
      return idx;
    };
  
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {
  
      var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);
  
      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index.
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : '';
    };
  var ___assert_fail = (condition, filename, line, func) =>
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);

  var __abort_js = () =>
      abort('native code called abort()');

  var AsciiToString = (ptr) => {
      var str = '';
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    };
  
  var awaitingDependencies = {
  };
  
  var registeredTypes = {
  };
  
  var typeDependencies = {
  };
  
  var BindingError =  class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};
  var throwBindingError = (message) => { throw new BindingError(message); };
  /** @param {Object=} options */
  function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name}' twice`);
        }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
  /** @param {Object=} options */
  function registerType(rawType, registeredInstance, options = {}) {
      return sharedRegisterType(rawType, registeredInstance, options);
    }
  
  var integerReadValueFromPointer = (name, width, signed) => {
      // integers are quite common, so generate very specialized functions
      switch (width) {
        case 1: return signed ?
          (pointer) => HEAP8[pointer] :
          (pointer) => HEAPU8[pointer];
        case 2: return signed ?
          (pointer) => HEAP16[((pointer)>>1)] :
          (pointer) => HEAPU16[((pointer)>>1)]
        case 4: return signed ?
          (pointer) => HEAP32[((pointer)>>2)] :
          (pointer) => HEAPU32[((pointer)>>2)]
        case 8: return signed ?
          (pointer) => HEAP64[((pointer)>>3)] :
          (pointer) => HEAPU64[((pointer)>>3)]
        default:
          throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };
  
  var embindRepr = (v) => {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    };
  
  var assertIntegerRange = (typeName, value, minRange, maxRange) => {
      if (value < minRange || value > maxRange) {
        throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${typeName}", which is outside the valid range [${minRange}, ${maxRange}]!`);
      }
    };
  /** @suppress {globalThis} */
  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
  
      const isUnsignedType = minRange === 0n;
  
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        // uint64 get converted to int64 in ABI, fix them up like we do for 32-bit integers.
        const bitSize = size * 8;
        fromWireType = (value) => {
          return BigInt.asUintN(bitSize, value);
        };
        maxRange = fromWireType(maxRange);
      }
  
      registerType(primitiveType, {
        name,
        fromWireType: fromWireType,
        toWireType: (destructors, value) => {
          if (typeof value == "number") {
            value = BigInt(value);
          }
          else if (typeof value != "bigint") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${this.name}`);
          }
          assertIntegerRange(name, value, minRange, maxRange);
          return value;
        },
        readValueFromPointer: integerReadValueFromPointer(name, size, !isUnsignedType),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  /** @suppress {globalThis} */
  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: function(wt) {
          // ambiguous emscripten ABI: sometimes return values are
          // true or false, and sometimes integers (0 or 1)
          return !!wt;
        },
        toWireType: function(destructors, o) {
          return o ? trueValue : falseValue;
        },
        readValueFromPointer: function(pointer) {
          return this.fromWireType(HEAPU8[pointer]);
        },
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  var emval_freelist = [];
  
  var emval_handles = [0,1,,1,null,1,true,1,false,1];
  var __emval_decref = (handle) => {
      if (handle > 9 && 0 === --emval_handles[handle + 1]) {
        assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);
        emval_handles[handle] = undefined;
        emval_freelist.push(handle);
      }
    };
  
  
  
  var Emval = {
  toValue:(handle) => {
        if (!handle) {
            throwBindingError(`Cannot use deleted val. handle = ${handle}`);
        }
        // handle 2 is supposed to be `undefined`.
        assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);
        return emval_handles[handle];
      },
  toHandle:(value) => {
        switch (value) {
          case undefined: return 2;
          case null: return 4;
          case true: return 6;
          case false: return 8;
          default:{
            const handle = emval_freelist.pop() || emval_handles.length;
            emval_handles[handle] = value;
            emval_handles[handle + 1] = 1;
            return handle;
          }
        }
      },
  };
  
  /** @suppress {globalThis} */
  function readPointer(pointer) {
      return this.fromWireType(HEAPU32[((pointer)>>2)]);
    }
  var EmValType = {
      name: 'emscripten::val',
      fromWireType: (handle) => {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      },
      toWireType: (destructors, value) => Emval.toHandle(value),
      readValueFromPointer: readPointer,
      destructorFunction: null, // This type does not need a destructor
  
      // TODO: do we need a deleteObject here?  write a test where
      // emval is passed into JS via an interface
    };
  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);

  var floatReadValueFromPointer = (name, width) => {
      switch (width) {
        case 4: return function(pointer) {
          return this.fromWireType(HEAPF32[((pointer)>>2)]);
        };
        case 8: return function(pointer) {
          return this.fromWireType(HEAPF64[((pointer)>>3)]);
        };
        default:
          throw new TypeError(`invalid float width (${width}): ${name}`);
      }
    };
  
  
  
  var __embind_register_float = (rawType, name, size) => {
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: (value) => value,
        toWireType: (destructors, value) => {
          if (typeof value != "number" && typeof value != "boolean") {
            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
          }
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        readValueFromPointer: floatReadValueFromPointer(name, size),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  var createNamedFunction = (name, func) => Object.defineProperty(func, 'name', { value: name });
  
  var runDestructors = (destructors) => {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    };
  
  
  function usesDestructorStack(argTypes) {
      // Skip return value at index 0 - it's not deleted here.
      for (var i = 1; i < argTypes.length; ++i) {
        // The type does not define a destructor function - must use dynamic stack
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
          return true;
        }
      }
      return false;
    }
  
  
  function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {
      if (numArgs < minArgs || numArgs > maxArgs) {
        var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;
        throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);
      }
    }
  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
      var needsDestructorStack = usesDestructorStack(argTypes);
      var argCount = argTypes.length - 2;
      var argsList = [];
      var argsListWired = ['fn'];
      for (var i = 0; i < argCount; ++i) {
        argsList.push(`arg${i}`);
        argsListWired.push(`arg${i}Wired`);
      }
      argsList = argsList.join(',');
      argsListWired = argsListWired.join(',');
  
      var invokerFnBody = `return function (${argsList}) {\n`;
  
      invokerFnBody += "checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "fromRetWire", "toClassParamWire"];
  
      for (var i = 0; i < argCount; ++i) {
        var argName = `toArg${i}Wire`;
        invokerFnBody += `var arg${i}Wired = ${argName}(${dtorStack}, arg${i});\n`;
        args1.push(argName);
      }
  
      invokerFnBody += (returns || isAsync ? "var rv = ":"") + `invoker(${argsListWired});\n`;
  
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = 2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
          var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += `${paramName}_dtor(${paramName});\n`;
            args1.push(`${paramName}_dtor`);
          }
        }
      }
  
      if (returns) {
        invokerFnBody += "var ret = fromRetWire(rv);\n" +
                         "return ret;\n";
      }
  
      invokerFnBody += "}\n";
  
      args1.push('checkArgCount', 'minArgs', 'maxArgs');
      invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + "Expected ${args1.length} closure arguments " + arguments.length + " given."); }\n${invokerFnBody}`;
      return new Function(args1, invokerFnBody);
    }
  
  function getRequiredArgCount(argTypes) {
      var requiredArgCount = argTypes.length - 2;
      for (var i = argTypes.length - 1; i >= 2; --i) {
        if (!argTypes[i].optional) {
          break;
        }
        requiredArgCount--;
      }
      return requiredArgCount;
    }
  
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      assert(!isAsync, 'Async bindings are only supported with JSPI.');
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
      // TODO: This omits argument count check - enable only at -O3 or similar.
      //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
      //       return FUNCTION_TABLE[fn];
      //    }
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = usesDestructorStack(argTypes);
  
      var returns = !argTypes[0].isVoid;
  
      var expectedArgCount = argCount - 2;
      var minArgs = getRequiredArgCount(argTypes);
      // Builld the arguments that will be passed into the closure around the invoker
      // function.
      var retType = argTypes[0];
      var instType = argTypes[1];
      var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, retType.fromWireType.bind(retType), instType?.toWireType.bind(instType)];
      for (var i = 2; i < argCount; ++i) {
        var argType = argTypes[i];
        closureArgs.push(argType.toWireType.bind(argType));
      }
      if (!needsDestructorStack) {
        // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
        for (var i = 2; i < argTypes.length; ++i) {
          if (argTypes[i].destructorFunction !== null) {
            closureArgs.push(argTypes[i].destructorFunction);
          }
        }
      }
      closureArgs.push(checkArgCount, minArgs, expectedArgCount);
  
      let invokerFactory = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
      var invokerFn = invokerFactory(...closureArgs);
      return createNamedFunction(humanName, invokerFn);
    }
  
  var ensureOverloadTable = (proto, methodName, humanName) => {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function(...args) {
          // TODO This check can be removed in -O3 level "unsafe" optimizations.
          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[args.length].apply(this, args);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    };
  
  /** @param {number=} numArguments */
  var exposePublicSymbol = (name, value, numArguments) => {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
          throwBindingError(`Cannot register public name '${name}' twice`);
        }
  
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module[name].overloadTable.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
  
  var heap32VectorToArray = (count, firstElement) => {
      var array = [];
      for (var i = 0; i < count; i++) {
        // TODO(https://github.com/emscripten-core/emscripten/issues/17310):
        // Find a way to hoist the `>> 2` or `>> 3` out of this loop.
        array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);
      }
      return array;
    };
  
  
  var InternalError =  class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};
  var throwInternalError = (message) => { throw new InternalError(message); };
  /** @param {number=} numArguments */
  var replacePublicSymbol = (name, value, numArguments) => {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistent public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
  
  
  
  var wasmTableMirror = [];
  
  /** @type {WebAssembly.Table} */
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        /** @suppress {checkTypes} */
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      /** @suppress {checkTypes} */
      assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');
      return func;
    };
  var embind__requireFunction = (signature, rawFunction, isAsync = false) => {
      assert(!isAsync, 'Async bindings are only supported with JSPI.');
  
      signature = AsciiToString(signature);
  
      function makeDynCaller() {
        var rtn = getWasmTableEntry(rawFunction);
        return rtn;
      }
  
      var fp = makeDynCaller();
      if (typeof fp != 'function') {
          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    };
  
  
  
  class UnboundTypeError extends Error {}
  
  
  
  var getTypeName = (type) => {
      var ptr = ___getTypeName(type);
      var rv = AsciiToString(ptr);
      _free(ptr);
      return rv;
    };
  var throwUnboundTypeError = (message, types) => {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));
    };
  
  
  
  
  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
  
      function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError('Mismatched type converter count');
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    };
  
  var getFunctionName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(");
      if (argsIndex === -1) return signature;
      assert(signature.endsWith(")"), "Parentheses for argument names should match.");
      return signature.slice(0, argsIndex);
    };
  var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = AsciiToString(name);
      name = getFunctionName(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);
  
      exposePublicSymbol(name, function() {
        throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, (argTypes) => {
        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync), argCount - 1);
        return [];
      });
    };

  
  
  
  
  /** @suppress {globalThis} */
  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
  
      const isUnsignedType = minRange === 0;
  
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        var bitshift = 32 - 8*size;
        fromWireType = (value) => (value << bitshift) >>> bitshift;
        maxRange = fromWireType(maxRange);
      }
  
      registerType(primitiveType, {
        name,
        fromWireType: fromWireType,
        toWireType: (destructors, value) => {
          if (typeof value != "number" && typeof value != "boolean") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${name}`);
          }
          assertIntegerRange(name, value, minRange, maxRange);
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
        BigInt64Array,
        BigUint64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
        var size = HEAPU32[((handle)>>2)];
        var data = HEAPU32[(((handle)+(4))>>2)];
        return new TA(HEAP8.buffer, data, size);
      }
  
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: decodeMemoryView,
        readValueFromPointer: decodeMemoryView,
      }, {
        ignoreDuplicateRegistrations: true,
      });
    };

  
  
  
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.codePointAt(i);
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
          // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
          // We need to manually skip over the second code unit for correct iteration.
          i++;
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  
  
  var __embind_register_std_string = (rawType, name) => {
      name = AsciiToString(name);
  
      registerType(rawType, {
        name,
        // For some method names we use string keys here since they are part of
        // the public/external API and/or used by the runtime-generated code.
        fromWireType(value) {
          var length = HEAPU32[((value)>>2)];
          var payload = value + 4;
  
          var str;
          {
            str = UTF8ToString(payload, length, true);
          }
  
          _free(value);
  
          return str;
        },
        toWireType(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
  
          var length;
          var valueIsOfTypeString = (typeof value == 'string');
  
          // We accept `string` or array views with single byte elements
          if (!(valueIsOfTypeString || (ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1))) {
            throwBindingError('Cannot pass non-string to std::string');
          }
          if (valueIsOfTypeString) {
            length = lengthBytesUTF8(value);
          } else {
            length = value.length;
          }
  
          // assumes POINTER_SIZE alignment
          var base = _malloc(4 + length + 1);
          var ptr = base + 4;
          HEAPU32[((base)>>2)] = length;
          if (valueIsOfTypeString) {
            {
              stringToUTF8(value, ptr, length + 1);
            }
          } else {
            HEAPU8.set(value, ptr);
          }
  
          if (destructors !== null) {
            destructors.push(_free, base);
          }
          return base;
        },
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        },
      });
    };

  
  
  
  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;  
  var UTF16ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
      var idx = ((ptr)>>1);
      var endIdx = findStringEnd(HEAPU16, idx, maxBytesToRead / 2, ignoreNul);
  
      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
      if (endIdx - idx > 16 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));
  
      // Fallback: decode without UTF16Decoder
      var str = '';
  
      // If maxBytesToRead is not passed explicitly, it will be undefined, and the
      // for-loop's condition will always evaluate to true. The loop is then
      // terminated on the first null char.
      for (var i = idx; i < endIdx; ++i) {
        var codeUnit = HEAPU16[i];
        // fromCharCode constructs a character from a UTF-16 code unit, so we can
        // pass the UTF16 string right through.
        str += String.fromCharCode(codeUnit);
      }
  
      return str;
    };
  
  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2; // Null terminator.
      var startPtr = outPtr;
      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        HEAP16[((outPtr)>>1)] = codeUnit;
        outPtr += 2;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP16[((outPtr)>>1)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF16 = (str) => str.length*2;
  
  var UTF32ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
      var str = '';
      var startIdx = ((ptr)>>2);
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      for (var i = 0; !(i >= maxBytesToRead / 4); i++) {
        var utf32 = HEAPU32[startIdx + i];
        if (!utf32 && !ignoreNul) break;
        str += String.fromCodePoint(utf32);
      }
      return str;
    };
  
  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
        // We need to manually skip over the second code unit for correct iteration.
        if (codePoint > 0xFFFF) {
          i++;
        }
        HEAP32[((outPtr)>>2)] = codePoint;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP32[((outPtr)>>2)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
        // We need to manually skip over the second code unit for correct iteration.
        if (codePoint > 0xFFFF) {
          i++;
        }
        len += 4;
      }
  
      return len;
    };
  var __embind_register_std_wstring = (rawType, charSize, name) => {
      name = AsciiToString(name);
      var decodeString, encodeString, lengthBytesUTF;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
      } else {
        assert(charSize === 4, 'only 2-byte and 4-byte strings are currently supported');
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
      }
      registerType(rawType, {
        name,
        fromWireType: (value) => {
          // Code mostly taken from _embind_register_std_string fromWireType
          var length = HEAPU32[((value)>>2)];
          var str = decodeString(value + 4, length * charSize, true);
  
          _free(value);
  
          return str;
        },
        toWireType: (destructors, value) => {
          if (!(typeof value == 'string')) {
            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
          }
  
          // assumes POINTER_SIZE alignment
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[((ptr)>>2)] = length / charSize;
  
          encodeString(value, ptr + 4, length + charSize);
  
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        }
      });
    };

  
  var __embind_register_void = (rawType, name) => {
      name = AsciiToString(name);
      registerType(rawType, {
        isVoid: true, // void return values can be optimized out sometimes
        name,
        fromWireType: () => undefined,
        // TODO: assert if anything else is given?
        toWireType: (destructors, o) => undefined,
      });
    };

  var emval_methodCallers = [];
  var emval_addMethodCaller = (caller) => {
      var id = emval_methodCallers.length;
      emval_methodCallers.push(caller);
      return id;
    };
  
  
  
  var requireRegisteredType = (rawType, humanName) => {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
        throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);
      }
      return impl;
    };
  var emval_lookupTypes = (argCount, argTypes) => {
      var a = new Array(argCount);
      for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAPU32[(((argTypes)+(i*4))>>2)],
                                     `parameter ${i}`);
      }
      return a;
    };
  
  
  var emval_returnValue = (toReturnWire, destructorsRef, handle) => {
      var destructors = [];
      var result = toReturnWire(destructors, handle);
      if (destructors.length) {
        // void, primitives and any other types w/o destructors don't need to allocate a handle
        HEAPU32[((destructorsRef)>>2)] = Emval.toHandle(destructors);
      }
      return result;
    };
  
  
  var emval_symbols = {
  };
  
  var getStringOrSymbol = (address) => {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
        return AsciiToString(address);
      }
      return symbol;
    };
  var __emval_create_invoker = (argCount, argTypesPtr, kind) => {
      var GenericWireTypeSize = 8;
  
      var [retType, ...argTypes] = emval_lookupTypes(argCount, argTypesPtr);
      var toReturnWire = retType.toWireType.bind(retType);
      var argFromPtr = argTypes.map(type => type.readValueFromPointer.bind(type));
      argCount--; // remove the extracted return type
  
      var captures = {'toValue': Emval.toValue};
      var args = argFromPtr.map((argFromPtr, i) => {
        var captureName = `argFromPtr${i}`;
        captures[captureName] = argFromPtr;
        return `${captureName}(args${i ? '+' + i * GenericWireTypeSize : ''})`;
      });
      var functionBody;
      switch (kind){
        case 0:
          functionBody = 'toValue(handle)';
          break;
        case 2:
          functionBody = 'new (toValue(handle))';
          break;
        case 3:
          functionBody = '';
          break;
        case 1:
          captures['getStringOrSymbol'] = getStringOrSymbol;
          functionBody = 'toValue(handle)[getStringOrSymbol(methodName)]';
          break;
      }
      functionBody += `(${args})`;
      if (!retType.isVoid) {
        captures['toReturnWire'] = toReturnWire;
        captures['emval_returnValue'] = emval_returnValue;
        functionBody = `return emval_returnValue(toReturnWire, destructorsRef, ${functionBody})`;
      }
      functionBody = `return function (handle, methodName, destructorsRef, args) {
  ${functionBody}
  }`;
  
      var invokerFunction = new Function(Object.keys(captures), functionBody)(...Object.values(captures));
      var functionName = `methodCaller<(${argTypes.map(t => t.name)}) => ${retType.name}>`;
      return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
    };


  
  
  var emval_get_global = () => globalThis;
  var __emval_get_global = (name) => {
      if (name===0) {
        return Emval.toHandle(emval_get_global());
      } else {
        name = getStringOrSymbol(name);
        return Emval.toHandle(emval_get_global()[name]);
      }
    };

  var __emval_get_property = (handle, key) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    };

  var __emval_incref = (handle) => {
      if (handle > 9) {
        emval_handles[handle + 1] += 1;
      }
    };

  
  
  var __emval_invoke = (caller, handle, methodName, destructorsRef, args) => {
      return emval_methodCallers[caller](handle, methodName, destructorsRef, args);
    };

  var __emval_new_array = () => Emval.toHandle([]);

  
  var __emval_new_cstring = (v) => Emval.toHandle(getStringOrSymbol(v));

  var __emval_new_object = () => Emval.toHandle({});

  
  
  var __emval_run_destructors = (handle) => {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    };

  var __emval_set_property = (handle, key, value) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      value = Emval.toValue(value);
      handle[key] = value;
    };

  var __emval_typeof = (handle) => {
      handle = Emval.toValue(handle);
      return Emval.toHandle(typeof handle);
    };
  function __munmap_js(addr, len, prot, flags, fd, offset) {
  }

  var getHeapMax = () =>
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648;
  
  var alignMemory = (size, alignment) => {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    };
  
  var growMemory = (size) => {
      var oldHeapSize = wasmMemory.buffer.byteLength;
      var pages = ((size - oldHeapSize + 65535) / 65536) | 0;
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
        updateMemoryViews();
        return 1 /*success*/;
      } catch(e) {
        err(`growMemory: Attempted to grow heap from ${oldHeapSize} bytes to ${size} bytes, but got error: ${e}`);
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
      assert(requestedSize > oldSize);
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
        return false;
      }
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = growMemory(newSize);
        if (replacement) {
  
          return true;
        }
      }
      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
      return false;
    };

  
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
      if (!keepRuntimeAlive()) {
        Module['onExit']?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
  
  
  /** @suppress {duplicate } */
  /** @param {boolean|number=} implicit */
  var exitJS = (status, implicit) => {
  
      checkUnflushedContent();
  
      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
      if (keepRuntimeAlive() && !implicit) {
        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
        readyPromiseReject?.(msg);
        err(msg);
      }
  
      _proc_exit(status);
    };
  var _exit = exitJS;
  var _fd_close = (fd) => {
      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');
    };

  function _fd_seek(fd, offset, whence, newOffset) {
  
  
      return 70;
  }

  var printCharBuffers = [null,[],[]];
  
  var printChar = (stream, curr) => {
      var buffer = printCharBuffers[stream];
      assert(buffer);
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    };
  
  var flush_NO_FILESYSTEM = () => {
      // flush anything remaining in the buffers during shutdown
      _fflush(0);
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    };
  
  
  var _fd_write = (fd, iov, iovcnt, pnum) => {
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr+j]);
        }
        num += len;
      }
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    };

    // Precreate a reverse lookup table from chars
    // "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" back to
    // bytes to make decoding fast.
    for (var base64ReverseLookup = new Uint8Array(123/*'z'+1*/), i = 25; i >= 0; --i) {
      base64ReverseLookup[48+i] = 52+i; // '0-9'
      base64ReverseLookup[65+i] = i; // 'A-Z'
      base64ReverseLookup[97+i] = 26+i; // 'a-z'
    }
    base64ReverseLookup[43] = 62; // '+'
    base64ReverseLookup[47] = 63; // '/'
assert(emval_handles.length === 5 * 2);
// End JS library code

// include: postlibrary.js
// This file is included after the automatically-generated JS library code
// but before the wasm module is created.

{

  // Begin ATMODULES hooks
  if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];
if (Module['print']) out = Module['print'];
if (Module['printErr']) err = Module['printErr'];
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];

Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;

  // End ATMODULES hooks

  checkIncomingModuleAPI();

  if (Module['arguments']) Module['arguments'];
  if (Module['thisProgram']) Module['thisProgram'];

  // Assertions on removed incoming Module JS APIs.
  assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');
  assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
  assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
  assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');
  assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
  assert(typeof Module['ENVIRONMENT'] == 'undefined', 'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
  assert(typeof Module['STACK_SIZE'] == 'undefined', 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');
  // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
  assert(typeof Module['wasmMemory'] == 'undefined', 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
  assert(typeof Module['INITIAL_MEMORY'] == 'undefined', 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');

}

// Begin runtime exports
  var missingLibrarySymbols = [
  'writeI53ToI64',
  'writeI53ToI64Clamped',
  'writeI53ToI64Signaling',
  'writeI53ToU64Clamped',
  'writeI53ToU64Signaling',
  'readI53FromI64',
  'readI53FromU64',
  'convertI32PairToI53',
  'convertI32PairToI53Checked',
  'convertU32PairToI53',
  'stackAlloc',
  'getTempRet0',
  'setTempRet0',
  'zeroMemory',
  'withStackSave',
  'strError',
  'inetPton4',
  'inetNtop4',
  'inetPton6',
  'inetNtop6',
  'readSockaddr',
  'writeSockaddr',
  'readEmAsmArgs',
  'jstoi_q',
  'getExecutableName',
  'autoResumeAudioContext',
  'getDynCaller',
  'dynCall',
  'handleException',
  'runtimeKeepalivePush',
  'runtimeKeepalivePop',
  'callUserCallback',
  'maybeExit',
  'asmjsMangle',
  'asyncLoad',
  'mmapAlloc',
  'HandleAllocator',
  'getNativeTypeSize',
  'getUniqueRunDependency',
  'addOnInit',
  'addOnPostCtor',
  'addOnPreMain',
  'addOnExit',
  'STACK_SIZE',
  'STACK_ALIGN',
  'POINTER_SIZE',
  'ASSERTIONS',
  'ccall',
  'cwrap',
  'convertJsFunctionToWasm',
  'getEmptyTableSlot',
  'updateTableMap',
  'getFunctionAddress',
  'addFunction',
  'removeFunction',
  'intArrayFromString',
  'intArrayToString',
  'stringToAscii',
  'stringToNewUTF8',
  'stringToUTF8OnStack',
  'writeArrayToMemory',
  'registerKeyEventCallback',
  'maybeCStringToJsString',
  'findEventTarget',
  'getBoundingClientRect',
  'fillMouseEventData',
  'registerMouseEventCallback',
  'registerWheelEventCallback',
  'registerUiEventCallback',
  'registerFocusEventCallback',
  'fillDeviceOrientationEventData',
  'registerDeviceOrientationEventCallback',
  'fillDeviceMotionEventData',
  'registerDeviceMotionEventCallback',
  'screenOrientation',
  'fillOrientationChangeEventData',
  'registerOrientationChangeEventCallback',
  'fillFullscreenChangeEventData',
  'registerFullscreenChangeEventCallback',
  'JSEvents_requestFullscreen',
  'JSEvents_resizeCanvasForFullscreen',
  'registerRestoreOldStyle',
  'hideEverythingExceptGivenElement',
  'restoreHiddenElements',
  'setLetterbox',
  'softFullscreenResizeWebGLRenderTarget',
  'doRequestFullscreen',
  'fillPointerlockChangeEventData',
  'registerPointerlockChangeEventCallback',
  'registerPointerlockErrorEventCallback',
  'requestPointerLock',
  'fillVisibilityChangeEventData',
  'registerVisibilityChangeEventCallback',
  'registerTouchEventCallback',
  'fillGamepadEventData',
  'registerGamepadEventCallback',
  'registerBeforeUnloadEventCallback',
  'fillBatteryEventData',
  'registerBatteryEventCallback',
  'setCanvasElementSize',
  'getCanvasElementSize',
  'jsStackTrace',
  'getCallstack',
  'convertPCtoSourceLocation',
  'getEnvStrings',
  'checkWasiClock',
  'wasiRightsToMuslOFlags',
  'wasiOFlagsToMuslOFlags',
  'initRandomFill',
  'randomFill',
  'safeSetTimeout',
  'setImmediateWrapped',
  'safeRequestAnimationFrame',
  'clearImmediateWrapped',
  'registerPostMainLoop',
  'registerPreMainLoop',
  'getPromise',
  'makePromise',
  'idsToPromises',
  'makePromiseCallback',
  'ExceptionInfo',
  'findMatchingCatch',
  'Browser_asyncPrepareDataCounter',
  'isLeapYear',
  'ydayFromDate',
  'arraySum',
  'addDays',
  'getSocketFromFD',
  'getSocketAddress',
  'FS_createPreloadedFile',
  'FS_modeStringToFlags',
  'FS_getMode',
  'FS_stdin_getChar',
  'FS_mkdirTree',
  '_setNetworkCallback',
  'heapObjectForWebGLType',
  'toTypedArrayIndex',
  'webgl_enable_ANGLE_instanced_arrays',
  'webgl_enable_OES_vertex_array_object',
  'webgl_enable_WEBGL_draw_buffers',
  'webgl_enable_WEBGL_multi_draw',
  'webgl_enable_EXT_polygon_offset_clamp',
  'webgl_enable_EXT_clip_control',
  'webgl_enable_WEBGL_polygon_mode',
  'emscriptenWebGLGet',
  'computeUnpackAlignedImageSize',
  'colorChannelsInGlTextureFormat',
  'emscriptenWebGLGetTexPixelData',
  'emscriptenWebGLGetUniform',
  'webglGetUniformLocation',
  'webglPrepareUniformLocationsBeforeFirstUse',
  'webglGetLeftBracePos',
  'emscriptenWebGLGetVertexAttrib',
  '__glGetActiveAttribOrUniform',
  'writeGLArray',
  'registerWebGlEventCallback',
  'runAndAbortIfError',
  'ALLOC_NORMAL',
  'ALLOC_STACK',
  'allocate',
  'writeStringToMemory',
  'writeAsciiToMemory',
  'demangle',
  'stackTrace',
  'getFunctionArgsName',
  'createJsInvokerSignature',
  'PureVirtualError',
  'getBasestPointer',
  'registerInheritedInstance',
  'unregisterInheritedInstance',
  'getInheritedInstance',
  'getInheritedInstanceCount',
  'getLiveInheritedInstances',
  'enumReadValueFromPointer',
  'genericPointerToWireType',
  'constNoSmartPtrRawPointerToWireType',
  'nonConstNoSmartPtrRawPointerToWireType',
  'init_RegisteredPointer',
  'RegisteredPointer',
  'RegisteredPointer_fromWireType',
  'runDestructor',
  'releaseClassHandle',
  'detachFinalizer',
  'attachFinalizer',
  'makeClassHandle',
  'init_ClassHandle',
  'ClassHandle',
  'throwInstanceAlreadyDeleted',
  'flushPendingDeletes',
  'setDelayFunction',
  'RegisteredClass',
  'shallowCopyInternalPointer',
  'downcastPointer',
  'upcastPointer',
  'validateThis',
  'char_0',
  'char_9',
  'makeLegalFunctionName',
  'count_emval_handles',
];
missingLibrarySymbols.forEach(missingLibrarySymbol);

  var unexportedSymbols = [
  'run',
  'addRunDependency',
  'removeRunDependency',
  'out',
  'err',
  'callMain',
  'abort',
  'wasmMemory',
  'wasmExports',
  'HEAPF32',
  'HEAPF64',
  'HEAP8',
  'HEAPU8',
  'HEAP16',
  'HEAPU16',
  'HEAP32',
  'HEAPU32',
  'HEAP64',
  'HEAPU64',
  'writeStackCookie',
  'checkStackCookie',
  'INT53_MAX',
  'INT53_MIN',
  'bigintToI53Checked',
  'stackSave',
  'stackRestore',
  'ptrToString',
  'exitJS',
  'getHeapMax',
  'growMemory',
  'ENV',
  'ERRNO_CODES',
  'DNS',
  'Protocols',
  'Sockets',
  'timers',
  'warnOnce',
  'readEmAsmArgsArray',
  'keepRuntimeAlive',
  'alignMemory',
  'wasmTable',
  'noExitRuntime',
  'addOnPreRun',
  'addOnPostRun',
  'freeTableIndexes',
  'functionsInTableMap',
  'setValue',
  'getValue',
  'PATH',
  'PATH_FS',
  'UTF8Decoder',
  'UTF8ArrayToString',
  'UTF8ToString',
  'stringToUTF8Array',
  'stringToUTF8',
  'lengthBytesUTF8',
  'AsciiToString',
  'UTF16Decoder',
  'UTF16ToString',
  'stringToUTF16',
  'lengthBytesUTF16',
  'UTF32ToString',
  'stringToUTF32',
  'lengthBytesUTF32',
  'JSEvents',
  'specialHTMLTargets',
  'findCanvasEventTarget',
  'currentFullscreenStrategy',
  'restoreOldWindowedStyle',
  'UNWIND_CACHE',
  'ExitStatus',
  'flush_NO_FILESYSTEM',
  'emSetImmediate',
  'emClearImmediate_deps',
  'emClearImmediate',
  'promiseMap',
  'uncaughtExceptionCount',
  'exceptionLast',
  'exceptionCaught',
  'Browser',
  'requestFullscreen',
  'requestFullScreen',
  'setCanvasSize',
  'getUserMedia',
  'createContext',
  'getPreloadedImageData__data',
  'wget',
  'MONTH_DAYS_REGULAR',
  'MONTH_DAYS_LEAP',
  'MONTH_DAYS_REGULAR_CUMULATIVE',
  'MONTH_DAYS_LEAP_CUMULATIVE',
  'base64Decode',
  'SYSCALLS',
  'preloadPlugins',
  'FS_stdin_getChar_buffer',
  'FS_unlink',
  'FS_createPath',
  'FS_createDevice',
  'FS_readFile',
  'FS',
  'FS_root',
  'FS_mounts',
  'FS_devices',
  'FS_streams',
  'FS_nextInode',
  'FS_nameTable',
  'FS_currentPath',
  'FS_initialized',
  'FS_ignorePermissions',
  'FS_filesystems',
  'FS_syncFSRequests',
  'FS_readFiles',
  'FS_lookupPath',
  'FS_getPath',
  'FS_hashName',
  'FS_hashAddNode',
  'FS_hashRemoveNode',
  'FS_lookupNode',
  'FS_createNode',
  'FS_destroyNode',
  'FS_isRoot',
  'FS_isMountpoint',
  'FS_isFile',
  'FS_isDir',
  'FS_isLink',
  'FS_isChrdev',
  'FS_isBlkdev',
  'FS_isFIFO',
  'FS_isSocket',
  'FS_flagsToPermissionString',
  'FS_nodePermissions',
  'FS_mayLookup',
  'FS_mayCreate',
  'FS_mayDelete',
  'FS_mayOpen',
  'FS_checkOpExists',
  'FS_nextfd',
  'FS_getStreamChecked',
  'FS_getStream',
  'FS_createStream',
  'FS_closeStream',
  'FS_dupStream',
  'FS_doSetAttr',
  'FS_chrdev_stream_ops',
  'FS_major',
  'FS_minor',
  'FS_makedev',
  'FS_registerDevice',
  'FS_getDevice',
  'FS_getMounts',
  'FS_syncfs',
  'FS_mount',
  'FS_unmount',
  'FS_lookup',
  'FS_mknod',
  'FS_statfs',
  'FS_statfsStream',
  'FS_statfsNode',
  'FS_create',
  'FS_mkdir',
  'FS_mkdev',
  'FS_symlink',
  'FS_rename',
  'FS_rmdir',
  'FS_readdir',
  'FS_readlink',
  'FS_stat',
  'FS_fstat',
  'FS_lstat',
  'FS_doChmod',
  'FS_chmod',
  'FS_lchmod',
  'FS_fchmod',
  'FS_doChown',
  'FS_chown',
  'FS_lchown',
  'FS_fchown',
  'FS_doTruncate',
  'FS_truncate',
  'FS_ftruncate',
  'FS_utime',
  'FS_open',
  'FS_close',
  'FS_isClosed',
  'FS_llseek',
  'FS_read',
  'FS_write',
  'FS_mmap',
  'FS_msync',
  'FS_ioctl',
  'FS_writeFile',
  'FS_cwd',
  'FS_chdir',
  'FS_createDefaultDirectories',
  'FS_createDefaultDevices',
  'FS_createSpecialDirectories',
  'FS_createStandardStreams',
  'FS_staticInit',
  'FS_init',
  'FS_quit',
  'FS_findObject',
  'FS_analyzePath',
  'FS_createFile',
  'FS_createDataFile',
  'FS_forceLoadFile',
  'FS_createLazyFile',
  'FS_absolutePath',
  'FS_createFolder',
  'FS_createLink',
  'FS_joinPath',
  'FS_mmapAlloc',
  'FS_standardizePath',
  'MEMFS',
  'TTY',
  'PIPEFS',
  'SOCKFS',
  'tempFixedLengthArray',
  'miniTempWebGLFloatBuffers',
  'miniTempWebGLIntBuffers',
  'GL',
  'AL',
  'GLUT',
  'EGL',
  'GLEW',
  'IDBStore',
  'SDL',
  'SDL_gfx',
  'allocateUTF8',
  'allocateUTF8OnStack',
  'print',
  'printErr',
  'jstoi_s',
  'InternalError',
  'BindingError',
  'throwInternalError',
  'throwBindingError',
  'registeredTypes',
  'awaitingDependencies',
  'typeDependencies',
  'tupleRegistrations',
  'structRegistrations',
  'sharedRegisterType',
  'whenDependentTypesAreResolved',
  'getTypeName',
  'getFunctionName',
  'heap32VectorToArray',
  'requireRegisteredType',
  'usesDestructorStack',
  'checkArgCount',
  'getRequiredArgCount',
  'createJsInvoker',
  'UnboundTypeError',
  'EmValType',
  'EmValOptionalType',
  'throwUnboundTypeError',
  'ensureOverloadTable',
  'exposePublicSymbol',
  'replacePublicSymbol',
  'createNamedFunction',
  'embindRepr',
  'registeredInstances',
  'registeredPointers',
  'registerType',
  'integerReadValueFromPointer',
  'floatReadValueFromPointer',
  'assertIntegerRange',
  'readPointer',
  'runDestructors',
  'craftInvokerFunction',
  'embind__requireFunction',
  'finalizationRegistry',
  'detachFinalizer_deps',
  'deletionQueue',
  'delayFunction',
  'emval_freelist',
  'emval_handles',
  'emval_symbols',
  'getStringOrSymbol',
  'Emval',
  'emval_get_global',
  'emval_returnValue',
  'emval_lookupTypes',
  'emval_methodCallers',
  'emval_addMethodCaller',
];
unexportedSymbols.forEach(unexportedRuntimeSymbol);

  // End runtime exports
  // Begin JS library exports
  // End JS library exports

// end include: postlibrary.js

function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}

// Imports from the Wasm binary.
var _malloc = makeInvalidEarlyAccess('_malloc');
var _free = makeInvalidEarlyAccess('_free');
var _fflush = makeInvalidEarlyAccess('_fflush');
var ___getTypeName = makeInvalidEarlyAccess('___getTypeName');
var _emscripten_stack_get_end = makeInvalidEarlyAccess('_emscripten_stack_get_end');
var _emscripten_stack_init = makeInvalidEarlyAccess('_emscripten_stack_init');

function assignWasmExports(wasmExports) {
  _malloc = createExportWrapper('malloc', 1);
  _free = createExportWrapper('free', 1);
  _fflush = createExportWrapper('fflush', 1);
  ___getTypeName = createExportWrapper('__getTypeName', 1);
  _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];
  wasmExports['emscripten_stack_get_base'];
  _emscripten_stack_init = wasmExports['emscripten_stack_init'];
  wasmExports['emscripten_stack_get_free'];
  wasmExports['_emscripten_stack_restore'];
  wasmExports['_emscripten_stack_alloc'];
  wasmExports['emscripten_stack_get_current'];
}
var wasmImports = {
  /** @export */
  __assert_fail: ___assert_fail,
  /** @export */
  _abort_js: __abort_js,
  /** @export */
  _embind_register_bigint: __embind_register_bigint,
  /** @export */
  _embind_register_bool: __embind_register_bool,
  /** @export */
  _embind_register_emval: __embind_register_emval,
  /** @export */
  _embind_register_float: __embind_register_float,
  /** @export */
  _embind_register_function: __embind_register_function,
  /** @export */
  _embind_register_integer: __embind_register_integer,
  /** @export */
  _embind_register_memory_view: __embind_register_memory_view,
  /** @export */
  _embind_register_std_string: __embind_register_std_string,
  /** @export */
  _embind_register_std_wstring: __embind_register_std_wstring,
  /** @export */
  _embind_register_void: __embind_register_void,
  /** @export */
  _emval_create_invoker: __emval_create_invoker,
  /** @export */
  _emval_decref: __emval_decref,
  /** @export */
  _emval_get_global: __emval_get_global,
  /** @export */
  _emval_get_property: __emval_get_property,
  /** @export */
  _emval_incref: __emval_incref,
  /** @export */
  _emval_invoke: __emval_invoke,
  /** @export */
  _emval_new_array: __emval_new_array,
  /** @export */
  _emval_new_cstring: __emval_new_cstring,
  /** @export */
  _emval_new_object: __emval_new_object,
  /** @export */
  _emval_run_destructors: __emval_run_destructors,
  /** @export */
  _emval_set_property: __emval_set_property,
  /** @export */
  _emval_typeof: __emval_typeof,
  /** @export */
  _munmap_js: __munmap_js,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  exit: _exit,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_write: _fd_write
};
var wasmExports = await createWasm();


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

var calledRun;

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run() {

  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    assert(!calledRun);
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve?.(Module);
    Module['onRuntimeInitialized']?.();
    consumedModuleProp('onRuntimeInitialized');

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  };
  try { // it doesn't matter if it fails
    flush_NO_FILESYSTEM();
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');
  }
}

function preInit() {
  if (Module['preInit']) {
    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
    while (Module['preInit'].length > 0) {
      Module['preInit'].shift()();
    }
  }
  consumedModuleProp('preInit');
}

preInit();
run();

// end include: postamble.js

// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
//
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.

if (runtimeInitialized)  {
  moduleRtn = Module;
} else {
  // Set up the promise that indicates the Module is initialized
  moduleRtn = new Promise((resolve, reject) => {
    readyPromiseResolve = resolve;
    readyPromiseReject = reject;
  });
}

// Assertion for attempting to access module properties on the incoming
// moduleArg.  In the past we used this object as the prototype of the module
// and assigned properties to it, but now we return a distinct object.  This
// keeps the instance private until it is ready (i.e the promise has been
// resolved).
for (const prop of Object.keys(Module)) {
  if (!(prop in moduleArg)) {
    Object.defineProperty(moduleArg, prop, {
      configurable: true,
      get() {
        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);
      }
    });
  }
}
// end include: postamble_modularize.js



  return moduleRtn;
}

/**
 * An instance of the `Herb` class using a Node.js WASM backend.
 * This loads `libherb` in Node.js using WebAssembly (WASM).
 */
const Herb = new HerbBackendNodeWASM(Herb$1);

class ErrorVisitor extends Visitor$1 {
    constructor() {
        super(...arguments);
        this.source = "Herb Parser ";
        this.diagnostics = [];
    }
    visitChildNodes(node) {
        super.visitChildNodes(node);
        node.errors.forEach(error => this.addDiagnosticForError(error, node));
    }
    addDiagnosticForError(error, node) {
        const diagnostic = {
            source: this.source,
            severity: nodeExports.DiagnosticSeverity.Error,
            range: this.rangeFromHerbError(error),
            message: error.message,
            code: error.type,
            data: {
                error: error.toJSON(),
                node: node.toJSON()
            }
        };
        this.diagnostics.push(diagnostic);
    }
    rangeFromHerbError(error) {
        return nodeExports.Range.create(nodeExports.Position.create(error.location.start.line - 1, error.location.start.column), nodeExports.Position.create(error.location.end.line - 1, error.location.end.column));
    }
}
class ParserService {
    parseDocument(textDocument) {
        const content = textDocument.getText();
        const result = Herb.parse(content);
        const errorVisitor = new ErrorVisitor();
        result.visit(errorVisitor);
        return {
            document: result.value,
            diagnostics: errorVisitor.diagnostics
        };
    }
}

class Position {
    line;
    column;
    static from(position) {
        return new Position(position.line, position.column);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Location {
    start;
    end;
    static from(location) {
        const start = Position.from(location.start);
        const end = Position.from(location.end);
        return new Location(start, end);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Range {
    start;
    end;
    static from(range) {
        return new Range(range[0], range[1]);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range.from(token.range), Location.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/errors.ts.erb
class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
}
class UnexpectedError extends HerbError {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── description: ${JSON.stringify(this.description)}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnexpectedTokenError extends HerbError {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;
        return output;
    }
}
class MissingOpeningTagError extends HerbError {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class MissingClosingTagError extends HerbError {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class TagNamesMismatchError extends HerbError {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class QuotesMismatchError extends HerbError {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
        output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;
        return output;
    }
}
class VoidElementClosingTagError extends HerbError {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnclosedElementError extends HerbError {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class RubyParseError extends HerbError {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
        output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += `└── level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
}
function fromSerializedError(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}
function convertToUTF8(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/nodes.ts.erb
class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "∅\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length == 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "│   ", isLast, false);
            }
            else {
                const symbol = isLast ? "└── " : "├── ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "∅\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? "└── " : "├── ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index == 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
}
class DocumentNode extends Node {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class LiteralNode extends Node {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
}
class HTMLOpenTagNode extends Node {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
}
class HTMLCloseTagNode extends Node {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class HTMLElementNode extends Node {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
}
class HTMLAttributeValueNode extends Node {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_quote: data.open_quote ? Token.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            close_quote: data.close_quote ? Token.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
        output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;
        return output;
    }
}
class HTMLAttributeNameNode extends Node {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class HTMLAttributeNode extends Node {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            name: data.name ? fromSerializedNode((data.name)) : null,
            equals: data.equals ? Token.from(data.equals) : null,
            value: data.value ? fromSerializedNode((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
        output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
        output += `└── value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
}
class HTMLTextNode extends Node {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
}
class HTMLCommentNode extends Node {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            comment_start: data.comment_start ? Token.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            comment_end: data.comment_end ? Token.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;
        return output;
    }
}
class HTMLDoctypeNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class XMLDeclarationNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class CDATANode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class WhitespaceNode extends Node {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            value: data.value ? Token.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBContentNode extends Node {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        // no-op for analyzed_ruby
        output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
        output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;
        return output;
    }
}
class ERBEndNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBElseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBIfNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBBlockNode extends Node {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhenNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBCaseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBCaseMatchNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhileNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUntilNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBForNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBRescueNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
}
class ERBEnsureNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBBeginNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUnlessNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBYieldNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBInNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
function fromSerializedNode(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode.from(node);
        case "AST_LITERAL_NODE": return LiteralNode.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node);
        case "AST_CDATA_NODE": return CDATANode.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
}

class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
}

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
class ParseResult extends Result {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode.from(result.value), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/node-type-guards.ts.erb
/**
 * Type guard functions for AST nodes.
 * These functions provide type checking by combining both instanceof
 * checks and type string comparisons for maximum reliability across different
 * runtime scenarios (e.g., serialized/deserialized nodes).
 */
/**
 * Checks if a node is a DocumentNode
 */
function isDocumentNode(node) {
    return node instanceof DocumentNode || node.type === "AST_DOCUMENT_NODE" || node.constructor.type === "AST_DOCUMENT_NODE";
}
/**
 * Checks if a node is a LiteralNode
 */
function isLiteralNode(node) {
    return node instanceof LiteralNode || node.type === "AST_LITERAL_NODE" || node.constructor.type === "AST_LITERAL_NODE";
}
/**
 * Checks if a node is a HTMLOpenTagNode
 */
function isHTMLOpenTagNode(node) {
    return node instanceof HTMLOpenTagNode || node.type === "AST_HTML_OPEN_TAG_NODE" || node.constructor.type === "AST_HTML_OPEN_TAG_NODE";
}
/**
 * Checks if a node is a HTMLCloseTagNode
 */
function isHTMLCloseTagNode(node) {
    return node instanceof HTMLCloseTagNode || node.type === "AST_HTML_CLOSE_TAG_NODE" || node.constructor.type === "AST_HTML_CLOSE_TAG_NODE";
}
/**
 * Checks if a node is a HTMLElementNode
 */
function isHTMLElementNode(node) {
    return node instanceof HTMLElementNode || node.type === "AST_HTML_ELEMENT_NODE" || node.constructor.type === "AST_HTML_ELEMENT_NODE";
}
/**
 * Checks if a node is a HTMLAttributeValueNode
 */
function isHTMLAttributeValueNode(node) {
    return node instanceof HTMLAttributeValueNode || node.type === "AST_HTML_ATTRIBUTE_VALUE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNameNode
 */
function isHTMLAttributeNameNode(node) {
    return node instanceof HTMLAttributeNameNode || node.type === "AST_HTML_ATTRIBUTE_NAME_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NAME_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNode
 */
function isHTMLAttributeNode(node) {
    return node instanceof HTMLAttributeNode || node.type === "AST_HTML_ATTRIBUTE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NODE";
}
/**
 * Checks if a node is a HTMLTextNode
 */
function isHTMLTextNode(node) {
    return node instanceof HTMLTextNode || node.type === "AST_HTML_TEXT_NODE" || node.constructor.type === "AST_HTML_TEXT_NODE";
}
/**
 * Checks if a node is a HTMLCommentNode
 */
function isHTMLCommentNode(node) {
    return node instanceof HTMLCommentNode || node.type === "AST_HTML_COMMENT_NODE" || node.constructor.type === "AST_HTML_COMMENT_NODE";
}
/**
 * Checks if a node is a HTMLDoctypeNode
 */
function isHTMLDoctypeNode(node) {
    return node instanceof HTMLDoctypeNode || node.type === "AST_HTML_DOCTYPE_NODE" || node.constructor.type === "AST_HTML_DOCTYPE_NODE";
}
/**
 * Checks if a node is a XMLDeclarationNode
 */
function isXMLDeclarationNode(node) {
    return node instanceof XMLDeclarationNode || node.type === "AST_XML_DECLARATION_NODE" || node.constructor.type === "AST_XML_DECLARATION_NODE";
}
/**
 * Checks if a node is a CDATANode
 */
function isCDATANode(node) {
    return node instanceof CDATANode || node.type === "AST_CDATA_NODE" || node.constructor.type === "AST_CDATA_NODE";
}
/**
 * Checks if a node is a WhitespaceNode
 */
function isWhitespaceNode(node) {
    return node instanceof WhitespaceNode || node.type === "AST_WHITESPACE_NODE" || node.constructor.type === "AST_WHITESPACE_NODE";
}
/**
 * Checks if a node is a ERBContentNode
 */
function isERBContentNode(node) {
    return node instanceof ERBContentNode || node.type === "AST_ERB_CONTENT_NODE" || node.constructor.type === "AST_ERB_CONTENT_NODE";
}
/**
 * Checks if a node is a ERBEndNode
 */
function isERBEndNode(node) {
    return node instanceof ERBEndNode || node.type === "AST_ERB_END_NODE" || node.constructor.type === "AST_ERB_END_NODE";
}
/**
 * Checks if a node is a ERBElseNode
 */
function isERBElseNode(node) {
    return node instanceof ERBElseNode || node.type === "AST_ERB_ELSE_NODE" || node.constructor.type === "AST_ERB_ELSE_NODE";
}
/**
 * Checks if a node is a ERBIfNode
 */
function isERBIfNode(node) {
    return node instanceof ERBIfNode || node.type === "AST_ERB_IF_NODE" || node.constructor.type === "AST_ERB_IF_NODE";
}
/**
 * Checks if a node is a ERBBlockNode
 */
function isERBBlockNode(node) {
    return node instanceof ERBBlockNode || node.type === "AST_ERB_BLOCK_NODE" || node.constructor.type === "AST_ERB_BLOCK_NODE";
}
/**
 * Checks if a node is a ERBWhenNode
 */
function isERBWhenNode(node) {
    return node instanceof ERBWhenNode || node.type === "AST_ERB_WHEN_NODE" || node.constructor.type === "AST_ERB_WHEN_NODE";
}
/**
 * Checks if a node is a ERBCaseNode
 */
function isERBCaseNode(node) {
    return node instanceof ERBCaseNode || node.type === "AST_ERB_CASE_NODE" || node.constructor.type === "AST_ERB_CASE_NODE";
}
/**
 * Checks if a node is a ERBCaseMatchNode
 */
function isERBCaseMatchNode(node) {
    return node instanceof ERBCaseMatchNode || node.type === "AST_ERB_CASE_MATCH_NODE" || node.constructor.type === "AST_ERB_CASE_MATCH_NODE";
}
/**
 * Checks if a node is a ERBWhileNode
 */
function isERBWhileNode(node) {
    return node instanceof ERBWhileNode || node.type === "AST_ERB_WHILE_NODE" || node.constructor.type === "AST_ERB_WHILE_NODE";
}
/**
 * Checks if a node is a ERBUntilNode
 */
function isERBUntilNode(node) {
    return node instanceof ERBUntilNode || node.type === "AST_ERB_UNTIL_NODE" || node.constructor.type === "AST_ERB_UNTIL_NODE";
}
/**
 * Checks if a node is a ERBForNode
 */
function isERBForNode(node) {
    return node instanceof ERBForNode || node.type === "AST_ERB_FOR_NODE" || node.constructor.type === "AST_ERB_FOR_NODE";
}
/**
 * Checks if a node is a ERBRescueNode
 */
function isERBRescueNode(node) {
    return node instanceof ERBRescueNode || node.type === "AST_ERB_RESCUE_NODE" || node.constructor.type === "AST_ERB_RESCUE_NODE";
}
/**
 * Checks if a node is a ERBEnsureNode
 */
function isERBEnsureNode(node) {
    return node instanceof ERBEnsureNode || node.type === "AST_ERB_ENSURE_NODE" || node.constructor.type === "AST_ERB_ENSURE_NODE";
}
/**
 * Checks if a node is a ERBBeginNode
 */
function isERBBeginNode(node) {
    return node instanceof ERBBeginNode || node.type === "AST_ERB_BEGIN_NODE" || node.constructor.type === "AST_ERB_BEGIN_NODE";
}
/**
 * Checks if a node is a ERBUnlessNode
 */
function isERBUnlessNode(node) {
    return node instanceof ERBUnlessNode || node.type === "AST_ERB_UNLESS_NODE" || node.constructor.type === "AST_ERB_UNLESS_NODE";
}
/**
 * Checks if a node is a ERBYieldNode
 */
function isERBYieldNode(node) {
    return node instanceof ERBYieldNode || node.type === "AST_ERB_YIELD_NODE" || node.constructor.type === "AST_ERB_YIELD_NODE";
}
/**
 * Checks if a node is a ERBInNode
 */
function isERBInNode(node) {
    return node instanceof ERBInNode || node.type === "AST_ERB_IN_NODE" || node.constructor.type === "AST_ERB_IN_NODE";
}
/**
 * Checks if a node is any ERB node type
 */
function isERBNode(node) {
    return isERBContentNode(node) ||
        isERBEndNode(node) ||
        isERBElseNode(node) ||
        isERBIfNode(node) ||
        isERBBlockNode(node) ||
        isERBWhenNode(node) ||
        isERBCaseNode(node) ||
        isERBCaseMatchNode(node) ||
        isERBWhileNode(node) ||
        isERBUntilNode(node) ||
        isERBForNode(node) ||
        isERBRescueNode(node) ||
        isERBEnsureNode(node) ||
        isERBBeginNode(node) ||
        isERBUnlessNode(node) ||
        isERBYieldNode(node) ||
        isERBInNode(node);
}
/**
 * Map of node classes to their corresponding type guard functions
 *
 * @example
 * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const NODE_TYPE_GUARDS = new Map([
    [DocumentNode, isDocumentNode],
    [LiteralNode, isLiteralNode],
    [HTMLOpenTagNode, isHTMLOpenTagNode],
    [HTMLCloseTagNode, isHTMLCloseTagNode],
    [HTMLElementNode, isHTMLElementNode],
    [HTMLAttributeValueNode, isHTMLAttributeValueNode],
    [HTMLAttributeNameNode, isHTMLAttributeNameNode],
    [HTMLAttributeNode, isHTMLAttributeNode],
    [HTMLTextNode, isHTMLTextNode],
    [HTMLCommentNode, isHTMLCommentNode],
    [HTMLDoctypeNode, isHTMLDoctypeNode],
    [XMLDeclarationNode, isXMLDeclarationNode],
    [CDATANode, isCDATANode],
    [WhitespaceNode, isWhitespaceNode],
    [ERBContentNode, isERBContentNode],
    [ERBEndNode, isERBEndNode],
    [ERBElseNode, isERBElseNode],
    [ERBIfNode, isERBIfNode],
    [ERBBlockNode, isERBBlockNode],
    [ERBWhenNode, isERBWhenNode],
    [ERBCaseNode, isERBCaseNode],
    [ERBCaseMatchNode, isERBCaseMatchNode],
    [ERBWhileNode, isERBWhileNode],
    [ERBUntilNode, isERBUntilNode],
    [ERBForNode, isERBForNode],
    [ERBRescueNode, isERBRescueNode],
    [ERBEnsureNode, isERBEnsureNode],
    [ERBBeginNode, isERBBeginNode],
    [ERBUnlessNode, isERBUnlessNode],
    [ERBYieldNode, isERBYieldNode],
    [ERBInNode, isERBInNode],
]);
/**
 * Map of AST node type strings to their corresponding type guard functions
 *
 * @example
 * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const AST_TYPE_GUARDS = new Map([
    ["AST_DOCUMENT_NODE", isDocumentNode],
    ["AST_LITERAL_NODE", isLiteralNode],
    ["AST_HTML_OPEN_TAG_NODE", isHTMLOpenTagNode],
    ["AST_HTML_CLOSE_TAG_NODE", isHTMLCloseTagNode],
    ["AST_HTML_ELEMENT_NODE", isHTMLElementNode],
    ["AST_HTML_ATTRIBUTE_VALUE_NODE", isHTMLAttributeValueNode],
    ["AST_HTML_ATTRIBUTE_NAME_NODE", isHTMLAttributeNameNode],
    ["AST_HTML_ATTRIBUTE_NODE", isHTMLAttributeNode],
    ["AST_HTML_TEXT_NODE", isHTMLTextNode],
    ["AST_HTML_COMMENT_NODE", isHTMLCommentNode],
    ["AST_HTML_DOCTYPE_NODE", isHTMLDoctypeNode],
    ["AST_XML_DECLARATION_NODE", isXMLDeclarationNode],
    ["AST_CDATA_NODE", isCDATANode],
    ["AST_WHITESPACE_NODE", isWhitespaceNode],
    ["AST_ERB_CONTENT_NODE", isERBContentNode],
    ["AST_ERB_END_NODE", isERBEndNode],
    ["AST_ERB_ELSE_NODE", isERBElseNode],
    ["AST_ERB_IF_NODE", isERBIfNode],
    ["AST_ERB_BLOCK_NODE", isERBBlockNode],
    ["AST_ERB_WHEN_NODE", isERBWhenNode],
    ["AST_ERB_CASE_NODE", isERBCaseNode],
    ["AST_ERB_CASE_MATCH_NODE", isERBCaseMatchNode],
    ["AST_ERB_WHILE_NODE", isERBWhileNode],
    ["AST_ERB_UNTIL_NODE", isERBUntilNode],
    ["AST_ERB_FOR_NODE", isERBForNode],
    ["AST_ERB_RESCUE_NODE", isERBRescueNode],
    ["AST_ERB_ENSURE_NODE", isERBEnsureNode],
    ["AST_ERB_BEGIN_NODE", isERBBeginNode],
    ["AST_ERB_UNLESS_NODE", isERBUnlessNode],
    ["AST_ERB_YIELD_NODE", isERBYieldNode],
    ["AST_ERB_IN_NODE", isERBInNode],
]);
/**
 * Checks if a node matches any of the provided type identifiers with proper type narrowing
 * Supports AST type strings, node classes, or type guard functions
 *
 * @example
 * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 *
 * @example
 * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 */
function isAnyOf(node, ...types) {
    return types.some(type => {
        if (typeof type === 'string') {
            return isNode(node, type);
        }
        else if (typeof type === 'function' && type.prototype && type.prototype.constructor === type && NODE_TYPE_GUARDS.has(type)) {
            return isNode(node, type);
        }
        else if (typeof type === 'function') {
            return type(node);
        }
        else {
            return false;
        }
    });
}
function areAllOfType(nodes, ...types) {
    return nodes.every(node => isAnyOf(node, ...types));
}
function filterNodes(nodes, ...types) {
    if (!nodes)
        return [];
    return nodes.filter(node => isAnyOf(node, ...types));
}
function isNode(node, type) {
    if (!node)
        return false;
    if (typeof type === 'string') {
        const guard = AST_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else if (typeof type === 'function') {
        const guard = NODE_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else {
        return false;
    }
}
function isToken(object) {
    return (object instanceof Token) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
}
function isParseResult(object) {
    return (object instanceof ParseResult) || (object?.constructor?.name === "ParseResult" && "value" in object);
}
/**
 * Filters an array of nodes to only include LiteralNode nodes
 */
function filterLiteralNodes(nodes) {
    return nodes.filter(isLiteralNode);
}
/**
 * Filters an array of nodes to only include ERBContentNode nodes
 */
function filterERBContentNodes(nodes) {
    return nodes.filter(isERBContentNode);
}

/**
 * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
 */
function isERBOutputNode(node) {
    return isNode(node, ERBContentNode) && ["<%=", "<%=="].includes(node.tag_opening?.value);
}
/**
 * Checks if an array of nodes contains any ERB content nodes
 */
function hasERBContent(nodes) {
    return nodes.some(isERBContentNode);
}
/**
 * Checks if an array of nodes contains any ERB output nodes (dynamic content)
 */
function hasERBOutput(nodes) {
    return nodes.some(isERBOutputNode);
}
/**
 * Extracts a static string from an array of literal nodes
 * Returns null if any node is not a literal node
 */
function getStaticStringFromNodes(nodes) {
    if (!areAllOfType(nodes, LiteralNode)) {
        return null;
    }
    return nodes.map(node => node.content).join("");
}
/**
 * Checks if nodes are effectively static (only literals and non-output ERB)
 * Non-output ERB like <% if %> doesn't affect static validation
 */
function isEffectivelyStatic(nodes) {
    return !hasERBOutput(nodes);
}
/**
 * Gets static-validatable content from nodes (ignores control ERB, includes literals)
 * Returns concatenated literal content for validation, or null if contains output ERB
 */
function getValidatableStaticContent(nodes) {
    if (hasERBOutput(nodes)) {
        return null;
    }
    return filterLiteralNodes(nodes).map(node => node.content).join("");
}
/**
 * Extracts a combined string from nodes, including ERB content
 * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
 * This is useful for debugging or displaying the full attribute name
 */
function getCombinedStringFromNodes(nodes) {
    return nodes.map(node => {
        if (isLiteralNode(node)) {
            return node.content;
        }
        else if (isERBContentNode(node)) {
            const opening = node.tag_opening?.value || "";
            const content = node.content?.value || "";
            const closing = node.tag_closing?.value || "";
            return `${opening}${content}${closing}`;
        }
        else {
            // For other node types, return a placeholder or empty string
            return `[${node.type}]`;
        }
    }).join("");
}
/**
 * Checks if an HTML attribute name node has dynamic content (contains ERB)
 */
function hasDynamicAttributeName$1(attributeNameNode) {
    if (!attributeNameNode.children) {
        return false;
    }
    return hasERBContent(attributeNameNode.children);
}
/**
 * Gets the static string value of an HTML attribute name node
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getStaticAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return null;
    }
    return getStaticStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the combined string representation of an HTML attribute name node
 * This includes both static and dynamic content, useful for debugging
 */
function getCombinedAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return "";
    }
    return getCombinedStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the tag name of an HTML element node
 */
function getTagName$1(node) {
    return node.tag_name?.value ?? "";
}
/**
 * Compares two positions to determine if the first comes before the second
 * Returns true if pos1 comes before pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionBefore(position1, position2, inclusive = false) {
    if (position1.line < position2.line)
        return true;
    if (position1.line > position2.line)
        return false;
    return inclusive ? position1.column <= position2.column : position1.column < position2.column;
}
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionAfter(position1, position2, inclusive = false) {
    if (position1.line > position2.line)
        return true;
    if (position1.line < position2.line)
        return false;
    return inclusive ? position1.column >= position2.column : position1.column > position2.column;
}
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
function getNodesBeforePosition(nodes, position, inclusive = false) {
    return nodes.filter(node => node.location && isPositionBefore(node.location.end, position, inclusive));
}
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
function getNodesAfterPosition(nodes, position, inclusive = true) {
    return nodes.filter(node => node.location && isPositionAfter(node.location.start, position, inclusive));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/visitor.ts.erb
class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitDocumentNode(node) {
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitChildNodes(node);
    }
}

class ParserRule {
    static type = "parser";
}
/**
 * Default context object with all keys defined but set to undefined
 */
const DEFAULT_LINT_CONTEXT = {
    fileName: undefined
};
class SourceRule {
    static type = "source";
}

var ControlFlowType;
(function (ControlFlowType) {
    ControlFlowType[ControlFlowType["CONDITIONAL"] = 0] = "CONDITIONAL";
    ControlFlowType[ControlFlowType["LOOP"] = 1] = "LOOP";
})(ControlFlowType || (ControlFlowType = {}));
/**
 * Base visitor class that provides common functionality for rule visitors
 */
class BaseRuleVisitor extends Visitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        super();
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
class ControlFlowTrackingVisitor extends BaseRuleVisitor {
    isInControlFlow = false;
    currentControlFlowType = null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    handleControlFlowNode(node, controlFlowType, visitChildren) {
        const wasInControlFlow = this.isInControlFlow;
        const previousControlFlowType = this.currentControlFlowType;
        this.isInControlFlow = true;
        this.currentControlFlowType = controlFlowType;
        const stateToRestore = this.onEnterControlFlow(controlFlowType, wasInControlFlow);
        visitChildren();
        this.onExitControlFlow(controlFlowType, wasInControlFlow, stateToRestore);
        this.isInControlFlow = wasInControlFlow;
        this.currentControlFlowType = previousControlFlowType;
    }
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    startNewBranch(visitChildren) {
        const stateToRestore = this.onEnterBranch();
        visitChildren();
        this.onExitBranch(stateToRestore);
    }
    visitERBIfNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBIfNode(node));
    }
    visitERBUnlessNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBUnlessNode(node));
    }
    visitERBCaseNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseNode(node));
    }
    visitERBCaseMatchNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseMatchNode(node));
    }
    visitERBWhileNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBWhileNode(node));
    }
    visitERBForNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBForNode(node));
    }
    visitERBUntilNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBUntilNode(node));
    }
    visitERBBlockNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBBlockNode(node));
    }
    visitERBElseNode(node) {
        this.startNewBranch(() => super.visitERBElseNode(node));
    }
    visitERBWhenNode(node) {
        this.startNewBranch(() => super.visitERBWhenNode(node));
    }
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
function getAttributes(node) {
    return node.children.filter(node => node.type === "AST_HTML_ATTRIBUTE_NODE");
}
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
function getTagName(node) {
    return node.tag_name?.value.toLowerCase() || null;
}
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        const staticName = getStaticAttributeName(nameNode);
        return staticName ? staticName.toLowerCase() : null;
    }
    return null;
}
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
function hasDynamicAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return hasDynamicAttributeName$1(nameNode);
    }
    return false;
}
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
function getCombinedAttributeNameString(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return getCombinedAttributeName(nameNode);
    }
    return "";
}
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
function hasStaticAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.every(child => child.type === "AST_LITERAL_NODE");
}
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
function getStaticAttributeValue(attributeNode) {
    if (!hasStaticAttributeValue(attributeNode))
        return null;
    const valueNode = attributeNode.value;
    const result = valueNode.children
        ?.filter(child => child.type === "AST_LITERAL_NODE")
        .map(child => child.content)
        .join("") || "";
    return result;
}
/**
 * Gets the value nodes array for dynamic inspection
 */
function getAttributeValueNodes(attributeNode) {
    const valueNode = attributeNode.value;
    return valueNode?.children || [];
}
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
function getAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (valueNode === null)
        return null;
    if (valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE" || !valueNode.children?.length) {
        return null;
    }
    let result = "";
    for (const child of valueNode.children) {
        switch (child.type) {
            case "AST_ERB_CONTENT_NODE": {
                const erbNode = child;
                if (erbNode.content) {
                    result += `${erbNode.tag_opening?.value}${erbNode.content.value}${erbNode.tag_closing?.value}`;
                }
                break;
            }
            case "AST_LITERAL_NODE": {
                result += child.content;
                break;
            }
        }
    }
    return result;
}
/**
 * Checks if an attribute has a value
 */
function hasAttributeValue(attributeNode) {
    return attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Gets the quote type used for an attribute value
 */
function getAttributeValueQuoteType(nodeOrAttribute) {
    let valueNode;
    if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_NODE") {
        const attributeNode = nodeOrAttribute;
        if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
            valueNode = attributeNode.value;
        }
    }
    else if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        valueNode = nodeOrAttribute;
    }
    if (valueNode) {
        if (valueNode.quoted && valueNode.open_quote) {
            return valueNode.open_quote.value === '"' ? "double" : "single";
        }
        return "none";
    }
    return null;
}
/**
 * Finds an attribute by name in a list of attributes
 */
function findAttributeByName(attributes, attributeName) {
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            const attributeNode = child;
            const name = getAttributeName(attributeNode);
            if (name === attributeName.toLowerCase()) {
                return attributeNode;
            }
        }
    }
    return null;
}
/**
 * Checks if a tag has a specific attribute
 */
function hasAttribute(node, attributeName) {
    return getAttribute(node, attributeName) !== null;
}
/**
 * Checks if a tag has a specific attribute
 */
function getAttribute(node, attributeName) {
    const attributes = getAttributes(node);
    return findAttributeByName(attributes, attributeName);
}
const HTML_VOID_ELEMENTS = new Set([
    "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta",
    "param", "source", "track", "wbr",
]);
const HTML_BOOLEAN_ATTRIBUTES = new Set([
    "autofocus", "autoplay", "checked", "controls", "defer", "disabled", "hidden",
    "loop", "multiple", "muted", "readonly", "required", "reversed", "selected",
    "open", "default", "formnovalidate", "novalidate", "itemscope", "scoped",
    "seamless", "allowfullscreen", "async", "compact", "declare", "nohref",
    "noresize", "noshade", "nowrap", "sortable", "truespeed", "typemustmatch"
]);
const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
/**
 * SVG elements that use camelCase naming
 */
const SVG_CAMEL_CASE_ELEMENTS = new Set([
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
]);
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
const SVG_LOWERCASE_TO_CAMELCASE = new Map(Array.from(SVG_CAMEL_CASE_ELEMENTS).map(element => [element.toLowerCase(), element]));
const VALID_ARIA_ROLES = new Set([
    "banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search",
    "article", "cell", "columnheader", "definition", "directory", "document", "feed", "figure",
    "group", "heading", "img", "list", "listitem", "math", "none", "note", "presentation",
    "row", "rowgroup", "rowheader", "separator", "table", "term", "tooltip",
    "alert", "alertdialog", "button", "checkbox", "combobox", "dialog", "grid", "gridcell", "link",
    "listbox", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "option",
    "progressbar", "radio", "radiogroup", "scrollbar", "searchbox", "slider", "spinbutton",
    "status", "switch", "tab", "tablist", "tabpanel", "textbox", "timer", "toolbar", "tree",
    "treegrid", "treeitem",
    "log", "marquee"
]);
const ARIA_ATTRIBUTES = new Set([
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-disabled',
    'aria-dropeffect',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-modal',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
]);
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
function createEndOfFileLocation(source) {
    const lines = source.split('\n');
    const lastLineNumber = lines.length;
    const lastLine = lines[lines.length - 1];
    const lastColumnNumber = lastLine.length;
    const startColumn = lastColumnNumber > 0 ? lastColumnNumber - 1 : 0;
    const start = new Position(lastLineNumber, startColumn);
    const end = new Position(lastLineNumber, lastColumnNumber);
    return new Location(start, end);
}
/**
 * Checks if an element is a void element
 */
function isVoidElement(tagName) {
    return HTML_VOID_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an attribute is a boolean attribute
 */
function isBooleanAttribute(attributeName) {
    return HTML_BOOLEAN_ATTRIBUTES.has(attributeName.toLowerCase());
}
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitHTMLOpenTagNode(node) {
        this.checkAttributesOnNode(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAttributesOnNode(node) {
        forEachAttribute(node, (attributeNode) => {
            const staticAttributeName = getAttributeName(attributeNode);
            const isDynamicName = hasDynamicAttributeName(attributeNode);
            const staticAttributeValue = getStaticAttributeValue(attributeNode);
            const valueNodes = getAttributeValueNodes(attributeNode);
            const hasOutputERB = hasERBOutput(valueNodes);
            const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
            if (staticAttributeName && staticAttributeValue !== null) {
                this.checkStaticAttributeStaticValue({
                    attributeName: staticAttributeName,
                    attributeValue: staticAttributeValue,
                    attributeNode,
                    parentNode: node
                });
            }
            else if (staticAttributeName && isEffectivelyStaticValue && !hasOutputERB) {
                const validatableContent = getValidatableStaticContent(valueNodes) || "";
                this.checkStaticAttributeStaticValue({ attributeName: staticAttributeName, attributeValue: validatableContent, attributeNode, parentNode: node });
            }
            else if (staticAttributeName && hasOutputERB) {
                const combinedValue = getAttributeValue(attributeNode);
                this.checkStaticAttributeDynamicValue({ attributeName: staticAttributeName, valueNodes, attributeNode, parentNode: node, combinedValue });
            }
            else if (isDynamicName && staticAttributeValue !== null) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                this.checkDynamicAttributeStaticValue({ nameNodes, attributeValue: staticAttributeValue, attributeNode, parentNode: node, combinedName });
            }
            else if (isDynamicName) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                const combinedValue = getAttributeValue(attributeNode);
                this.checkDynamicAttributeDynamicValue({ nameNodes, valueNodes, attributeNode, parentNode: node, combinedName, combinedValue });
            }
        });
    }
    /**
     * Static attribute name with static value: class="container"
     */
    checkStaticAttributeStaticValue(params) {
        // Default implementation does nothing
    }
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    checkStaticAttributeDynamicValue(params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    checkDynamicAttributeStaticValue(params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    checkDynamicAttributeDynamicValue(params) {
        // Default implementation does nothing
    }
}
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
function forEachAttribute(node, callback) {
    const attributes = getAttributes(node);
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            callback(child);
        }
    }
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
class BaseSourceRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense for source rules
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source) {
        this.visitSource(source);
    }
    /**
     * Helper method to create a location for a specific position in the source
     */
    createLocationAt(source, position) {
        const beforePosition = source.substring(0, position);
        const lines = beforePosition.split('\n');
        const line = lines.length;
        const column = lines[lines.length - 1].length + 1;
        const start = new Position(line, column);
        const end = new Position(line, column);
        return new Location(start, end);
    }
}

class ERBNoEmptyTagsVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        this.visitChildNodes(node);
        const { content, tag_closing } = node;
        if (!content)
            return;
        if (tag_closing?.value === "")
            return;
        if (content.value.trim().length > 0)
            return;
        this.addOffense("ERB tag should not be empty. Remove empty ERB tags or add content.", node.location, "error");
    }
}
class ERBNoEmptyTagsRule extends ParserRule {
    name = "erb-no-empty-tags";
    check(result, context) {
        const visitor = new ERBNoEmptyTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoOutputControlFlowRuleVisitor extends BaseRuleVisitor {
    visitERBIfNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    checkOutputControlFlow(controlBlock) {
        const openTag = controlBlock.tag_opening;
        if (!openTag) {
            return;
        }
        if (openTag.value === "<%=") {
            let controlBlockType = controlBlock.type;
            if (controlBlock.type === "AST_ERB_IF_NODE")
                controlBlockType = "if";
            if (controlBlock.type === "AST_ERB_ELSE_NODE")
                controlBlockType = "else";
            if (controlBlock.type === "AST_ERB_END_NODE")
                controlBlockType = "end";
            if (controlBlock.type === "AST_ERB_UNLESS_NODE")
                controlBlockType = "unless";
            this.addOffense(`Control flow statements like \`${controlBlockType}\` should not be used with output tags. Use \`<% ${controlBlockType} ... %>\` instead.`, openTag.location, "error");
        }
        return;
    }
}
class ERBNoOutputControlFlowRule extends ParserRule {
    name = "erb-no-output-control-flow";
    check(result, context) {
        const visitor = new ERBNoOutputControlFlowRuleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoSilentTagInAttributeNameVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNameNode(node) {
        const erbNodes = filterERBContentNodes(node.children);
        const silentNodes = erbNodes.filter(this.isSilentERBTag);
        for (const node of silentNodes) {
            this.addOffense(`Remove silent ERB tag from HTML attribute name. Silent ERB tags (\`${node.tag_opening?.value}\`) do not output content and should not be used in attribute names.`, node.location, "error");
        }
    }
    // TODO: might be worth to extract
    isSilentERBTag(node) {
        const silentTags = ["<%", "<%-", "<%#"];
        return silentTags.includes(node.tag_opening?.value || "");
    }
}
class ERBNoSilentTagInAttributeNameRule extends ParserRule {
    name = "erb-no-silent-tag-in-attribute-name";
    check(result, context) {
        const visitor = new ERBNoSilentTagInAttributeNameVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

const DEFAULT_ERB_TO_RUBY_STRING_OPTIONS = {
    ...DEFAULT_PRINT_OPTIONS,
    forceQuotes: false
};
/**
 * ERBToRubyStringPrinter - Converts ERB snippets to Ruby strings with interpolation
 *
 * This printer transforms ERB templates into Ruby strings by:
 * - Converting literal text to string content
 * - Converting <%= %> tags to #{} interpolation
 * - Converting simple if/else blocks to ternary operators
 * - Ignoring <% %> tags (they don't produce output)
 *
 * Examples:
 * - `hello world <%= hello %>` => `"hello world #{hello}"`
 * - `hello world <% hello %>` => `"hello world "`
 * - `Welcome <%= user.name %>!` => `"Welcome #{user.name}!"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>` => `"logged_in? ? "Welcome" : "Login"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>!` => `"#{logged_in? ? "Welcome" : "Login"}!"`
 */
class ERBToRubyStringPrinter extends IdentityPrinter {
    // TODO: cleanup `.type === "AST_*" checks`
    static print(node, options = DEFAULT_ERB_TO_RUBY_STRING_OPTIONS) {
        const erbNodes = filterNodes([node], ERBContentNode);
        if (erbNodes.length === 1 && isERBOutputNode(erbNodes[0]) && !options.forceQuotes) {
            return (erbNodes[0].content?.value || "").trim();
        }
        if ('children' in node && Array.isArray(node.children)) {
            const childErbNodes = filterNodes(node.children, ERBContentNode);
            const hasOnlyERBContent = node.children.length > 0 && node.children.length === childErbNodes.length;
            if (hasOnlyERBContent && childErbNodes.length === 1 && isERBOutputNode(childErbNodes[0]) && !options.forceQuotes) {
                return (childErbNodes[0].content?.value || "").trim();
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_IF_NODE" && !options.forceQuotes) {
                const ifNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertToTernary(ifNode)) {
                    printer.convertToTernaryWithoutWrapper(ifNode);
                    return printer.context.getOutput();
                }
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_UNLESS_NODE" && !options.forceQuotes) {
                const unlessNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertUnlessToTernary(unlessNode)) {
                    printer.convertUnlessToTernaryWithoutWrapper(unlessNode);
                    return printer.context.getOutput();
                }
            }
        }
        const printer = new ERBToRubyStringPrinter();
        printer.context.write('"');
        printer.visit(node);
        printer.context.write('"');
        return printer.context.getOutput();
    }
    visitHTMLTextNode(node) {
        if (node.content) {
            const escapedContent = node.content.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            this.context.write(escapedContent);
        }
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.context.write("#{");
            if (node.content?.value) {
                this.context.write(node.content.value.trim());
            }
            this.context.write("}");
        }
    }
    visitERBIfNode(node) {
        if (this.canConvertToTernary(node)) {
            this.convertToTernary(node);
        }
    }
    visitERBUnlessNode(node) {
        if (this.canConvertUnlessToTernary(node)) {
            this.convertUnlessToTernary(node);
        }
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    canConvertToTernary(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        const ifOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!ifOnlyText)
            return false;
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE") {
            return node.subsequent.statements
                ? node.subsequent.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertToTernaryWithoutWrapper(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
    canConvertUnlessToTernary(node) {
        const unlessOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!unlessOnlyText)
            return false;
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            return node.else_clause.statements
                ? node.else_clause.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertUnlessToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertUnlessToTernaryWithoutWrapper(node) {
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
}

class ERBPreferImageTagHelperVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(openTag) {
        const tagName = getTagName(openTag);
        if (tagName !== "img")
            return;
        const attributes = getAttributes(openTag);
        const srcAttribute = findAttributeByName(attributes, "src");
        if (!srcAttribute)
            return;
        if (!srcAttribute.value)
            return;
        const node = srcAttribute.value;
        const hasERBContent = this.containsERBContent(node);
        if (hasERBContent) {
            if (this.isDataUri(node))
                return;
            if (this.shouldFlagAsImageTagCandidate(node)) {
                const suggestedExpression = this.buildSuggestedExpression(node);
                this.addOffense(`Prefer \`image_tag\` helper over manual \`<img>\` with dynamic ERB expressions. Use \`<%= image_tag ${suggestedExpression}, alt: "..." %>\` instead.`, srcAttribute.location, "warning");
            }
        }
    }
    containsERBContent(node) {
        return filterNodes(node.children, ERBContentNode).length > 0;
    }
    isOnlyERBContent(node) {
        return node.children.length > 0 && node.children.length === filterNodes(node.children, ERBContentNode).length;
    }
    getContentofFirstChild(node) {
        if (!node.children || node.children.length === 0)
            return "";
        const firstChild = node.children[0];
        if (isNode(firstChild, LiteralNode)) {
            return (firstChild.content || "").trim();
        }
        return "";
    }
    isDataUri(node) {
        return this.getContentofFirstChild(node).startsWith("data:");
    }
    isFullUrl(node) {
        const content = this.getContentofFirstChild(node);
        return content.startsWith("http://") || content.startsWith("https://");
    }
    shouldFlagAsImageTagCandidate(node) {
        if (this.isOnlyERBContent(node))
            return true;
        if (this.isFullUrl(node))
            return false;
        return true;
    }
    buildSuggestedExpression(node) {
        if (!node.children)
            return "expression";
        try {
            return ERBToRubyStringPrinter.print(node, { ignoreErrors: false });
        }
        catch (error) {
            return "expression";
        }
    }
}
class ERBPreferImageTagHelperRule extends ParserRule {
    name = "erb-prefer-image-tag-helper";
    check(result, context) {
        const visitor = new ERBPreferImageTagHelperVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBRequiresTrailingNewlineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        if (source.endsWith('\n'))
            return;
        if (!this.context.fileName)
            return;
        this.addOffense("File must end with trailing newline", createEndOfFileLocation(source), "error");
    }
}
class ERBRequiresTrailingNewlineRule extends SourceRule {
    name = "erb-requires-trailing-newline";
    check(source, context) {
        const visitor = new ERBRequiresTrailingNewlineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
}

class RequireWhitespaceInsideTags extends BaseRuleVisitor {
    visitChildNodes(node) {
        this.checkWhitespace(node);
        super.visitChildNodes(node);
    }
    checkWhitespace(node) {
        if (!isERBNode(node)) {
            return;
        }
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const content = node.content;
        if (!openTag || !closeTag || !content) {
            return;
        }
        const value = content.value;
        if (openTag.value === "<%#") {
            this.checkCommentTagWhitespace(openTag, closeTag, value);
        }
        else {
            this.checkOpenTagWhitespace(openTag, value);
            this.checkCloseTagWhitespace(closeTag, value);
        }
    }
    checkCommentTagWhitespace(openTag, closeTag, content) {
        if (!content.startsWith(" ") && !content.startsWith("\n") && !content.startsWith("=")) {
            this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, "error");
        }
        else if (content.startsWith("=") && content.length > 1 && !content[1].match(/\s/)) {
            this.addOffense(`Add whitespace after \`<%#=\`.`, openTag.location, "error");
        }
        if (!content.endsWith(" ") && !content.endsWith("\n")) {
            this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, "error");
        }
    }
    checkOpenTagWhitespace(openTag, content) {
        if (content.startsWith(" ") || content.startsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, "error");
    }
    checkCloseTagWhitespace(closeTag, content) {
        if (content.endsWith(" ") || content.endsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, "error");
    }
}
class ERBRequireWhitespaceRule extends ParserRule {
    name = "erb-require-whitespace-inside-tags";
    check(result, context) {
        const visitor = new RequireWhitespaceInsideTags(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AnchorRechireHrefVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkATag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkATag(node) {
        const tagName = getTagName(node);
        if (tagName !== "a") {
            return;
        }
        if (!hasAttribute(node, "href")) {
            this.addOffense("Add an `href` attribute to `<a>` to ensure it is focusable and accessible.", node.tag_name.location, "error");
        }
    }
}
class HTMLAnchorRequireHrefRule extends ParserRule {
    name = "html-anchor-require-href";
    check(result, context) {
        const visitor = new AnchorRechireHrefVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaAttributeMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName.startsWith("aria-"))
            return;
        if (ARIA_ATTRIBUTES.has(attributeName))
            return;
        this.addOffense(`The attribute \`${attributeName}\` is not a valid ARIA attribute. ARIA attributes must match the WAI-ARIA specification.`, attributeNode.location, "error");
    }
}
class HTMLAriaAttributeMustBeValid extends ParserRule {
    name = "html-aria-attribute-must-be-valid";
    check(result, context) {
        const visitor = new AriaAttributeMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaLabelIsWellFormattedVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-label")
            return;
        if (attributeValue.match(/[\r\n]+/) || attributeValue.match(/&#10;|&#13;|&#x0A;|&#x0D;/i)) {
            this.addOffense("The `aria-label` attribute value text should not contain line breaks. Use concise, single-line descriptions.", attributeNode.location, "error");
            return;
        }
        if (this.looksLikeId(attributeValue)) {
            this.addOffense("The `aria-label` attribute value should not be formatted like an ID. Use natural, sentence-case text instead.", attributeNode.location, "error");
            return;
        }
        if (attributeValue.match(/^[a-z]/)) {
            this.addOffense("The `aria-label` attribute value text should be formatted like visual text. Use sentence case (capitalize the first letter).", attributeNode.location, "error");
        }
    }
    looksLikeId(text) {
        return (text.includes('_') ||
            text.includes('-') ||
            /^[a-z]+([A-Z][a-z]*)*$/.test(text)) && !text.includes(' ');
    }
}
class HTMLAriaLabelIsWellFormattedRule extends ParserRule {
    name = "html-aria-label-is-well-formatted";
    check(result, context) {
        const visitor = new AriaLabelIsWellFormattedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAriaLevelMustBeValidVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        this.validateAriaLevel(attributeValue, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        const validatableContent = getValidatableStaticContent(valueNodes);
        if (validatableContent !== null) {
            this.validateAriaLevel(validatableContent, attributeNode);
            return;
        }
        if (!hasERBOutput(valueNodes))
            return;
        const literalNodes = filterLiteralNodes(valueNodes);
        const erbOutputNodes = filterERBContentNodes(valueNodes).filter(isERBOutputNode);
        if (literalNodes.length > 0 && erbOutputNodes.length > 0) {
            const staticPart = literalNodes.map(node => node.content).join("");
            // TODO: this can be cleaned up using @herb-tools/printer
            const erbPart = erbOutputNodes[0];
            const erbText = `${erbPart.tag_opening?.value || ""}${erbPart.content?.value || ""}${erbPart.tag_closing?.value || ""}`;
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${staticPart}\` and the ERB expression \`${erbText}\`.`, attributeNode.location);
        }
    }
    validateAriaLevel(attributeValue, attributeNode) {
        if (!attributeValue || attributeValue === "") {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got an empty value.`, attributeNode.location);
            return;
        }
        const number = parseInt(attributeValue);
        if (isNaN(number) || number < 1 || number > 6 || attributeValue !== number.toString()) {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${attributeValue}\`.`, attributeNode.location);
        }
    }
}
class HTMLAriaLevelMustBeValidRule extends ParserRule {
    name = "html-aria-level-must-be-valid";
    check(result, context) {
        const visitor = new HTMLAriaLevelMustBeValidVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleHeadingRequiresLevel extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode, parentNode }) {
        if (!(attributeName === "role" && attributeValue === "heading"))
            return;
        const ariaLevelAttributes = getAttributes(parentNode).find(attribute => getAttributeName(attribute) === "aria-level");
        if (ariaLevelAttributes)
            return;
        this.addOffense(`Element with \`role="heading"\` must have an \`aria-level\` attribute.`, attributeNode.location, "error");
    }
}
class HTMLAriaRoleHeadingRequiresLevelRule extends ParserRule {
    name = "html-aria-role-heading-requires-level";
    check(result, context) {
        const visitor = new AriaRoleHeadingRequiresLevel(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "role")
            return;
        if (!attributeValue)
            return;
        if (VALID_ARIA_ROLES.has(attributeValue))
            return;
        this.addOffense(`The \`role\` attribute must be a valid ARIA role. Role \`${attributeValue}\` is not recognized.`, attributeNode.location, "error");
    }
}
class HTMLAriaRoleMustBeValidRule extends ParserRule {
    name = "html-aria-role-must-be-valid";
    check(result, context) {
        const visitor = new AriaRoleMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeDoubleQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (attributeValue?.includes('"'))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${attributeValue}"\`.`, attributeNode.value.location, "warning");
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode, combinedValue }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (filterLiteralNodes(valueNodes).some(node => node.content?.includes('"')))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, "warning");
    }
}
class HTMLAttributeDoubleQuotesRule extends ParserRule {
    name = "html-attribute-double-quotes";
    check(result, context) {
        const visitor = new AttributeDoubleQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAttributeEqualsSpacingVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNode(attribute) {
        if (!attribute.equals || !attribute.name || !attribute.value) {
            return;
        }
        if (attribute.equals.value.startsWith(" ")) {
            this.addOffense("Remove whitespace before `=` in HTML attribute", attribute.equals.location, "error");
        }
        if (attribute.equals.value.endsWith(" ")) {
            this.addOffense("Remove whitespace after `=` in HTML attribute", attribute.equals.location, "error");
        }
    }
}
class HTMLAttributeEqualsSpacingRule extends ParserRule {
    name = "html-attribute-equals-spacing";
    check(result, context) {
        const visitor = new HTMLAttributeEqualsSpacingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeValuesRequireQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${attributeValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, "error");
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${combinedValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, "error");
    }
    hasAttributeValue(attributeNode) {
        return attributeNode.value?.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    isQuoted(attributeNode) {
        const valueNode = attributeNode.value;
        return valueNode.quoted;
    }
}
class HTMLAttributeValuesRequireQuotesRule extends ParserRule {
    name = "html-attribute-values-require-quotes";
    check(result, context) {
        const visitor = new AttributeValuesRequireQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT = new Set([
    "button", "fieldset", "input", "optgroup", "option", "select", "textarea"
]);
class AvoidBothDisabledAndAriaDisabledVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkElement(node) {
        const tagName = getTagName(node);
        if (!tagName || !ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT.has(tagName)) {
            return;
        }
        const hasDisabled = hasAttribute(node, "disabled");
        const hasAriaDisabled = hasAttribute(node, "aria-disabled");
        if ((hasDisabled && this.hasERBContent(node, "disabled")) || (hasAriaDisabled && this.hasERBContent(node, "aria-disabled"))) {
            return;
        }
        if (hasDisabled && hasAriaDisabled) {
            this.addOffense("aria-disabled may be used in place of native HTML disabled to allow tab-focus on an otherwise ignored element. Setting both attributes is contradictory and confusing. Choose either disabled or aria-disabled, not both.", node.tag_name.location, "error");
        }
    }
    hasERBContent(node, attributeName) {
        const attributes = getAttributes(node);
        const attribute = findAttributeByName(attributes, attributeName);
        if (!attribute)
            return false;
        const valueNode = attribute.value;
        if (!valueNode || valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE")
            return false;
        const htmlValueNode = valueNode;
        if (!htmlValueNode.children)
            return false;
        return htmlValueNode.children.some((child) => child.type === "AST_ERB_CONTENT_NODE");
    }
}
class HTMLAvoidBothDisabledAndAriaDisabledRule extends ParserRule {
    name = "html-avoid-both-disabled-and-aria-disabled";
    check(result, context) {
        const visitor = new AvoidBothDisabledAndAriaDisabledVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BooleanAttributesNoValueVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${attributeName}\` should not have a value. Use \`${attributeName}\` instead of \`${attributeName}="${attributeName}"\`.`, attributeNode.value.location, "error");
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${attributeName}\` should not have a value. Use \`${attributeName}\` instead of \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, "error");
    }
}
class HTMLBooleanAttributesNoValueRule extends ParserRule {
    name = "html-boolean-attributes-no-value";
    check(result, context) {
        const visitor = new BooleanAttributesNoValueVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class IframeHasTitleVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkIframeElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkIframeElement(node) {
        const tagName = getTagName(node);
        if (tagName !== "iframe") {
            return;
        }
        const ariaHiddenAttribute = getAttribute(node, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return;
            }
        }
        const attribute = getAttribute(node, "title");
        if (!attribute) {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location, "error");
            return;
        }
        const value = getAttributeValue(attribute);
        if (!value || value.trim() === "") {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location, "error");
        }
    }
}
class HTMLIframeHasTitleRule extends ParserRule {
    name = "html-iframe-has-title";
    check(result, context) {
        const visitor = new IframeHasTitleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ImgRequireAltVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(node) {
        const tagName = getTagName(node);
        if (tagName !== "img") {
            return;
        }
        if (!hasAttribute(node, "alt")) {
            this.addOffense('Missing required `alt` attribute on `<img>` tag. Add `alt=""` for decorative images or `alt="description"` for informative images.', node.tag_name.location, "error");
        }
    }
}
class HTMLImgRequireAltRule extends ParserRule {
    name = "html-img-require-alt";
    check(result, context) {
        const visitor = new ImgRequireAltVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NavigationHasLabelVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkNavigationElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkNavigationElement(node) {
        const tagName = getTagName(node);
        const isNavElement = tagName === "nav";
        const hasNavigationRole = this.hasRoleNavigation(node);
        if (!isNavElement && !hasNavigationRole) {
            return;
        }
        const hasAriaLabel = hasAttribute(node, "aria-label");
        const hasAriaLabelledby = hasAttribute(node, "aria-labelledby");
        if (!hasAriaLabel && !hasAriaLabelledby) {
            let message = `The navigation landmark should have a unique accessible name via \`aria-label\` or \`aria-labelledby\`. Remember that the name does not need to include "navigation" or "nav" since it will already be announced.`;
            if (hasNavigationRole && !isNavElement) {
                message += ` Additionally, you can safely drop the \`role="navigation"\` and replace it with the native HTML \`<nav>\` element.`;
            }
            this.addOffense(message, node.tag_name.location, "error");
        }
    }
    hasRoleNavigation(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "navigation";
    }
}
class HTMLNavigationHasLabelRule extends ParserRule {
    name = "html-navigation-has-label";
    check(result, context) {
        const visitor = new NavigationHasLabelVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const INTERACTIVE_ELEMENTS = new Set([
    "button", "summary", "input", "select", "textarea", "a"
]);
class NoAriaHiddenOnFocusableVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkAriaHiddenOnFocusable(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAriaHiddenOnFocusable(node) {
        if (!this.hasAriaHiddenTrue(node))
            return;
        if (this.isFocusable(node)) {
            this.addOffense(`Elements that are focusable should not have \`aria-hidden="true"\` because it will cause confusion for assistive technology users.`, node.tag_name.location, "error");
        }
    }
    hasAriaHiddenTrue(node) {
        const attributes = getAttributes(node);
        const ariaHiddenAttr = findAttributeByName(attributes, "aria-hidden");
        if (!ariaHiddenAttr)
            return false;
        const value = getAttributeValue(ariaHiddenAttr);
        return value === "true";
    }
    isFocusable(node) {
        const tagName = getTagName(node);
        if (!tagName)
            return false;
        const tabIndexValue = this.getTabIndexValue(node);
        if (tagName === "a") {
            const hasHref = hasAttribute(node, "href");
            if (!hasHref) {
                return tabIndexValue !== null && tabIndexValue >= 0;
            }
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        if (INTERACTIVE_ELEMENTS.has(tagName)) {
            // Interactive elements are focusable unless tabindex is negative
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        else {
            // Non-interactive elements are focusable only if tabindex >= 0
            return tabIndexValue !== null && tabIndexValue >= 0;
        }
    }
    getTabIndexValue(node) {
        const attributes = getAttributes(node);
        const tabIndexAttribute = findAttributeByName(attributes, "tabindex");
        if (!tabIndexAttribute)
            return null;
        const value = getAttributeValue(tabIndexAttribute);
        if (!value)
            return null;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? null : parsed;
    }
}
class HTMLNoAriaHiddenOnFocusableRule extends ParserRule {
    name = "html-no-aria-hidden-on-focusable";
    check(result, context) {
        const visitor = new NoAriaHiddenOnFocusableVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoDuplicateAttributesVisitor extends AttributeVisitorMixin {
    attributeNames = new Map();
    visitHTMLOpenTagNode(node) {
        this.attributeNames.clear();
        super.visitHTMLOpenTagNode(node);
        this.reportDuplicates();
    }
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    trackAttributeName(attributeName, attributeNode) {
        if (!this.attributeNames.has(attributeName)) {
            this.attributeNames.set(attributeName, []);
        }
        this.attributeNames.get(attributeName).push(attributeNode);
    }
    reportDuplicates() {
        for (const [attributeName, attributeNodes] of this.attributeNames) {
            if (attributeNodes.length > 1) {
                for (let i = 1; i < attributeNodes.length; i++) {
                    const attributeNode = attributeNodes[i];
                    this.addOffense(`Duplicate attribute \`${attributeName}\` found on tag. Remove the duplicate occurrence.`, attributeNode.name.location, "error");
                }
            }
        }
    }
}
class HTMLNoDuplicateAttributesRule extends ParserRule {
    name = "html-no-duplicate-attributes";
    check(result, context) {
        const visitor = new NoDuplicateAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class OutputPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.write(IdentityPrinter.print(node));
        }
    }
}
class NoDuplicateIdsVisitor extends ControlFlowTrackingVisitor {
    documentIds = new Set();
    currentBranchIds = new Set();
    controlFlowIds = new Set();
    visitHTMLAttributeNode(node) {
        this.checkAttribute(node);
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds,
            previousControlFlowIds: this.controlFlowIds
        };
        this.currentBranchIds = new Set();
        if (!wasAlreadyInControlFlow) {
            this.controlFlowIds = new Set();
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowIds.forEach(id => this.documentIds.add(id));
        }
        this.currentBranchIds = stateToRestore.previousBranchIds;
        this.controlFlowIds = stateToRestore.previousControlFlowIds;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds
        };
        if (this.isInControlFlow) {
            this.currentBranchIds = new Set();
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    checkAttribute(attributeNode) {
        if (!this.isIdAttribute(attributeNode))
            return;
        const idValue = this.extractIdValue(attributeNode);
        if (!idValue)
            return;
        if (this.isWhitespaceOnlyId(idValue.identifier))
            return;
        this.processIdDuplicate(idValue, attributeNode);
    }
    isIdAttribute(attributeNode) {
        if (!attributeNode.name?.children || !attributeNode.value)
            return false;
        return getStaticAttributeName(attributeNode.name) === "id";
    }
    extractIdValue(attributeNode) {
        const valueNodes = attributeNode.value?.children || [];
        if (hasERBOutput(valueNodes) && this.isInControlFlow && this.currentControlFlowType === ControlFlowType.LOOP) {
            return null;
        }
        const identifier = isEffectivelyStatic(valueNodes) ? getValidatableStaticContent(valueNodes) : OutputPrinter.print(valueNodes);
        if (!identifier)
            return null;
        return { identifier, shouldTrackDuplicates: true };
    }
    isWhitespaceOnlyId(identifier) {
        return identifier !== '' && identifier.trim() === '';
    }
    processIdDuplicate(idValue, attributeNode) {
        const { identifier, shouldTrackDuplicates } = idValue;
        if (!shouldTrackDuplicates)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowId(identifier, attributeNode);
        }
        else {
            this.handleGlobalId(identifier, attributeNode);
        }
    }
    handleControlFlowId(identifier, attributeNode) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.handleLoopId(identifier, attributeNode);
        }
        else {
            this.handleConditionalId(identifier, attributeNode);
        }
        this.currentBranchIds.add(identifier);
    }
    handleLoopId(identifier, attributeNode) {
        const isStaticId = this.isStaticId(attributeNode);
        if (isStaticId) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        if (this.currentBranchIds.has(identifier)) {
            this.addSameLoopIterationOffense(identifier, attributeNode.location);
        }
    }
    handleConditionalId(identifier, attributeNode) {
        if (this.currentBranchIds.has(identifier)) {
            this.addSameBranchOffense(identifier, attributeNode.location);
            return;
        }
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.controlFlowIds.add(identifier);
    }
    handleGlobalId(identifier, attributeNode) {
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.documentIds.add(identifier);
    }
    isStaticId(attributeNode) {
        const valueNodes = attributeNode.value.children;
        const isCompletelyStatic = valueNodes.every(child => isNode(child, LiteralNode));
        const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
        return isCompletelyStatic || isEffectivelyStaticValue;
    }
    addDuplicateIdOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found. IDs must be unique within a document.`, location, "error");
    }
    addSameLoopIterationOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same loop iteration. IDs must be unique within the same loop iteration.`, location, "error");
    }
    addSameBranchOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same control flow branch. IDs must be unique within the same control flow branch.`, location, "error");
    }
}
class HTMLNoDuplicateIdsRule extends ParserRule {
    name = "html-no-duplicate-ids";
    check(result, context) {
        const visitor = new NoDuplicateIdsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoEmptyHeadingsVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        this.checkHeadingElement(node);
        super.visitHTMLElementNode(node);
    }
    checkHeadingElement(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (!tagName) {
            return;
        }
        const isStandardHeading = HEADING_TAGS.has(tagName);
        const isAriaHeading = this.hasHeadingRole(openTag);
        if (!isStandardHeading && !isAriaHeading) {
            return;
        }
        if (this.isEmptyHeading(node)) {
            const elementDescription = isStandardHeading
                ? `\`<${tagName}>\``
                : `\`<${tagName} role="heading">\``;
            this.addOffense(`Heading element ${elementDescription} must not be empty. Provide accessible text content for screen readers and SEO.`, node.location, "error");
        }
    }
    isEmptyHeading(node) {
        if (!node.body || node.body.length === 0) {
            return true;
        }
        // Check if all content is just whitespace or inaccessible
        let hasAccessibleContent = false;
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                // Check if this element is accessible (not aria-hidden="true")
                if (this.isElementAccessible(elementNode)) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                hasAccessibleContent = true;
                break;
            }
        }
        return !hasAccessibleContent;
    }
    hasHeadingRole(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "heading";
    }
    isElementAccessible(node) {
        // Check if the element has aria-hidden="true"
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return true;
        }
        const openTag = node.open_tag;
        const attributes = getAttributes(openTag);
        const ariaHiddenAttribute = findAttributeByName(attributes, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return false;
            }
        }
        // Recursively check if the element has any accessible content
        if (!node.body || node.body.length === 0) {
            return false;
        }
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    return true;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                return true;
            }
        }
        return false;
    }
}
class HTMLNoEmptyHeadingsRule extends ParserRule {
    name = "html-no-empty-headings";
    check(result, context) {
        const visitor = new NoEmptyHeadingsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NestedLinkVisitor extends BaseRuleVisitor {
    linkStack = [];
    checkNestedLink(openTag) {
        if (this.linkStack.length > 0) {
            this.addOffense("Nested `<a>` elements are not allowed. Links cannot contain other links.", openTag.tag_name.location, "error");
            return true;
        }
        return false;
    }
    visitHTMLElementNode(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (tagName !== "a") {
            super.visitHTMLElementNode(node);
            return;
        }
        // If we're already inside a link, this is a nested link
        this.checkNestedLink(openTag);
        this.linkStack.push(openTag);
        super.visitHTMLElementNode(node);
        this.linkStack.pop();
    }
    // Handle self-closing <a> tags (though they're not valid HTML, they might exist)
    visitHTMLOpenTagNode(node) {
        const tagName = getTagName(node);
        if (tagName === "a" && node.is_void) {
            this.checkNestedLink(node);
        }
        super.visitHTMLOpenTagNode(node);
    }
}
class HTMLNoNestedLinksRule extends ParserRule {
    name = "html-no-nested-links";
    check(result, context) {
        const visitor = new NestedLinkVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoPositiveTabIndexVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "tabindex")
            return;
        const tabIndexValue = parseInt(attributeValue, 10);
        if (!isNaN(tabIndexValue) && tabIndexValue > 0) {
            this.addOffense(`Do not use positive \`tabindex\` values as they are error prone and can severely disrupt navigation experience for keyboard users. Use \`tabindex="0"\` to make an element focusable or \`tabindex=\"-1\"\` to remove it from the tab sequence.`, attributeNode.location, "error");
        }
    }
}
class HTMLNoPositiveTabIndexRule extends ParserRule {
    name = "html-no-positive-tab-index";
    check(result, context) {
        const visitor = new NoPositiveTabIndexVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoSelfClosingVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node) === "svg") {
            this.visit(node.open_tag);
        }
        else {
            this.visitChildNodes(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_closing?.value === "/>") {
            const tagName = getTagName$1(node);
            const instead = isVoidElement(tagName) ? `<${tagName}>` : `<${tagName}></${tagName}>`;
            this.addOffense(`Use \`${instead}\` instead of self-closing \`<${tagName} />\` for HTML compatibility.`, node.location, "error");
        }
    }
}
class HTMLNoSelfClosingRule extends ParserRule {
    name = "html-no-self-closing";
    check(result, context) {
        const visitor = new NoSelfClosingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoTitleAttributeVisitor extends BaseRuleVisitor {
    ALLOWED_ELEMENTS_WITH_TITLE = new Set(["iframe", "link"]);
    visitHTMLOpenTagNode(node) {
        this.checkTitleAttribute(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkTitleAttribute(node) {
        const tagName = getTagName(node);
        if (!tagName || this.ALLOWED_ELEMENTS_WITH_TITLE.has(tagName)) {
            return;
        }
        if (hasAttribute(node, "title")) {
            this.addOffense("The `title` attribute should never be used as it is inaccessible for several groups of users. Use `aria-label` or `aria-describedby` instead. Exceptions are provided for `<iframe>` and `<link>` elements.", node.tag_name.location, "error");
        }
    }
}
class HTMLNoTitleAttributeRule extends ParserRule {
    name = "html-no-title-attribute";
    check(result, context) {
        const visitor = new NoTitleAttributeVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class XMLDeclarationChecker extends BaseRuleVisitor {
    hasXMLDeclaration = false;
    visitXMLDeclarationNode(_node) {
        this.hasXMLDeclaration = true;
    }
    visitChildNodes(node) {
        if (this.hasXMLDeclaration)
            return;
        super.visitChildNodes(node);
    }
}
class TagNameLowercaseVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node).toLowerCase() === "svg") {
            this.checkTagName(node.open_tag);
            this.checkTagName(node.close_tag);
        }
        else {
            super.visitHTMLElementNode(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        this.checkTagName(node);
    }
    visitHTMLCloseTagNode(node) {
        this.checkTagName(node);
    }
    checkTagName(node) {
        if (!node)
            return;
        const tagName = getTagName$1(node);
        if (!tagName)
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const type = isNode(node, HTMLOpenTagNode) ? "Opening" : "Closing";
        const open = isNode(node, HTMLOpenTagNode) ? "<" : "</";
        if (tagName !== lowercaseTagName) {
            this.addOffense(`${type} tag name \`${open}${tagName}>\` should be lowercase. Use \`${open}${lowercaseTagName}>\` instead.`, node.tag_name.location, "error");
        }
    }
}
class HTMLTagNameLowercaseRule extends ParserRule {
    name = "html-tag-name-lowercase";
    isEnabled(result, context) {
        if (context?.fileName?.endsWith(".xml") || context?.fileName?.endsWith(".xml.erb")) {
            return false;
        }
        const checker = new XMLDeclarationChecker(this.name);
        checker.visit(result.value);
        return !checker.hasXMLDeclaration;
    }
    check(result, context) {
        const visitor = new TagNameLowercaseVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ParserNoErrorsRule extends ParserRule {
    name = "parser-no-errors";
    check(result) {
        return result.recursiveErrors().map(error => this.herbErrorToLintOffense(error));
    }
    herbErrorToLintOffense(error) {
        return {
            message: `${error.message} (\`${error.type}\`)`,
            location: error.location,
            severity: error.severity,
            rule: this.name,
            code: this.name,
            source: "linter"
        };
    }
}

class SVGTagNameCapitalizationVisitor extends BaseRuleVisitor {
    insideSVG = false;
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName && ["svg"].includes(tagName.toLowerCase())) {
            const wasInsideSVG = this.insideSVG;
            this.insideSVG = true;
            this.visitChildNodes(node);
            this.insideSVG = wasInsideSVG;
            return;
        }
        if (this.insideSVG) {
            if (node.open_tag) {
                this.checkTagName(node.open_tag);
            }
            if (node.close_tag) {
                this.checkTagName(node.close_tag);
            }
        }
        this.visitChildNodes(node);
    }
    checkTagName(node) {
        const tagName = node.tag_name?.value;
        if (!tagName)
            return;
        if (SVG_CAMEL_CASE_ELEMENTS.has(tagName))
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const correctCamelCase = SVG_LOWERCASE_TO_CAMELCASE.get(lowercaseTagName);
        if (correctCamelCase && tagName !== correctCamelCase) {
            let type = node.type;
            if (node.type == "AST_HTML_OPEN_TAG_NODE")
                type = "Opening";
            if (node.type == "AST_HTML_CLOSE_TAG_NODE")
                type = "Closing";
            this.addOffense(`${type} SVG tag name \`${tagName}\` should use proper capitalization. Use \`${correctCamelCase}\` instead.`, node.tag_name.location, "error");
        }
    }
}
class SVGTagNameCapitalizationRule extends ParserRule {
    name = "svg-tag-name-capitalization";
    check(result, context) {
        const visitor = new SVGTagNameCapitalizationVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const defaultRules = [
    ERBNoEmptyTagsRule,
    ERBNoOutputControlFlowRule,
    ERBNoSilentTagInAttributeNameRule,
    ERBPreferImageTagHelperRule,
    ERBRequiresTrailingNewlineRule,
    ERBRequireWhitespaceRule,
    HTMLAnchorRequireHrefRule,
    HTMLAriaAttributeMustBeValid,
    HTMLAriaLabelIsWellFormattedRule,
    HTMLAriaLevelMustBeValidRule,
    HTMLAriaRoleHeadingRequiresLevelRule,
    HTMLAriaRoleMustBeValidRule,
    HTMLAttributeDoubleQuotesRule,
    HTMLAttributeEqualsSpacingRule,
    HTMLAttributeValuesRequireQuotesRule,
    HTMLAvoidBothDisabledAndAriaDisabledRule,
    HTMLBooleanAttributesNoValueRule,
    HTMLIframeHasTitleRule,
    HTMLImgRequireAltRule,
    HTMLNavigationHasLabelRule,
    HTMLNoAriaHiddenOnFocusableRule,
    // HTMLNoBlockInsideInlineRule,
    HTMLNoDuplicateAttributesRule,
    HTMLNoDuplicateIdsRule,
    HTMLNoEmptyHeadingsRule,
    HTMLNoNestedLinksRule,
    HTMLNoPositiveTabIndexRule,
    HTMLNoSelfClosingRule,
    HTMLNoTitleAttributeRule,
    HTMLTagNameLowercaseRule,
    ParserNoErrorsRule,
    SVGTagNameCapitalizationRule,
];

class Linter {
    rules;
    herb;
    offenses;
    /**
     * Creates a new Linter instance.
     * @param herb - The Herb backend instance for parsing and lexing
     * @param rules - Array of rule classes (Parser/AST or Lexer) to use. If not provided, uses default rules.
     */
    constructor(herb, rules) {
        this.herb = herb;
        this.rules = rules !== undefined ? rules : this.getDefaultRules();
        this.offenses = [];
    }
    /**
     * Returns the default set of rule classes used by the linter.
     * @returns Array of rule classes
     */
    getDefaultRules() {
        return defaultRules;
    }
    getRuleCount() {
        return this.rules.length;
    }
    /**
     * Type guard to check if a rule is a LexerRule
     */
    isLexerRule(rule) {
        return rule.constructor.type === "lexer";
    }
    /**
     * Type guard to check if a rule is a SourceRule
     */
    isSourceRule(rule) {
        return rule.constructor.type === "source";
    }
    /**
     * Lint source code using Parser/AST, Lexer, and Source rules.
     * @param source - The source code to lint
     * @param context - Optional context for linting (e.g., fileName for distinguishing files vs snippets)
     */
    lint(source, context) {
        this.offenses = [];
        const parseResult = this.herb.parse(source, { track_whitespace: true });
        const lexResult = this.herb.lex(source);
        for (const RuleClass of this.rules) {
            const rule = new RuleClass();
            let isEnabled = true;
            let ruleOffenses;
            if (this.isLexerRule(rule)) {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(lexResult, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(lexResult, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            else if (this.isSourceRule(rule)) {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(source, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(source, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            else {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(parseResult, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(parseResult, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            this.offenses.push(...ruleOffenses);
        }
        const errors = this.offenses.filter(offense => offense.severity === "error").length;
        const warnings = this.offenses.filter(offense => offense.severity === "warning").length;
        return {
            offenses: this.offenses,
            errors,
            warnings
        };
    }
}

class LinterService {
    constructor(settings) {
        this.source = "Herb Linter ";
        this.settings = settings;
        this.linter = new Linter(Herb);
    }
    async lintDocument(textDocument) {
        var _a, _b, _c, _d;
        const settings = await this.settings.getDocumentSettings(textDocument.uri);
        const linterEnabled = (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.linter) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : true;
        if (!linterEnabled) {
            return { diagnostics: [] };
        }
        const lintResult = this.linter.lint(textDocument.getText(), { fileName: textDocument.uri });
        const excludedRules = (_d = (_c = settings === null || settings === void 0 ? void 0 : settings.linter) === null || _c === void 0 ? void 0 : _c.excludedRules) !== null && _d !== void 0 ? _d : ["parser-no-errors"];
        const offenses = lintResult.offenses.filter(offense => !excludedRules.includes(offense.rule));
        const diagnostics = offenses.map(offense => {
            const range = nodeExports.Range.create(nodeExports.Position.create(offense.location.start.line - 1, offense.location.start.column), nodeExports.Position.create(offense.location.end.line - 1, offense.location.end.column));
            const codeDescription = {
                href: `https://herb-tools.dev/linter/rules/${offense.rule}`
            };
            return {
                source: this.source,
                severity: this.lintToDignosticSeverity(offense.severity),
                range,
                message: offense.message,
                code: offense.rule,
                data: { rule: offense.rule },
                codeDescription
            };
        });
        return { diagnostics };
    }
    lintToDignosticSeverity(severity) {
        switch (severity) {
            case "error": return nodeExports.DiagnosticSeverity.Error;
            case "warning": return nodeExports.DiagnosticSeverity.Warning;
            case "info": return nodeExports.DiagnosticSeverity.Information;
            case "hint": return nodeExports.DiagnosticSeverity.Hint;
        }
    }
}

var version = "0.6.1";

class Config {
    constructor(projectPath, config) {
        this.path = Config.configPathFromProjectPath(projectPath);
        this.config = config;
    }
    get version() {
        return this.config.version;
    }
    get createdAt() {
        return new Date(this.config.createdAt);
    }
    get updatedAt() {
        return new Date(this.config.updatedAt);
    }
    get options() {
        return this.config.options;
    }
    toJSON() {
        return JSON.stringify(this.config, null, "  ");
    }
    updateTimestamp() {
        this.config.updatedAt = new Date().toISOString();
    }
    updateVersion() {
        this.config.version = version;
    }
    async write() {
        this.updateVersion();
        this.updateTimestamp();
        const folder = require$$1.dirname(this.path);
        require$$2$1.promises.stat(folder)
            .then(() => { })
            .catch(async () => await require$$2$1.promises.mkdir(folder))
            .finally(async () => await require$$2$1.promises.writeFile(this.path, this.toJSON()));
    }
    async read() {
        return await require$$2$1.promises.readFile(this.path, "utf8");
    }
    static configPathFromProjectPath(projectPath) {
        return require$$1.join(projectPath, this.configPath);
    }
    static async fromPathOrNew(projectPath) {
        try {
            return await this.fromPath(projectPath);
        }
        catch (error) {
            return Config.newConfig(projectPath);
        }
    }
    static async fromPath(projectPath) {
        const configPath = Config.configPathFromProjectPath(projectPath);
        try {
            const config = JSON.parse(await require$$2$1.promises.readFile(configPath, "utf8"));
            return new Config(projectPath, config);
        }
        catch (error) {
            throw new Error(`Error reading config file at: ${configPath}. Error: ${error.message}`);
        }
    }
    static newConfig(projectPath) {
        return new Config(projectPath, {
            version,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            options: {}
        });
    }
}
Config.configPath = ".herb-lsp/config.json";

class Project {
    constructor(connection, projectPath) {
        this.projectPath = projectPath;
        this.connection = connection;
        this.herbBackend = Herb;
    }
    async initialize() {
        await this.herbBackend.load();
    }
    async refresh() {
        // TODO
    }
}

var balancedMatch;
var hasRequiredBalancedMatch;

function requireBalancedMatch () {
	if (hasRequiredBalancedMatch) return balancedMatch;
	hasRequiredBalancedMatch = 1;
	balancedMatch = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    if(a===b) {
	      return [ai, bi];
	    }
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}
	return balancedMatch;
}

var braceExpansion;
var hasRequiredBraceExpansion;

function requireBraceExpansion () {
	if (hasRequiredBraceExpansion) return braceExpansion;
	hasRequiredBraceExpansion = 1;
	var balanced = requireBalancedMatch();

	braceExpansion = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m) return [str];

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  if (/\$$/.test(m.pre)) {    
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre+ '{' + m.body + '}' + post[k];
	      expansions.push(expansion);
	    }
	  } else {
	    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	    var isSequence = isNumericSequence || isAlphaSequence;
	    var isOptions = m.body.indexOf(',') >= 0;
	    if (!isSequence && !isOptions) {
	      // {a},b}
	      if (m.post.match(/,.*\}/)) {
	        str = m.pre + '{' + m.body + escClose + m.post;
	        return expand(str);
	      }
	      return [str];
	    }

	    var n;
	    if (isSequence) {
	      n = m.body.split(/\.\./);
	    } else {
	      n = parseCommaParts(m.body);
	      if (n.length === 1) {
	        // x{{a,b}}y ==> x{a}y x{b}y
	        n = expand(n[0], false).map(embrace);
	        if (n.length === 1) {
	          return post.map(function(p) {
	            return m.pre + n[0] + p;
	          });
	        }
	      }
	    }

	    // at this point, n is the parts, and we know it's not a comma set
	    // with a single entry.
	    var N;

	    if (isSequence) {
	      var x = numeric(n[0]);
	      var y = numeric(n[1]);
	      var width = Math.max(n[0].length, n[1].length);
	      var incr = n.length == 3
	        ? Math.abs(numeric(n[2]))
	        : 1;
	      var test = lte;
	      var reverse = y < x;
	      if (reverse) {
	        incr *= -1;
	        test = gte;
	      }
	      var pad = n.some(isPadded);

	      N = [];

	      for (var i = x; test(i, y); i += incr) {
	        var c;
	        if (isAlphaSequence) {
	          c = String.fromCharCode(i);
	          if (c === '\\')
	            c = '';
	        } else {
	          c = String(i);
	          if (pad) {
	            var need = width - c.length;
	            if (need > 0) {
	              var z = new Array(need + 1).join('0');
	              if (i < 0)
	                c = '-' + z + c.slice(1);
	              else
	                c = z + c;
	            }
	          }
	        }
	        N.push(c);
	      }
	    } else {
	      N = [];

	      for (var j = 0; j < n.length; j++) {
	        N.push.apply(N, expand(n[j], false));
	      }
	    }

	    for (var j = 0; j < N.length; j++) {
	      for (var k = 0; k < post.length; k++) {
	        var expansion = pre + N[j] + post[k];
	        if (!isTop || isSequence || expansion)
	          expansions.push(expansion);
	      }
	    }
	  }

	  return expansions;
	}
	return braceExpansion;
}

var braceExpansionExports = requireBraceExpansion();
var expand = /*@__PURE__*/getDefaultExportFromCjs(braceExpansionExports);

const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};

/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};

// parse a single path portion
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark$1 = '[^/]';
// * => any number of characters
const star$1 = qmark$1 + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark$1 + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star$1 +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star$1;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark$1;
                hasMagic = true;
                continue;
            }
            re += regExpEscape$1(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}

/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};

const minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform$2 = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
const sep = defaultPlatform$2 === 'win32' ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform$2;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            return pp.filter(p => p !== GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof Stream ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
class Minipass extends node_events.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new node_string_decoder.StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}

const realpathSync = require$$2$1.realpathSync.native;
const defaultFS = {
    lstatSync: require$$2$1.lstatSync,
    readdir: require$$2$1.readdir,
    readdirSync: require$$2$1.readdirSync,
    readlinkSync: require$$2$1.readlinkSync,
    realpathSync,
    promises: {
        lstat: promises.lstat,
        readdir: promises.readdir,
        readlink: promises.readlink,
        realpath: promises.realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS__namespace ?
    defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH = 0b0010_0000_0000;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 0b0011_1111_1111;
const entToType = (s) => s.isFile() ? IFREG
    : s.isDirectory() ? IFDIR
        : s.isSymbolicLink() ? IFLNK
            : s.isCharacterDevice() ? IFCHR
                : s.isBlockDevice() ? IFBLK
                    : s.isSocket() ? IFSOCK
                        : s.isFIFO() ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
class ResolveCache extends LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
class ChildrenCache extends LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
        return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     */
    get path() {
        return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ?
            this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.isCWD)
            return '';
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.isCWD)
            return '';
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return (this.isUnknown() ? 'Unknown'
            : this.isDirectory() ? 'Directory'
                : this.isFile() ? 'File'
                    : this.isSymbolicLink() ? 'SymbolicLink'
                        : this.isFIFO() ? 'FIFO'
                            : this.isCharacterDevice() ? 'CharacterDevice'
                                : this.isBlockDevice() ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
                                        : 'Unknown');
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase ?
            this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.realpathSync()?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR)
            t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === 'ENOENT')
            ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return node_path.win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp, '$1\\');
        return rootPath === compare;
    }
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = node_url.fileURLToPath(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map(e => e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else if (withFileTypes) {
            return entry.readdirSync();
        }
        else {
            return entry.readdirSync().map(e => e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path.win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return node_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path.posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
const PathScurry = process.platform === 'win32' ? PathScurryWin32
    : process.platform === 'darwin' ? PathScurryDarwin
        : PathScurryPosix;

// this is just a very light wrapper around 2 arrays with an offset index
const isPatternList = (pl) => pl.length >= 1;
const isGlobList = (gl) => gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */
class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
            throw new TypeError('empty pattern list');
        }
        if (!isGlobList(globList)) {
            throw new TypeError('empty glob list');
        }
        if (globList.length !== patternList.length) {
            throw new TypeError('mismatched pattern list and glob list lengths');
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError('index out of range');
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [p0, p1, p2, p3, ''].join('/');
                const g = [g0, g1, g2, g3, ''].join('/');
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
            else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + '/';
                const g = g1 + '/';
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
        return typeof this.#patternList[this.#index] === 'string';
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
        return (this.#globString =
            this.#globString ||
                (this.#index === 0 ?
                    this.isAbsolute() ?
                        this.#globList[0] + this.#globList.slice(1).join('/')
                        : this.#globList.join('/')
                    : this.#globList.slice(this.#index).join('/')));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
        if (this.#rest !== undefined)
            return this.#rest;
        if (!this.hasMore())
            return (this.#rest = null);
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined ?
            this.#isUNC
            : (this.#isUNC =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    pl[0] === '' &&
                    pl[1] === '' &&
                    typeof pl[2] === 'string' &&
                    !!pl[2] &&
                    typeof pl[3] === 'string' &&
                    !!pl[3]);
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined ?
            this.#isDrive
            : (this.#isDrive =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    this.length > 1 &&
                    typeof pl[0] === 'string' &&
                    /^[a-z]:$/i.test(pl[0]));
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined ?
            this.#isAbsolute
            : (this.#isAbsolute =
                (pl[0] === '' && pl.length > 1) ||
                    this.isDrive() ||
                    this.isUNC());
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
        const p = this.#patternList[0];
        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
            p
            : '';
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
        return !(this.#index === 0 ||
            !this.isGlobstar() ||
            !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
            return false;
        this.#followGlobstar = false;
        return true;
    }
}

// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode
const defaultPlatform$1 = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * Class used to process ignored patterns
 */
class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform$1, }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true,
        };
        for (const ign of ignored)
            this.add(ign);
    }
    add(ign) {
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        const mm = new Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
            const parsed = mm.set[i];
            const globParts = mm.globParts[i];
            /* c8 ignore start */
            if (!parsed || !globParts) {
                throw new Error('invalid pattern object');
            }
            // strip off leading ./ portions
            // https://github.com/isaacs/node-glob/issues/570
            while (parsed[0] === '.' && globParts[0] === '.') {
                parsed.shift();
                globParts.shift();
            }
            /* c8 ignore stop */
            const p = new Pattern(parsed, globParts, 0, this.platform);
            const m = new Minimatch(p.globString(), this.mmopts);
            const children = globParts[globParts.length - 1] === '**';
            const absolute = p.isAbsolute();
            if (absolute)
                this.absolute.push(m);
            else
                this.relative.push(m);
            if (children) {
                if (absolute)
                    this.absoluteChildren.push(m);
                else
                    this.relativeChildren.push(m);
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || '.';
        const relatives = `${relative}/`;
        for (const m of this.relative) {
            if (m.match(relative) || m.match(relatives))
                return true;
        }
        for (const m of this.absolute) {
            if (m.match(fullpath) || m.match(fullpaths))
                return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + '/';
        const relative = (p.relative() || '.') + '/';
        for (const m of this.relativeChildren) {
            if (m.match(relative))
                return true;
        }
        for (const m of this.absoluteChildren) {
            if (m.match(fullpath))
                return true;
        }
        return false;
    }
}

// synchronous utility for filtering entries and calculating subwalks
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache =
            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined ?
                    this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith('.')) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                }
                else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    }
                    else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === 'string' &&
                // dots and empty were handled already
                rp !== '..' &&
                rp !== '' &&
                rp !== '.') {
                this.testString(e, rp, rest.rest(), absolute);
            }
            else if (rp === '..') {
                /* c8 ignore start */
                const ep = e.parent || e;
                /* c8 ignore stop */
                this.subwalks.add(ep, rest);
            }
            else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
}

/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new Ignore([ignore], opts)
    : Array.isArray(ignore) ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
            if (!this.includeChildMatches &&
                typeof this.#ignore.add !== 'function') {
                const m = 'cannot ignore child matches, ignore lacks add() method.';
                throw new Error(m);
            }
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return (e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)) ?
            e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        // we know we have an ignore if this is false, but TS doesn't
        if (!this.includeChildMatches && this.#ignore?.add) {
            const ign = `${e.relativePosix()}/**`;
            this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
                '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
}
class GlobWalker extends GlobUtil {
    matches = new Set();
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej) => {
            this.walkCB(this.path, this.patterns, () => {
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                }
                else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, () => {
            if (this.signal?.aborted)
                throw this.signal.reason;
        });
        return this.matches;
    }
}
class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new Minipass({
            signal: this.signal,
            objectMode: true,
        });
        this.results.on('drain', () => this.resume());
        this.results.on('resume', () => this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
            this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(() => {
                this.walkCB(target, this.patterns, () => this.results.end());
            });
        }
        else {
            this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
    }
}

// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const defaultPlatform = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * An object that can perform glob pattern traversals.
 */
class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
        /* c8 ignore start */
        if (!opts)
            throw new TypeError('glob options required');
        /* c8 ignore stop */
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = '';
        }
        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
            opts.cwd = node_url.fileURLToPath(opts.cwd);
        }
        this.cwd = opts.cwd || '';
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth =
            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error('cannot set absolute and withFileTypes:true');
        }
        if (typeof pattern === 'string') {
            pattern = [pattern];
        }
        this.windowsPathsNoEscape =
            !!opts.windowsPathsNoEscape ||
                opts.allowWindowsEscape ===
                    false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map(p => p.replace(/\\/g, '/'));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError('base matching requires globstar');
            }
            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined &&
                opts.nocase !== opts.scurry.nocase) {
                throw new Error('nocase option contradicts provided scurry option');
            }
        }
        else {
            const Scurry = opts.platform === 'win32' ? PathScurryWin32
                : opts.platform === 'darwin' ? PathScurryDarwin
                    : opts.platform ? PathScurryPosix
                        : PathScurry;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs,
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug,
        };
        const mms = this.pattern.map(p => new Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
            const g = globParts[i];
            /* c8 ignore start */
            if (!g)
                throw new Error('invalid pattern object');
            /* c8 ignore stop */
            return new Pattern(set, g, 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...(await new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walk()),
        ];
    }
    walkSync() {
        return [
            ...new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walkSync(),
        ];
    }
    stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).stream();
    }
    streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}

/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */
const hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
        pattern = [pattern];
    }
    for (const p of pattern) {
        if (new Minimatch(p, options).hasMagic())
            return true;
    }
    return false;
};

function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
}
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
const streamSync = globStreamSync;
const stream = Object.assign(globStream, { sync: globStreamSync });
const iterateSync = globIterateSync;
const iterate = Object.assign(globIterate, {
    sync: globIterateSync,
});
const sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync,
});
const glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape,
});
glob.glob = glob;

class FormattingService {
    constructor(connection, documents, project, settings) {
        this.connection = connection;
        this.documents = documents;
        this.project = project;
        this.settings = settings;
    }
    async initialize() {
        try {
            this.config = await Config.fromPathOrNew(this.project.projectPath);
            this.connection.console.log("Herb formatter initialized successfully");
        }
        catch (error) {
            this.connection.console.error(`Failed to initialize Herb formatter: ${error}`);
        }
    }
    async refreshConfig() {
        this.config = await Config.fromPathOrNew(this.project.projectPath);
    }
    async shouldFormatFile(filePath) {
        var _a;
        if (!((_a = this.config) === null || _a === void 0 ? void 0 : _a.options.formatter)) {
            return true;
        }
        const formatter = this.config.options.formatter;
        // Check if formatting is disabled in project config
        if (formatter.enabled === false) {
            return false;
        }
        // Check exclude patterns first
        if (formatter.exclude) {
            for (const pattern of formatter.exclude) {
                try {
                    const matches = await new Promise((resolve, reject) => {
                        glob(pattern, { cwd: this.project.projectPath }).then(resolve).catch(reject);
                    });
                    if (Array.isArray(matches) && matches.some((match) => filePath.includes(match) || filePath.endsWith(match))) {
                        return false;
                    }
                }
                catch (error) {
                    continue;
                }
            }
        }
        if (formatter.include && formatter.include.length > 0) {
            for (const pattern of formatter.include) {
                try {
                    const matches = await new Promise((resolve, reject) => {
                        glob(pattern, { cwd: this.project.projectPath }).then(resolve).catch(reject);
                    });
                    if (Array.isArray(matches) && matches.some((match) => filePath.includes(match) || filePath.endsWith(match))) {
                        return true;
                    }
                }
                catch (error) {
                    continue;
                }
            }
            return false;
        }
        return true;
    }
    async getFormatterOptions(uri) {
        var _a, _b, _c, _d, _e, _f, _g;
        const settings = await this.settings.getDocumentSettings(uri);
        const projectFormatter = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.options.formatter) || {};
        return {
            indentWidth: (_d = (_b = projectFormatter.indentWidth) !== null && _b !== void 0 ? _b : (_c = settings === null || settings === void 0 ? void 0 : settings.formatter) === null || _c === void 0 ? void 0 : _c.indentWidth) !== null && _d !== void 0 ? _d : defaultFormatOptions.indentWidth,
            maxLineLength: (_g = (_e = projectFormatter.maxLineLength) !== null && _e !== void 0 ? _e : (_f = settings === null || settings === void 0 ? void 0 : settings.formatter) === null || _f === void 0 ? void 0 : _f.maxLineLength) !== null && _g !== void 0 ? _g : defaultFormatOptions.maxLineLength
        };
    }
    async performFormatting(params) {
        const document = this.documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        try {
            const options = await this.getFormatterOptions(params.textDocument.uri);
            const formatter = new Formatter(this.project.herbBackend, options);
            const text = document.getText();
            let newText = formatter.format(text);
            if (!newText.endsWith('\n')) {
                newText = newText + '\n';
            }
            if (newText === text) {
                return [];
            }
            const range = {
                start: nodeExports.Position.create(0, 0),
                end: nodeExports.Position.create(document.lineCount, 0)
            };
            return [{ range, newText }];
        }
        catch (error) {
            this.connection.console.error(`Formatting failed: ${error}`);
            return [];
        }
    }
    async formatDocument(params) {
        var _a;
        const settings = await this.settings.getDocumentSettings(params.textDocument.uri);
        if (((_a = settings === null || settings === void 0 ? void 0 : settings.formatter) === null || _a === void 0 ? void 0 : _a.enabled) === false) {
            return [];
        }
        const filePath = params.textDocument.uri.replace(/^file:\/\//, '');
        if (!(await this.shouldFormatFile(filePath))) {
            return [];
        }
        return this.performFormatting(params);
    }
    async formatDocumentIgnoreConfig(params) {
        return this.performFormatting(params);
    }
    async performRangeFormatting(params) {
        var _a;
        const document = this.documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        try {
            const options = await this.getFormatterOptions(params.textDocument.uri);
            const formatter = new Formatter(this.project.herbBackend, options);
            const rangeText = document.getText(params.range);
            const lines = rangeText.split('\n');
            let minIndentLevel = Infinity;
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '') {
                    const indent = ((_a = line.match(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0]) || '';
                    const indentLevel = Math.floor(indent.length / options.indentWidth);
                    minIndentLevel = Math.min(minIndentLevel, indentLevel);
                }
            }
            if (minIndentLevel === Infinity) {
                minIndentLevel = 0;
            }
            let textToFormat = rangeText;
            if (minIndentLevel > 0) {
                const minIndentString = ' '.repeat(minIndentLevel * options.indentWidth);
                textToFormat = lines.map(line => {
                    if (line.trim() === '') {
                        return line;
                    }
                    return line.startsWith(minIndentString) ? line.slice(minIndentString.length) : line;
                }).join('\n');
            }
            let formattedText = formatter.format(textToFormat, { ...options });
            if (minIndentLevel > 0) {
                const formattedLines = formattedText.split('\n');
                const indentString = ' '.repeat(minIndentLevel * options.indentWidth);
                formattedText = formattedLines.map((line, _index) => {
                    if (line.trim() === '') {
                        return line;
                    }
                    return indentString + line;
                }).join('\n');
            }
            if (!formattedText.endsWith('\n')) {
                formattedText += '\n';
            }
            if (formattedText === rangeText) {
                return [];
            }
            return [{ range: params.range, newText: formattedText }];
        }
        catch (error) {
            this.connection.console.error(`Range formatting failed: ${error}`);
            return [];
        }
    }
    async formatRange(params) {
        const filePath = params.textDocument.uri.replace(/^file:\/\//, '');
        if (!(await this.shouldFormatFile(filePath))) {
            return [];
        }
        return this.performRangeFormatting(params);
    }
    async formatRangeIgnoreConfig(params) {
        return this.performRangeFormatting(params);
    }
}

class Service {
    constructor(connection, params) {
        this.connection = connection;
        this.settings = new Settings(params, this.connection);
        this.documentService = new DocumentService(this.connection);
        this.project = new Project(connection, this.settings.projectPath.replace("file://", ""));
        this.parserService = new ParserService();
        this.linterService = new LinterService(this.settings);
        this.formatting = new FormattingService(this.connection, this.documentService.documents, this.project, this.settings);
        this.diagnostics = new Diagnostics(this.connection, this.documentService, this.parserService, this.linterService);
        // Initialize global settings from initialization options
        if (params.initializationOptions) {
            this.settings.globalSettings = params.initializationOptions;
        }
    }
    async init() {
        await this.project.initialize();
        await this.formatting.initialize();
        this.config = await Config.fromPathOrNew(this.project.projectPath);
        // Only keep settings for open documents
        this.documentService.onDidClose((change) => {
            this.settings.documentSettings.delete(change.document.uri);
        });
        // The content of a text document has changed. This event is emitted
        // when the text document first opened or when its content has changed.
        this.documentService.onDidChangeContent(async (change) => {
            await this.diagnostics.refreshDocument(change.document);
        });
    }
    async refresh() {
        await this.project.refresh();
        await this.diagnostics.refreshAllDocuments();
    }
    async refreshConfig() {
        this.config = await Config.fromPathOrNew(this.project.projectPath);
        await this.formatting.refreshConfig();
    }
}

class Server {
    constructor() {
        this.connection = nodeExports.createConnection(nodeExports.ProposedFeatures.all);
        this.setupEventHandlers();
    }
    setupEventHandlers() {
        this.connection.onInitialize(async (params) => {
            this.service = new Service(this.connection, params);
            await this.service.init();
            const result = {
                capabilities: {
                    textDocumentSync: nodeExports.TextDocumentSyncKind.Incremental,
                    documentFormattingProvider: true,
                    documentRangeFormattingProvider: true,
                },
            };
            if (this.service.settings.hasWorkspaceFolderCapability) {
                result.capabilities.workspace = {
                    workspaceFolders: {
                        supported: true,
                    },
                };
            }
            return result;
        });
        this.connection.onInitialized(() => {
            if (this.service.settings.hasConfigurationCapability) {
                // Register for all configuration changes.
                this.connection.client.register(nodeExports.DidChangeConfigurationNotification.type, undefined);
            }
            if (this.service.settings.hasWorkspaceFolderCapability) {
                this.connection.workspace.onDidChangeWorkspaceFolders((_event) => {
                    this.connection.console.log("Workspace folder change event received.");
                });
            }
            this.connection.client.register(nodeExports.DidChangeWatchedFilesNotification.type, {
                watchers: [
                    { globPattern: `**/**/*.html.erb` },
                    { globPattern: `**/**/.herb-lsp/config.json` },
                ],
            });
        });
        this.connection.onDidChangeConfiguration(async (change) => {
            if (this.service.settings.hasConfigurationCapability) {
                // Reset all cached document settings
                this.service.settings.documentSettings.clear();
            }
            else {
                this.service.settings.globalSettings = ((change.settings.languageServerHerb || this.service.settings.defaultSettings));
            }
            await this.service.refresh();
        });
        this.connection.onDidOpenTextDocument(async (params) => {
            const document = this.service.documentService.get(params.textDocument.uri);
            if (document) {
                await this.service.diagnostics.refreshDocument(document);
            }
        });
        this.connection.onDidChangeWatchedFiles((params) => {
            params.changes.forEach(async (event) => {
                if (event.uri.endsWith("/.herb-lsp/config.json")) {
                    await this.service.refreshConfig();
                    const documents = this.service.documentService.getAll();
                    await Promise.all(documents.map(document => this.service.diagnostics.refreshDocument(document)));
                }
            });
        });
        this.connection.onDocumentFormatting((params) => {
            return this.service.formatting.formatDocument(params);
        });
        this.connection.onDocumentRangeFormatting((params) => {
            return this.service.formatting.formatRange(params);
        });
    }
    listen() {
        this.connection.listen();
    }
}

class CLI {
    constructor() {
        this.usage = `
  Usage: herb-language-server [options]

  Options:
    --stdio          use stdio
    --node-ipc       use node-ipc
    --socket=<port>  use socket
`;
    }
    run() {
        if (process.argv.length <= 2) {
            console.error(`Error: Connection input stream is not set. Set command line parameters: '--node-ipc', '--stdio' or '--socket=<port>'`);
            console.error(this.usage);
            process.exit(1);
        }
        const server = new Server();
        server.listen();
    }
}

const cli = new CLI();
cli.run();
//# sourceMappingURL=herb-language-server.js.map
