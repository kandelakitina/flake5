"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
const path_1 = __importDefault(require("path"));
const package_json_1 = require("../package.json");
const fs_1 = require("fs");
class Config {
    constructor(projectPath, config) {
        this.path = Config.configPathFromProjectPath(projectPath);
        this.config = config;
    }
    get version() {
        return this.config.version;
    }
    get createdAt() {
        return new Date(this.config.createdAt);
    }
    get updatedAt() {
        return new Date(this.config.updatedAt);
    }
    get options() {
        return this.config.options;
    }
    toJSON() {
        return JSON.stringify(this.config, null, "  ");
    }
    updateTimestamp() {
        this.config.updatedAt = new Date().toISOString();
    }
    updateVersion() {
        this.config.version = package_json_1.version;
    }
    async write() {
        this.updateVersion();
        this.updateTimestamp();
        const folder = path_1.default.dirname(this.path);
        fs_1.promises.stat(folder)
            .then(() => { })
            .catch(async () => await fs_1.promises.mkdir(folder))
            .finally(async () => await fs_1.promises.writeFile(this.path, this.toJSON()));
    }
    async read() {
        return await fs_1.promises.readFile(this.path, "utf8");
    }
    static configPathFromProjectPath(projectPath) {
        return path_1.default.join(projectPath, this.configPath);
    }
    static async fromPathOrNew(projectPath) {
        try {
            return await this.fromPath(projectPath);
        }
        catch (error) {
            return Config.newConfig(projectPath);
        }
    }
    static async fromPath(projectPath) {
        const configPath = Config.configPathFromProjectPath(projectPath);
        try {
            const config = JSON.parse(await fs_1.promises.readFile(configPath, "utf8"));
            return new Config(projectPath, config);
        }
        catch (error) {
            throw new Error(`Error reading config file at: ${configPath}. Error: ${error.message}`);
        }
    }
    static newConfig(projectPath) {
        return new Config(projectPath, {
            version: package_json_1.version,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            options: {}
        });
    }
}
exports.Config = Config;
Config.configPath = ".herb-lsp/config.json";
//# sourceMappingURL=config.js.map