import { Node, ERBContentNode, HTMLElementNode, HTMLOpenTagNode, HTMLCloseTagNode, HTMLAttributeNameNode } from "./nodes.js";
import type { Location } from "./location.js";
import type { Position } from "./position.js";
/**
 * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
 */
export declare function isERBOutputNode(node: Node): node is ERBContentNode;
/**
 * Checks if a node is a non-output ERB node (control flow: <% %>)
 */
export declare function isERBControlFlowNode(node: Node): node is ERBContentNode;
/**
 * Checks if an array of nodes contains any ERB content nodes
 */
export declare function hasERBContent(nodes: Node[]): boolean;
/**
 * Checks if an array of nodes contains any ERB output nodes (dynamic content)
 */
export declare function hasERBOutput(nodes: Node[]): boolean;
/**
 * Extracts a static string from an array of literal nodes
 * Returns null if any node is not a literal node
 */
export declare function getStaticStringFromNodes(nodes: Node[]): string | null;
/**
 * Extracts static content from nodes, including mixed literal/ERB content
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
export declare function getStaticContentFromNodes(nodes: Node[]): string | null;
/**
 * Checks if nodes contain any literal content (for static validation)
 */
export declare function hasStaticContent(nodes: Node[]): boolean;
/**
 * Checks if nodes are effectively static (only literals and non-output ERB)
 * Non-output ERB like <% if %> doesn't affect static validation
 */
export declare function isEffectivelyStatic(nodes: Node[]): boolean;
/**
 * Gets static-validatable content from nodes (ignores control ERB, includes literals)
 * Returns concatenated literal content for validation, or null if contains output ERB
 */
export declare function getValidatableStaticContent(nodes: Node[]): string | null;
/**
 * Extracts a combined string from nodes, including ERB content
 * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
 * This is useful for debugging or displaying the full attribute name
 */
export declare function getCombinedStringFromNodes(nodes: Node[]): string;
/**
 * Checks if an HTML attribute name node has a static (literal-only) name
 */
export declare function hasStaticAttributeName(attributeNameNode: HTMLAttributeNameNode): boolean;
/**
 * Checks if an HTML attribute name node has dynamic content (contains ERB)
 */
export declare function hasDynamicAttributeName(attributeNameNode: HTMLAttributeNameNode): boolean;
/**
 * Gets the static string value of an HTML attribute name node
 * Returns null if the attribute name contains dynamic content (ERB)
 */
export declare function getStaticAttributeName(attributeNameNode: HTMLAttributeNameNode): string | null;
/**
 * Gets the combined string representation of an HTML attribute name node
 * This includes both static and dynamic content, useful for debugging
 */
export declare function getCombinedAttributeName(attributeNameNode: HTMLAttributeNameNode): string;
/**
 * Gets the tag name of an HTML element node
 */
export declare function getTagName(node: HTMLElementNode | HTMLOpenTagNode | HTMLCloseTagNode): string;
/**
 * Check if a node is a comment (HTML comment or ERB comment)
 */
export declare function isCommentNode(node: Node): boolean;
/**
 * Compares two positions to determine if they are equal
 * Returns true if pos1 and pos2 are at the same location
 */
export declare function isPositionEqual(position1: Position, position2: Position): boolean;
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
export declare function isPositionAfter(position1: Position, position2: Position, inclusive?: boolean): boolean;
/**
 * Gets nodes that appear before the specified location in source order
 * Uses line and column positions to determine ordering
 */
export declare function getNodesBeforeLocation<T extends Node>(nodes: T[], location: Location): T[];
/**
 * Gets nodes that appear after the specified location in source order
 * Uses line and column positions to determine ordering
 */
export declare function getNodesAfterLocation<T extends Node>(nodes: T[], location: Location): T[];
/**
 * Splits nodes into before and after the specified location
 * Returns an object with `before` and `after` arrays
 */
export declare function splitNodesAroundLocation<T extends Node>(nodes: T[], location: Location): {
    before: T[];
    after: T[];
};
/**
 * Splits nodes at a specific position
 * Returns nodes that end before the position and nodes that start after the position
 * More precise than splitNodesAroundLocation as it uses a single position point
 * Uses the same defaults as the individual functions: before=exclusive, after=inclusive
 */
export declare function splitNodesAroundPosition<T extends Node>(nodes: T[], position: Position): {
    before: T[];
    after: T[];
};
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
export declare function getNodesBeforePosition<T extends Node>(nodes: T[], position: Position, inclusive?: boolean): T[];
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
export declare function getNodesAfterPosition<T extends Node>(nodes: T[], position: Position, inclusive?: boolean): T[];
