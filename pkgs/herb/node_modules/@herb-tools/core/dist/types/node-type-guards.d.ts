import type { Node, NodeType, ERBNode } from "./nodes.js";
import { Token } from "./token.js";
import { ParseResult } from "./parse-result.js";
import { DocumentNode, LiteralNode, HTMLOpenTagNode, HTMLCloseTagNode, HTMLElementNode, HTMLAttributeValueNode, HTMLAttributeNameNode, HTMLAttributeNode, HTMLTextNode, HTMLCommentNode, HTMLDoctypeNode, XMLDeclarationNode, CDATANode, WhitespaceNode, ERBContentNode, ERBEndNode, ERBElseNode, ERBIfNode, ERBBlockNode, ERBWhenNode, ERBCaseNode, ERBCaseMatchNode, ERBWhileNode, ERBUntilNode, ERBForNode, ERBRescueNode, ERBEnsureNode, ERBBeginNode, ERBUnlessNode, ERBYieldNode, ERBInNode } from "./nodes.js";
/**
 * Type guard functions for AST nodes.
 * These functions provide type checking by combining both instanceof
 * checks and type string comparisons for maximum reliability across different
 * runtime scenarios (e.g., serialized/deserialized nodes).
 */
/**
 * Checks if a node is a DocumentNode
 */
export declare function isDocumentNode(node: Node): node is DocumentNode;
/**
 * Checks if a node is a LiteralNode
 */
export declare function isLiteralNode(node: Node): node is LiteralNode;
/**
 * Checks if a node is a HTMLOpenTagNode
 */
export declare function isHTMLOpenTagNode(node: Node): node is HTMLOpenTagNode;
/**
 * Checks if a node is a HTMLCloseTagNode
 */
export declare function isHTMLCloseTagNode(node: Node): node is HTMLCloseTagNode;
/**
 * Checks if a node is a HTMLElementNode
 */
export declare function isHTMLElementNode(node: Node): node is HTMLElementNode;
/**
 * Checks if a node is a HTMLAttributeValueNode
 */
export declare function isHTMLAttributeValueNode(node: Node): node is HTMLAttributeValueNode;
/**
 * Checks if a node is a HTMLAttributeNameNode
 */
export declare function isHTMLAttributeNameNode(node: Node): node is HTMLAttributeNameNode;
/**
 * Checks if a node is a HTMLAttributeNode
 */
export declare function isHTMLAttributeNode(node: Node): node is HTMLAttributeNode;
/**
 * Checks if a node is a HTMLTextNode
 */
export declare function isHTMLTextNode(node: Node): node is HTMLTextNode;
/**
 * Checks if a node is a HTMLCommentNode
 */
export declare function isHTMLCommentNode(node: Node): node is HTMLCommentNode;
/**
 * Checks if a node is a HTMLDoctypeNode
 */
export declare function isHTMLDoctypeNode(node: Node): node is HTMLDoctypeNode;
/**
 * Checks if a node is a XMLDeclarationNode
 */
export declare function isXMLDeclarationNode(node: Node): node is XMLDeclarationNode;
/**
 * Checks if a node is a CDATANode
 */
export declare function isCDATANode(node: Node): node is CDATANode;
/**
 * Checks if a node is a WhitespaceNode
 */
export declare function isWhitespaceNode(node: Node): node is WhitespaceNode;
/**
 * Checks if a node is a ERBContentNode
 */
export declare function isERBContentNode(node: Node): node is ERBContentNode;
/**
 * Checks if a node is a ERBEndNode
 */
export declare function isERBEndNode(node: Node): node is ERBEndNode;
/**
 * Checks if a node is a ERBElseNode
 */
export declare function isERBElseNode(node: Node): node is ERBElseNode;
/**
 * Checks if a node is a ERBIfNode
 */
export declare function isERBIfNode(node: Node): node is ERBIfNode;
/**
 * Checks if a node is a ERBBlockNode
 */
export declare function isERBBlockNode(node: Node): node is ERBBlockNode;
/**
 * Checks if a node is a ERBWhenNode
 */
export declare function isERBWhenNode(node: Node): node is ERBWhenNode;
/**
 * Checks if a node is a ERBCaseNode
 */
export declare function isERBCaseNode(node: Node): node is ERBCaseNode;
/**
 * Checks if a node is a ERBCaseMatchNode
 */
export declare function isERBCaseMatchNode(node: Node): node is ERBCaseMatchNode;
/**
 * Checks if a node is a ERBWhileNode
 */
export declare function isERBWhileNode(node: Node): node is ERBWhileNode;
/**
 * Checks if a node is a ERBUntilNode
 */
export declare function isERBUntilNode(node: Node): node is ERBUntilNode;
/**
 * Checks if a node is a ERBForNode
 */
export declare function isERBForNode(node: Node): node is ERBForNode;
/**
 * Checks if a node is a ERBRescueNode
 */
export declare function isERBRescueNode(node: Node): node is ERBRescueNode;
/**
 * Checks if a node is a ERBEnsureNode
 */
export declare function isERBEnsureNode(node: Node): node is ERBEnsureNode;
/**
 * Checks if a node is a ERBBeginNode
 */
export declare function isERBBeginNode(node: Node): node is ERBBeginNode;
/**
 * Checks if a node is a ERBUnlessNode
 */
export declare function isERBUnlessNode(node: Node): node is ERBUnlessNode;
/**
 * Checks if a node is a ERBYieldNode
 */
export declare function isERBYieldNode(node: Node): node is ERBYieldNode;
/**
 * Checks if a node is a ERBInNode
 */
export declare function isERBInNode(node: Node): node is ERBInNode;
/**
 * Convenience type guards for common node categories
 */
/**
 * Checks if a node is any HTML node type
 */
export declare function isHTMLNode(node: Node): boolean;
/**
 * Checks if a node is any ERB node type
 */
export declare function isERBNode(node: Node): node is ERBNode;
/**
 * Map of node classes to their corresponding type guard functions
 *
 * @example
 * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
export declare const NODE_TYPE_GUARDS: Map<new (...args: any[]) => Node, (node: Node) => boolean>;
/**
 * Map of AST node type strings to their corresponding type guard functions
 *
 * @example
 * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
export declare const AST_TYPE_GUARDS: Map<NodeType, (node: Node) => boolean>;
type NodeTypeToClass = {
    "AST_DOCUMENT_NODE": DocumentNode;
    "AST_LITERAL_NODE": LiteralNode;
    "AST_HTML_OPEN_TAG_NODE": HTMLOpenTagNode;
    "AST_HTML_CLOSE_TAG_NODE": HTMLCloseTagNode;
    "AST_HTML_ELEMENT_NODE": HTMLElementNode;
    "AST_HTML_ATTRIBUTE_VALUE_NODE": HTMLAttributeValueNode;
    "AST_HTML_ATTRIBUTE_NAME_NODE": HTMLAttributeNameNode;
    "AST_HTML_ATTRIBUTE_NODE": HTMLAttributeNode;
    "AST_HTML_TEXT_NODE": HTMLTextNode;
    "AST_HTML_COMMENT_NODE": HTMLCommentNode;
    "AST_HTML_DOCTYPE_NODE": HTMLDoctypeNode;
    "AST_XML_DECLARATION_NODE": XMLDeclarationNode;
    "AST_CDATA_NODE": CDATANode;
    "AST_WHITESPACE_NODE": WhitespaceNode;
    "AST_ERB_CONTENT_NODE": ERBContentNode;
    "AST_ERB_END_NODE": ERBEndNode;
    "AST_ERB_ELSE_NODE": ERBElseNode;
    "AST_ERB_IF_NODE": ERBIfNode;
    "AST_ERB_BLOCK_NODE": ERBBlockNode;
    "AST_ERB_WHEN_NODE": ERBWhenNode;
    "AST_ERB_CASE_NODE": ERBCaseNode;
    "AST_ERB_CASE_MATCH_NODE": ERBCaseMatchNode;
    "AST_ERB_WHILE_NODE": ERBWhileNode;
    "AST_ERB_UNTIL_NODE": ERBUntilNode;
    "AST_ERB_FOR_NODE": ERBForNode;
    "AST_ERB_RESCUE_NODE": ERBRescueNode;
    "AST_ERB_ENSURE_NODE": ERBEnsureNode;
    "AST_ERB_BEGIN_NODE": ERBBeginNode;
    "AST_ERB_UNLESS_NODE": ERBUnlessNode;
    "AST_ERB_YIELD_NODE": ERBYieldNode;
    "AST_ERB_IN_NODE": ERBInNode;
};
type ClassToInstance<T> = T extends new (...args: any[]) => infer R ? R : never;
/**
 * Checks if a node matches any of the provided type identifiers with proper type narrowing
 * Supports AST type strings, node classes, or type guard functions
 *
 * @example
 * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 *
 * @example
 * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 */
export declare function isAnyOf(node: Node, ...types: Array<NodeType | (new (...args: any[]) => Node) | ((node: Node) => boolean)>): boolean;
/**
 * Checks if a node does NOT match any of the provided type identifiers
 * Supports AST type strings, node classes, or type guard functions
 * This is the logical inverse of isAnyOf
 *
 * @example
 * if (isNoneOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 *
 * @example
 * if (isNoneOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 *
 * @example
 * if (isNoneOf(node, isHTMLTextNode, isLiteralNode)) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 */
export declare function isNoneOf(node: Node, ...types: Array<NodeType | (new (...args: any[]) => Node) | ((node: Node) => boolean)>): boolean;
/**
 * Checks if ALL nodes in an array match any of the provided type identifiers
 * Supports AST type strings, node classes, or type guard functions
 * Provides type narrowing for the array when true
 *
 * @example
 * if (areAllOfType(nodes, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // nodes is narrowed to (HTMLTextNode | LiteralNode)[]
 * }
 *
 * @example
 * if (areAllOfType(nodes, HTMLTextNode, LiteralNode)) {
 *   // nodes is narrowed to (HTMLTextNode | LiteralNode)[]
 * }
 *
 * @example
 * if (areAllOfType(nodes, isHTMLTextNode, isLiteralNode)) {
 *   // all nodes are either HTMLTextNode or LiteralNode
 * }
 */
export declare function areAllOfType<T extends NodeType[]>(nodes: Node[], ...types: T): nodes is NodeTypeToClass[T[number]][];
export declare function areAllOfType<T extends (new (...args: any[]) => Node)[]>(nodes: Node[], ...types: T): nodes is ClassToInstance<T[number]>[];
export declare function areAllOfType(nodes: Node[], ...types: Array<(node: Node) => boolean>): boolean;
/**
 * Filters an array of nodes to only include nodes matching any of the provided type identifiers
 * Supports AST type strings, node classes, or type guard functions
 * Returns a properly typed array of the filtered nodes
 *
 * @example
 * const filtered = filterNodes(nodes, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")
 * // filtered is typed as (HTMLTextNode | LiteralNode)[]
 *
 * @example
 * const filtered = filterNodes(nodes, HTMLTextNode, LiteralNode)
 * // filtered is typed as (HTMLTextNode | LiteralNode)[]
 *
 * @example
 * const filtered = filterNodes(nodes, isHTMLTextNode, isLiteralNode)
 * // filtered contains only HTMLTextNode or LiteralNode instances
 *
 * @example
 * const filtered = filterNodes(nodes, "AST_LITERAL_NODE", HTMLTextNode, isERBContentNode)
 * // filtered contains only LiteralNode, HTMLTextNode, or ERBContentNode instances
 */
export declare function filterNodes<T extends NodeType[]>(nodes: Node[] | undefined | null, ...types: T): NodeTypeToClass[T[number]][];
export declare function filterNodes<T extends (new (...args: any[]) => Node)[]>(nodes: Node[] | undefined | null, ...types: T): ClassToInstance<T[number]>[];
export declare function filterNodes(nodes: Node[] | undefined | null, ...types: Array<(node: Node) => boolean>): Node[];
/**
 * Checks if a node matches a specific type identifier with proper type narrowing
 * Supports AST type strings or node classes
 *
 * @example
 * if (isNode(node, "AST_HTML_TEXT_NODE")) {
 *   // node is narrowed to HTMLTextNode
 * }
 *
 * @example
 * if (isNode(node, HTMLTextNode)) {
 *   // node is narrowed to HTMLTextNode
 * }
 */
export declare function isNode<T extends NodeType>(node: Node | null | undefined, type: T): node is NodeTypeToClass[T];
export declare function isNode<T extends new (...args: any[]) => Node>(node: Node | null | undefined, type: T): node is ClassToInstance<T>;
export declare function isToken(object: any): object is Token;
export declare function isParseResult(object: any): object is ParseResult;
/**
 * Checks if a node has children (contains other nodes)
 */
export declare function hasChildren(node: Node): boolean;
/**
 * Filter functions for extracting specific node types from arrays
 */
/**
 * Filters an array of nodes to only include DocumentNode nodes
 */
export declare function filterDocumentNodes(nodes: Node[]): DocumentNode[];
/**
 * Filters an array of nodes to only include LiteralNode nodes
 */
export declare function filterLiteralNodes(nodes: Node[]): LiteralNode[];
/**
 * Filters an array of nodes to only include HTMLOpenTagNode nodes
 */
export declare function filterHTMLOpenTagNodes(nodes: Node[]): HTMLOpenTagNode[];
/**
 * Filters an array of nodes to only include HTMLCloseTagNode nodes
 */
export declare function filterHTMLCloseTagNodes(nodes: Node[]): HTMLCloseTagNode[];
/**
 * Filters an array of nodes to only include HTMLElementNode nodes
 */
export declare function filterHTMLElementNodes(nodes: Node[]): HTMLElementNode[];
/**
 * Filters an array of nodes to only include HTMLAttributeValueNode nodes
 */
export declare function filterHTMLAttributeValueNodes(nodes: Node[]): HTMLAttributeValueNode[];
/**
 * Filters an array of nodes to only include HTMLAttributeNameNode nodes
 */
export declare function filterHTMLAttributeNameNodes(nodes: Node[]): HTMLAttributeNameNode[];
/**
 * Filters an array of nodes to only include HTMLAttributeNode nodes
 */
export declare function filterHTMLAttributeNodes(nodes: Node[]): HTMLAttributeNode[];
/**
 * Filters an array of nodes to only include HTMLTextNode nodes
 */
export declare function filterHTMLTextNodes(nodes: Node[]): HTMLTextNode[];
/**
 * Filters an array of nodes to only include HTMLCommentNode nodes
 */
export declare function filterHTMLCommentNodes(nodes: Node[]): HTMLCommentNode[];
/**
 * Filters an array of nodes to only include HTMLDoctypeNode nodes
 */
export declare function filterHTMLDoctypeNodes(nodes: Node[]): HTMLDoctypeNode[];
/**
 * Filters an array of nodes to only include XMLDeclarationNode nodes
 */
export declare function filterXMLDeclarationNodes(nodes: Node[]): XMLDeclarationNode[];
/**
 * Filters an array of nodes to only include CDATANode nodes
 */
export declare function filterCDATANodes(nodes: Node[]): CDATANode[];
/**
 * Filters an array of nodes to only include WhitespaceNode nodes
 */
export declare function filterWhitespaceNodes(nodes: Node[]): WhitespaceNode[];
/**
 * Filters an array of nodes to only include ERBContentNode nodes
 */
export declare function filterERBContentNodes(nodes: Node[]): ERBContentNode[];
/**
 * Filters an array of nodes to only include ERBEndNode nodes
 */
export declare function filterERBEndNodes(nodes: Node[]): ERBEndNode[];
/**
 * Filters an array of nodes to only include ERBElseNode nodes
 */
export declare function filterERBElseNodes(nodes: Node[]): ERBElseNode[];
/**
 * Filters an array of nodes to only include ERBIfNode nodes
 */
export declare function filterERBIfNodes(nodes: Node[]): ERBIfNode[];
/**
 * Filters an array of nodes to only include ERBBlockNode nodes
 */
export declare function filterERBBlockNodes(nodes: Node[]): ERBBlockNode[];
/**
 * Filters an array of nodes to only include ERBWhenNode nodes
 */
export declare function filterERBWhenNodes(nodes: Node[]): ERBWhenNode[];
/**
 * Filters an array of nodes to only include ERBCaseNode nodes
 */
export declare function filterERBCaseNodes(nodes: Node[]): ERBCaseNode[];
/**
 * Filters an array of nodes to only include ERBCaseMatchNode nodes
 */
export declare function filterERBCaseMatchNodes(nodes: Node[]): ERBCaseMatchNode[];
/**
 * Filters an array of nodes to only include ERBWhileNode nodes
 */
export declare function filterERBWhileNodes(nodes: Node[]): ERBWhileNode[];
/**
 * Filters an array of nodes to only include ERBUntilNode nodes
 */
export declare function filterERBUntilNodes(nodes: Node[]): ERBUntilNode[];
/**
 * Filters an array of nodes to only include ERBForNode nodes
 */
export declare function filterERBForNodes(nodes: Node[]): ERBForNode[];
/**
 * Filters an array of nodes to only include ERBRescueNode nodes
 */
export declare function filterERBRescueNodes(nodes: Node[]): ERBRescueNode[];
/**
 * Filters an array of nodes to only include ERBEnsureNode nodes
 */
export declare function filterERBEnsureNodes(nodes: Node[]): ERBEnsureNode[];
/**
 * Filters an array of nodes to only include ERBBeginNode nodes
 */
export declare function filterERBBeginNodes(nodes: Node[]): ERBBeginNode[];
/**
 * Filters an array of nodes to only include ERBUnlessNode nodes
 */
export declare function filterERBUnlessNodes(nodes: Node[]): ERBUnlessNode[];
/**
 * Filters an array of nodes to only include ERBYieldNode nodes
 */
export declare function filterERBYieldNodes(nodes: Node[]): ERBYieldNode[];
/**
 * Filters an array of nodes to only include ERBInNode nodes
 */
export declare function filterERBInNodes(nodes: Node[]): ERBInNode[];
export {};
