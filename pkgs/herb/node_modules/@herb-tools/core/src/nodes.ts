// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/nodes.ts.erb

import { Location } from "./location.js"
import { Token, SerializedToken } from "./token.js"
import { HerbError } from "./errors.js"
import { convertToUTF8 } from "./util.js"

import type { SerializedLocation } from "./location.js"
import type { SerializedHerbError } from "./errors.js"
import type { Visitor } from "./visitor.js"

export type SerializedNodeType = string

export interface SerializedNode {
  type: SerializedNodeType
  location: SerializedLocation
  errors: SerializedHerbError[]
}

export interface BaseNodeProps {
  type: NodeType
  location: Location
  errors: HerbError[]
}

export abstract class Node implements BaseNodeProps {
  readonly type: NodeType
  readonly location: Location
  readonly errors: HerbError[]

  static from(node: SerializedNode): Node {
    return fromSerializedNode(node)
  }

  static get type(): NodeType {
    throw new Error("AST_NODE")
  }

  constructor(type: NodeType, location: Location, errors: HerbError[]) {
    this.type = type
    this.location = location
    this.errors = errors
  }

  toJSON(): SerializedNode {
    return {
      type: this.type,
      location: this.location.toJSON(),
      errors: this.errors,
    }
  }

  inspect(): string {
    return this.treeInspect(0)
  }

  is<T extends Node>(nodeClass: { new(...args: any[]): T; prototype: T, type: NodeType }): this is T {
    return this.type === nodeClass.type
  }

  isOfType<T extends Node>(type: NodeType): this is T {
    return this.type === type
  }

  get isSingleLine(): boolean {
    return this.location.start.line === this.location.end.line
  }

  abstract treeInspect(indent?: number): string
  abstract recursiveErrors(): HerbError[]
  abstract accept(visitor: Visitor): void
  abstract childNodes(): (Node | null | undefined)[]
  abstract compactChildNodes(): Node[]

  protected inspectArray(
    array: (Node | HerbError)[] | null | undefined,
    prefix: string,
  ): string {
    if (!array) return "∅\n"
    if (array.length === 0) return "[]\n"

    let output = `(${array.length} item${array.length == 1 ? "" : "s"})\n`

    array.forEach((item, index) => {
      const isLast = index === array.length - 1

      if (item instanceof Node || item instanceof HerbError) {
        output += this.inspectNode(
          item,
          prefix,
          isLast ? "    " : "│   ",
          isLast,
          false,
        )
      } else {
        const symbol = isLast ? "└── " : "├── "
        output += `${prefix}${symbol} ${item}\n`
      }
    })

    output += `${prefix}\n`

    return output
  }

  protected inspectNode(
    node: Node | HerbError | undefined | null,
    prefix: string,
    prefix2: string = "    ",
    last: boolean = true,
    trailingNewline: boolean = true,
  ): string {
    if (!node) return "∅\n"

    let output = trailingNewline ? "\n" : ""
    output += `${prefix}`

    output += last ? "└── " : "├── "
    output += node
      .treeInspect()
      .trimStart()
      .split("\n")
      .map((line, index) =>
        index == 0 ? line.trimStart() : `${prefix}${prefix2}${line}`,
      )
      .join("\n")
      .trimStart()

    output += `\n`

    return output
  }
}

export interface SerializedDocumentNode extends SerializedNode {
  type: "AST_DOCUMENT_NODE";
  children: SerializedNode[];
}

export interface DocumentNodeProps extends BaseNodeProps {
  children: Node[];
}

export class DocumentNode extends Node {
  readonly children: Node[];

  static get type(): NodeType {
    return "AST_DOCUMENT_NODE"
  }

  static from(data: SerializedDocumentNode): DocumentNode {
    return new DocumentNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      children: (data.children || []).map(node => fromSerializedNode(node)),
    })
  }

  constructor(props: DocumentNodeProps) {
    super(props.type, props.location, props.errors);
    this.children = props.children;
  }

  accept(visitor: Visitor): void {
    visitor.visitDocumentNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedDocumentNode {
    return {
      ...super.toJSON(),
      type: "AST_DOCUMENT_NODE",
      children: this.children.map(node => node.toJSON()),
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `└── children: ${this.inspectArray(this.children, "    ")}`;

    return output
  }
}

export interface SerializedLiteralNode extends SerializedNode {
  type: "AST_LITERAL_NODE";
  content: string;
}

export interface LiteralNodeProps extends BaseNodeProps {
  content: string;
}

export class LiteralNode extends Node {
  readonly content: string;

  static get type(): NodeType {
    return "AST_LITERAL_NODE"
  }

  static from(data: SerializedLiteralNode): LiteralNode {
    return new LiteralNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      content: data.content,
    })
  }

  constructor(props: LiteralNodeProps) {
    super(props.type, props.location, props.errors);
    this.content = convertToUTF8(props.content);
  }

  accept(visitor: Visitor): void {
    visitor.visitLiteralNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
    ].flat();
  }

  toJSON(): SerializedLiteralNode {
    return {
      ...super.toJSON(),
      type: "AST_LITERAL_NODE",
      content: this.content,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLOpenTagNode extends SerializedNode {
  type: "AST_HTML_OPEN_TAG_NODE";
  tag_opening: SerializedToken | null;
  tag_name: SerializedToken | null;
  tag_closing: SerializedToken | null;
  children: SerializedNode[];
  is_void: boolean;
}

export interface HTMLOpenTagNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  tag_name: Token | null;
  tag_closing: Token | null;
  children: Node[];
  is_void: boolean;
}

export class HTMLOpenTagNode extends Node {
  readonly tag_opening: Token | null;
  readonly tag_name: Token | null;
  readonly tag_closing: Token | null;
  readonly children: Node[];
  readonly is_void: boolean;

  static get type(): NodeType {
    return "AST_HTML_OPEN_TAG_NODE"
  }

  static from(data: SerializedHTMLOpenTagNode): HTMLOpenTagNode {
    return new HTMLOpenTagNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      tag_name: data.tag_name ? Token.from(data.tag_name) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      is_void: data.is_void,
    })
  }

  constructor(props: HTMLOpenTagNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.tag_name = props.tag_name;
    this.tag_closing = props.tag_closing;
    this.children = props.children;
    this.is_void = props.is_void;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLOpenTagNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedHTMLOpenTagNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_OPEN_TAG_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      tag_name: this.tag_name ? this.tag_name.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      is_void: this.is_void,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLCloseTagNode extends SerializedNode {
  type: "AST_HTML_CLOSE_TAG_NODE";
  tag_opening: SerializedToken | null;
  tag_name: SerializedToken | null;
  children: SerializedNode[];
  tag_closing: SerializedToken | null;
}

export interface HTMLCloseTagNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  tag_name: Token | null;
  children: Node[];
  tag_closing: Token | null;
}

export class HTMLCloseTagNode extends Node {
  readonly tag_opening: Token | null;
  readonly tag_name: Token | null;
  readonly children: Node[];
  readonly tag_closing: Token | null;

  static get type(): NodeType {
    return "AST_HTML_CLOSE_TAG_NODE"
  }

  static from(data: SerializedHTMLCloseTagNode): HTMLCloseTagNode {
    return new HTMLCloseTagNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      tag_name: data.tag_name ? Token.from(data.tag_name) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
    })
  }

  constructor(props: HTMLCloseTagNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.tag_name = props.tag_name;
    this.children = props.children;
    this.tag_closing = props.tag_closing;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLCloseTagNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedHTMLCloseTagNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_CLOSE_TAG_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      tag_name: this.tag_name ? this.tag_name.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLElementNode extends SerializedNode {
  type: "AST_HTML_ELEMENT_NODE";
  open_tag: SerializedHTMLOpenTagNode | null;
  tag_name: SerializedToken | null;
  body: SerializedNode[];
  close_tag: SerializedHTMLCloseTagNode | null;
  is_void: boolean;
}

export interface HTMLElementNodeProps extends BaseNodeProps {
  open_tag: HTMLOpenTagNode | null;
  tag_name: Token | null;
  body: Node[];
  close_tag: HTMLCloseTagNode | null;
  is_void: boolean;
}

export class HTMLElementNode extends Node {
  readonly open_tag: HTMLOpenTagNode | null;
  readonly tag_name: Token | null;
  readonly body: Node[];
  readonly close_tag: HTMLCloseTagNode | null;
  readonly is_void: boolean;

  static get type(): NodeType {
    return "AST_HTML_ELEMENT_NODE"
  }

  static from(data: SerializedHTMLElementNode): HTMLElementNode {
    return new HTMLElementNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
      tag_name: data.tag_name ? Token.from(data.tag_name) : null,
      body: (data.body || []).map(node => fromSerializedNode(node)),
      close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
      is_void: data.is_void,
    })
  }

  constructor(props: HTMLElementNodeProps) {
    super(props.type, props.location, props.errors);
    this.open_tag = props.open_tag;
    this.tag_name = props.tag_name;
    this.body = props.body;
    this.close_tag = props.close_tag;
    this.is_void = props.is_void;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLElementNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      this.open_tag,
      ...this.body,
      this.close_tag,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      this.open_tag ? this.open_tag.recursiveErrors() : [],
      ...this.body.map(node => node.recursiveErrors()),
      this.close_tag ? this.close_tag.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedHTMLElementNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_ELEMENT_NODE",
      open_tag: this.open_tag ? this.open_tag.toJSON() : null,
      tag_name: this.tag_name ? this.tag_name.toJSON() : null,
      body: this.body.map(node => node.toJSON()),
      close_tag: this.close_tag ? this.close_tag.toJSON() : null,
      is_void: this.is_void,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
    output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
    output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
    output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
    output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLAttributeValueNode extends SerializedNode {
  type: "AST_HTML_ATTRIBUTE_VALUE_NODE";
  open_quote: SerializedToken | null;
  children: SerializedNode[];
  close_quote: SerializedToken | null;
  quoted: boolean;
}

export interface HTMLAttributeValueNodeProps extends BaseNodeProps {
  open_quote: Token | null;
  children: Node[];
  close_quote: Token | null;
  quoted: boolean;
}

export class HTMLAttributeValueNode extends Node {
  readonly open_quote: Token | null;
  readonly children: Node[];
  readonly close_quote: Token | null;
  readonly quoted: boolean;

  static get type(): NodeType {
    return "AST_HTML_ATTRIBUTE_VALUE_NODE"
  }

  static from(data: SerializedHTMLAttributeValueNode): HTMLAttributeValueNode {
    return new HTMLAttributeValueNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      open_quote: data.open_quote ? Token.from(data.open_quote) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      close_quote: data.close_quote ? Token.from(data.close_quote) : null,
      quoted: data.quoted,
    })
  }

  constructor(props: HTMLAttributeValueNodeProps) {
    super(props.type, props.location, props.errors);
    this.open_quote = props.open_quote;
    this.children = props.children;
    this.close_quote = props.close_quote;
    this.quoted = props.quoted;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLAttributeValueNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedHTMLAttributeValueNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
      open_quote: this.open_quote ? this.open_quote.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      close_quote: this.close_quote ? this.close_quote.toJSON() : null,
      quoted: this.quoted,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
    output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLAttributeNameNode extends SerializedNode {
  type: "AST_HTML_ATTRIBUTE_NAME_NODE";
  children: SerializedNode[];
}

export interface HTMLAttributeNameNodeProps extends BaseNodeProps {
  children: Node[];
}

export class HTMLAttributeNameNode extends Node {
  readonly children: Node[];

  static get type(): NodeType {
    return "AST_HTML_ATTRIBUTE_NAME_NODE"
  }

  static from(data: SerializedHTMLAttributeNameNode): HTMLAttributeNameNode {
    return new HTMLAttributeNameNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      children: (data.children || []).map(node => fromSerializedNode(node)),
    })
  }

  constructor(props: HTMLAttributeNameNodeProps) {
    super(props.type, props.location, props.errors);
    this.children = props.children;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLAttributeNameNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedHTMLAttributeNameNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_ATTRIBUTE_NAME_NODE",
      children: this.children.map(node => node.toJSON()),
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `└── children: ${this.inspectArray(this.children, "    ")}`;

    return output
  }
}

export interface SerializedHTMLAttributeNode extends SerializedNode {
  type: "AST_HTML_ATTRIBUTE_NODE";
  name: SerializedHTMLAttributeNameNode | null;
  equals: SerializedToken | null;
  value: SerializedHTMLAttributeValueNode | null;
}

export interface HTMLAttributeNodeProps extends BaseNodeProps {
  name: HTMLAttributeNameNode | null;
  equals: Token | null;
  value: HTMLAttributeValueNode | null;
}

export class HTMLAttributeNode extends Node {
  readonly name: HTMLAttributeNameNode | null;
  readonly equals: Token | null;
  readonly value: HTMLAttributeValueNode | null;

  static get type(): NodeType {
    return "AST_HTML_ATTRIBUTE_NODE"
  }

  static from(data: SerializedHTMLAttributeNode): HTMLAttributeNode {
    return new HTMLAttributeNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      name: data.name ? fromSerializedNode((data.name)) : null,
      equals: data.equals ? Token.from(data.equals) : null,
      value: data.value ? fromSerializedNode((data.value)) : null,
    })
  }

  constructor(props: HTMLAttributeNodeProps) {
    super(props.type, props.location, props.errors);
    this.name = props.name;
    this.equals = props.equals;
    this.value = props.value;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLAttributeNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      this.name,
      this.value,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      this.name ? this.name.recursiveErrors() : [],
      this.value ? this.value.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedHTMLAttributeNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_ATTRIBUTE_NODE",
      name: this.name ? this.name.toJSON() : null,
      equals: this.equals ? this.equals.toJSON() : null,
      value: this.value ? this.value.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
    output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
    output += `└── value: ${this.inspectNode(this.value, "    ")}`;

    return output
  }
}

export interface SerializedHTMLTextNode extends SerializedNode {
  type: "AST_HTML_TEXT_NODE";
  content: string;
}

export interface HTMLTextNodeProps extends BaseNodeProps {
  content: string;
}

export class HTMLTextNode extends Node {
  readonly content: string;

  static get type(): NodeType {
    return "AST_HTML_TEXT_NODE"
  }

  static from(data: SerializedHTMLTextNode): HTMLTextNode {
    return new HTMLTextNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      content: data.content,
    })
  }

  constructor(props: HTMLTextNodeProps) {
    super(props.type, props.location, props.errors);
    this.content = convertToUTF8(props.content);
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLTextNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
    ].flat();
  }

  toJSON(): SerializedHTMLTextNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_TEXT_NODE",
      content: this.content,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLCommentNode extends SerializedNode {
  type: "AST_HTML_COMMENT_NODE";
  comment_start: SerializedToken | null;
  children: SerializedNode[];
  comment_end: SerializedToken | null;
}

export interface HTMLCommentNodeProps extends BaseNodeProps {
  comment_start: Token | null;
  children: Node[];
  comment_end: Token | null;
}

export class HTMLCommentNode extends Node {
  readonly comment_start: Token | null;
  readonly children: Node[];
  readonly comment_end: Token | null;

  static get type(): NodeType {
    return "AST_HTML_COMMENT_NODE"
  }

  static from(data: SerializedHTMLCommentNode): HTMLCommentNode {
    return new HTMLCommentNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      comment_start: data.comment_start ? Token.from(data.comment_start) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      comment_end: data.comment_end ? Token.from(data.comment_end) : null,
    })
  }

  constructor(props: HTMLCommentNodeProps) {
    super(props.type, props.location, props.errors);
    this.comment_start = props.comment_start;
    this.children = props.children;
    this.comment_end = props.comment_end;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLCommentNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedHTMLCommentNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_COMMENT_NODE",
      comment_start: this.comment_start ? this.comment_start.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      comment_end: this.comment_end ? this.comment_end.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedHTMLDoctypeNode extends SerializedNode {
  type: "AST_HTML_DOCTYPE_NODE";
  tag_opening: SerializedToken | null;
  children: SerializedNode[];
  tag_closing: SerializedToken | null;
}

export interface HTMLDoctypeNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  children: Node[];
  tag_closing: Token | null;
}

export class HTMLDoctypeNode extends Node {
  readonly tag_opening: Token | null;
  readonly children: Node[];
  readonly tag_closing: Token | null;

  static get type(): NodeType {
    return "AST_HTML_DOCTYPE_NODE"
  }

  static from(data: SerializedHTMLDoctypeNode): HTMLDoctypeNode {
    return new HTMLDoctypeNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
    })
  }

  constructor(props: HTMLDoctypeNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.children = props.children;
    this.tag_closing = props.tag_closing;
  }

  accept(visitor: Visitor): void {
    visitor.visitHTMLDoctypeNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedHTMLDoctypeNode {
    return {
      ...super.toJSON(),
      type: "AST_HTML_DOCTYPE_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedXMLDeclarationNode extends SerializedNode {
  type: "AST_XML_DECLARATION_NODE";
  tag_opening: SerializedToken | null;
  children: SerializedNode[];
  tag_closing: SerializedToken | null;
}

export interface XMLDeclarationNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  children: Node[];
  tag_closing: Token | null;
}

export class XMLDeclarationNode extends Node {
  readonly tag_opening: Token | null;
  readonly children: Node[];
  readonly tag_closing: Token | null;

  static get type(): NodeType {
    return "AST_XML_DECLARATION_NODE"
  }

  static from(data: SerializedXMLDeclarationNode): XMLDeclarationNode {
    return new XMLDeclarationNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
    })
  }

  constructor(props: XMLDeclarationNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.children = props.children;
    this.tag_closing = props.tag_closing;
  }

  accept(visitor: Visitor): void {
    visitor.visitXMLDeclarationNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedXMLDeclarationNode {
    return {
      ...super.toJSON(),
      type: "AST_XML_DECLARATION_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedCDATANode extends SerializedNode {
  type: "AST_CDATA_NODE";
  tag_opening: SerializedToken | null;
  children: SerializedNode[];
  tag_closing: SerializedToken | null;
}

export interface CDATANodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  children: Node[];
  tag_closing: Token | null;
}

export class CDATANode extends Node {
  readonly tag_opening: Token | null;
  readonly children: Node[];
  readonly tag_closing: Token | null;

  static get type(): NodeType {
    return "AST_CDATA_NODE"
  }

  static from(data: SerializedCDATANode): CDATANode {
    return new CDATANode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
    })
  }

  constructor(props: CDATANodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.children = props.children;
    this.tag_closing = props.tag_closing;
  }

  accept(visitor: Visitor): void {
    visitor.visitCDATANode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedCDATANode {
    return {
      ...super.toJSON(),
      type: "AST_CDATA_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedWhitespaceNode extends SerializedNode {
  type: "AST_WHITESPACE_NODE";
  value: SerializedToken | null;
}

export interface WhitespaceNodeProps extends BaseNodeProps {
  value: Token | null;
}

export class WhitespaceNode extends Node {
  readonly value: Token | null;

  static get type(): NodeType {
    return "AST_WHITESPACE_NODE"
  }

  static from(data: SerializedWhitespaceNode): WhitespaceNode {
    return new WhitespaceNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      value: data.value ? Token.from(data.value) : null,
    })
  }

  constructor(props: WhitespaceNodeProps) {
    super(props.type, props.location, props.errors);
    this.value = props.value;
  }

  accept(visitor: Visitor): void {
    visitor.visitWhitespaceNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
    ].flat();
  }

  toJSON(): SerializedWhitespaceNode {
    return {
      ...super.toJSON(),
      type: "AST_WHITESPACE_NODE",
      value: this.value ? this.value.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedERBContentNode extends SerializedNode {
  type: "AST_ERB_CONTENT_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  // no-op for analyzed_ruby
  parsed: boolean;
  valid: boolean;
}

export interface ERBContentNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  // no-op for analyzed_ruby
  parsed: boolean;
  valid: boolean;
}

export class ERBContentNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  // no-op for analyzed_ruby
  readonly parsed: boolean;
  readonly valid: boolean;

  static get type(): NodeType {
    return "AST_ERB_CONTENT_NODE"
  }

  static from(data: SerializedERBContentNode): ERBContentNode {
    return new ERBContentNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      // no-op for analyzed_ruby
      parsed: data.parsed,
      valid: data.valid,
    })
  }

  constructor(props: ERBContentNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    // no-op for analyzed_ruby
    this.parsed = props.parsed;
    this.valid = props.valid;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBContentNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
    ].flat();
  }

  toJSON(): SerializedERBContentNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_CONTENT_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      // no-op for analyzed_ruby
      parsed: this.parsed,
      valid: this.valid,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    // no-op for analyzed_ruby
    output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
    output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;

    return output
  }
}

export interface SerializedERBEndNode extends SerializedNode {
  type: "AST_ERB_END_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
}

export interface ERBEndNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
}

export class ERBEndNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;

  static get type(): NodeType {
    return "AST_ERB_END_NODE"
  }

  static from(data: SerializedERBEndNode): ERBEndNode {
    return new ERBEndNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
    })
  }

  constructor(props: ERBEndNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBEndNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
    ].flat();
  }

  toJSON(): SerializedERBEndNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_END_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedERBElseNode extends SerializedNode {
  type: "AST_ERB_ELSE_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
}

export interface ERBElseNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
}

export class ERBElseNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];

  static get type(): NodeType {
    return "AST_ERB_ELSE_NODE"
  }

  static from(data: SerializedERBElseNode): ERBElseNode {
    return new ERBElseNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
    })
  }

  constructor(props: ERBElseNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBElseNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedERBElseNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_ELSE_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;

    return output
  }
}

export interface SerializedERBIfNode extends SerializedNode {
  type: "AST_ERB_IF_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  subsequent: SerializedNode | null;
  end_node: SerializedERBEndNode | null;
}

export interface ERBIfNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  subsequent: Node | null;
  end_node: ERBEndNode | null;
}

export class ERBIfNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly subsequent: Node | null;
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_IF_NODE"
  }

  static from(data: SerializedERBIfNode): ERBIfNode {
    return new ERBIfNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBIfNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.subsequent = props.subsequent;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBIfNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.subsequent,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.subsequent ? this.subsequent.recursiveErrors() : [],
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBIfNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_IF_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      subsequent: this.subsequent ? this.subsequent.toJSON() : null,
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBBlockNode extends SerializedNode {
  type: "AST_ERB_BLOCK_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  body: SerializedNode[];
  end_node: SerializedERBEndNode | null;
}

export interface ERBBlockNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  body: Node[];
  end_node: ERBEndNode | null;
}

export class ERBBlockNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly body: Node[];
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_BLOCK_NODE"
  }

  static from(data: SerializedERBBlockNode): ERBBlockNode {
    return new ERBBlockNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      body: (data.body || []).map(node => fromSerializedNode(node)),
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBBlockNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.body = props.body;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBBlockNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.body,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.body.map(node => node.recursiveErrors()),
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBBlockNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_BLOCK_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      body: this.body.map(node => node.toJSON()),
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBWhenNode extends SerializedNode {
  type: "AST_ERB_WHEN_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
}

export interface ERBWhenNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
}

export class ERBWhenNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];

  static get type(): NodeType {
    return "AST_ERB_WHEN_NODE"
  }

  static from(data: SerializedERBWhenNode): ERBWhenNode {
    return new ERBWhenNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
    })
  }

  constructor(props: ERBWhenNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBWhenNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedERBWhenNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_WHEN_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;

    return output
  }
}

export interface SerializedERBCaseNode extends SerializedNode {
  type: "AST_ERB_CASE_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  children: SerializedNode[];
  conditions: SerializedNode[];
  else_clause: SerializedERBElseNode | null;
  end_node: SerializedERBEndNode | null;
}

export interface ERBCaseNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  children: Node[];
  conditions: any[];
  else_clause: ERBElseNode | null;
  end_node: ERBEndNode | null;
}

export class ERBCaseNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly children: Node[];
  readonly conditions: Node[];
  readonly else_clause: ERBElseNode | null;
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_CASE_NODE"
  }

  static from(data: SerializedERBCaseNode): ERBCaseNode {
    return new ERBCaseNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
      else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBCaseNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.children = props.children;
    this.conditions = props.conditions;
    this.else_clause = props.else_clause;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBCaseNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
      ...this.conditions,
      this.else_clause,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
      ...this.conditions.map(node => node.recursiveErrors()),
      this.else_clause ? this.else_clause.recursiveErrors() : [],
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBCaseNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_CASE_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      conditions: this.conditions.map(node => node.toJSON()),
      else_clause: this.else_clause ? this.else_clause.toJSON() : null,
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
    output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBCaseMatchNode extends SerializedNode {
  type: "AST_ERB_CASE_MATCH_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  children: SerializedNode[];
  conditions: SerializedNode[];
  else_clause: SerializedERBElseNode | null;
  end_node: SerializedERBEndNode | null;
}

export interface ERBCaseMatchNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  children: Node[];
  conditions: any[];
  else_clause: ERBElseNode | null;
  end_node: ERBEndNode | null;
}

export class ERBCaseMatchNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly children: Node[];
  readonly conditions: Node[];
  readonly else_clause: ERBElseNode | null;
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_CASE_MATCH_NODE"
  }

  static from(data: SerializedERBCaseMatchNode): ERBCaseMatchNode {
    return new ERBCaseMatchNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      children: (data.children || []).map(node => fromSerializedNode(node)),
      conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
      else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBCaseMatchNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.children = props.children;
    this.conditions = props.conditions;
    this.else_clause = props.else_clause;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBCaseMatchNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.children,
      ...this.conditions,
      this.else_clause,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.children.map(node => node.recursiveErrors()),
      ...this.conditions.map(node => node.recursiveErrors()),
      this.else_clause ? this.else_clause.recursiveErrors() : [],
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBCaseMatchNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_CASE_MATCH_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      children: this.children.map(node => node.toJSON()),
      conditions: this.conditions.map(node => node.toJSON()),
      else_clause: this.else_clause ? this.else_clause.toJSON() : null,
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
    output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
    output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBWhileNode extends SerializedNode {
  type: "AST_ERB_WHILE_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  end_node: SerializedERBEndNode | null;
}

export interface ERBWhileNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  end_node: ERBEndNode | null;
}

export class ERBWhileNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_WHILE_NODE"
  }

  static from(data: SerializedERBWhileNode): ERBWhileNode {
    return new ERBWhileNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBWhileNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBWhileNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBWhileNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_WHILE_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBUntilNode extends SerializedNode {
  type: "AST_ERB_UNTIL_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  end_node: SerializedERBEndNode | null;
}

export interface ERBUntilNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  end_node: ERBEndNode | null;
}

export class ERBUntilNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_UNTIL_NODE"
  }

  static from(data: SerializedERBUntilNode): ERBUntilNode {
    return new ERBUntilNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBUntilNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBUntilNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBUntilNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_UNTIL_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBForNode extends SerializedNode {
  type: "AST_ERB_FOR_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  end_node: SerializedERBEndNode | null;
}

export interface ERBForNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  end_node: ERBEndNode | null;
}

export class ERBForNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_FOR_NODE"
  }

  static from(data: SerializedERBForNode): ERBForNode {
    return new ERBForNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBForNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBForNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBForNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_FOR_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBRescueNode extends SerializedNode {
  type: "AST_ERB_RESCUE_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  subsequent: SerializedERBRescueNode | null;
}

export interface ERBRescueNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  subsequent: ERBRescueNode | null;
}

export class ERBRescueNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly subsequent: ERBRescueNode | null;

  static get type(): NodeType {
    return "AST_ERB_RESCUE_NODE"
  }

  static from(data: SerializedERBRescueNode): ERBRescueNode {
    return new ERBRescueNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
    })
  }

  constructor(props: ERBRescueNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.subsequent = props.subsequent;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBRescueNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.subsequent,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.subsequent ? this.subsequent.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBRescueNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_RESCUE_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      subsequent: this.subsequent ? this.subsequent.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;

    return output
  }
}

export interface SerializedERBEnsureNode extends SerializedNode {
  type: "AST_ERB_ENSURE_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
}

export interface ERBEnsureNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
}

export class ERBEnsureNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];

  static get type(): NodeType {
    return "AST_ERB_ENSURE_NODE"
  }

  static from(data: SerializedERBEnsureNode): ERBEnsureNode {
    return new ERBEnsureNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
    })
  }

  constructor(props: ERBEnsureNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBEnsureNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedERBEnsureNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_ENSURE_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;

    return output
  }
}

export interface SerializedERBBeginNode extends SerializedNode {
  type: "AST_ERB_BEGIN_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  rescue_clause: SerializedERBRescueNode | null;
  else_clause: SerializedERBElseNode | null;
  ensure_clause: SerializedERBEnsureNode | null;
  end_node: SerializedERBEndNode | null;
}

export interface ERBBeginNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  rescue_clause: ERBRescueNode | null;
  else_clause: ERBElseNode | null;
  ensure_clause: ERBEnsureNode | null;
  end_node: ERBEndNode | null;
}

export class ERBBeginNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly rescue_clause: ERBRescueNode | null;
  readonly else_clause: ERBElseNode | null;
  readonly ensure_clause: ERBEnsureNode | null;
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_BEGIN_NODE"
  }

  static from(data: SerializedERBBeginNode): ERBBeginNode {
    return new ERBBeginNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
      else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
      ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBBeginNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.rescue_clause = props.rescue_clause;
    this.else_clause = props.else_clause;
    this.ensure_clause = props.ensure_clause;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBBeginNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.rescue_clause,
      this.else_clause,
      this.ensure_clause,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
      this.else_clause ? this.else_clause.recursiveErrors() : [],
      this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBBeginNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_BEGIN_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
      else_clause: this.else_clause ? this.else_clause.toJSON() : null,
      ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
    output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
    output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBUnlessNode extends SerializedNode {
  type: "AST_ERB_UNLESS_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
  else_clause: SerializedERBElseNode | null;
  end_node: SerializedERBEndNode | null;
}

export interface ERBUnlessNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
  else_clause: ERBElseNode | null;
  end_node: ERBEndNode | null;
}

export class ERBUnlessNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];
  readonly else_clause: ERBElseNode | null;
  readonly end_node: ERBEndNode | null;

  static get type(): NodeType {
    return "AST_ERB_UNLESS_NODE"
  }

  static from(data: SerializedERBUnlessNode): ERBUnlessNode {
    return new ERBUnlessNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
      else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
      end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
    })
  }

  constructor(props: ERBUnlessNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
    this.else_clause = props.else_clause;
    this.end_node = props.end_node;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBUnlessNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
      this.else_clause,
      this.end_node,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
      this.else_clause ? this.else_clause.recursiveErrors() : [],
      this.end_node ? this.end_node.recursiveErrors() : [],
    ].flat();
  }

  toJSON(): SerializedERBUnlessNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_UNLESS_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
      else_clause: this.else_clause ? this.else_clause.toJSON() : null,
      end_node: this.end_node ? this.end_node.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
    output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
    output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;

    return output
  }
}

export interface SerializedERBYieldNode extends SerializedNode {
  type: "AST_ERB_YIELD_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
}

export interface ERBYieldNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
}

export class ERBYieldNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;

  static get type(): NodeType {
    return "AST_ERB_YIELD_NODE"
  }

  static from(data: SerializedERBYieldNode): ERBYieldNode {
    return new ERBYieldNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
    })
  }

  constructor(props: ERBYieldNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBYieldNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
    ].flat();
  }

  toJSON(): SerializedERBYieldNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_YIELD_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;

    return output
  }
}

export interface SerializedERBInNode extends SerializedNode {
  type: "AST_ERB_IN_NODE";
  tag_opening: SerializedToken | null;
  content: SerializedToken | null;
  tag_closing: SerializedToken | null;
  statements: SerializedNode[];
}

export interface ERBInNodeProps extends BaseNodeProps {
  tag_opening: Token | null;
  content: Token | null;
  tag_closing: Token | null;
  statements: Node[];
}

export class ERBInNode extends Node {
  readonly tag_opening: Token | null;
  readonly content: Token | null;
  readonly tag_closing: Token | null;
  readonly statements: Node[];

  static get type(): NodeType {
    return "AST_ERB_IN_NODE"
  }

  static from(data: SerializedERBInNode): ERBInNode {
    return new ERBInNode({
      type: data.type,
      location: Location.from(data.location),
      errors: (data.errors || []).map(error => HerbError.from(error)),
      tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
      content: data.content ? Token.from(data.content) : null,
      tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
      statements: (data.statements || []).map(node => fromSerializedNode(node)),
    })
  }

  constructor(props: ERBInNodeProps) {
    super(props.type, props.location, props.errors);
    this.tag_opening = props.tag_opening;
    this.content = props.content;
    this.tag_closing = props.tag_closing;
    this.statements = props.statements;
  }

  accept(visitor: Visitor): void {
    visitor.visitERBInNode(this)
  }

  childNodes(): (Node | null | undefined)[] {
    return [
      ...this.statements,
    ];
  }

  compactChildNodes(): Node[] {
    return this.childNodes().filter(node => node !== null && node !== undefined)
  }

  recursiveErrors(): HerbError[] {
    return [
      ...this.errors,
      ...this.statements.map(node => node.recursiveErrors()),
    ].flat();
  }

  toJSON(): SerializedERBInNode {
    return {
      ...super.toJSON(),
      type: "AST_ERB_IN_NODE",
      tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
      content: this.content ? this.content.toJSON() : null,
      tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
      statements: this.statements.map(node => node.toJSON()),
    };
  }

  treeInspect(): string {
    let output = "";

    output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
    output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
    output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
    output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
    output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
    output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;

    return output
  }
}


export type ConcreteNode =
  DocumentNode |  LiteralNode |  HTMLOpenTagNode |  HTMLCloseTagNode |  HTMLElementNode |  HTMLAttributeValueNode |  HTMLAttributeNameNode |  HTMLAttributeNode |  HTMLTextNode |  HTMLCommentNode |  HTMLDoctypeNode |  XMLDeclarationNode |  CDATANode |  WhitespaceNode |  ERBContentNode |  ERBEndNode |  ERBElseNode |  ERBIfNode |  ERBBlockNode |  ERBWhenNode |  ERBCaseNode |  ERBCaseMatchNode |  ERBWhileNode |  ERBUntilNode |  ERBForNode |  ERBRescueNode |  ERBEnsureNode |  ERBBeginNode |  ERBUnlessNode |  ERBYieldNode |  ERBInNode
export function fromSerializedNode(node: SerializedDocumentNode): DocumentNode;
export function fromSerializedNode(node: SerializedLiteralNode): LiteralNode;
export function fromSerializedNode(node: SerializedHTMLOpenTagNode): HTMLOpenTagNode;
export function fromSerializedNode(node: SerializedHTMLCloseTagNode): HTMLCloseTagNode;
export function fromSerializedNode(node: SerializedHTMLElementNode): HTMLElementNode;
export function fromSerializedNode(node: SerializedHTMLAttributeValueNode): HTMLAttributeValueNode;
export function fromSerializedNode(node: SerializedHTMLAttributeNameNode): HTMLAttributeNameNode;
export function fromSerializedNode(node: SerializedHTMLAttributeNode): HTMLAttributeNode;
export function fromSerializedNode(node: SerializedHTMLTextNode): HTMLTextNode;
export function fromSerializedNode(node: SerializedHTMLCommentNode): HTMLCommentNode;
export function fromSerializedNode(node: SerializedHTMLDoctypeNode): HTMLDoctypeNode;
export function fromSerializedNode(node: SerializedXMLDeclarationNode): XMLDeclarationNode;
export function fromSerializedNode(node: SerializedCDATANode): CDATANode;
export function fromSerializedNode(node: SerializedWhitespaceNode): WhitespaceNode;
export function fromSerializedNode(node: SerializedERBContentNode): ERBContentNode;
export function fromSerializedNode(node: SerializedERBEndNode): ERBEndNode;
export function fromSerializedNode(node: SerializedERBElseNode): ERBElseNode;
export function fromSerializedNode(node: SerializedERBIfNode): ERBIfNode;
export function fromSerializedNode(node: SerializedERBBlockNode): ERBBlockNode;
export function fromSerializedNode(node: SerializedERBWhenNode): ERBWhenNode;
export function fromSerializedNode(node: SerializedERBCaseNode): ERBCaseNode;
export function fromSerializedNode(node: SerializedERBCaseMatchNode): ERBCaseMatchNode;
export function fromSerializedNode(node: SerializedERBWhileNode): ERBWhileNode;
export function fromSerializedNode(node: SerializedERBUntilNode): ERBUntilNode;
export function fromSerializedNode(node: SerializedERBForNode): ERBForNode;
export function fromSerializedNode(node: SerializedERBRescueNode): ERBRescueNode;
export function fromSerializedNode(node: SerializedERBEnsureNode): ERBEnsureNode;
export function fromSerializedNode(node: SerializedERBBeginNode): ERBBeginNode;
export function fromSerializedNode(node: SerializedERBUnlessNode): ERBUnlessNode;
export function fromSerializedNode(node: SerializedERBYieldNode): ERBYieldNode;
export function fromSerializedNode(node: SerializedERBInNode): ERBInNode;
export function fromSerializedNode(node: SerializedNode): Node;

export function fromSerializedNode(node: SerializedNode): Node {
  switch (node.type) {
    case "AST_DOCUMENT_NODE": return DocumentNode.from(node as SerializedDocumentNode);
    case "AST_LITERAL_NODE": return LiteralNode.from(node as SerializedLiteralNode);
    case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node as SerializedHTMLOpenTagNode);
    case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node as SerializedHTMLCloseTagNode);
    case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node as SerializedHTMLElementNode);
    case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node as SerializedHTMLAttributeValueNode);
    case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node as SerializedHTMLAttributeNameNode);
    case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node as SerializedHTMLAttributeNode);
    case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node as SerializedHTMLTextNode);
    case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node as SerializedHTMLCommentNode);
    case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node as SerializedHTMLDoctypeNode);
    case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node as SerializedXMLDeclarationNode);
    case "AST_CDATA_NODE": return CDATANode.from(node as SerializedCDATANode);
    case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node as SerializedWhitespaceNode);
    case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node as SerializedERBContentNode);
    case "AST_ERB_END_NODE": return ERBEndNode.from(node as SerializedERBEndNode);
    case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node as SerializedERBElseNode);
    case "AST_ERB_IF_NODE": return ERBIfNode.from(node as SerializedERBIfNode);
    case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node as SerializedERBBlockNode);
    case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node as SerializedERBWhenNode);
    case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node as SerializedERBCaseNode);
    case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node as SerializedERBCaseMatchNode);
    case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node as SerializedERBWhileNode);
    case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node as SerializedERBUntilNode);
    case "AST_ERB_FOR_NODE": return ERBForNode.from(node as SerializedERBForNode);
    case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node as SerializedERBRescueNode);
    case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node as SerializedERBEnsureNode);
    case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node as SerializedERBBeginNode);
    case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node as SerializedERBUnlessNode);
    case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node as SerializedERBYieldNode);
    case "AST_ERB_IN_NODE": return ERBInNode.from(node as SerializedERBInNode);

    default:
      throw new Error(`Unknown node type: ${node.type}`);
  }
}

export type NodeType =
  | "AST_DOCUMENT_NODE"
  | "AST_LITERAL_NODE"
  | "AST_HTML_OPEN_TAG_NODE"
  | "AST_HTML_CLOSE_TAG_NODE"
  | "AST_HTML_ELEMENT_NODE"
  | "AST_HTML_ATTRIBUTE_VALUE_NODE"
  | "AST_HTML_ATTRIBUTE_NAME_NODE"
  | "AST_HTML_ATTRIBUTE_NODE"
  | "AST_HTML_TEXT_NODE"
  | "AST_HTML_COMMENT_NODE"
  | "AST_HTML_DOCTYPE_NODE"
  | "AST_XML_DECLARATION_NODE"
  | "AST_CDATA_NODE"
  | "AST_WHITESPACE_NODE"
  | "AST_ERB_CONTENT_NODE"
  | "AST_ERB_END_NODE"
  | "AST_ERB_ELSE_NODE"
  | "AST_ERB_IF_NODE"
  | "AST_ERB_BLOCK_NODE"
  | "AST_ERB_WHEN_NODE"
  | "AST_ERB_CASE_NODE"
  | "AST_ERB_CASE_MATCH_NODE"
  | "AST_ERB_WHILE_NODE"
  | "AST_ERB_UNTIL_NODE"
  | "AST_ERB_FOR_NODE"
  | "AST_ERB_RESCUE_NODE"
  | "AST_ERB_ENSURE_NODE"
  | "AST_ERB_BEGIN_NODE"
  | "AST_ERB_UNLESS_NODE"
  | "AST_ERB_YIELD_NODE"
  | "AST_ERB_IN_NODE"

export type ERBNodeType = Extract<NodeType, `AST_ERB_${string}`>;

export type ERBNode =
  | ERBContentNode
  | ERBEndNode
  | ERBElseNode
  | ERBIfNode
  | ERBBlockNode
  | ERBWhenNode
  | ERBCaseNode
  | ERBCaseMatchNode
  | ERBWhileNode
  | ERBUntilNode
  | ERBForNode
  | ERBRescueNode
  | ERBEnsureNode
  | ERBBeginNode
  | ERBUnlessNode
  | ERBYieldNode
  | ERBInNode

export const ERBNodeClasses = [
  ERBContentNode,
  ERBEndNode,
  ERBElseNode,
  ERBIfNode,
  ERBBlockNode,
  ERBWhenNode,
  ERBCaseNode,
  ERBCaseMatchNode,
  ERBWhileNode,
  ERBUntilNode,
  ERBForNode,
  ERBRescueNode,
  ERBEnsureNode,
  ERBBeginNode,
  ERBUnlessNode,
  ERBYieldNode,
  ERBInNode,
]
