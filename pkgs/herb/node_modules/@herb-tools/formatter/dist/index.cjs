'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const dedent = createDedent({});
function createDedent(options) {
  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings),
      trimWhitespace = true
    } = options;

    // first, perform interpolation
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      let next = raw[i];
      if (escapeSpecialCharacters) {
        // handle escaped newlines, backticks, and interpolation characters
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
      }
      result += next;
      if (i < values.length) {
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        result += values[i];
      }
    }

    // now strip indentation
    const lines = result.split("\n");
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          // this is the first indented line
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent; // appease TypeScript
      result = lines
      // https://github.com/typescript-eslint/typescript-eslint/issues/7140
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      .map(l => l[0] === " " || l[0] === "\t" ? l.slice(m) : l).join("\n");
    }

    // dedent eats leading and trailing whitespace too
    if (trimWhitespace) {
      result = result.trim();
    }

    // handle escaped newlines at the end to ensure they don't get stripped too
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, "\n");
    }
    return result;
  }
}

class Position {
    line;
    column;
    static from(position) {
        return new Position(position.line, position.column);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Location {
    start;
    end;
    static from(location) {
        const start = Position.from(location.start);
        const end = Position.from(location.end);
        return new Location(start, end);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Range {
    start;
    end;
    static from(range) {
        return new Range(range[0], range[1]);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range.from(token.range), Location.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/errors.ts.erb
class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
}
class UnexpectedError extends HerbError {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── description: ${JSON.stringify(this.description)}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnexpectedTokenError extends HerbError {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;
        return output;
    }
}
class MissingOpeningTagError extends HerbError {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class MissingClosingTagError extends HerbError {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class TagNamesMismatchError extends HerbError {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class QuotesMismatchError extends HerbError {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
        output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;
        return output;
    }
}
class VoidElementClosingTagError extends HerbError {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnclosedElementError extends HerbError {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class RubyParseError extends HerbError {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
        output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += `└── level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
}
function fromSerializedError(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}
function convertToUTF8(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/nodes.ts.erb
class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "∅\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length == 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "│   ", isLast, false);
            }
            else {
                const symbol = isLast ? "└── " : "├── ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "∅\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? "└── " : "├── ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index == 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
}
class DocumentNode extends Node {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class LiteralNode extends Node {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
}
class HTMLOpenTagNode extends Node {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
}
class HTMLCloseTagNode extends Node {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class HTMLElementNode extends Node {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
}
class HTMLAttributeValueNode extends Node {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_quote: data.open_quote ? Token.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            close_quote: data.close_quote ? Token.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
        output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;
        return output;
    }
}
class HTMLAttributeNameNode extends Node {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class HTMLAttributeNode extends Node {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            name: data.name ? fromSerializedNode((data.name)) : null,
            equals: data.equals ? Token.from(data.equals) : null,
            value: data.value ? fromSerializedNode((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
        output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
        output += `└── value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
}
class HTMLTextNode extends Node {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
}
class HTMLCommentNode extends Node {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            comment_start: data.comment_start ? Token.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            comment_end: data.comment_end ? Token.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;
        return output;
    }
}
class HTMLDoctypeNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class XMLDeclarationNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class CDATANode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class WhitespaceNode extends Node {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            value: data.value ? Token.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBContentNode extends Node {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        // no-op for analyzed_ruby
        output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
        output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;
        return output;
    }
}
class ERBEndNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBElseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBIfNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBBlockNode extends Node {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhenNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBCaseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBCaseMatchNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhileNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUntilNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBForNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBRescueNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
}
class ERBEnsureNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBBeginNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUnlessNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBYieldNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBInNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
function fromSerializedNode(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode.from(node);
        case "AST_LITERAL_NODE": return LiteralNode.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node);
        case "AST_CDATA_NODE": return CDATANode.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
}

class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
}

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
class ParseResult extends Result {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode.from(result.value), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/node-type-guards.ts.erb
/**
 * Type guard functions for AST nodes.
 * These functions provide type checking by combining both instanceof
 * checks and type string comparisons for maximum reliability across different
 * runtime scenarios (e.g., serialized/deserialized nodes).
 */
/**
 * Checks if a node is a DocumentNode
 */
function isDocumentNode(node) {
    return node instanceof DocumentNode || node.type === "AST_DOCUMENT_NODE" || node.constructor.type === "AST_DOCUMENT_NODE";
}
/**
 * Checks if a node is a LiteralNode
 */
function isLiteralNode(node) {
    return node instanceof LiteralNode || node.type === "AST_LITERAL_NODE" || node.constructor.type === "AST_LITERAL_NODE";
}
/**
 * Checks if a node is a HTMLOpenTagNode
 */
function isHTMLOpenTagNode(node) {
    return node instanceof HTMLOpenTagNode || node.type === "AST_HTML_OPEN_TAG_NODE" || node.constructor.type === "AST_HTML_OPEN_TAG_NODE";
}
/**
 * Checks if a node is a HTMLCloseTagNode
 */
function isHTMLCloseTagNode(node) {
    return node instanceof HTMLCloseTagNode || node.type === "AST_HTML_CLOSE_TAG_NODE" || node.constructor.type === "AST_HTML_CLOSE_TAG_NODE";
}
/**
 * Checks if a node is a HTMLElementNode
 */
function isHTMLElementNode(node) {
    return node instanceof HTMLElementNode || node.type === "AST_HTML_ELEMENT_NODE" || node.constructor.type === "AST_HTML_ELEMENT_NODE";
}
/**
 * Checks if a node is a HTMLAttributeValueNode
 */
function isHTMLAttributeValueNode(node) {
    return node instanceof HTMLAttributeValueNode || node.type === "AST_HTML_ATTRIBUTE_VALUE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNameNode
 */
function isHTMLAttributeNameNode(node) {
    return node instanceof HTMLAttributeNameNode || node.type === "AST_HTML_ATTRIBUTE_NAME_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NAME_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNode
 */
function isHTMLAttributeNode(node) {
    return node instanceof HTMLAttributeNode || node.type === "AST_HTML_ATTRIBUTE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NODE";
}
/**
 * Checks if a node is a HTMLTextNode
 */
function isHTMLTextNode(node) {
    return node instanceof HTMLTextNode || node.type === "AST_HTML_TEXT_NODE" || node.constructor.type === "AST_HTML_TEXT_NODE";
}
/**
 * Checks if a node is a HTMLCommentNode
 */
function isHTMLCommentNode(node) {
    return node instanceof HTMLCommentNode || node.type === "AST_HTML_COMMENT_NODE" || node.constructor.type === "AST_HTML_COMMENT_NODE";
}
/**
 * Checks if a node is a HTMLDoctypeNode
 */
function isHTMLDoctypeNode(node) {
    return node instanceof HTMLDoctypeNode || node.type === "AST_HTML_DOCTYPE_NODE" || node.constructor.type === "AST_HTML_DOCTYPE_NODE";
}
/**
 * Checks if a node is a XMLDeclarationNode
 */
function isXMLDeclarationNode(node) {
    return node instanceof XMLDeclarationNode || node.type === "AST_XML_DECLARATION_NODE" || node.constructor.type === "AST_XML_DECLARATION_NODE";
}
/**
 * Checks if a node is a CDATANode
 */
function isCDATANode(node) {
    return node instanceof CDATANode || node.type === "AST_CDATA_NODE" || node.constructor.type === "AST_CDATA_NODE";
}
/**
 * Checks if a node is a WhitespaceNode
 */
function isWhitespaceNode(node) {
    return node instanceof WhitespaceNode || node.type === "AST_WHITESPACE_NODE" || node.constructor.type === "AST_WHITESPACE_NODE";
}
/**
 * Checks if a node is a ERBContentNode
 */
function isERBContentNode(node) {
    return node instanceof ERBContentNode || node.type === "AST_ERB_CONTENT_NODE" || node.constructor.type === "AST_ERB_CONTENT_NODE";
}
/**
 * Checks if a node is a ERBEndNode
 */
function isERBEndNode(node) {
    return node instanceof ERBEndNode || node.type === "AST_ERB_END_NODE" || node.constructor.type === "AST_ERB_END_NODE";
}
/**
 * Checks if a node is a ERBElseNode
 */
function isERBElseNode(node) {
    return node instanceof ERBElseNode || node.type === "AST_ERB_ELSE_NODE" || node.constructor.type === "AST_ERB_ELSE_NODE";
}
/**
 * Checks if a node is a ERBIfNode
 */
function isERBIfNode(node) {
    return node instanceof ERBIfNode || node.type === "AST_ERB_IF_NODE" || node.constructor.type === "AST_ERB_IF_NODE";
}
/**
 * Checks if a node is a ERBBlockNode
 */
function isERBBlockNode(node) {
    return node instanceof ERBBlockNode || node.type === "AST_ERB_BLOCK_NODE" || node.constructor.type === "AST_ERB_BLOCK_NODE";
}
/**
 * Checks if a node is a ERBWhenNode
 */
function isERBWhenNode(node) {
    return node instanceof ERBWhenNode || node.type === "AST_ERB_WHEN_NODE" || node.constructor.type === "AST_ERB_WHEN_NODE";
}
/**
 * Checks if a node is a ERBCaseNode
 */
function isERBCaseNode(node) {
    return node instanceof ERBCaseNode || node.type === "AST_ERB_CASE_NODE" || node.constructor.type === "AST_ERB_CASE_NODE";
}
/**
 * Checks if a node is a ERBCaseMatchNode
 */
function isERBCaseMatchNode(node) {
    return node instanceof ERBCaseMatchNode || node.type === "AST_ERB_CASE_MATCH_NODE" || node.constructor.type === "AST_ERB_CASE_MATCH_NODE";
}
/**
 * Checks if a node is a ERBWhileNode
 */
function isERBWhileNode(node) {
    return node instanceof ERBWhileNode || node.type === "AST_ERB_WHILE_NODE" || node.constructor.type === "AST_ERB_WHILE_NODE";
}
/**
 * Checks if a node is a ERBUntilNode
 */
function isERBUntilNode(node) {
    return node instanceof ERBUntilNode || node.type === "AST_ERB_UNTIL_NODE" || node.constructor.type === "AST_ERB_UNTIL_NODE";
}
/**
 * Checks if a node is a ERBForNode
 */
function isERBForNode(node) {
    return node instanceof ERBForNode || node.type === "AST_ERB_FOR_NODE" || node.constructor.type === "AST_ERB_FOR_NODE";
}
/**
 * Checks if a node is a ERBRescueNode
 */
function isERBRescueNode(node) {
    return node instanceof ERBRescueNode || node.type === "AST_ERB_RESCUE_NODE" || node.constructor.type === "AST_ERB_RESCUE_NODE";
}
/**
 * Checks if a node is a ERBEnsureNode
 */
function isERBEnsureNode(node) {
    return node instanceof ERBEnsureNode || node.type === "AST_ERB_ENSURE_NODE" || node.constructor.type === "AST_ERB_ENSURE_NODE";
}
/**
 * Checks if a node is a ERBBeginNode
 */
function isERBBeginNode(node) {
    return node instanceof ERBBeginNode || node.type === "AST_ERB_BEGIN_NODE" || node.constructor.type === "AST_ERB_BEGIN_NODE";
}
/**
 * Checks if a node is a ERBUnlessNode
 */
function isERBUnlessNode(node) {
    return node instanceof ERBUnlessNode || node.type === "AST_ERB_UNLESS_NODE" || node.constructor.type === "AST_ERB_UNLESS_NODE";
}
/**
 * Checks if a node is a ERBYieldNode
 */
function isERBYieldNode(node) {
    return node instanceof ERBYieldNode || node.type === "AST_ERB_YIELD_NODE" || node.constructor.type === "AST_ERB_YIELD_NODE";
}
/**
 * Checks if a node is a ERBInNode
 */
function isERBInNode(node) {
    return node instanceof ERBInNode || node.type === "AST_ERB_IN_NODE" || node.constructor.type === "AST_ERB_IN_NODE";
}
/**
 * Checks if a node is any ERB node type
 */
function isERBNode(node) {
    return isERBContentNode(node) ||
        isERBEndNode(node) ||
        isERBElseNode(node) ||
        isERBIfNode(node) ||
        isERBBlockNode(node) ||
        isERBWhenNode(node) ||
        isERBCaseNode(node) ||
        isERBCaseMatchNode(node) ||
        isERBWhileNode(node) ||
        isERBUntilNode(node) ||
        isERBForNode(node) ||
        isERBRescueNode(node) ||
        isERBEnsureNode(node) ||
        isERBBeginNode(node) ||
        isERBUnlessNode(node) ||
        isERBYieldNode(node) ||
        isERBInNode(node);
}
/**
 * Map of node classes to their corresponding type guard functions
 *
 * @example
 * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const NODE_TYPE_GUARDS = new Map([
    [DocumentNode, isDocumentNode],
    [LiteralNode, isLiteralNode],
    [HTMLOpenTagNode, isHTMLOpenTagNode],
    [HTMLCloseTagNode, isHTMLCloseTagNode],
    [HTMLElementNode, isHTMLElementNode],
    [HTMLAttributeValueNode, isHTMLAttributeValueNode],
    [HTMLAttributeNameNode, isHTMLAttributeNameNode],
    [HTMLAttributeNode, isHTMLAttributeNode],
    [HTMLTextNode, isHTMLTextNode],
    [HTMLCommentNode, isHTMLCommentNode],
    [HTMLDoctypeNode, isHTMLDoctypeNode],
    [XMLDeclarationNode, isXMLDeclarationNode],
    [CDATANode, isCDATANode],
    [WhitespaceNode, isWhitespaceNode],
    [ERBContentNode, isERBContentNode],
    [ERBEndNode, isERBEndNode],
    [ERBElseNode, isERBElseNode],
    [ERBIfNode, isERBIfNode],
    [ERBBlockNode, isERBBlockNode],
    [ERBWhenNode, isERBWhenNode],
    [ERBCaseNode, isERBCaseNode],
    [ERBCaseMatchNode, isERBCaseMatchNode],
    [ERBWhileNode, isERBWhileNode],
    [ERBUntilNode, isERBUntilNode],
    [ERBForNode, isERBForNode],
    [ERBRescueNode, isERBRescueNode],
    [ERBEnsureNode, isERBEnsureNode],
    [ERBBeginNode, isERBBeginNode],
    [ERBUnlessNode, isERBUnlessNode],
    [ERBYieldNode, isERBYieldNode],
    [ERBInNode, isERBInNode],
]);
/**
 * Map of AST node type strings to their corresponding type guard functions
 *
 * @example
 * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const AST_TYPE_GUARDS = new Map([
    ["AST_DOCUMENT_NODE", isDocumentNode],
    ["AST_LITERAL_NODE", isLiteralNode],
    ["AST_HTML_OPEN_TAG_NODE", isHTMLOpenTagNode],
    ["AST_HTML_CLOSE_TAG_NODE", isHTMLCloseTagNode],
    ["AST_HTML_ELEMENT_NODE", isHTMLElementNode],
    ["AST_HTML_ATTRIBUTE_VALUE_NODE", isHTMLAttributeValueNode],
    ["AST_HTML_ATTRIBUTE_NAME_NODE", isHTMLAttributeNameNode],
    ["AST_HTML_ATTRIBUTE_NODE", isHTMLAttributeNode],
    ["AST_HTML_TEXT_NODE", isHTMLTextNode],
    ["AST_HTML_COMMENT_NODE", isHTMLCommentNode],
    ["AST_HTML_DOCTYPE_NODE", isHTMLDoctypeNode],
    ["AST_XML_DECLARATION_NODE", isXMLDeclarationNode],
    ["AST_CDATA_NODE", isCDATANode],
    ["AST_WHITESPACE_NODE", isWhitespaceNode],
    ["AST_ERB_CONTENT_NODE", isERBContentNode],
    ["AST_ERB_END_NODE", isERBEndNode],
    ["AST_ERB_ELSE_NODE", isERBElseNode],
    ["AST_ERB_IF_NODE", isERBIfNode],
    ["AST_ERB_BLOCK_NODE", isERBBlockNode],
    ["AST_ERB_WHEN_NODE", isERBWhenNode],
    ["AST_ERB_CASE_NODE", isERBCaseNode],
    ["AST_ERB_CASE_MATCH_NODE", isERBCaseMatchNode],
    ["AST_ERB_WHILE_NODE", isERBWhileNode],
    ["AST_ERB_UNTIL_NODE", isERBUntilNode],
    ["AST_ERB_FOR_NODE", isERBForNode],
    ["AST_ERB_RESCUE_NODE", isERBRescueNode],
    ["AST_ERB_ENSURE_NODE", isERBEnsureNode],
    ["AST_ERB_BEGIN_NODE", isERBBeginNode],
    ["AST_ERB_UNLESS_NODE", isERBUnlessNode],
    ["AST_ERB_YIELD_NODE", isERBYieldNode],
    ["AST_ERB_IN_NODE", isERBInNode],
]);
/**
 * Checks if a node matches any of the provided type identifiers with proper type narrowing
 * Supports AST type strings, node classes, or type guard functions
 *
 * @example
 * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 *
 * @example
 * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 */
function isAnyOf(node, ...types) {
    return types.some(type => {
        if (typeof type === 'string') {
            return isNode(node, type);
        }
        else if (typeof type === 'function' && type.prototype && type.prototype.constructor === type && NODE_TYPE_GUARDS.has(type)) {
            return isNode(node, type);
        }
        else if (typeof type === 'function') {
            return type(node);
        }
        else {
            return false;
        }
    });
}
/**
 * Checks if a node does NOT match any of the provided type identifiers
 * Supports AST type strings, node classes, or type guard functions
 * This is the logical inverse of isAnyOf
 *
 * @example
 * if (isNoneOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 *
 * @example
 * if (isNoneOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 *
 * @example
 * if (isNoneOf(node, isHTMLTextNode, isLiteralNode)) {
 *   // node is neither HTMLTextNode nor LiteralNode
 * }
 */
function isNoneOf(node, ...types) {
    return !isAnyOf(node, ...types);
}
function filterNodes(nodes, ...types) {
    if (!nodes)
        return [];
    return nodes.filter(node => isAnyOf(node, ...types));
}
function isNode(node, type) {
    if (!node)
        return false;
    if (typeof type === 'string') {
        const guard = AST_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else if (typeof type === 'function') {
        const guard = NODE_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else {
        return false;
    }
}
function isToken(object) {
    return (object instanceof Token) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
}
function isParseResult(object) {
    return (object instanceof ParseResult) || (object?.constructor?.name === "ParseResult" && "value" in object);
}

/**
 * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
 */
function isERBOutputNode(node) {
    return isNode(node, ERBContentNode) && ["<%=", "<%=="].includes(node.tag_opening?.value);
}
/**
 * Checks if a node is a non-output ERB node (control flow: <% %>)
 */
function isERBControlFlowNode(node) {
    return isAnyOf(node, ERBIfNode, ERBUnlessNode, ERBBlockNode, ERBCaseNode, ERBCaseMatchNode, ERBWhileNode, ERBForNode, ERBBeginNode);
}
/**
 * Checks if an array of nodes contains any ERB output nodes (dynamic content)
 */
function hasERBOutput(nodes) {
    return nodes.some(isERBOutputNode);
}
/**
 * Extracts a combined string from nodes, including ERB content
 * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
 * This is useful for debugging or displaying the full attribute name
 */
function getCombinedStringFromNodes(nodes) {
    return nodes.map(node => {
        if (isLiteralNode(node)) {
            return node.content;
        }
        else if (isERBContentNode(node)) {
            const opening = node.tag_opening?.value || "";
            const content = node.content?.value || "";
            const closing = node.tag_closing?.value || "";
            return `${opening}${content}${closing}`;
        }
        else {
            // For other node types, return a placeholder or empty string
            return `[${node.type}]`;
        }
    }).join("");
}
/**
 * Gets the combined string representation of an HTML attribute name node
 * This includes both static and dynamic content, useful for debugging
 */
function getCombinedAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return "";
    }
    return getCombinedStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the tag name of an HTML element node
 */
function getTagName(node) {
    return node.tag_name?.value ?? "";
}
/**
 * Check if a node is a comment (HTML comment or ERB comment)
 */
function isCommentNode(node) {
    return isNode(node, HTMLCommentNode) || (isERBNode(node) && !isERBControlFlowNode(node));
}
/**
 * Compares two positions to determine if the first comes before the second
 * Returns true if pos1 comes before pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionBefore(position1, position2, inclusive = false) {
    if (position1.line < position2.line)
        return true;
    if (position1.line > position2.line)
        return false;
    return inclusive ? position1.column <= position2.column : position1.column < position2.column;
}
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionAfter(position1, position2, inclusive = false) {
    if (position1.line > position2.line)
        return true;
    if (position1.line < position2.line)
        return false;
    return inclusive ? position1.column >= position2.column : position1.column > position2.column;
}
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
function getNodesBeforePosition(nodes, position, inclusive = false) {
    return nodes.filter(node => node.location && isPositionBefore(node.location.end, position, inclusive));
}
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
function getNodesAfterPosition(nodes, position, inclusive = true) {
    return nodes.filter(node => node.location && isPositionAfter(node.location.start, position, inclusive));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.6.1/templates/javascript/packages/core/src/visitor.ts.erb
class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitDocumentNode(node) {
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitChildNodes(node);
    }
}

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

({
    ...DEFAULT_PRINT_OPTIONS});

// TODO: we can probably expand this list with more tags/attributes
const FORMATTABLE_ATTRIBUTES = {
    '*': ['class'],
    'img': ['srcset', 'sizes']
};
/**
 * Printer traverses the Herb AST using the Visitor pattern
 * and emits a formatted string with proper indentation, line breaks, and attribute wrapping.
 */
class FormatPrinter extends Printer {
    /**
     * @deprecated integrate indentWidth into this.options and update FormatOptions to extend from @herb-tools/printer options
     */
    indentWidth;
    /**
     * @deprecated integrate maxLineLength into this.options and update FormatOptions to extend from @herb-tools/printer options
     */
    maxLineLength;
    /**
     * @deprecated refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
     */
    lines = [];
    indentLevel = 0;
    inlineMode = false;
    currentAttributeName = null;
    elementStack = [];
    elementFormattingAnalysis = new Map();
    source;
    // TODO: extract
    static INLINE_ELEMENTS = new Set([
        'a', 'abbr', 'acronym', 'b', 'bdo', 'big', 'br', 'cite', 'code',
        'dfn', 'em', 'i', 'img', 'kbd', 'label', 'map', 'object', 'q',
        'samp', 'small', 'span', 'strong', 'sub', 'sup',
        'tt', 'var', 'del', 'ins', 'mark', 's', 'u', 'time', 'wbr'
    ]);
    static CONTENT_PRESERVING_ELEMENTS = new Set([
        'script', 'style', 'pre', 'textarea'
    ]);
    static SPACEABLE_CONTAINERS = new Set([
        'div', 'section', 'article', 'main', 'header', 'footer', 'aside',
        'figure', 'details', 'summary', 'dialog', 'fieldset'
    ]);
    static TIGHT_GROUP_PARENTS = new Set([
        'ul', 'ol', 'nav', 'select', 'datalist', 'optgroup', 'tr', 'thead',
        'tbody', 'tfoot'
    ]);
    static TIGHT_GROUP_CHILDREN = new Set([
        'li', 'option', 'td', 'th', 'dt', 'dd'
    ]);
    static SPACING_THRESHOLD = 3;
    constructor(source, options) {
        super();
        this.source = source;
        this.indentWidth = options.indentWidth;
        this.maxLineLength = options.maxLineLength;
    }
    print(input) {
        if (isToken(input))
            return input.value;
        const node = isParseResult(input) ? input.value : input;
        // TODO: refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
        this.lines = [];
        this.indentLevel = 0;
        this.visit(node);
        return this.lines.join("\n");
    }
    /**
     * Get the current element (top of stack)
     */
    get currentElement() {
        return this.elementStack.length > 0 ? this.elementStack[this.elementStack.length - 1] : null;
    }
    /**
     * Get the current tag name from the current element context
     */
    get currentTagName() {
        return this.currentElement?.open_tag?.tag_name?.value ?? "";
    }
    /**
     * Append text to the last line instead of creating a new line
     */
    pushToLastLine(text) {
        if (this.lines.length > 0) {
            this.lines[this.lines.length - 1] += text;
        }
        else {
            this.lines.push(text);
        }
    }
    /**
     * Capture output from a callback into a separate lines array
     * Useful for testing what output would be generated without affecting the main output
     */
    capture(callback) {
        const previousLines = this.lines;
        const previousInlineMode = this.inlineMode;
        this.lines = [];
        try {
            callback();
            return this.lines;
        }
        finally {
            this.lines = previousLines;
            this.inlineMode = previousInlineMode;
        }
    }
    /**
     * Capture all nodes that would be visited during a callback
     * Returns a flat list of all nodes without generating any output
     */
    captureNodes(callback) {
        const capturedNodes = [];
        const previousLines = this.lines;
        const previousInlineMode = this.inlineMode;
        const originalPush = this.push.bind(this);
        const originalPushToLastLine = this.pushToLastLine.bind(this);
        const originalVisit = this.visit.bind(this);
        this.lines = [];
        this.push = () => { };
        this.pushToLastLine = () => { };
        this.visit = (node) => {
            capturedNodes.push(node);
            originalVisit(node);
        };
        try {
            callback();
            return capturedNodes;
        }
        finally {
            this.lines = previousLines;
            this.inlineMode = previousInlineMode;
            this.push = originalPush;
            this.pushToLastLine = originalPushToLastLine;
            this.visit = originalVisit;
        }
    }
    /**
     * @deprecated refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
     */
    push(line) {
        this.lines.push(line);
    }
    /**
     * @deprecated refactor to use @herb-tools/printer infrastructre (or rework printer use push and this.lines)
     */
    pushWithIndent(line) {
        const indent = line.trim() === "" ? "" : this.indent;
        this.push(indent + line);
    }
    withIndent(callback) {
        this.indentLevel++;
        const result = callback();
        this.indentLevel--;
        return result;
    }
    get indent() {
        return " ".repeat(this.indentLevel * this.indentWidth);
    }
    /**
     * Format ERB content with proper spacing around the inner content.
     * Returns empty string if content is empty, otherwise wraps content with single spaces.
     */
    formatERBContent(content) {
        return content.trim() ? ` ${content.trim()} ` : "";
    }
    /**
     * Count total attributes including those inside ERB conditionals
     */
    getTotalAttributeCount(attributes, inlineNodes = []) {
        let totalAttributeCount = attributes.length;
        inlineNodes.forEach(node => {
            if (isERBControlFlowNode(node)) {
                const capturedNodes = this.captureNodes(() => this.visit(node));
                const attributeNodes = filterNodes(capturedNodes, HTMLAttributeNode);
                totalAttributeCount += attributeNodes.length;
            }
        });
        return totalAttributeCount;
    }
    /**
     * Extract inline nodes (non-attribute, non-whitespace) from a list of nodes
     */
    extractInlineNodes(nodes) {
        return nodes.filter(child => isNoneOf(child, HTMLAttributeNode, WhitespaceNode));
    }
    /**
     * Determine if spacing should be added between sibling elements
     *
     * This implements the "rule of three" intelligent spacing system:
     * - Adds spacing between 3 or more meaningful siblings
     * - Respects semantic groupings (e.g., ul/li, nav/a stay tight)
     * - Groups comments with following elements
     * - Preserves user-added spacing
     *
     * @param parentElement - The parent element containing the siblings
     * @param siblings - Array of all sibling nodes
     * @param currentIndex - Index of the current node being evaluated
     * @param hasExistingSpacing - Whether user-added spacing already exists
     * @returns true if spacing should be added before the current element
     */
    shouldAddSpacingBetweenSiblings(parentElement, siblings, currentIndex, hasExistingSpacing) {
        if (hasExistingSpacing) {
            return true;
        }
        const hasMixedContent = siblings.some(child => isNode(child, HTMLTextNode) && child.content.trim() !== "");
        if (hasMixedContent) {
            return false;
        }
        const meaningfulSiblings = siblings.filter(child => this.isNonWhitespaceNode(child));
        if (meaningfulSiblings.length < FormatPrinter.SPACING_THRESHOLD) {
            return false;
        }
        const parentTagName = parentElement ? getTagName(parentElement) : null;
        if (parentTagName && FormatPrinter.TIGHT_GROUP_PARENTS.has(parentTagName)) {
            return false;
        }
        const isSpaceableContainer = !parentTagName || (parentTagName && FormatPrinter.SPACEABLE_CONTAINERS.has(parentTagName));
        if (!isSpaceableContainer && meaningfulSiblings.length < 5) {
            return false;
        }
        const currentNode = siblings[currentIndex];
        const previousMeaningfulIndex = this.findPreviousMeaningfulSibling(siblings, currentIndex);
        const isCurrentComment = isCommentNode(currentNode);
        if (previousMeaningfulIndex !== -1) {
            const previousNode = siblings[previousMeaningfulIndex];
            const isPreviousComment = isCommentNode(previousNode);
            if (isPreviousComment && !isCurrentComment && (isNode(currentNode, HTMLElementNode) || isERBNode(currentNode))) {
                return false;
            }
            if (isPreviousComment && isCurrentComment) {
                return false;
            }
        }
        if (isNode(currentNode, HTMLElementNode)) {
            const currentTagName = getTagName(currentNode);
            if (FormatPrinter.INLINE_ELEMENTS.has(currentTagName)) {
                return false;
            }
            if (FormatPrinter.TIGHT_GROUP_CHILDREN.has(currentTagName)) {
                return false;
            }
            if (currentTagName === 'a' && parentTagName === 'nav') {
                return false;
            }
        }
        const isBlockElement = this.isBlockLevelNode(currentNode);
        const isERBBlock = isERBNode(currentNode) && isERBControlFlowNode(currentNode);
        const isComment = isCommentNode(currentNode);
        return isBlockElement || isERBBlock || isComment;
    }
    /**
     * Token list attributes that contain space-separated values and benefit from
     * spacing around ERB content for readability
     */
    static TOKEN_LIST_ATTRIBUTES = new Set([
        'class', 'data-controller', 'data-action'
    ]);
    /**
     * Check if we're currently processing a token list attribute that needs spacing
     */
    isInTokenListAttribute() {
        return this.currentAttributeName !== null &&
            FormatPrinter.TOKEN_LIST_ATTRIBUTES.has(this.currentAttributeName);
    }
    /**
     * Find the previous meaningful (non-whitespace) sibling
     */
    findPreviousMeaningfulSibling(siblings, currentIndex) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            if (this.isNonWhitespaceNode(siblings[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Check if a node represents a block-level element
     */
    isBlockLevelNode(node) {
        if (!isNode(node, HTMLElementNode)) {
            return false;
        }
        const tagName = getTagName(node);
        if (FormatPrinter.INLINE_ELEMENTS.has(tagName)) {
            return false;
        }
        return true;
    }
    /**
     * Render attributes as a space-separated string
     */
    renderAttributesString(attributes) {
        if (attributes.length === 0)
            return "";
        return ` ${attributes.map(attribute => this.renderAttribute(attribute)).join(" ")}`;
    }
    /**
     * Determine if a tag should be rendered inline based on attribute count and other factors
     */
    shouldRenderInline(totalAttributeCount, inlineLength, indentLength, maxLineLength = this.maxLineLength, hasComplexERB = false, hasMultilineAttributes = false, attributes = []) {
        if (hasComplexERB || hasMultilineAttributes)
            return false;
        if (totalAttributeCount === 0) {
            return inlineLength + indentLength <= maxLineLength;
        }
        if (totalAttributeCount === 1 && attributes.length === 1) {
            const attribute = attributes[0];
            const attributeName = this.getAttributeName(attribute);
            if (attributeName === 'class') {
                const attributeValue = this.getAttributeValue(attribute);
                const wouldBeMultiline = this.wouldClassAttributeBeMultiline(attributeValue, indentLength);
                if (!wouldBeMultiline) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        if (totalAttributeCount > 3 || inlineLength + indentLength > maxLineLength) {
            return false;
        }
        return true;
    }
    getAttributeName(attribute) {
        return attribute.name ? getCombinedAttributeName(attribute.name) : "";
    }
    wouldClassAttributeBeMultiline(content, indentLength) {
        const normalizedContent = content.replace(/\s+/g, ' ').trim();
        const hasActualNewlines = /\r?\n/.test(content);
        if (hasActualNewlines && normalizedContent.length > 80) {
            const lines = content.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            if (lines.length > 1) {
                return true;
            }
        }
        const attributeLine = `class="${normalizedContent}"`;
        const currentIndent = indentLength;
        if (currentIndent + attributeLine.length > this.maxLineLength && normalizedContent.length > 60) {
            if (/<%[^%]*%>/.test(normalizedContent)) {
                return false;
            }
            const classes = normalizedContent.split(' ');
            const lines = this.breakTokensIntoLines(classes, currentIndent);
            return lines.length > 1;
        }
        return false;
    }
    getAttributeValue(attribute) {
        if (isNode(attribute.value, HTMLAttributeValueNode)) {
            return attribute.value.children.map(child => isNode(child, HTMLTextNode) ? child.content : IdentityPrinter.print(child)).join('');
        }
        return '';
    }
    hasMultilineAttributes(attributes) {
        return attributes.some(attribute => {
            if (isNode(attribute.value, HTMLAttributeValueNode)) {
                const content = getCombinedStringFromNodes(attribute.value.children);
                if (/\r?\n/.test(content)) {
                    const name = attribute.name ? getCombinedAttributeName(attribute.name) : "";
                    if (name === "class") {
                        const normalizedContent = content.replace(/\s+/g, ' ').trim();
                        return normalizedContent.length > 80;
                    }
                    const lines = content.split(/\r?\n/);
                    if (lines.length > 1) {
                        return lines.slice(1).some(line => /^\s+/.test(line));
                    }
                }
            }
            return false;
        });
    }
    formatClassAttribute(content, name, equals, open_quote, close_quote) {
        const normalizedContent = content.replace(/\s+/g, ' ').trim();
        const hasActualNewlines = /\r?\n/.test(content);
        if (hasActualNewlines && normalizedContent.length > 80) {
            const lines = content.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            if (lines.length > 1) {
                return open_quote + this.formatMultilineAttributeValue(lines) + close_quote;
            }
        }
        const currentIndent = this.indentLevel * this.indentWidth;
        const attributeLine = `${name}${equals}${open_quote}${normalizedContent}${close_quote}`;
        if (currentIndent + attributeLine.length > this.maxLineLength && normalizedContent.length > 60) {
            if (/<%[^%]*%>/.test(normalizedContent)) {
                return open_quote + normalizedContent + close_quote;
            }
            const classes = normalizedContent.split(' ');
            const lines = this.breakTokensIntoLines(classes, currentIndent);
            if (lines.length > 1) {
                return open_quote + this.formatMultilineAttributeValue(lines) + close_quote;
            }
        }
        return open_quote + normalizedContent + close_quote;
    }
    isFormattableAttribute(attributeName, tagName) {
        const globalFormattable = FORMATTABLE_ATTRIBUTES['*'] || [];
        const tagSpecificFormattable = FORMATTABLE_ATTRIBUTES[tagName.toLowerCase()] || [];
        return globalFormattable.includes(attributeName) || tagSpecificFormattable.includes(attributeName);
    }
    formatMultilineAttribute(content, name, open_quote, close_quote) {
        if (name === 'srcset' || name === 'sizes') {
            const normalizedContent = content.replace(/\s+/g, ' ').trim();
            return open_quote + normalizedContent + close_quote;
        }
        const lines = content.split('\n');
        if (lines.length <= 1) {
            return open_quote + content + close_quote;
        }
        const formattedContent = this.formatMultilineAttributeValue(lines);
        return open_quote + formattedContent + close_quote;
    }
    formatMultilineAttributeValue(lines) {
        const indent = " ".repeat((this.indentLevel + 1) * this.indentWidth);
        const closeIndent = " ".repeat(this.indentLevel * this.indentWidth);
        return "\n" + lines.map(line => indent + line).join("\n") + "\n" + closeIndent;
    }
    breakTokensIntoLines(tokens, currentIndent, separator = ' ') {
        const lines = [];
        let currentLine = '';
        for (const token of tokens) {
            const testLine = currentLine ? currentLine + separator + token : token;
            if (testLine.length > (this.maxLineLength - currentIndent - 6)) {
                if (currentLine) {
                    lines.push(currentLine);
                    currentLine = token;
                }
                else {
                    lines.push(token);
                }
            }
            else {
                currentLine = testLine;
            }
        }
        if (currentLine)
            lines.push(currentLine);
        return lines;
    }
    /**
     * Render multiline attributes for a tag
     */
    renderMultilineAttributes(tagName, allChildren = [], isSelfClosing = false) {
        this.pushWithIndent(`<${tagName}`);
        this.withIndent(() => {
            allChildren.forEach(child => {
                if (isNode(child, HTMLAttributeNode)) {
                    this.pushWithIndent(this.renderAttribute(child));
                }
                else if (!isNode(child, WhitespaceNode)) {
                    this.visit(child);
                }
            });
        });
        if (isSelfClosing) {
            this.pushWithIndent("/>");
        }
        else {
            this.pushWithIndent(">");
        }
    }
    /**
     * Reconstruct the text representation of an ERB node
     * @param withFormatting - if true, format the content; if false, preserve original
     */
    reconstructERBNode(node, withFormatting = true) {
        const open = node.tag_opening?.value ?? "";
        const close = node.tag_closing?.value ?? "";
        const content = node.content?.value ?? "";
        const inner = withFormatting ? this.formatERBContent(content) : content;
        return open + inner + close;
    }
    /**
     * Print an ERB tag (<% %> or <%= %>) with single spaces around inner content.
     */
    printERBNode(node) {
        const indent = this.inlineMode ? "" : this.indent;
        const erbText = this.reconstructERBNode(node, true);
        this.push(indent + erbText);
    }
    // --- Visitor methods ---
    visitDocumentNode(node) {
        let lastWasMeaningful = false;
        let hasHandledSpacing = false;
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (isNode(child, HTMLTextNode)) {
                const isWhitespaceOnly = child.content.trim() === "";
                if (isWhitespaceOnly) {
                    const hasPreviousNonWhitespace = i > 0 && this.isNonWhitespaceNode(node.children[i - 1]);
                    const hasNextNonWhitespace = i < node.children.length - 1 && this.isNonWhitespaceNode(node.children[i + 1]);
                    const hasMultipleNewlines = child.content.includes('\n\n');
                    if (hasPreviousNonWhitespace && hasNextNonWhitespace && hasMultipleNewlines) {
                        this.push("");
                        hasHandledSpacing = true;
                    }
                    continue;
                }
            }
            if (this.isNonWhitespaceNode(child) && lastWasMeaningful && !hasHandledSpacing) {
                this.push("");
            }
            this.visit(child);
            if (this.isNonWhitespaceNode(child)) {
                lastWasMeaningful = true;
                hasHandledSpacing = false;
            }
        }
    }
    visitHTMLElementNode(node) {
        this.elementStack.push(node);
        this.elementFormattingAnalysis.set(node, this.analyzeElementFormatting(node));
        this.visit(node.open_tag);
        if (node.body.length > 0) {
            this.visitHTMLElementBody(node.body, node);
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        this.elementStack.pop();
    }
    visitHTMLElementBody(body, element) {
        if (this.isContentPreserving(element)) {
            element.body.map(child => this.pushToLastLine(IdentityPrinter.print(child)));
            return;
        }
        const analysis = this.elementFormattingAnalysis.get(element);
        const hasTextFlow = this.isInTextFlowContext(null, body);
        const children = this.filterSignificantChildren(body, hasTextFlow);
        if (analysis?.elementContentInline) {
            if (children.length === 0)
                return;
            const oldInlineMode = this.inlineMode;
            const nodesToRender = hasTextFlow ? body : children;
            this.inlineMode = true;
            const lines = this.capture(() => {
                nodesToRender.forEach(child => {
                    if (isNode(child, HTMLTextNode)) {
                        if (hasTextFlow) {
                            const normalizedContent = child.content.replace(/\s+/g, ' ');
                            if (normalizedContent && normalizedContent !== ' ') {
                                this.push(normalizedContent);
                            }
                            else if (normalizedContent === ' ') {
                                this.push(' ');
                            }
                        }
                        else {
                            const normalizedContent = child.content.replace(/\s+/g, ' ').trim();
                            if (normalizedContent) {
                                this.push(normalizedContent);
                            }
                        }
                    }
                    else if (isNode(child, WhitespaceNode)) {
                        return;
                    }
                    else {
                        this.visit(child);
                    }
                });
            });
            const content = lines.join('');
            const inlineContent = hasTextFlow ? content.replace(/\s+/g, ' ').trim() : content.trim();
            if (inlineContent) {
                this.pushToLastLine(inlineContent);
            }
            this.inlineMode = oldInlineMode;
            return;
        }
        if (children.length === 0)
            return;
        this.withIndent(() => {
            if (hasTextFlow) {
                this.visitTextFlowChildren(children);
            }
            else {
                this.visitElementChildren(body, element);
            }
        });
    }
    /**
     * Visit element children with intelligent spacing logic
     */
    visitElementChildren(body, parentElement) {
        let lastWasMeaningful = false;
        let hasHandledSpacing = false;
        for (let i = 0; i < body.length; i++) {
            const child = body[i];
            if (isNode(child, HTMLTextNode)) {
                const isWhitespaceOnly = child.content.trim() === "";
                if (isWhitespaceOnly) {
                    const hasPreviousNonWhitespace = i > 0 && this.isNonWhitespaceNode(body[i - 1]);
                    const hasNextNonWhitespace = i < body.length - 1 && this.isNonWhitespaceNode(body[i + 1]);
                    const hasMultipleNewlines = child.content.includes('\n\n');
                    if (hasPreviousNonWhitespace && hasNextNonWhitespace && hasMultipleNewlines) {
                        this.push("");
                        hasHandledSpacing = true;
                    }
                    continue;
                }
            }
            if (this.isNonWhitespaceNode(child) && lastWasMeaningful && !hasHandledSpacing) {
                const element = body[i - 1];
                const hasExistingSpacing = i > 0 && isNode(element, HTMLTextNode) && element.content.trim() === "" && (element.content.includes('\n\n') || element.content.split('\n').length > 2);
                const shouldAddSpacing = this.shouldAddSpacingBetweenSiblings(parentElement, body, i, hasExistingSpacing);
                if (shouldAddSpacing) {
                    this.push("");
                }
            }
            this.visit(child);
            if (this.isNonWhitespaceNode(child)) {
                lastWasMeaningful = true;
                hasHandledSpacing = false;
            }
        }
    }
    visitHTMLOpenTagNode(node) {
        const attributes = filterNodes(node.children, HTMLAttributeNode);
        const inlineNodes = this.extractInlineNodes(node.children);
        const isSelfClosing = node.tag_closing?.value === "/>";
        if (this.currentElement && this.elementFormattingAnalysis.has(this.currentElement)) {
            const analysis = this.elementFormattingAnalysis.get(this.currentElement);
            if (analysis.openTagInline) {
                const inline = this.renderInlineOpen(getTagName(node), attributes, isSelfClosing, inlineNodes, node.children);
                this.push(this.inlineMode ? inline : this.indent + inline);
                return;
            }
            else {
                this.renderMultilineAttributes(getTagName(node), node.children, isSelfClosing);
                return;
            }
        }
        const inline = this.renderInlineOpen(getTagName(node), attributes, isSelfClosing, inlineNodes, node.children);
        const totalAttributeCount = this.getTotalAttributeCount(attributes, inlineNodes);
        const shouldKeepInline = this.shouldRenderInline(totalAttributeCount, inline.length, this.indent.length, this.maxLineLength, false, this.hasMultilineAttributes(attributes), attributes);
        if (shouldKeepInline) {
            this.push(this.inlineMode ? inline : this.indent + inline);
        }
        else {
            this.renderMultilineAttributes(getTagName(node), node.children, isSelfClosing);
        }
    }
    visitHTMLCloseTagNode(node) {
        const closingTag = IdentityPrinter.print(node);
        const analysis = this.currentElement && this.elementFormattingAnalysis.get(this.currentElement);
        const closeTagInline = analysis?.closeTagInline;
        if (this.currentElement && closeTagInline) {
            this.pushToLastLine(closingTag);
        }
        else {
            this.pushWithIndent(closingTag);
        }
    }
    visitHTMLTextNode(node) {
        if (this.inlineMode) {
            const normalizedContent = node.content.replace(/\s+/g, ' ').trim();
            if (normalizedContent) {
                this.push(normalizedContent);
            }
            return;
        }
        let text = node.content.trim();
        if (!text)
            return;
        const wrapWidth = this.maxLineLength - this.indent.length;
        const words = text.split(/\s+/);
        const lines = [];
        let line = "";
        for (const word of words) {
            if ((line + (line ? " " : "") + word).length > wrapWidth && line) {
                lines.push(this.indent + line);
                line = word;
            }
            else {
                line += (line ? " " : "") + word;
            }
        }
        if (line)
            lines.push(this.indent + line);
        lines.forEach(line => this.push(line));
    }
    visitHTMLAttributeNode(node) {
        this.pushWithIndent(this.renderAttribute(node));
    }
    visitHTMLAttributeNameNode(node) {
        this.pushWithIndent(getCombinedAttributeName(node));
    }
    visitHTMLAttributeValueNode(node) {
        this.pushWithIndent(IdentityPrinter.print(node));
    }
    // TODO: rework
    visitHTMLCommentNode(node) {
        const open = node.comment_start?.value ?? "";
        const close = node.comment_end?.value ?? "";
        let inner;
        if (node.children && node.children.length > 0) {
            inner = node.children.map(child => {
                if (isNode(child, HTMLTextNode) || isNode(child, LiteralNode)) {
                    return child.content;
                }
                else if (isERBNode(child) || isNode(child, ERBContentNode)) {
                    return this.reconstructERBNode(child, false);
                }
                else {
                    return "";
                }
            }).join("");
            const hasNewlines = inner.includes('\n');
            if (hasNewlines) {
                const lines = inner.split('\n');
                const childIndent = " ".repeat(this.indentWidth);
                const firstLineHasContent = lines[0].trim() !== '';
                if (firstLineHasContent && lines.length > 1) {
                    const contentLines = lines.map(line => line.trim()).filter(line => line !== '');
                    inner = '\n' + contentLines.map(line => childIndent + line).join('\n') + '\n';
                }
                else {
                    const contentLines = lines.filter((line, index) => {
                        return line.trim() !== '' && !(index === 0 || index === lines.length - 1);
                    });
                    const minIndent = contentLines.length > 0 ? Math.min(...contentLines.map(line => line.length - line.trimStart().length)) : 0;
                    const processedLines = lines.map((line, index) => {
                        const trimmedLine = line.trim();
                        if ((index === 0 || index === lines.length - 1) && trimmedLine === '') {
                            return line;
                        }
                        if (trimmedLine !== '') {
                            const currentIndent = line.length - line.trimStart().length;
                            const relativeIndent = Math.max(0, currentIndent - minIndent);
                            return childIndent + " ".repeat(relativeIndent) + trimmedLine;
                        }
                        return line;
                    });
                    inner = processedLines.join('\n');
                }
            }
            else {
                inner = ` ${inner.trim()} `;
            }
        }
        else {
            inner = "";
        }
        this.pushWithIndent(open + inner + close);
    }
    visitERBCommentNode(node) {
        const open = node.tag_opening?.value || "<%#";
        const content = node?.content?.value || "";
        const close = node.tag_closing?.value || "%>";
        const contentLines = content.split("\n");
        const contentTrimmedLines = content.trim().split("\n");
        if (contentLines.length === 1 && contentTrimmedLines.length === 1) {
            const startsWithSpace = content[0] === " ";
            const before = startsWithSpace ? "" : " ";
            this.pushWithIndent(open + before + content.trimEnd() + ' ' + close);
            return;
        }
        if (contentTrimmedLines.length === 1) {
            this.pushWithIndent(open + ' ' + content.trim() + ' ' + close);
            return;
        }
        const firstLineEmpty = contentLines[0].trim() === "";
        const dedentedContent = dedent(firstLineEmpty ? content : content.trimStart());
        this.pushWithIndent(open);
        this.withIndent(() => {
            dedentedContent.split("\n").forEach(line => this.pushWithIndent(line));
        });
        this.pushWithIndent(close);
    }
    visitHTMLDoctypeNode(node) {
        this.pushWithIndent(IdentityPrinter.print(node));
    }
    visitXMLDeclarationNode(node) {
        this.pushWithIndent(IdentityPrinter.print(node));
    }
    visitCDATANode(node) {
        this.pushWithIndent(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        // TODO: this feels hacky
        if (node.tag_opening?.value === "<%#") {
            this.visitERBCommentNode(node);
        }
        else {
            this.printERBNode(node);
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        this.visitAll(node.conditions);
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitElementChildren(node.body, null));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBIfNode(node) {
        if (this.inlineMode) {
            this.printERBNode(node);
            node.statements.forEach(child => {
                if (isNode(child, HTMLAttributeNode)) {
                    this.lines.push(" ");
                    this.lines.push(this.renderAttribute(child));
                }
                else {
                    const shouldAddSpaces = this.isInTokenListAttribute();
                    if (shouldAddSpaces) {
                        this.lines.push(" ");
                    }
                    this.visit(child);
                    if (shouldAddSpaces) {
                        this.lines.push(" ");
                    }
                }
            });
            const hasHTMLAttributes = node.statements.some(child => isNode(child, HTMLAttributeNode));
            const isTokenList = this.isInTokenListAttribute();
            if ((hasHTMLAttributes || isTokenList) && node.end_node) {
                this.lines.push(" ");
            }
            if (node.subsequent)
                this.visit(node.end_node);
            if (node.end_node)
                this.visit(node.end_node);
        }
        else {
            this.printERBNode(node);
            this.withIndent(() => {
                node.statements.forEach(child => this.visit(child));
            });
            if (node.subsequent)
                this.visit(node.subsequent);
            if (node.end_node)
                this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        this.withIndent(() => node.statements.forEach(statement => this.visit(statement)));
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        this.visitAll(node.conditions);
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.rescue_clause)
            this.visit(node.rescue_clause);
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.ensure_clause)
            this.visit(node.ensure_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.end_node)
            this.visit(node.end_node);
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        this.withIndent(() => this.visitAll(node.statements));
        if (node.else_clause)
            this.visit(node.else_clause);
        if (node.end_node)
            this.visit(node.end_node);
    }
    // --- Element Formatting Analysis Helpers ---
    /**
     * Analyzes an HTMLElementNode and returns formatting decisions for all parts
     */
    analyzeElementFormatting(node) {
        const openTagInline = this.shouldRenderOpenTagInline(node);
        const elementContentInline = this.shouldRenderElementContentInline(node);
        const closeTagInline = this.shouldRenderCloseTagInline(node, elementContentInline);
        return {
            openTagInline,
            elementContentInline,
            closeTagInline
        };
    }
    /**
     * Determines if the open tag should be rendered inline
     */
    shouldRenderOpenTagInline(node) {
        const children = node.open_tag?.children || [];
        const attributes = filterNodes(children, HTMLAttributeNode);
        const inlineNodes = this.extractInlineNodes(children);
        const hasERBControlFlow = inlineNodes.some(node => isERBControlFlowNode(node)) || children.some(node => isERBControlFlowNode(node));
        const hasComplexERB = hasERBControlFlow && this.hasComplexERBControlFlow(inlineNodes);
        if (hasComplexERB)
            return false;
        const totalAttributeCount = this.getTotalAttributeCount(attributes, inlineNodes);
        const hasMultilineAttrs = this.hasMultilineAttributes(attributes);
        if (hasMultilineAttrs)
            return false;
        const inline = this.renderInlineOpen(getTagName(node), attributes, node.open_tag?.tag_closing?.value === "/>", inlineNodes, children);
        return this.shouldRenderInline(totalAttributeCount, inline.length, this.indent.length, this.maxLineLength, hasComplexERB, hasMultilineAttrs, attributes);
    }
    /**
     * Determines if the element content should be rendered inline
     */
    shouldRenderElementContentInline(node) {
        const tagName = getTagName(node);
        const children = this.filterSignificantChildren(node.body, this.isInTextFlowContext(null, node.body));
        const isInlineElement = this.isInlineElement(tagName);
        const openTagInline = this.shouldRenderOpenTagInline(node);
        if (!openTagInline)
            return false;
        if (children.length === 0)
            return true;
        if (isInlineElement) {
            const fullInlineResult = this.tryRenderInlineFull(node, tagName, filterNodes(node.open_tag?.children, HTMLAttributeNode), children);
            if (fullInlineResult) {
                const totalLength = this.indent.length + fullInlineResult.length;
                return totalLength <= this.maxLineLength || totalLength <= 120;
            }
            return false;
        }
        const allNestedAreInline = this.areAllNestedElementsInline(children);
        const hasMultilineText = this.hasMultilineTextContent(children);
        const hasMixedContent = this.hasMixedTextAndInlineContent(children);
        if (allNestedAreInline && (!hasMultilineText || hasMixedContent)) {
            const fullInlineResult = this.tryRenderInlineFull(node, tagName, filterNodes(node.open_tag?.children, HTMLAttributeNode), children);
            if (fullInlineResult) {
                const totalLength = this.indent.length + fullInlineResult.length;
                if (totalLength <= this.maxLineLength) {
                    return true;
                }
            }
        }
        const inlineResult = this.tryRenderInline(children, tagName);
        if (inlineResult) {
            const openTagResult = this.renderInlineOpen(tagName, filterNodes(node.open_tag?.children, HTMLAttributeNode), false, [], node.open_tag?.children || []);
            const childrenContent = this.renderChildrenInline(children);
            const fullLine = openTagResult + childrenContent + `</${tagName}>`;
            if ((this.indent.length + fullLine.length) <= this.maxLineLength) {
                return true;
            }
        }
        return false;
    }
    /**
     * Determines if the close tag should be rendered inline (usually follows content decision)
     */
    shouldRenderCloseTagInline(node, elementContentInline) {
        if (node.is_void)
            return true;
        if (node.open_tag?.tag_closing?.value === "/>")
            return true;
        if (this.isContentPreserving(node))
            return true;
        const children = this.filterSignificantChildren(node.body, this.isInTextFlowContext(null, node.body));
        if (children.length === 0)
            return true;
        return elementContentInline;
    }
    // --- Utility methods ---
    isNonWhitespaceNode(node) {
        if (isNode(node, WhitespaceNode))
            return false;
        if (isNode(node, HTMLTextNode))
            return node.content.trim() !== "";
        return true;
    }
    /**
     * Check if an element should be treated as inline based on its tag name
     */
    isInlineElement(tagName) {
        return FormatPrinter.INLINE_ELEMENTS.has(tagName.toLowerCase());
    }
    /**
     * Check if we're in a text flow context (parent contains mixed text and inline elements)
     */
    visitTextFlowChildren(children) {
        let currentLineContent = "";
        for (const child of children) {
            if (isNode(child, HTMLTextNode)) {
                const content = child.content;
                let processedContent = content.replace(/\s+/g, ' ').trim();
                if (processedContent) {
                    const hasLeadingSpace = /^\s/.test(content);
                    if (currentLineContent && hasLeadingSpace && !currentLineContent.endsWith(' ')) {
                        currentLineContent += ' ';
                    }
                    currentLineContent += processedContent;
                    const hasTrailingSpace = /\s$/.test(content);
                    if (hasTrailingSpace && !currentLineContent.endsWith(' ')) {
                        currentLineContent += ' ';
                    }
                    if ((this.indent.length + currentLineContent.length) > Math.max(this.maxLineLength, 120)) {
                        children.forEach(child => this.visit(child));
                        return;
                    }
                }
            }
            else if (isNode(child, HTMLElementNode)) {
                const childTagName = getTagName(child);
                if (this.isInlineElement(childTagName)) {
                    const childInline = this.tryRenderInlineFull(child, childTagName, filterNodes(child.open_tag?.children, HTMLAttributeNode), this.filterEmptyNodes(child.body));
                    if (childInline) {
                        currentLineContent += childInline;
                        if ((this.indent.length + currentLineContent.length) > this.maxLineLength) {
                            children.forEach(child => this.visit(child));
                            return;
                        }
                    }
                    else {
                        if (currentLineContent.trim()) {
                            this.pushWithIndent(currentLineContent.trim());
                            currentLineContent = "";
                        }
                        this.visit(child);
                    }
                }
                else {
                    if (currentLineContent.trim()) {
                        this.pushWithIndent(currentLineContent.trim());
                        currentLineContent = "";
                    }
                    this.visit(child);
                }
            }
            else if (isNode(child, ERBContentNode)) {
                const oldLines = this.lines;
                const oldInlineMode = this.inlineMode;
                // TODO: use this.capture
                try {
                    this.lines = [];
                    this.inlineMode = true;
                    this.visit(child);
                    const erbContent = this.lines.join("");
                    currentLineContent += erbContent;
                    if ((this.indent.length + currentLineContent.length) > Math.max(this.maxLineLength, 120)) {
                        this.lines = oldLines;
                        this.inlineMode = oldInlineMode;
                        children.forEach(child => this.visit(child));
                        return;
                    }
                }
                finally {
                    this.lines = oldLines;
                    this.inlineMode = oldInlineMode;
                }
            }
            else {
                if (currentLineContent.trim()) {
                    this.pushWithIndent(currentLineContent.trim());
                    currentLineContent = "";
                }
                this.visit(child);
            }
        }
        if (currentLineContent.trim()) {
            const finalLine = this.indent + currentLineContent.trim();
            if (finalLine.length > Math.max(this.maxLineLength, 120)) {
                this.visitAll(children);
                return;
            }
            this.push(finalLine);
        }
    }
    isInTextFlowContext(_parent, children) {
        const hasTextContent = children.some(child => isNode(child, HTMLTextNode) && child.content.trim() !== "");
        const nonTextChildren = children.filter(child => !isNode(child, HTMLTextNode));
        if (!hasTextContent)
            return false;
        if (nonTextChildren.length === 0)
            return false;
        const allInline = nonTextChildren.every(child => {
            if (isNode(child, ERBContentNode))
                return true;
            if (isNode(child, HTMLElementNode)) {
                return this.isInlineElement(getTagName(child));
            }
            return false;
        });
        if (!allInline)
            return false;
        return true;
    }
    renderInlineOpen(name, attributes, selfClose, inlineNodes = [], allChildren = []) {
        const parts = attributes.map(attribute => this.renderAttribute(attribute));
        if (inlineNodes.length > 0) {
            let result = `<${name}`;
            if (allChildren.length > 0) {
                const lines = this.capture(() => {
                    allChildren.forEach(child => {
                        if (isNode(child, HTMLAttributeNode)) {
                            this.lines.push(" " + this.renderAttribute(child));
                        }
                        else if (!(isNode(child, WhitespaceNode))) {
                            const wasInlineMode = this.inlineMode;
                            this.inlineMode = true;
                            this.lines.push(" ");
                            this.visit(child);
                            this.inlineMode = wasInlineMode;
                        }
                    });
                });
                result += lines.join("");
            }
            else {
                if (parts.length > 0) {
                    result += ` ${parts.join(" ")}`;
                }
                const lines = this.capture(() => {
                    inlineNodes.forEach(node => {
                        const wasInlineMode = this.inlineMode;
                        if (!isERBControlFlowNode(node)) {
                            this.inlineMode = true;
                        }
                        this.visit(node);
                        this.inlineMode = wasInlineMode;
                    });
                });
                result += lines.join("");
            }
            result += selfClose ? " />" : ">";
            return result;
        }
        return `<${name}${parts.length ? " " + parts.join(" ") : ""}${selfClose ? " />" : ">"}`;
    }
    renderAttribute(attribute) {
        const name = attribute.name ? getCombinedAttributeName(attribute.name) : "";
        const equals = attribute.equals?.value ?? "";
        this.currentAttributeName = name;
        let value = "";
        if (isNode(attribute.value, HTMLAttributeValueNode)) {
            const attributeValue = attribute.value;
            let open_quote = attributeValue.open_quote?.value ?? "";
            let close_quote = attributeValue.close_quote?.value ?? "";
            let htmlTextContent = "";
            const content = attributeValue.children.map((child) => {
                if (isNode(child, HTMLTextNode) || isNode(child, LiteralNode)) {
                    htmlTextContent += child.content;
                    return child.content;
                }
                else if (isNode(child, ERBContentNode)) {
                    return IdentityPrinter.print(child);
                }
                else {
                    const printed = IdentityPrinter.print(child);
                    if (this.currentAttributeName && FormatPrinter.TOKEN_LIST_ATTRIBUTES.has(this.currentAttributeName)) {
                        return printed.replace(/%>([^<\s])/g, '%> $1').replace(/([^>\s])<%/g, '$1 <%');
                    }
                    return printed;
                }
            }).join("");
            if (open_quote === "" && close_quote === "") {
                open_quote = '"';
                close_quote = '"';
            }
            else if (open_quote === "'" && close_quote === "'" && !htmlTextContent.includes('"')) {
                open_quote = '"';
                close_quote = '"';
            }
            if (this.isFormattableAttribute(name, this.currentTagName)) {
                if (name === 'class') {
                    value = this.formatClassAttribute(content, name, equals, open_quote, close_quote);
                }
                else {
                    value = this.formatMultilineAttribute(content, name, open_quote, close_quote);
                }
            }
            else {
                value = open_quote + content + close_quote;
            }
        }
        this.currentAttributeName = null;
        return name + equals + value;
    }
    /**
     * Try to render a complete element inline including opening tag, children, and closing tag
     */
    tryRenderInlineFull(_node, tagName, attributes, children) {
        let result = `<${tagName}`;
        result += this.renderAttributesString(attributes);
        result += ">";
        const childrenContent = this.tryRenderChildrenInline(children);
        if (!childrenContent)
            return null;
        result += childrenContent;
        result += `</${tagName}>`;
        return result;
    }
    /**
     * Try to render just the children inline (without tags)
     */
    tryRenderChildrenInline(children) {
        let result = "";
        for (const child of children) {
            if (isNode(child, HTMLTextNode)) {
                const normalizedContent = child.content.replace(/\s+/g, ' ');
                const hasLeadingSpace = /^\s/.test(child.content);
                const hasTrailingSpace = /\s$/.test(child.content);
                const trimmedContent = normalizedContent.trim();
                if (trimmedContent) {
                    let finalContent = trimmedContent;
                    if (hasLeadingSpace && result && !result.endsWith(' ')) {
                        finalContent = ' ' + finalContent;
                    }
                    if (hasTrailingSpace) {
                        finalContent = finalContent + ' ';
                    }
                    result += finalContent;
                }
                else if (hasLeadingSpace || hasTrailingSpace) {
                    if (result && !result.endsWith(' ')) {
                        result += ' ';
                    }
                }
            }
            else if (isNode(child, HTMLElementNode)) {
                const tagName = getTagName(child);
                if (!this.isInlineElement(tagName)) {
                    return null;
                }
                const childInline = this.tryRenderInlineFull(child, tagName, filterNodes(child.open_tag?.children, HTMLAttributeNode), this.filterEmptyNodes(child.body));
                if (!childInline) {
                    return null;
                }
                result += childInline;
            }
            else {
                result += this.capture(() => this.visit(child)).join("");
            }
        }
        return result.trim();
    }
    /**
     * Try to render children inline if they are simple enough.
     * Returns the inline string if possible, null otherwise.
     */
    tryRenderInline(children, tagName) {
        for (const child of children) {
            if (isNode(child, HTMLTextNode)) {
                if (child.content.includes('\n')) {
                    return null;
                }
            }
            else if (isNode(child, HTMLElementNode)) {
                const isInlineElement = this.isInlineElement(getTagName(child));
                if (!isInlineElement) {
                    return null;
                }
            }
            else if (isNode(child, ERBContentNode)) ;
            else {
                return null;
            }
        }
        let content = "";
        this.capture(() => {
            content = this.renderChildrenInline(children);
        });
        return `<${tagName}>${content}</${tagName}>`;
    }
    /**
     * Check if children contain mixed text and inline elements (like "text<em>inline</em>text")
     * or mixed ERB output and text (like "<%= value %> text")
     * This indicates content that should be formatted inline even with structural newlines
     */
    hasMixedTextAndInlineContent(children) {
        let hasText = false;
        let hasInlineElements = false;
        for (const child of children) {
            if (isNode(child, HTMLTextNode)) {
                if (child.content.trim() !== "") {
                    hasText = true;
                }
            }
            else if (isNode(child, HTMLElementNode)) {
                if (this.isInlineElement(getTagName(child))) {
                    hasInlineElements = true;
                }
            }
        }
        return (hasText && hasInlineElements) || (hasERBOutput(children) && hasText);
    }
    /**
     * Check if children contain any text content with newlines
     */
    hasMultilineTextContent(children) {
        for (const child of children) {
            if (isNode(child, HTMLTextNode)) {
                return child.content.includes('\n');
            }
            if (isNode(child, HTMLElementNode)) {
                const nestedChildren = this.filterEmptyNodes(child.body);
                if (this.hasMultilineTextContent(nestedChildren)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Check if all nested elements in the children are inline elements
     */
    areAllNestedElementsInline(children) {
        for (const child of children) {
            if (isNode(child, HTMLElementNode)) {
                if (!this.isInlineElement(getTagName(child))) {
                    return false;
                }
                const nestedChildren = this.filterEmptyNodes(child.body);
                if (!this.areAllNestedElementsInline(nestedChildren)) {
                    return false;
                }
            }
            else if (isAnyOf(child, HTMLDoctypeNode, HTMLCommentNode, isERBControlFlowNode)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Check if element has complex ERB control flow
     */
    hasComplexERBControlFlow(inlineNodes) {
        return inlineNodes.some(node => {
            if (isNode(node, ERBIfNode)) {
                if (node.statements.length > 0 && node.location) {
                    const startLine = node.location.start.line;
                    const endLine = node.location.end.line;
                    return startLine !== endLine;
                }
                return false;
            }
            return false;
        });
    }
    /**
     * Filter children to remove insignificant whitespace
     */
    filterSignificantChildren(body, hasTextFlow) {
        return body.filter(child => {
            if (isNode(child, WhitespaceNode))
                return false;
            if (isNode(child, HTMLTextNode)) {
                if (hasTextFlow && child.content === " ")
                    return true;
                return child.content.trim() !== "";
            }
            return true;
        });
    }
    /**
     * Filter out empty text nodes and whitespace nodes
     */
    filterEmptyNodes(nodes) {
        return nodes.filter(child => !isNode(child, WhitespaceNode) && !(isNode(child, HTMLTextNode) && child.content.trim() === ""));
    }
    renderElementInline(element) {
        const children = this.filterEmptyNodes(element.body);
        return this.renderChildrenInline(children);
    }
    renderChildrenInline(children) {
        let content = '';
        for (const child of children) {
            if (isNode(child, HTMLTextNode)) {
                content += child.content;
            }
            else if (isNode(child, HTMLElementNode)) {
                const tagName = getTagName(child);
                const attributes = filterNodes(child.open_tag?.children, HTMLAttributeNode);
                const attributesString = this.renderAttributesString(attributes);
                const childContent = this.renderElementInline(child);
                content += `<${tagName}${attributesString}>${childContent}</${tagName}>`;
            }
            else if (isNode(child, ERBContentNode)) {
                content += this.reconstructERBNode(child, true);
            }
        }
        return content.replace(/\s+/g, ' ').trim();
    }
    isContentPreserving(element) {
        const tagName = getTagName(element);
        return FormatPrinter.CONTENT_PRESERVING_ELEMENTS.has(tagName);
    }
}

/**
 * Default values for formatting options.
 */
const defaultFormatOptions = {
    indentWidth: 2,
    maxLineLength: 80,
};
/**
 * Merge provided options with defaults for any missing values.
 * @param options partial formatting options
 * @returns a complete set of formatting options
 */
function resolveFormatOptions(options = {}) {
    return {
        indentWidth: options.indentWidth ?? defaultFormatOptions.indentWidth,
        maxLineLength: options.maxLineLength ?? defaultFormatOptions.maxLineLength,
    };
}

/**
 * Formatter uses a Herb Backend to parse the source and then
 * formats the resulting AST into a well-indented, wrapped string.
 */
class Formatter {
    herb;
    options;
    constructor(herb, options = {}) {
        this.herb = herb;
        this.options = resolveFormatOptions(options);
    }
    /**
     * Format a source string, optionally overriding format options per call.
     */
    format(source, options = {}) {
        const result = this.parse(source);
        if (result.failed)
            return source;
        const resolvedOptions = resolveFormatOptions({ ...this.options, ...options });
        return new FormatPrinter(source, resolvedOptions).print(result.value);
    }
    parse(source) {
        this.herb.ensureBackend();
        return this.herb.parse(source);
    }
}

exports.FormatPrinter = FormatPrinter;
exports.Formatter = Formatter;
exports.defaultFormatOptions = defaultFormatOptions;
exports.resolveFormatOptions = resolveFormatOptions;
//# sourceMappingURL=index.cjs.map
