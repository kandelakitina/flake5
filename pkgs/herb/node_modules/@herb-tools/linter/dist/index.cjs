'use strict';

var core = require('@herb-tools/core');

class ParserRule {
    static type = "parser";
}
class LexerRule {
    static type = "lexer";
}
/**
 * Default context object with all keys defined but set to undefined
 */
const DEFAULT_LINT_CONTEXT = {
    fileName: undefined
};
class SourceRule {
    static type = "source";
}

var ControlFlowType;
(function (ControlFlowType) {
    ControlFlowType[ControlFlowType["CONDITIONAL"] = 0] = "CONDITIONAL";
    ControlFlowType[ControlFlowType["LOOP"] = 1] = "LOOP";
})(ControlFlowType || (ControlFlowType = {}));
/**
 * Base visitor class that provides common functionality for rule visitors
 */
class BaseRuleVisitor extends core.Visitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        super();
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
class ControlFlowTrackingVisitor extends BaseRuleVisitor {
    isInControlFlow = false;
    currentControlFlowType = null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    handleControlFlowNode(node, controlFlowType, visitChildren) {
        const wasInControlFlow = this.isInControlFlow;
        const previousControlFlowType = this.currentControlFlowType;
        this.isInControlFlow = true;
        this.currentControlFlowType = controlFlowType;
        const stateToRestore = this.onEnterControlFlow(controlFlowType, wasInControlFlow);
        visitChildren();
        this.onExitControlFlow(controlFlowType, wasInControlFlow, stateToRestore);
        this.isInControlFlow = wasInControlFlow;
        this.currentControlFlowType = previousControlFlowType;
    }
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    startNewBranch(visitChildren) {
        const stateToRestore = this.onEnterBranch();
        visitChildren();
        this.onExitBranch(stateToRestore);
    }
    visitERBIfNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBIfNode(node));
    }
    visitERBUnlessNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBUnlessNode(node));
    }
    visitERBCaseNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseNode(node));
    }
    visitERBCaseMatchNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseMatchNode(node));
    }
    visitERBWhileNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBWhileNode(node));
    }
    visitERBForNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBForNode(node));
    }
    visitERBUntilNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBUntilNode(node));
    }
    visitERBBlockNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBBlockNode(node));
    }
    visitERBElseNode(node) {
        this.startNewBranch(() => super.visitERBElseNode(node));
    }
    visitERBWhenNode(node) {
        this.startNewBranch(() => super.visitERBWhenNode(node));
    }
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
function getAttributes(node) {
    return node.children.filter(node => node.type === "AST_HTML_ATTRIBUTE_NODE");
}
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
function getTagName(node) {
    return node.tag_name?.value.toLowerCase() || null;
}
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        const staticName = core.getStaticAttributeName(nameNode);
        return staticName ? staticName.toLowerCase() : null;
    }
    return null;
}
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
function hasDynamicAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return core.hasDynamicAttributeName(nameNode);
    }
    return false;
}
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
function getCombinedAttributeNameString(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return core.getCombinedAttributeName(nameNode);
    }
    return "";
}
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
function hasStaticAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.every(child => child.type === "AST_LITERAL_NODE");
}
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
function getStaticAttributeValue(attributeNode) {
    if (!hasStaticAttributeValue(attributeNode))
        return null;
    const valueNode = attributeNode.value;
    const result = valueNode.children
        ?.filter(child => child.type === "AST_LITERAL_NODE")
        .map(child => child.content)
        .join("") || "";
    return result;
}
/**
 * Gets the value nodes array for dynamic inspection
 */
function getAttributeValueNodes(attributeNode) {
    const valueNode = attributeNode.value;
    return valueNode?.children || [];
}
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
function getAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (valueNode === null)
        return null;
    if (valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE" || !valueNode.children?.length) {
        return null;
    }
    let result = "";
    for (const child of valueNode.children) {
        switch (child.type) {
            case "AST_ERB_CONTENT_NODE": {
                const erbNode = child;
                if (erbNode.content) {
                    result += `${erbNode.tag_opening?.value}${erbNode.content.value}${erbNode.tag_closing?.value}`;
                }
                break;
            }
            case "AST_LITERAL_NODE": {
                result += child.content;
                break;
            }
        }
    }
    return result;
}
/**
 * Checks if an attribute has a value
 */
function hasAttributeValue(attributeNode) {
    return attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Gets the quote type used for an attribute value
 */
function getAttributeValueQuoteType(nodeOrAttribute) {
    let valueNode;
    if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_NODE") {
        const attributeNode = nodeOrAttribute;
        if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
            valueNode = attributeNode.value;
        }
    }
    else if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        valueNode = nodeOrAttribute;
    }
    if (valueNode) {
        if (valueNode.quoted && valueNode.open_quote) {
            return valueNode.open_quote.value === '"' ? "double" : "single";
        }
        return "none";
    }
    return null;
}
/**
 * Finds an attribute by name in a list of attributes
 */
function findAttributeByName(attributes, attributeName) {
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            const attributeNode = child;
            const name = getAttributeName(attributeNode);
            if (name === attributeName.toLowerCase()) {
                return attributeNode;
            }
        }
    }
    return null;
}
/**
 * Checks if a tag has a specific attribute
 */
function hasAttribute(node, attributeName) {
    return getAttribute(node, attributeName) !== null;
}
/**
 * Checks if a tag has a specific attribute
 */
function getAttribute(node, attributeName) {
    const attributes = getAttributes(node);
    return findAttributeByName(attributes, attributeName);
}
/**
 * Common HTML element categorization
 */
const HTML_INLINE_ELEMENTS = new Set([
    "a", "abbr", "acronym", "b", "bdo", "big", "br", "button", "cite", "code",
    "dfn", "em", "i", "img", "input", "kbd", "label", "map", "object", "output",
    "q", "samp", "script", "select", "small", "span", "strong", "sub", "sup",
    "textarea", "time", "tt", "var"
]);
const HTML_BLOCK_ELEMENTS = new Set([
    "address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl",
    "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2",
    "h3", "h4", "h5", "h6", "header", "hr", "li", "main", "nav", "noscript",
    "ol", "p", "pre", "section", "table", "tfoot", "ul", "video"
]);
const HTML_VOID_ELEMENTS = new Set([
    "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta",
    "param", "source", "track", "wbr",
]);
const HTML_BOOLEAN_ATTRIBUTES = new Set([
    "autofocus", "autoplay", "checked", "controls", "defer", "disabled", "hidden",
    "loop", "multiple", "muted", "readonly", "required", "reversed", "selected",
    "open", "default", "formnovalidate", "novalidate", "itemscope", "scoped",
    "seamless", "allowfullscreen", "async", "compact", "declare", "nohref",
    "noresize", "noshade", "nowrap", "sortable", "truespeed", "typemustmatch"
]);
const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
/**
 * SVG elements that use camelCase naming
 */
const SVG_CAMEL_CASE_ELEMENTS = new Set([
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
]);
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
const SVG_LOWERCASE_TO_CAMELCASE = new Map(Array.from(SVG_CAMEL_CASE_ELEMENTS).map(element => [element.toLowerCase(), element]));
const VALID_ARIA_ROLES = new Set([
    "banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search",
    "article", "cell", "columnheader", "definition", "directory", "document", "feed", "figure",
    "group", "heading", "img", "list", "listitem", "math", "none", "note", "presentation",
    "row", "rowgroup", "rowheader", "separator", "table", "term", "tooltip",
    "alert", "alertdialog", "button", "checkbox", "combobox", "dialog", "grid", "gridcell", "link",
    "listbox", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "option",
    "progressbar", "radio", "radiogroup", "scrollbar", "searchbox", "slider", "spinbutton",
    "status", "switch", "tab", "tablist", "tabpanel", "textbox", "timer", "toolbar", "tree",
    "treegrid", "treeitem",
    "log", "marquee"
]);
const ARIA_ATTRIBUTES = new Set([
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-disabled',
    'aria-dropeffect',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-modal',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
]);
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
function createEndOfFileLocation(source) {
    const lines = source.split('\n');
    const lastLineNumber = lines.length;
    const lastLine = lines[lines.length - 1];
    const lastColumnNumber = lastLine.length;
    const startColumn = lastColumnNumber > 0 ? lastColumnNumber - 1 : 0;
    const start = new core.Position(lastLineNumber, startColumn);
    const end = new core.Position(lastLineNumber, lastColumnNumber);
    return new core.Location(start, end);
}
/**
 * Checks if an element is inline
 */
function isInlineElement(tagName) {
    return HTML_INLINE_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is block-level
 */
function isBlockElement(tagName) {
    return HTML_BLOCK_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is a void element
 */
function isVoidElement(tagName) {
    return HTML_VOID_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an attribute is a boolean attribute
 */
function isBooleanAttribute(attributeName) {
    return HTML_BOOLEAN_ATTRIBUTES.has(attributeName.toLowerCase());
}
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitHTMLOpenTagNode(node) {
        this.checkAttributesOnNode(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAttributesOnNode(node) {
        forEachAttribute(node, (attributeNode) => {
            const staticAttributeName = getAttributeName(attributeNode);
            const isDynamicName = hasDynamicAttributeName(attributeNode);
            const staticAttributeValue = getStaticAttributeValue(attributeNode);
            const valueNodes = getAttributeValueNodes(attributeNode);
            const hasOutputERB = core.hasERBOutput(valueNodes);
            const isEffectivelyStaticValue = core.isEffectivelyStatic(valueNodes);
            if (staticAttributeName && staticAttributeValue !== null) {
                this.checkStaticAttributeStaticValue({
                    attributeName: staticAttributeName,
                    attributeValue: staticAttributeValue,
                    attributeNode,
                    parentNode: node
                });
            }
            else if (staticAttributeName && isEffectivelyStaticValue && !hasOutputERB) {
                const validatableContent = core.getValidatableStaticContent(valueNodes) || "";
                this.checkStaticAttributeStaticValue({ attributeName: staticAttributeName, attributeValue: validatableContent, attributeNode, parentNode: node });
            }
            else if (staticAttributeName && hasOutputERB) {
                const combinedValue = getAttributeValue(attributeNode);
                this.checkStaticAttributeDynamicValue({ attributeName: staticAttributeName, valueNodes, attributeNode, parentNode: node, combinedValue });
            }
            else if (isDynamicName && staticAttributeValue !== null) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                this.checkDynamicAttributeStaticValue({ nameNodes, attributeValue: staticAttributeValue, attributeNode, parentNode: node, combinedName });
            }
            else if (isDynamicName) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                const combinedValue = getAttributeValue(attributeNode);
                this.checkDynamicAttributeDynamicValue({ nameNodes, valueNodes, attributeNode, parentNode: node, combinedName, combinedValue });
            }
        });
    }
    /**
     * Static attribute name with static value: class="container"
     */
    checkStaticAttributeStaticValue(params) {
        // Default implementation does nothing
    }
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    checkStaticAttributeDynamicValue(params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    checkDynamicAttributeStaticValue(params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    checkDynamicAttributeDynamicValue(params) {
        // Default implementation does nothing
    }
}
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
function forEachAttribute(node, callback) {
    const attributes = getAttributes(node);
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            callback(child);
        }
    }
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
class BaseSourceRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense for source rules
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source) {
        this.visitSource(source);
    }
    /**
     * Helper method to create a location for a specific position in the source
     */
    createLocationAt(source, position) {
        const beforePosition = source.substring(0, position);
        const lines = beforePosition.split('\n');
        const line = lines.length;
        const column = lines[lines.length - 1].length + 1;
        const start = new core.Position(line, column);
        const end = new core.Position(line, column);
        return new core.Location(start, end);
    }
}

class ERBNoEmptyTagsVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        this.visitChildNodes(node);
        const { content, tag_closing } = node;
        if (!content)
            return;
        if (tag_closing?.value === "")
            return;
        if (content.value.trim().length > 0)
            return;
        this.addOffense("ERB tag should not be empty. Remove empty ERB tags or add content.", node.location, "error");
    }
}
class ERBNoEmptyTagsRule extends ParserRule {
    name = "erb-no-empty-tags";
    check(result, context) {
        const visitor = new ERBNoEmptyTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoOutputControlFlowRuleVisitor extends BaseRuleVisitor {
    visitERBIfNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    checkOutputControlFlow(controlBlock) {
        const openTag = controlBlock.tag_opening;
        if (!openTag) {
            return;
        }
        if (openTag.value === "<%=") {
            let controlBlockType = controlBlock.type;
            if (controlBlock.type === "AST_ERB_IF_NODE")
                controlBlockType = "if";
            if (controlBlock.type === "AST_ERB_ELSE_NODE")
                controlBlockType = "else";
            if (controlBlock.type === "AST_ERB_END_NODE")
                controlBlockType = "end";
            if (controlBlock.type === "AST_ERB_UNLESS_NODE")
                controlBlockType = "unless";
            this.addOffense(`Control flow statements like \`${controlBlockType}\` should not be used with output tags. Use \`<% ${controlBlockType} ... %>\` instead.`, openTag.location, "error");
        }
        return;
    }
}
class ERBNoOutputControlFlowRule extends ParserRule {
    name = "erb-no-output-control-flow";
    check(result, context) {
        const visitor = new ERBNoOutputControlFlowRuleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoSilentTagInAttributeNameVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNameNode(node) {
        const erbNodes = core.filterERBContentNodes(node.children);
        const silentNodes = erbNodes.filter(this.isSilentERBTag);
        for (const node of silentNodes) {
            this.addOffense(`Remove silent ERB tag from HTML attribute name. Silent ERB tags (\`${node.tag_opening?.value}\`) do not output content and should not be used in attribute names.`, node.location, "error");
        }
    }
    // TODO: might be worth to extract
    isSilentERBTag(node) {
        const silentTags = ["<%", "<%-", "<%#"];
        return silentTags.includes(node.tag_opening?.value || "");
    }
}
class ERBNoSilentTagInAttributeNameRule extends ParserRule {
    name = "erb-no-silent-tag-in-attribute-name";
    check(result, context) {
        const visitor = new ERBNoSilentTagInAttributeNameVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends core.Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (core.isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = core.isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = core.getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = core.getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

const DEFAULT_ERB_TO_RUBY_STRING_OPTIONS = {
    ...DEFAULT_PRINT_OPTIONS,
    forceQuotes: false
};
/**
 * ERBToRubyStringPrinter - Converts ERB snippets to Ruby strings with interpolation
 *
 * This printer transforms ERB templates into Ruby strings by:
 * - Converting literal text to string content
 * - Converting <%= %> tags to #{} interpolation
 * - Converting simple if/else blocks to ternary operators
 * - Ignoring <% %> tags (they don't produce output)
 *
 * Examples:
 * - `hello world <%= hello %>` => `"hello world #{hello}"`
 * - `hello world <% hello %>` => `"hello world "`
 * - `Welcome <%= user.name %>!` => `"Welcome #{user.name}!"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>` => `"logged_in? ? "Welcome" : "Login"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>!` => `"#{logged_in? ? "Welcome" : "Login"}!"`
 */
class ERBToRubyStringPrinter extends IdentityPrinter {
    // TODO: cleanup `.type === "AST_*" checks`
    static print(node, options = DEFAULT_ERB_TO_RUBY_STRING_OPTIONS) {
        const erbNodes = core.filterNodes([node], core.ERBContentNode);
        if (erbNodes.length === 1 && core.isERBOutputNode(erbNodes[0]) && !options.forceQuotes) {
            return (erbNodes[0].content?.value || "").trim();
        }
        if ('children' in node && Array.isArray(node.children)) {
            const childErbNodes = core.filterNodes(node.children, core.ERBContentNode);
            const hasOnlyERBContent = node.children.length > 0 && node.children.length === childErbNodes.length;
            if (hasOnlyERBContent && childErbNodes.length === 1 && core.isERBOutputNode(childErbNodes[0]) && !options.forceQuotes) {
                return (childErbNodes[0].content?.value || "").trim();
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_IF_NODE" && !options.forceQuotes) {
                const ifNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertToTernary(ifNode)) {
                    printer.convertToTernaryWithoutWrapper(ifNode);
                    return printer.context.getOutput();
                }
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_UNLESS_NODE" && !options.forceQuotes) {
                const unlessNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertUnlessToTernary(unlessNode)) {
                    printer.convertUnlessToTernaryWithoutWrapper(unlessNode);
                    return printer.context.getOutput();
                }
            }
        }
        const printer = new ERBToRubyStringPrinter();
        printer.context.write('"');
        printer.visit(node);
        printer.context.write('"');
        return printer.context.getOutput();
    }
    visitHTMLTextNode(node) {
        if (node.content) {
            const escapedContent = node.content.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            this.context.write(escapedContent);
        }
    }
    visitERBContentNode(node) {
        if (core.isERBOutputNode(node)) {
            this.context.write("#{");
            if (node.content?.value) {
                this.context.write(node.content.value.trim());
            }
            this.context.write("}");
        }
    }
    visitERBIfNode(node) {
        if (this.canConvertToTernary(node)) {
            this.convertToTernary(node);
        }
    }
    visitERBUnlessNode(node) {
        if (this.canConvertUnlessToTernary(node)) {
            this.convertUnlessToTernary(node);
        }
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    canConvertToTernary(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        const ifOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!ifOnlyText)
            return false;
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE") {
            return node.subsequent.statements
                ? node.subsequent.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertToTernaryWithoutWrapper(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
    canConvertUnlessToTernary(node) {
        const unlessOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!unlessOnlyText)
            return false;
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            return node.else_clause.statements
                ? node.else_clause.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertUnlessToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertUnlessToTernaryWithoutWrapper(node) {
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
}

class ERBPreferImageTagHelperVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(openTag) {
        const tagName = getTagName(openTag);
        if (tagName !== "img")
            return;
        const attributes = getAttributes(openTag);
        const srcAttribute = findAttributeByName(attributes, "src");
        if (!srcAttribute)
            return;
        if (!srcAttribute.value)
            return;
        const node = srcAttribute.value;
        const hasERBContent = this.containsERBContent(node);
        if (hasERBContent) {
            if (this.isDataUri(node))
                return;
            if (this.shouldFlagAsImageTagCandidate(node)) {
                const suggestedExpression = this.buildSuggestedExpression(node);
                this.addOffense(`Prefer \`image_tag\` helper over manual \`<img>\` with dynamic ERB expressions. Use \`<%= image_tag ${suggestedExpression}, alt: "..." %>\` instead.`, srcAttribute.location, "warning");
            }
        }
    }
    containsERBContent(node) {
        return core.filterNodes(node.children, core.ERBContentNode).length > 0;
    }
    isOnlyERBContent(node) {
        return node.children.length > 0 && node.children.length === core.filterNodes(node.children, core.ERBContentNode).length;
    }
    getContentofFirstChild(node) {
        if (!node.children || node.children.length === 0)
            return "";
        const firstChild = node.children[0];
        if (core.isNode(firstChild, core.LiteralNode)) {
            return (firstChild.content || "").trim();
        }
        return "";
    }
    isDataUri(node) {
        return this.getContentofFirstChild(node).startsWith("data:");
    }
    isFullUrl(node) {
        const content = this.getContentofFirstChild(node);
        return content.startsWith("http://") || content.startsWith("https://");
    }
    shouldFlagAsImageTagCandidate(node) {
        if (this.isOnlyERBContent(node))
            return true;
        if (this.isFullUrl(node))
            return false;
        return true;
    }
    buildSuggestedExpression(node) {
        if (!node.children)
            return "expression";
        try {
            return ERBToRubyStringPrinter.print(node, { ignoreErrors: false });
        }
        catch (error) {
            return "expression";
        }
    }
}
class ERBPreferImageTagHelperRule extends ParserRule {
    name = "erb-prefer-image-tag-helper";
    check(result, context) {
        const visitor = new ERBPreferImageTagHelperVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBRequiresTrailingNewlineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        if (source.endsWith('\n'))
            return;
        if (!this.context.fileName)
            return;
        this.addOffense("File must end with trailing newline", createEndOfFileLocation(source), "error");
    }
}
class ERBRequiresTrailingNewlineRule extends SourceRule {
    name = "erb-requires-trailing-newline";
    check(source, context) {
        const visitor = new ERBRequiresTrailingNewlineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
}

class RequireWhitespaceInsideTags extends BaseRuleVisitor {
    visitChildNodes(node) {
        this.checkWhitespace(node);
        super.visitChildNodes(node);
    }
    checkWhitespace(node) {
        if (!core.isERBNode(node)) {
            return;
        }
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const content = node.content;
        if (!openTag || !closeTag || !content) {
            return;
        }
        const value = content.value;
        if (openTag.value === "<%#") {
            this.checkCommentTagWhitespace(openTag, closeTag, value);
        }
        else {
            this.checkOpenTagWhitespace(openTag, value);
            this.checkCloseTagWhitespace(closeTag, value);
        }
    }
    checkCommentTagWhitespace(openTag, closeTag, content) {
        if (!content.startsWith(" ") && !content.startsWith("\n") && !content.startsWith("=")) {
            this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, "error");
        }
        else if (content.startsWith("=") && content.length > 1 && !content[1].match(/\s/)) {
            this.addOffense(`Add whitespace after \`<%#=\`.`, openTag.location, "error");
        }
        if (!content.endsWith(" ") && !content.endsWith("\n")) {
            this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, "error");
        }
    }
    checkOpenTagWhitespace(openTag, content) {
        if (content.startsWith(" ") || content.startsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, "error");
    }
    checkCloseTagWhitespace(closeTag, content) {
        if (content.endsWith(" ") || content.endsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, "error");
    }
}
class ERBRequireWhitespaceRule extends ParserRule {
    name = "erb-require-whitespace-inside-tags";
    check(result, context) {
        const visitor = new RequireWhitespaceInsideTags(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AnchorRechireHrefVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkATag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkATag(node) {
        const tagName = getTagName(node);
        if (tagName !== "a") {
            return;
        }
        if (!hasAttribute(node, "href")) {
            this.addOffense("Add an `href` attribute to `<a>` to ensure it is focusable and accessible.", node.tag_name.location, "error");
        }
    }
}
class HTMLAnchorRequireHrefRule extends ParserRule {
    name = "html-anchor-require-href";
    check(result, context) {
        const visitor = new AnchorRechireHrefVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaAttributeMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName.startsWith("aria-"))
            return;
        if (ARIA_ATTRIBUTES.has(attributeName))
            return;
        this.addOffense(`The attribute \`${attributeName}\` is not a valid ARIA attribute. ARIA attributes must match the WAI-ARIA specification.`, attributeNode.location, "error");
    }
}
class HTMLAriaAttributeMustBeValid extends ParserRule {
    name = "html-aria-attribute-must-be-valid";
    check(result, context) {
        const visitor = new AriaAttributeMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaLabelIsWellFormattedVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-label")
            return;
        if (attributeValue.match(/[\r\n]+/) || attributeValue.match(/&#10;|&#13;|&#x0A;|&#x0D;/i)) {
            this.addOffense("The `aria-label` attribute value text should not contain line breaks. Use concise, single-line descriptions.", attributeNode.location, "error");
            return;
        }
        if (this.looksLikeId(attributeValue)) {
            this.addOffense("The `aria-label` attribute value should not be formatted like an ID. Use natural, sentence-case text instead.", attributeNode.location, "error");
            return;
        }
        if (attributeValue.match(/^[a-z]/)) {
            this.addOffense("The `aria-label` attribute value text should be formatted like visual text. Use sentence case (capitalize the first letter).", attributeNode.location, "error");
        }
    }
    looksLikeId(text) {
        return (text.includes('_') ||
            text.includes('-') ||
            /^[a-z]+([A-Z][a-z]*)*$/.test(text)) && !text.includes(' ');
    }
}
class HTMLAriaLabelIsWellFormattedRule extends ParserRule {
    name = "html-aria-label-is-well-formatted";
    check(result, context) {
        const visitor = new AriaLabelIsWellFormattedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAriaLevelMustBeValidVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        this.validateAriaLevel(attributeValue, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        const validatableContent = core.getValidatableStaticContent(valueNodes);
        if (validatableContent !== null) {
            this.validateAriaLevel(validatableContent, attributeNode);
            return;
        }
        if (!core.hasERBOutput(valueNodes))
            return;
        const literalNodes = core.filterLiteralNodes(valueNodes);
        const erbOutputNodes = core.filterERBContentNodes(valueNodes).filter(core.isERBOutputNode);
        if (literalNodes.length > 0 && erbOutputNodes.length > 0) {
            const staticPart = literalNodes.map(node => node.content).join("");
            // TODO: this can be cleaned up using @herb-tools/printer
            const erbPart = erbOutputNodes[0];
            const erbText = `${erbPart.tag_opening?.value || ""}${erbPart.content?.value || ""}${erbPart.tag_closing?.value || ""}`;
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${staticPart}\` and the ERB expression \`${erbText}\`.`, attributeNode.location);
        }
    }
    validateAriaLevel(attributeValue, attributeNode) {
        if (!attributeValue || attributeValue === "") {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got an empty value.`, attributeNode.location);
            return;
        }
        const number = parseInt(attributeValue);
        if (isNaN(number) || number < 1 || number > 6 || attributeValue !== number.toString()) {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${attributeValue}\`.`, attributeNode.location);
        }
    }
}
class HTMLAriaLevelMustBeValidRule extends ParserRule {
    name = "html-aria-level-must-be-valid";
    check(result, context) {
        const visitor = new HTMLAriaLevelMustBeValidVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleHeadingRequiresLevel extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode, parentNode }) {
        if (!(attributeName === "role" && attributeValue === "heading"))
            return;
        const ariaLevelAttributes = getAttributes(parentNode).find(attribute => getAttributeName(attribute) === "aria-level");
        if (ariaLevelAttributes)
            return;
        this.addOffense(`Element with \`role="heading"\` must have an \`aria-level\` attribute.`, attributeNode.location, "error");
    }
}
class HTMLAriaRoleHeadingRequiresLevelRule extends ParserRule {
    name = "html-aria-role-heading-requires-level";
    check(result, context) {
        const visitor = new AriaRoleHeadingRequiresLevel(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "role")
            return;
        if (!attributeValue)
            return;
        if (VALID_ARIA_ROLES.has(attributeValue))
            return;
        this.addOffense(`The \`role\` attribute must be a valid ARIA role. Role \`${attributeValue}\` is not recognized.`, attributeNode.location, "error");
    }
}
class HTMLAriaRoleMustBeValidRule extends ParserRule {
    name = "html-aria-role-must-be-valid";
    check(result, context) {
        const visitor = new AriaRoleMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeDoubleQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (attributeValue?.includes('"'))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${attributeValue}"\`.`, attributeNode.value.location, "warning");
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode, combinedValue }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (core.filterLiteralNodes(valueNodes).some(node => node.content?.includes('"')))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, "warning");
    }
}
class HTMLAttributeDoubleQuotesRule extends ParserRule {
    name = "html-attribute-double-quotes";
    check(result, context) {
        const visitor = new AttributeDoubleQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAttributeEqualsSpacingVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNode(attribute) {
        if (!attribute.equals || !attribute.name || !attribute.value) {
            return;
        }
        if (attribute.equals.value.startsWith(" ")) {
            this.addOffense("Remove whitespace before `=` in HTML attribute", attribute.equals.location, "error");
        }
        if (attribute.equals.value.endsWith(" ")) {
            this.addOffense("Remove whitespace after `=` in HTML attribute", attribute.equals.location, "error");
        }
    }
}
class HTMLAttributeEqualsSpacingRule extends ParserRule {
    name = "html-attribute-equals-spacing";
    check(result, context) {
        const visitor = new HTMLAttributeEqualsSpacingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeValuesRequireQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${attributeValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, "error");
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${combinedValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, "error");
    }
    hasAttributeValue(attributeNode) {
        return attributeNode.value?.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    isQuoted(attributeNode) {
        const valueNode = attributeNode.value;
        return valueNode.quoted;
    }
}
class HTMLAttributeValuesRequireQuotesRule extends ParserRule {
    name = "html-attribute-values-require-quotes";
    check(result, context) {
        const visitor = new AttributeValuesRequireQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT = new Set([
    "button", "fieldset", "input", "optgroup", "option", "select", "textarea"
]);
class AvoidBothDisabledAndAriaDisabledVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkElement(node) {
        const tagName = getTagName(node);
        if (!tagName || !ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT.has(tagName)) {
            return;
        }
        const hasDisabled = hasAttribute(node, "disabled");
        const hasAriaDisabled = hasAttribute(node, "aria-disabled");
        if ((hasDisabled && this.hasERBContent(node, "disabled")) || (hasAriaDisabled && this.hasERBContent(node, "aria-disabled"))) {
            return;
        }
        if (hasDisabled && hasAriaDisabled) {
            this.addOffense("aria-disabled may be used in place of native HTML disabled to allow tab-focus on an otherwise ignored element. Setting both attributes is contradictory and confusing. Choose either disabled or aria-disabled, not both.", node.tag_name.location, "error");
        }
    }
    hasERBContent(node, attributeName) {
        const attributes = getAttributes(node);
        const attribute = findAttributeByName(attributes, attributeName);
        if (!attribute)
            return false;
        const valueNode = attribute.value;
        if (!valueNode || valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE")
            return false;
        const htmlValueNode = valueNode;
        if (!htmlValueNode.children)
            return false;
        return htmlValueNode.children.some((child) => child.type === "AST_ERB_CONTENT_NODE");
    }
}
class HTMLAvoidBothDisabledAndAriaDisabledRule extends ParserRule {
    name = "html-avoid-both-disabled-and-aria-disabled";
    check(result, context) {
        const visitor = new AvoidBothDisabledAndAriaDisabledVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BooleanAttributesNoValueVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${attributeName}\` should not have a value. Use \`${attributeName}\` instead of \`${attributeName}="${attributeName}"\`.`, attributeNode.value.location, "error");
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${attributeName}\` should not have a value. Use \`${attributeName}\` instead of \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, "error");
    }
}
class HTMLBooleanAttributesNoValueRule extends ParserRule {
    name = "html-boolean-attributes-no-value";
    check(result, context) {
        const visitor = new BooleanAttributesNoValueVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class IframeHasTitleVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkIframeElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkIframeElement(node) {
        const tagName = getTagName(node);
        if (tagName !== "iframe") {
            return;
        }
        const ariaHiddenAttribute = getAttribute(node, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return;
            }
        }
        const attribute = getAttribute(node, "title");
        if (!attribute) {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location, "error");
            return;
        }
        const value = getAttributeValue(attribute);
        if (!value || value.trim() === "") {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location, "error");
        }
    }
}
class HTMLIframeHasTitleRule extends ParserRule {
    name = "html-iframe-has-title";
    check(result, context) {
        const visitor = new IframeHasTitleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ImgRequireAltVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(node) {
        const tagName = getTagName(node);
        if (tagName !== "img") {
            return;
        }
        if (!hasAttribute(node, "alt")) {
            this.addOffense('Missing required `alt` attribute on `<img>` tag. Add `alt=""` for decorative images or `alt="description"` for informative images.', node.tag_name.location, "error");
        }
    }
}
class HTMLImgRequireAltRule extends ParserRule {
    name = "html-img-require-alt";
    check(result, context) {
        const visitor = new ImgRequireAltVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NavigationHasLabelVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkNavigationElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkNavigationElement(node) {
        const tagName = getTagName(node);
        const isNavElement = tagName === "nav";
        const hasNavigationRole = this.hasRoleNavigation(node);
        if (!isNavElement && !hasNavigationRole) {
            return;
        }
        const hasAriaLabel = hasAttribute(node, "aria-label");
        const hasAriaLabelledby = hasAttribute(node, "aria-labelledby");
        if (!hasAriaLabel && !hasAriaLabelledby) {
            let message = `The navigation landmark should have a unique accessible name via \`aria-label\` or \`aria-labelledby\`. Remember that the name does not need to include "navigation" or "nav" since it will already be announced.`;
            if (hasNavigationRole && !isNavElement) {
                message += ` Additionally, you can safely drop the \`role="navigation"\` and replace it with the native HTML \`<nav>\` element.`;
            }
            this.addOffense(message, node.tag_name.location, "error");
        }
    }
    hasRoleNavigation(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "navigation";
    }
}
class HTMLNavigationHasLabelRule extends ParserRule {
    name = "html-navigation-has-label";
    check(result, context) {
        const visitor = new NavigationHasLabelVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const INTERACTIVE_ELEMENTS = new Set([
    "button", "summary", "input", "select", "textarea", "a"
]);
class NoAriaHiddenOnFocusableVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkAriaHiddenOnFocusable(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAriaHiddenOnFocusable(node) {
        if (!this.hasAriaHiddenTrue(node))
            return;
        if (this.isFocusable(node)) {
            this.addOffense(`Elements that are focusable should not have \`aria-hidden="true"\` because it will cause confusion for assistive technology users.`, node.tag_name.location, "error");
        }
    }
    hasAriaHiddenTrue(node) {
        const attributes = getAttributes(node);
        const ariaHiddenAttr = findAttributeByName(attributes, "aria-hidden");
        if (!ariaHiddenAttr)
            return false;
        const value = getAttributeValue(ariaHiddenAttr);
        return value === "true";
    }
    isFocusable(node) {
        const tagName = getTagName(node);
        if (!tagName)
            return false;
        const tabIndexValue = this.getTabIndexValue(node);
        if (tagName === "a") {
            const hasHref = hasAttribute(node, "href");
            if (!hasHref) {
                return tabIndexValue !== null && tabIndexValue >= 0;
            }
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        if (INTERACTIVE_ELEMENTS.has(tagName)) {
            // Interactive elements are focusable unless tabindex is negative
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        else {
            // Non-interactive elements are focusable only if tabindex >= 0
            return tabIndexValue !== null && tabIndexValue >= 0;
        }
    }
    getTabIndexValue(node) {
        const attributes = getAttributes(node);
        const tabIndexAttribute = findAttributeByName(attributes, "tabindex");
        if (!tabIndexAttribute)
            return null;
        const value = getAttributeValue(tabIndexAttribute);
        if (!value)
            return null;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? null : parsed;
    }
}
class HTMLNoAriaHiddenOnFocusableRule extends ParserRule {
    name = "html-no-aria-hidden-on-focusable";
    check(result, context) {
        const visitor = new NoAriaHiddenOnFocusableVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoDuplicateAttributesVisitor extends AttributeVisitorMixin {
    attributeNames = new Map();
    visitHTMLOpenTagNode(node) {
        this.attributeNames.clear();
        super.visitHTMLOpenTagNode(node);
        this.reportDuplicates();
    }
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    trackAttributeName(attributeName, attributeNode) {
        if (!this.attributeNames.has(attributeName)) {
            this.attributeNames.set(attributeName, []);
        }
        this.attributeNames.get(attributeName).push(attributeNode);
    }
    reportDuplicates() {
        for (const [attributeName, attributeNodes] of this.attributeNames) {
            if (attributeNodes.length > 1) {
                for (let i = 1; i < attributeNodes.length; i++) {
                    const attributeNode = attributeNodes[i];
                    this.addOffense(`Duplicate attribute \`${attributeName}\` found on tag. Remove the duplicate occurrence.`, attributeNode.name.location, "error");
                }
            }
        }
    }
}
class HTMLNoDuplicateAttributesRule extends ParserRule {
    name = "html-no-duplicate-attributes";
    check(result, context) {
        const visitor = new NoDuplicateAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class OutputPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        if (core.isERBOutputNode(node)) {
            this.write(IdentityPrinter.print(node));
        }
    }
}
class NoDuplicateIdsVisitor extends ControlFlowTrackingVisitor {
    documentIds = new Set();
    currentBranchIds = new Set();
    controlFlowIds = new Set();
    visitHTMLAttributeNode(node) {
        this.checkAttribute(node);
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds,
            previousControlFlowIds: this.controlFlowIds
        };
        this.currentBranchIds = new Set();
        if (!wasAlreadyInControlFlow) {
            this.controlFlowIds = new Set();
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowIds.forEach(id => this.documentIds.add(id));
        }
        this.currentBranchIds = stateToRestore.previousBranchIds;
        this.controlFlowIds = stateToRestore.previousControlFlowIds;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds
        };
        if (this.isInControlFlow) {
            this.currentBranchIds = new Set();
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    checkAttribute(attributeNode) {
        if (!this.isIdAttribute(attributeNode))
            return;
        const idValue = this.extractIdValue(attributeNode);
        if (!idValue)
            return;
        if (this.isWhitespaceOnlyId(idValue.identifier))
            return;
        this.processIdDuplicate(idValue, attributeNode);
    }
    isIdAttribute(attributeNode) {
        if (!attributeNode.name?.children || !attributeNode.value)
            return false;
        return core.getStaticAttributeName(attributeNode.name) === "id";
    }
    extractIdValue(attributeNode) {
        const valueNodes = attributeNode.value?.children || [];
        if (core.hasERBOutput(valueNodes) && this.isInControlFlow && this.currentControlFlowType === ControlFlowType.LOOP) {
            return null;
        }
        const identifier = core.isEffectivelyStatic(valueNodes) ? core.getValidatableStaticContent(valueNodes) : OutputPrinter.print(valueNodes);
        if (!identifier)
            return null;
        return { identifier, shouldTrackDuplicates: true };
    }
    isWhitespaceOnlyId(identifier) {
        return identifier !== '' && identifier.trim() === '';
    }
    processIdDuplicate(idValue, attributeNode) {
        const { identifier, shouldTrackDuplicates } = idValue;
        if (!shouldTrackDuplicates)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowId(identifier, attributeNode);
        }
        else {
            this.handleGlobalId(identifier, attributeNode);
        }
    }
    handleControlFlowId(identifier, attributeNode) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.handleLoopId(identifier, attributeNode);
        }
        else {
            this.handleConditionalId(identifier, attributeNode);
        }
        this.currentBranchIds.add(identifier);
    }
    handleLoopId(identifier, attributeNode) {
        const isStaticId = this.isStaticId(attributeNode);
        if (isStaticId) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        if (this.currentBranchIds.has(identifier)) {
            this.addSameLoopIterationOffense(identifier, attributeNode.location);
        }
    }
    handleConditionalId(identifier, attributeNode) {
        if (this.currentBranchIds.has(identifier)) {
            this.addSameBranchOffense(identifier, attributeNode.location);
            return;
        }
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.controlFlowIds.add(identifier);
    }
    handleGlobalId(identifier, attributeNode) {
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.documentIds.add(identifier);
    }
    isStaticId(attributeNode) {
        const valueNodes = attributeNode.value.children;
        const isCompletelyStatic = valueNodes.every(child => core.isNode(child, core.LiteralNode));
        const isEffectivelyStaticValue = core.isEffectivelyStatic(valueNodes);
        return isCompletelyStatic || isEffectivelyStaticValue;
    }
    addDuplicateIdOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found. IDs must be unique within a document.`, location, "error");
    }
    addSameLoopIterationOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same loop iteration. IDs must be unique within the same loop iteration.`, location, "error");
    }
    addSameBranchOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same control flow branch. IDs must be unique within the same control flow branch.`, location, "error");
    }
}
class HTMLNoDuplicateIdsRule extends ParserRule {
    name = "html-no-duplicate-ids";
    check(result, context) {
        const visitor = new NoDuplicateIdsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoEmptyHeadingsVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        this.checkHeadingElement(node);
        super.visitHTMLElementNode(node);
    }
    checkHeadingElement(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (!tagName) {
            return;
        }
        const isStandardHeading = HEADING_TAGS.has(tagName);
        const isAriaHeading = this.hasHeadingRole(openTag);
        if (!isStandardHeading && !isAriaHeading) {
            return;
        }
        if (this.isEmptyHeading(node)) {
            const elementDescription = isStandardHeading
                ? `\`<${tagName}>\``
                : `\`<${tagName} role="heading">\``;
            this.addOffense(`Heading element ${elementDescription} must not be empty. Provide accessible text content for screen readers and SEO.`, node.location, "error");
        }
    }
    isEmptyHeading(node) {
        if (!node.body || node.body.length === 0) {
            return true;
        }
        // Check if all content is just whitespace or inaccessible
        let hasAccessibleContent = false;
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                // Check if this element is accessible (not aria-hidden="true")
                if (this.isElementAccessible(elementNode)) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                hasAccessibleContent = true;
                break;
            }
        }
        return !hasAccessibleContent;
    }
    hasHeadingRole(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "heading";
    }
    isElementAccessible(node) {
        // Check if the element has aria-hidden="true"
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return true;
        }
        const openTag = node.open_tag;
        const attributes = getAttributes(openTag);
        const ariaHiddenAttribute = findAttributeByName(attributes, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return false;
            }
        }
        // Recursively check if the element has any accessible content
        if (!node.body || node.body.length === 0) {
            return false;
        }
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    return true;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                return true;
            }
        }
        return false;
    }
}
class HTMLNoEmptyHeadingsRule extends ParserRule {
    name = "html-no-empty-headings";
    check(result, context) {
        const visitor = new NoEmptyHeadingsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NestedLinkVisitor extends BaseRuleVisitor {
    linkStack = [];
    checkNestedLink(openTag) {
        if (this.linkStack.length > 0) {
            this.addOffense("Nested `<a>` elements are not allowed. Links cannot contain other links.", openTag.tag_name.location, "error");
            return true;
        }
        return false;
    }
    visitHTMLElementNode(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (tagName !== "a") {
            super.visitHTMLElementNode(node);
            return;
        }
        // If we're already inside a link, this is a nested link
        this.checkNestedLink(openTag);
        this.linkStack.push(openTag);
        super.visitHTMLElementNode(node);
        this.linkStack.pop();
    }
    // Handle self-closing <a> tags (though they're not valid HTML, they might exist)
    visitHTMLOpenTagNode(node) {
        const tagName = getTagName(node);
        if (tagName === "a" && node.is_void) {
            this.checkNestedLink(node);
        }
        super.visitHTMLOpenTagNode(node);
    }
}
class HTMLNoNestedLinksRule extends ParserRule {
    name = "html-no-nested-links";
    check(result, context) {
        const visitor = new NestedLinkVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoPositiveTabIndexVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "tabindex")
            return;
        const tabIndexValue = parseInt(attributeValue, 10);
        if (!isNaN(tabIndexValue) && tabIndexValue > 0) {
            this.addOffense(`Do not use positive \`tabindex\` values as they are error prone and can severely disrupt navigation experience for keyboard users. Use \`tabindex="0"\` to make an element focusable or \`tabindex=\"-1\"\` to remove it from the tab sequence.`, attributeNode.location, "error");
        }
    }
}
class HTMLNoPositiveTabIndexRule extends ParserRule {
    name = "html-no-positive-tab-index";
    check(result, context) {
        const visitor = new NoPositiveTabIndexVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoSelfClosingVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (core.getTagName(node) === "svg") {
            this.visit(node.open_tag);
        }
        else {
            this.visitChildNodes(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_closing?.value === "/>") {
            const tagName = core.getTagName(node);
            const instead = isVoidElement(tagName) ? `<${tagName}>` : `<${tagName}></${tagName}>`;
            this.addOffense(`Use \`${instead}\` instead of self-closing \`<${tagName} />\` for HTML compatibility.`, node.location, "error");
        }
    }
}
class HTMLNoSelfClosingRule extends ParserRule {
    name = "html-no-self-closing";
    check(result, context) {
        const visitor = new NoSelfClosingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoTitleAttributeVisitor extends BaseRuleVisitor {
    ALLOWED_ELEMENTS_WITH_TITLE = new Set(["iframe", "link"]);
    visitHTMLOpenTagNode(node) {
        this.checkTitleAttribute(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkTitleAttribute(node) {
        const tagName = getTagName(node);
        if (!tagName || this.ALLOWED_ELEMENTS_WITH_TITLE.has(tagName)) {
            return;
        }
        if (hasAttribute(node, "title")) {
            this.addOffense("The `title` attribute should never be used as it is inaccessible for several groups of users. Use `aria-label` or `aria-describedby` instead. Exceptions are provided for `<iframe>` and `<link>` elements.", node.tag_name.location, "error");
        }
    }
}
class HTMLNoTitleAttributeRule extends ParserRule {
    name = "html-no-title-attribute";
    check(result, context) {
        const visitor = new NoTitleAttributeVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class XMLDeclarationChecker extends BaseRuleVisitor {
    hasXMLDeclaration = false;
    visitXMLDeclarationNode(_node) {
        this.hasXMLDeclaration = true;
    }
    visitChildNodes(node) {
        if (this.hasXMLDeclaration)
            return;
        super.visitChildNodes(node);
    }
}
class TagNameLowercaseVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (core.getTagName(node).toLowerCase() === "svg") {
            this.checkTagName(node.open_tag);
            this.checkTagName(node.close_tag);
        }
        else {
            super.visitHTMLElementNode(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        this.checkTagName(node);
    }
    visitHTMLCloseTagNode(node) {
        this.checkTagName(node);
    }
    checkTagName(node) {
        if (!node)
            return;
        const tagName = core.getTagName(node);
        if (!tagName)
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const type = core.isNode(node, core.HTMLOpenTagNode) ? "Opening" : "Closing";
        const open = core.isNode(node, core.HTMLOpenTagNode) ? "<" : "</";
        if (tagName !== lowercaseTagName) {
            this.addOffense(`${type} tag name \`${open}${tagName}>\` should be lowercase. Use \`${open}${lowercaseTagName}>\` instead.`, node.tag_name.location, "error");
        }
    }
}
class HTMLTagNameLowercaseRule extends ParserRule {
    name = "html-tag-name-lowercase";
    isEnabled(result, context) {
        if (context?.fileName?.endsWith(".xml") || context?.fileName?.endsWith(".xml.erb")) {
            return false;
        }
        const checker = new XMLDeclarationChecker(this.name);
        checker.visit(result.value);
        return !checker.hasXMLDeclaration;
    }
    check(result, context) {
        const visitor = new TagNameLowercaseVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ParserNoErrorsRule extends ParserRule {
    name = "parser-no-errors";
    check(result) {
        return result.recursiveErrors().map(error => this.herbErrorToLintOffense(error));
    }
    herbErrorToLintOffense(error) {
        return {
            message: `${error.message} (\`${error.type}\`)`,
            location: error.location,
            severity: error.severity,
            rule: this.name,
            code: this.name,
            source: "linter"
        };
    }
}

class SVGTagNameCapitalizationVisitor extends BaseRuleVisitor {
    insideSVG = false;
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName && ["svg"].includes(tagName.toLowerCase())) {
            const wasInsideSVG = this.insideSVG;
            this.insideSVG = true;
            this.visitChildNodes(node);
            this.insideSVG = wasInsideSVG;
            return;
        }
        if (this.insideSVG) {
            if (node.open_tag) {
                this.checkTagName(node.open_tag);
            }
            if (node.close_tag) {
                this.checkTagName(node.close_tag);
            }
        }
        this.visitChildNodes(node);
    }
    checkTagName(node) {
        const tagName = node.tag_name?.value;
        if (!tagName)
            return;
        if (SVG_CAMEL_CASE_ELEMENTS.has(tagName))
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const correctCamelCase = SVG_LOWERCASE_TO_CAMELCASE.get(lowercaseTagName);
        if (correctCamelCase && tagName !== correctCamelCase) {
            let type = node.type;
            if (node.type == "AST_HTML_OPEN_TAG_NODE")
                type = "Opening";
            if (node.type == "AST_HTML_CLOSE_TAG_NODE")
                type = "Closing";
            this.addOffense(`${type} SVG tag name \`${tagName}\` should use proper capitalization. Use \`${correctCamelCase}\` instead.`, node.tag_name.location, "error");
        }
    }
}
class SVGTagNameCapitalizationRule extends ParserRule {
    name = "svg-tag-name-capitalization";
    check(result, context) {
        const visitor = new SVGTagNameCapitalizationVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const defaultRules = [
    ERBNoEmptyTagsRule,
    ERBNoOutputControlFlowRule,
    ERBNoSilentTagInAttributeNameRule,
    ERBPreferImageTagHelperRule,
    ERBRequiresTrailingNewlineRule,
    ERBRequireWhitespaceRule,
    HTMLAnchorRequireHrefRule,
    HTMLAriaAttributeMustBeValid,
    HTMLAriaLabelIsWellFormattedRule,
    HTMLAriaLevelMustBeValidRule,
    HTMLAriaRoleHeadingRequiresLevelRule,
    HTMLAriaRoleMustBeValidRule,
    HTMLAttributeDoubleQuotesRule,
    HTMLAttributeEqualsSpacingRule,
    HTMLAttributeValuesRequireQuotesRule,
    HTMLAvoidBothDisabledAndAriaDisabledRule,
    HTMLBooleanAttributesNoValueRule,
    HTMLIframeHasTitleRule,
    HTMLImgRequireAltRule,
    HTMLNavigationHasLabelRule,
    HTMLNoAriaHiddenOnFocusableRule,
    // HTMLNoBlockInsideInlineRule,
    HTMLNoDuplicateAttributesRule,
    HTMLNoDuplicateIdsRule,
    HTMLNoEmptyHeadingsRule,
    HTMLNoNestedLinksRule,
    HTMLNoPositiveTabIndexRule,
    HTMLNoSelfClosingRule,
    HTMLNoTitleAttributeRule,
    HTMLTagNameLowercaseRule,
    ParserNoErrorsRule,
    SVGTagNameCapitalizationRule,
];

class Linter {
    rules;
    herb;
    offenses;
    /**
     * Creates a new Linter instance.
     * @param herb - The Herb backend instance for parsing and lexing
     * @param rules - Array of rule classes (Parser/AST or Lexer) to use. If not provided, uses default rules.
     */
    constructor(herb, rules) {
        this.herb = herb;
        this.rules = rules !== undefined ? rules : this.getDefaultRules();
        this.offenses = [];
    }
    /**
     * Returns the default set of rule classes used by the linter.
     * @returns Array of rule classes
     */
    getDefaultRules() {
        return defaultRules;
    }
    getRuleCount() {
        return this.rules.length;
    }
    /**
     * Type guard to check if a rule is a LexerRule
     */
    isLexerRule(rule) {
        return rule.constructor.type === "lexer";
    }
    /**
     * Type guard to check if a rule is a SourceRule
     */
    isSourceRule(rule) {
        return rule.constructor.type === "source";
    }
    /**
     * Lint source code using Parser/AST, Lexer, and Source rules.
     * @param source - The source code to lint
     * @param context - Optional context for linting (e.g., fileName for distinguishing files vs snippets)
     */
    lint(source, context) {
        this.offenses = [];
        const parseResult = this.herb.parse(source, { track_whitespace: true });
        const lexResult = this.herb.lex(source);
        for (const RuleClass of this.rules) {
            const rule = new RuleClass();
            let isEnabled = true;
            let ruleOffenses;
            if (this.isLexerRule(rule)) {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(lexResult, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(lexResult, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            else if (this.isSourceRule(rule)) {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(source, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(source, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            else {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(parseResult, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(parseResult, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            this.offenses.push(...ruleOffenses);
        }
        const errors = this.offenses.filter(offense => offense.severity === "error").length;
        const warnings = this.offenses.filter(offense => offense.severity === "warning").length;
        return {
            offenses: this.offenses,
            errors,
            warnings
        };
    }
}

class BlockInsideInlineVisitor extends BaseRuleVisitor {
    inlineStack = [];
    isValidHTMLOpenTag(node) {
        return !!(node.open_tag && node.open_tag.type === "AST_HTML_OPEN_TAG_NODE");
    }
    getElementType(tagName) {
        const isInline = isInlineElement(tagName);
        const isBlock = isBlockElement(tagName);
        const isUnknown = !isInline && !isBlock;
        return { isInline, isBlock, isUnknown };
    }
    addOffenseMessage(tagName, isBlock, openTag) {
        const parentInline = this.inlineStack[this.inlineStack.length - 1];
        const elementType = isBlock ? "Block-level" : "Unknown";
        this.addOffense(`${elementType} element \`<${tagName}>\` cannot be placed inside inline element \`<${parentInline}>\`.`, openTag.tag_name.location, "error");
    }
    visitInlineElement(node, tagName) {
        this.inlineStack.push(tagName);
        super.visitHTMLElementNode(node);
        this.inlineStack.pop();
    }
    visitBlockElement(node) {
        const savedStack = [...this.inlineStack];
        this.inlineStack = [];
        super.visitHTMLElementNode(node);
        this.inlineStack = savedStack;
    }
    visitHTMLElementNode(node) {
        if (!this.isValidHTMLOpenTag(node)) {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = openTag.tag_name?.value.toLowerCase();
        if (!tagName) {
            super.visitHTMLElementNode(node);
            return;
        }
        const { isInline, isBlock, isUnknown } = this.getElementType(tagName);
        if ((isBlock || isUnknown) && this.inlineStack.length > 0) {
            this.addOffenseMessage(tagName, isBlock, openTag);
        }
        if (isInline) {
            this.visitInlineElement(node, tagName);
            return;
        }
        this.visitBlockElement(node);
    }
}
class HTMLNoBlockInsideInlineRule extends ParserRule {
    name = "html-no-block-inside-inline";
    check(result, context) {
        const visitor = new BlockInsideInlineVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

exports.DEFAULT_LINT_CONTEXT = DEFAULT_LINT_CONTEXT;
exports.ERBNoEmptyTagsRule = ERBNoEmptyTagsRule;
exports.ERBNoOutputControlFlowRule = ERBNoOutputControlFlowRule;
exports.ERBNoSilentTagInAttributeNameRule = ERBNoSilentTagInAttributeNameRule;
exports.ERBPreferImageTagHelperRule = ERBPreferImageTagHelperRule;
exports.ERBRequiresTrailingNewlineRule = ERBRequiresTrailingNewlineRule;
exports.HTMLAnchorRequireHrefRule = HTMLAnchorRequireHrefRule;
exports.HTMLAriaLabelIsWellFormattedRule = HTMLAriaLabelIsWellFormattedRule;
exports.HTMLAriaLevelMustBeValidRule = HTMLAriaLevelMustBeValidRule;
exports.HTMLAriaRoleHeadingRequiresLevelRule = HTMLAriaRoleHeadingRequiresLevelRule;
exports.HTMLAriaRoleMustBeValidRule = HTMLAriaRoleMustBeValidRule;
exports.HTMLAttributeDoubleQuotesRule = HTMLAttributeDoubleQuotesRule;
exports.HTMLAttributeEqualsSpacingRule = HTMLAttributeEqualsSpacingRule;
exports.HTMLAttributeValuesRequireQuotesRule = HTMLAttributeValuesRequireQuotesRule;
exports.HTMLAvoidBothDisabledAndAriaDisabledRule = HTMLAvoidBothDisabledAndAriaDisabledRule;
exports.HTMLBooleanAttributesNoValueRule = HTMLBooleanAttributesNoValueRule;
exports.HTMLIframeHasTitleRule = HTMLIframeHasTitleRule;
exports.HTMLImgRequireAltRule = HTMLImgRequireAltRule;
exports.HTMLNavigationHasLabelRule = HTMLNavigationHasLabelRule;
exports.HTMLNoAriaHiddenOnFocusableRule = HTMLNoAriaHiddenOnFocusableRule;
exports.HTMLNoBlockInsideInlineRule = HTMLNoBlockInsideInlineRule;
exports.HTMLNoDuplicateAttributesRule = HTMLNoDuplicateAttributesRule;
exports.HTMLNoDuplicateIdsRule = HTMLNoDuplicateIdsRule;
exports.HTMLNoEmptyHeadingsRule = HTMLNoEmptyHeadingsRule;
exports.HTMLNoNestedLinksRule = HTMLNoNestedLinksRule;
exports.HTMLNoPositiveTabIndexRule = HTMLNoPositiveTabIndexRule;
exports.HTMLNoSelfClosingRule = HTMLNoSelfClosingRule;
exports.HTMLNoTitleAttributeRule = HTMLNoTitleAttributeRule;
exports.HTMLTagNameLowercaseRule = HTMLTagNameLowercaseRule;
exports.LexerRule = LexerRule;
exports.Linter = Linter;
exports.ParserRule = ParserRule;
exports.SVGTagNameCapitalizationRule = SVGTagNameCapitalizationRule;
exports.SourceRule = SourceRule;
//# sourceMappingURL=index.cjs.map
