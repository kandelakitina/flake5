import { ParserRule } from "../types.js";
import { BaseRuleVisitor, getTagName, hasAttribute, getAttributeValue, findAttributeByName, getAttributes } from "./rule-utils.js";
const INTERACTIVE_ELEMENTS = new Set([
    "button", "summary", "input", "select", "textarea", "a"
]);
class NoAriaHiddenOnFocusableVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkAriaHiddenOnFocusable(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAriaHiddenOnFocusable(node) {
        if (!this.hasAriaHiddenTrue(node))
            return;
        if (this.isFocusable(node)) {
            this.addOffense(`Elements that are focusable should not have \`aria-hidden="true"\` because it will cause confusion for assistive technology users.`, node.tag_name.location, "error");
        }
    }
    hasAriaHiddenTrue(node) {
        const attributes = getAttributes(node);
        const ariaHiddenAttr = findAttributeByName(attributes, "aria-hidden");
        if (!ariaHiddenAttr)
            return false;
        const value = getAttributeValue(ariaHiddenAttr);
        return value === "true";
    }
    isFocusable(node) {
        const tagName = getTagName(node);
        if (!tagName)
            return false;
        const tabIndexValue = this.getTabIndexValue(node);
        if (tagName === "a") {
            const hasHref = hasAttribute(node, "href");
            if (!hasHref) {
                return tabIndexValue !== null && tabIndexValue >= 0;
            }
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        if (INTERACTIVE_ELEMENTS.has(tagName)) {
            // Interactive elements are focusable unless tabindex is negative
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        else {
            // Non-interactive elements are focusable only if tabindex >= 0
            return tabIndexValue !== null && tabIndexValue >= 0;
        }
    }
    getTabIndexValue(node) {
        const attributes = getAttributes(node);
        const tabIndexAttribute = findAttributeByName(attributes, "tabindex");
        if (!tabIndexAttribute)
            return null;
        const value = getAttributeValue(tabIndexAttribute);
        if (!value)
            return null;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? null : parsed;
    }
}
export class HTMLNoAriaHiddenOnFocusableRule extends ParserRule {
    name = "html-no-aria-hidden-on-focusable";
    check(result, context) {
        const visitor = new NoAriaHiddenOnFocusableVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-no-aria-hidden-on-focusable.js.map