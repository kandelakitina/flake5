import { Visitor, Location } from "@herb-tools/core";
import type { HTMLAttributeNode, HTMLAttributeValueNode, HTMLOpenTagNode, LexResult, Token, Node } from "@herb-tools/core";
import type * as Nodes from "@herb-tools/core";
import type { LintOffense, LintSeverity, LintContext } from "../types.js";
export declare enum ControlFlowType {
    CONDITIONAL = 0,
    LOOP = 1
}
/**
 * Base visitor class that provides common functionality for rule visitors
 */
export declare abstract class BaseRuleVisitor extends Visitor {
    readonly offenses: LintOffense[];
    protected ruleName: string;
    protected context: LintContext;
    constructor(ruleName: string, context?: Partial<LintContext>);
    /**
     * Helper method to create a lint offense
     */
    protected createOffense(message: string, location: Location, severity?: LintSeverity): LintOffense;
    /**
     * Helper method to add an offense to the offenses array
     */
    protected addOffense(message: string, location: Location, severity?: LintSeverity): void;
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
export declare abstract class ControlFlowTrackingVisitor<TControlFlowState = any, TBranchState = any> extends BaseRuleVisitor {
    protected isInControlFlow: boolean;
    protected currentControlFlowType: ControlFlowType | null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    protected handleControlFlowNode(node: Node, controlFlowType: ControlFlowType, visitChildren: () => void): void;
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    protected startNewBranch(visitChildren: () => void): void;
    visitERBIfNode(node: Nodes.ERBIfNode): void;
    visitERBUnlessNode(node: Nodes.ERBUnlessNode): void;
    visitERBCaseNode(node: Nodes.ERBCaseNode): void;
    visitERBCaseMatchNode(node: Nodes.ERBCaseMatchNode): void;
    visitERBWhileNode(node: Nodes.ERBWhileNode): void;
    visitERBForNode(node: Nodes.ERBForNode): void;
    visitERBUntilNode(node: Nodes.ERBUntilNode): void;
    visitERBBlockNode(node: Nodes.ERBBlockNode): void;
    visitERBElseNode(node: Nodes.ERBElseNode): void;
    visitERBWhenNode(node: Nodes.ERBWhenNode): void;
    protected abstract onEnterControlFlow(controlFlowType: ControlFlowType, wasAlreadyInControlFlow: boolean): TControlFlowState;
    protected abstract onExitControlFlow(controlFlowType: ControlFlowType, wasAlreadyInControlFlow: boolean, stateToRestore: TControlFlowState): void;
    protected abstract onEnterBranch(): TBranchState;
    protected abstract onExitBranch(stateToRestore: TBranchState): void;
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
export declare function getAttributes(node: HTMLOpenTagNode): HTMLAttributeNode[];
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
export declare function getTagName(node: HTMLOpenTagNode): string | null;
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
export declare function getAttributeName(attributeNode: HTMLAttributeNode): string | null;
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
export declare function hasDynamicAttributeName(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
export declare function getCombinedAttributeNameString(attributeNode: HTMLAttributeNode): string;
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
export declare function hasStaticAttributeValue(attributeNode: HTMLAttributeNode): boolean;
/**
 * Checks if an attribute value contains dynamic content (ERB)
 */
export declare function hasDynamicAttributeValue(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
export declare function getStaticAttributeValue(attributeNode: HTMLAttributeNode): string | null;
/**
 * Gets the value nodes array for dynamic inspection
 */
export declare function getAttributeValueNodes(attributeNode: HTMLAttributeNode): Node[];
/**
 * Checks if an attribute value contains any static content (for validation purposes)
 */
export declare function hasStaticAttributeValueContent(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the static content of an attribute value (all literal parts combined)
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
export declare function getStaticAttributeValueContent(attributeNode: HTMLAttributeNode): string | null;
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
export declare function getAttributeValue(attributeNode: HTMLAttributeNode): string | null;
/**
 * Checks if an attribute has a value
 */
export declare function hasAttributeValue(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the quote type used for an attribute value
 */
export declare function getAttributeValueQuoteType(nodeOrAttribute: HTMLAttributeNode | HTMLAttributeValueNode): "single" | "double" | "none" | null;
/**
 * Finds an attribute by name in a list of attributes
 */
export declare function findAttributeByName(attributes: Node[], attributeName: string): HTMLAttributeNode | null;
/**
 * Checks if a tag has a specific attribute
 */
export declare function hasAttribute(node: HTMLOpenTagNode, attributeName: string): boolean;
/**
 * Checks if a tag has a specific attribute
 */
export declare function getAttribute(node: HTMLOpenTagNode, attributeName: string): HTMLAttributeNode | null;
/**
 * Common HTML element categorization
 */
export declare const HTML_INLINE_ELEMENTS: Set<string>;
export declare const HTML_BLOCK_ELEMENTS: Set<string>;
export declare const HTML_VOID_ELEMENTS: Set<string>;
export declare const HTML_BOOLEAN_ATTRIBUTES: Set<string>;
export declare const HEADING_TAGS: Set<string>;
/**
 * SVG elements that use camelCase naming
 */
export declare const SVG_CAMEL_CASE_ELEMENTS: Set<string>;
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
export declare const SVG_LOWERCASE_TO_CAMELCASE: Map<string, string>;
export declare const VALID_ARIA_ROLES: Set<string>;
/**
 * Parameter types for AttributeVisitorMixin methods
 */
export interface StaticAttributeStaticValueParams {
    attributeName: string;
    attributeValue: string;
    attributeNode: HTMLAttributeNode;
    parentNode: HTMLOpenTagNode;
}
export interface StaticAttributeDynamicValueParams {
    attributeName: string;
    valueNodes: Node[];
    attributeNode: HTMLAttributeNode;
    parentNode: HTMLOpenTagNode;
    combinedValue?: string | null;
}
export interface DynamicAttributeStaticValueParams {
    nameNodes: Node[];
    attributeValue: string;
    attributeNode: HTMLAttributeNode;
    parentNode: HTMLOpenTagNode;
    combinedName?: string;
}
export interface DynamicAttributeDynamicValueParams {
    nameNodes: Node[];
    valueNodes: Node[];
    attributeNode: HTMLAttributeNode;
    parentNode: HTMLOpenTagNode;
    combinedName?: string;
    combinedValue?: string | null;
}
export declare const ARIA_ATTRIBUTES: Set<string>;
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
export declare function createEndOfFileLocation(source: string): Location;
/**
 * Checks if an element is inline
 */
export declare function isInlineElement(tagName: string): boolean;
/**
 * Checks if an element is block-level
 */
export declare function isBlockElement(tagName: string): boolean;
/**
 * Checks if an element is a void element
 */
export declare function isVoidElement(tagName: string): boolean;
/**
 * Checks if an attribute is a boolean attribute
 */
export declare function isBooleanAttribute(attributeName: string): boolean;
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
export declare abstract class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName: string, context?: Partial<LintContext>);
    visitHTMLOpenTagNode(node: HTMLOpenTagNode): void;
    private checkAttributesOnNode;
    /**
     * Static attribute name with static value: class="container"
     */
    protected checkStaticAttributeStaticValue(params: StaticAttributeStaticValueParams): void;
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    protected checkStaticAttributeDynamicValue(params: StaticAttributeDynamicValueParams): void;
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    protected checkDynamicAttributeStaticValue(params: DynamicAttributeStaticValueParams): void;
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    protected checkDynamicAttributeDynamicValue(params: DynamicAttributeDynamicValueParams): void;
}
/**
 * Checks if an attribute value is quoted
 */
export declare function isAttributeValueQuoted(attributeNode: HTMLAttributeNode): boolean;
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
export declare function forEachAttribute(node: HTMLOpenTagNode, callback: (attributeNode: HTMLAttributeNode) => void): void;
/**
 * Base lexer visitor class that provides common functionality for lexer-based rule visitors
 */
export declare abstract class BaseLexerRuleVisitor {
    readonly offenses: LintOffense[];
    protected ruleName: string;
    protected context: LintContext;
    constructor(ruleName: string, context?: Partial<LintContext>);
    /**
     * Helper method to create a lint offense for lexer rules
     */
    protected createOffense(message: string, location: Location, severity?: LintSeverity): LintOffense;
    /**
     * Helper method to add an offense to the offenses array
     */
    protected addOffense(message: string, location: Location, severity?: LintSeverity): void;
    /**
     * Main entry point for lexer rule visitors
     * @param lexResult - The lexer result containing tokens and source
     */
    visit(lexResult: LexResult): void;
    /**
     * Visit all tokens
     * Override this method to implement token-level checks
     */
    protected visitTokens(tokens: Token[]): void;
    /**
     * Visit individual tokens
     * Override this method to implement per-token checks
     */
    protected visitToken(_token: Token): void;
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
export declare abstract class BaseSourceRuleVisitor {
    readonly offenses: LintOffense[];
    protected ruleName: string;
    protected context: LintContext;
    constructor(ruleName: string, context?: Partial<LintContext>);
    /**
     * Helper method to create a lint offense for source rules
     */
    protected createOffense(message: string, location: Location, severity?: LintSeverity): LintOffense;
    /**
     * Helper method to add an offense to the offenses array
     */
    protected addOffense(message: string, location: Location, severity?: LintSeverity): void;
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source: string): void;
    /**
     * Visit the source code directly
     * Override this method to implement source-level checks
     */
    protected abstract visitSource(source: string): void;
    /**
     * Helper method to create a location for a specific position in the source
     */
    protected createLocationAt(source: string, position: number): Location;
}
